<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MinMaxPeakFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.misc</a> &gt; <span class="el_source">MinMaxPeakFinder.java</span></div><h1>MinMaxPeakFinder.java</h1><pre class="source lang-java linenums">package algorithms.misc;

import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import java.util.Arrays;

/**
 * find peaks in sequential data by finding the minima above  threshold and
 * the maxima and then the maxima which are a gain factor above either
 * adjacent minima.
 * The success of the method depends upon a reasonable lowThreshold and
 * gain.
 * 
 * NOTE: methods such as those in MedianSmooth could be used to find a
 * windowed mean and max (and hence, standard deviation, but they are
 * dependent upon the size of the window.  A peak that is a wide gradual
 * plateau and a narrow window might miss the peak.
 * 
 * first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright
   and license.
 * 
 * @author nichole
 */
<span class="fc" id="L29">public class MinMaxPeakFinder {</span>
    
    public int[] findPeaks(float[] values) {
                
<span class="fc" id="L33">        float mean3Percent = calculateMeanOfSmallest(values, 0.03f);</span>
        
<span class="fc" id="L35">        return findPeaks(values, mean3Percent, 2.5f);</span>
    }
    
    /**
     * copies and sorts values, then takes the fraction*values.length
     * first indexes and calculates the mean for them and returns it.
     * 
     * @param values
     * @param fraction
     * @return 
     */
    public float calculateMeanOfSmallest(float[] values, float fraction) {
        
<span class="fc" id="L48">        float[] a = Arrays.copyOf(values, values.length);</span>
        
<span class="fc" id="L50">        Arrays.sort(a);</span>
        
<span class="fc" id="L52">        float mean = 0;</span>
<span class="fc" id="L53">        int end = Math.round(fraction * values.length);</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (end == 0) {</span>
<span class="fc" id="L55">            end = 1;</span>
        }
<span class="fc bfc" id="L57" title="All 2 branches covered.">        for (int i = 0; i &lt; end; ++i) {</span>
<span class="fc" id="L58">            mean += a[i];</span>
        }
<span class="fc" id="L60">        mean /= (float)end;</span>
        
<span class="fc" id="L62">        return mean;</span>
    }
    
    public int[] findPeaks(float[] values, float lowThreshold, 
        float factorAboveMin) {
        
<span class="fc" id="L68">        int[] minMaxIdxs = findMinimaMaxima(values, lowThreshold);</span>
        
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (minMaxIdxs.length == 0) {</span>
<span class="nc" id="L71">            return new int[0];</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        } else if (minMaxIdxs.length == 1) {</span>
<span class="nc" id="L73">            return minMaxIdxs;</span>
        } 
        
<span class="fc" id="L76">        TIntList peaks = new TIntArrayList(minMaxIdxs.length/2);</span>

        // choose candidates from minMaxIndexes that are
        //     &gt;= factorAboveMin for one adjacent minima
<span class="fc bfc" id="L80" title="All 2 branches covered.">        for (int ii = 0; ii &lt; minMaxIdxs.length; ii++) {</span>

<span class="fc" id="L82">            int idx = minMaxIdxs[ii];</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (idx &gt; -1) {</span>
                // this is a maxima

<span class="fc" id="L87">                boolean found = false;</span>
                
                // compare to preceding minimum
<span class="pc bfc" id="L90" title="All 2 branches covered.">                for (int iii = (ii - 1); iii &gt; -1; iii--) {</span>
<span class="fc" id="L91">                    int idx2 = minMaxIdxs[iii];</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="fc" id="L93">                        float compare = values[-1*idx2];</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">                        if (compare &lt; lowThreshold) {</span>
                            // avoids divide by very small number sometimes
<span class="nc" id="L96">                            compare = lowThreshold;</span>
                        }
<span class="pc bpc" id="L98" title="2 of 4 branches missed.">                        if (values[idx] &gt;= lowThreshold &amp;&amp; </span>
                            values[idx] &gt;= factorAboveMin * compare) {
                            
<span class="fc" id="L101">                            peaks.add(idx);</span>
<span class="fc" id="L102">                            found = true;</span>
                        }
                        break;
                    }
                }
                
<span class="pc bpc" id="L108" title="1 of 4 branches missed.">                if (found &amp;&amp; (ii &gt; 0)) {</span>
<span class="fc" id="L109">                    continue;</span>
                }

                //compare to proceeding minimum
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                for (int iii = (ii + 1); iii &lt; minMaxIdxs.length; iii++) {</span>
<span class="fc" id="L114">                    int idx2 = minMaxIdxs[iii];</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="fc" id="L116">                        float compare = values[-1*idx2];</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">                        if (compare &lt; lowThreshold) {</span>
                            // avoids divide by very small number sometimes
<span class="nc" id="L119">                            compare = lowThreshold;</span>
                        }
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">                        if (values[idx] &gt;= lowThreshold </span>
                            &amp;&amp; values[idx] &gt;= factorAboveMin * compare) {
                            
<span class="nc" id="L124">                            peaks.add(idx);</span>
                        }
                        
                        break;
                    }
                }
            }
        }

<span class="fc" id="L133">        return peaks.toArray(new int[peaks.size()]);</span>
    }
    
    /**
     * find the minima above lowThreshold and the maxima in values
     * and return their indexes.  the negative values are -1*index for a minima
     * while positive indexes are the indexes of maxima.
     * 
     * @param values
     * @param lowThreshold
     * @return 
     */
    public int[] findMinimaMaxima(float[] values, float lowThreshold) {
        
<span class="fc" id="L147">        TIntList minMaxIdxs = new TIntArrayList();</span>
        
<span class="fc" id="L149">        float lastK = values[0];</span>
<span class="fc" id="L150">        boolean incr = true;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (int ii = 1; ii &lt; values.length; ii++) {</span>

<span class="fc" id="L153">            float currentK = values[ii];</span>

<span class="fc bfc" id="L155" title="All 4 branches covered.">            if ((currentK &lt; lastK) &amp;&amp; incr) {</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">                if (values[ii - 1] &gt; lowThreshold) {</span>
<span class="fc" id="L157">                    minMaxIdxs.add(ii - 1);</span>
                }
<span class="fc" id="L159">                incr = false;</span>
<span class="fc bfc" id="L160" title="All 4 branches covered.">            } else if ((currentK &gt; lastK) &amp;&amp; !incr) {</span>
                // values below outputLowThreshold[0] are handled by
                // callers.  TODO: redesign the caller and this method
                // to not need to understand peculiarities of the data.
<span class="fc" id="L164">                minMaxIdxs.add(-1*(ii - 1));</span>
<span class="fc" id="L165">                incr = true;</span>
            }

<span class="fc" id="L168">            lastK = currentK;</span>
        }

<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (incr) {</span>
            // add the last point
<span class="fc" id="L173">             minMaxIdxs.add(values.length - 1);</span>
        }
        
<span class="fc" id="L176">        return minMaxIdxs.toArray(new int[minMaxIdxs.size()]);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>