<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscSorter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.misc</a> &gt; <span class="el_source">MiscSorter.java</span></div><h1>MiscSorter.java</h1><pre class="source lang-java linenums">package algorithms.misc;

/**
 * 
   first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright
   and license.

 * @author nichole
 */
<span class="nc" id="L15">public class MiscSorter {</span>
    
    /**
     * use quicksort to sort a by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     */
    public static void sortBy1stArg(int[] a, int[] b) {
        
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L27">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L29" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L30">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L33">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L36">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L37">    }</span>
    
    
    /**
     * sort by increasing value a1 and apply same changes to a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     */
    public static void sortBy1stArgThen2nd(float[] a1, float[] a2) {
<span class="fc bfc" id="L49" title="All 2 branches covered.">        if (a1 == null) {</span>
<span class="fc" id="L50">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (a2 == null) {</span>
<span class="fc" id="L53">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (a1.length != a2.length) {</span>
<span class="fc" id="L56">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
<span class="fc" id="L59">        sortBy1stArgThen2nd(a1, a2, 0, a1.length - 1);</span>
<span class="fc" id="L60">    }</span>
    
     
    /**
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     * @param idxLo starting index of sorting of a1, inclusive
     * @param idxHi stopping index of sorting of a1, inclusive
     */
    public static void sortBy1stArgThen2nd(float[] a1, float[] a2, int idxLo, 
        int idxHi) {

<span class="fc" id="L72">        int indexMid = -1;</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L76">            indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
<span class="fc" id="L77">            sortBy1stArgThen2nd(a1, a2, idxLo, indexMid);</span>
<span class="fc" id="L78">            sortBy1stArgThen2nd(a1, a2, indexMid + 1, idxHi);</span>
<span class="fc" id="L79">            mergeBy1stArgThen2nd(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L81">    }</span>
    
    private static void mergeBy1stArgThen2nd(float[] a1, float[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L86">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L87">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L89">        float[] a2Left = new float[nLeft + 1];</span>
<span class="fc" id="L90">        float[] a1Left = new float[nLeft + 1];</span>

<span class="fc" id="L92">        float[] a2Right = new float[nRight + 1];</span>
<span class="fc" id="L93">        float[] a1Right = new float[nRight + 1];</span>

<span class="fc" id="L95">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L96">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L98">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L99">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L101">        a2Left[nLeft] = Float.MAX_VALUE;</span>
<span class="fc" id="L102">        a1Left[nLeft] = Float.MAX_VALUE;</span>
<span class="fc" id="L103">        a2Right[nRight] = Float.MAX_VALUE;</span>
<span class="fc" id="L104">        a1Right[nRight] = Float.MAX_VALUE;</span>

<span class="fc" id="L106">        int leftPos = 0;</span>
<span class="fc" id="L107">        int rightPos = 0;</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L110">            float l = a1Left[leftPos];</span>
<span class="fc" id="L111">            float r = a1Right[rightPos];</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">            if (l == r) {</span>
<span class="fc" id="L114">                float lx = a2Left[leftPos];</span>
<span class="fc" id="L115">                float rx = a2Right[rightPos];</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">                if (lx &lt;= rx) {</span>
<span class="fc" id="L118">                    a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L119">                    a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L120">                    leftPos++;</span>
                } else {
<span class="fc" id="L122">                    a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L123">                    a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L124">                    rightPos++;</span>
                }
<span class="fc bfc" id="L126" title="All 2 branches covered.">            } else if (l &lt; r) {</span>
<span class="fc" id="L127">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L128">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L129">                leftPos++;</span>
            } else {
<span class="fc" id="L131">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L132">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L133">                rightPos++;</span>
            }
        }
<span class="fc" id="L136">    }</span>

    public static void sortBy1stArg(int[] a, float[] b) {
        
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L141">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L144">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L150">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L151">    }</span>
       
    /**
     * use mergesort to sort by increasing values of a and apply same swaps to
     * b.
     * @param a
     * @param b 
     */
    public static void sortBy1stArg2(int[] a, int[] b) {
        
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L162">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L165">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L168">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L171">        sortBy1stArg2(a, b, 0, a.length - 1);</span>
<span class="fc" id="L172">    }</span>
    
    /**
     * use quicksort to 
       sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L187">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L190">            return;</span>
        }
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L194">            int x = a[idxLo];</span>
<span class="fc" id="L195">            int store = idxLo;</span>
<span class="fc" id="L196">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L200">                    store++;     </span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L203">                    idxMid--;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L206">                    break;</span>
                }
<span class="fc" id="L208">                int swap = a[store];</span>
<span class="fc" id="L209">                a[store] = a[idxMid];</span>
<span class="fc" id="L210">                a[idxMid] = swap;</span>
<span class="fc" id="L211">                int swap2 = b[store];</span>
<span class="fc" id="L212">                b[store] = b[idxMid];</span>
<span class="fc" id="L213">                b[idxMid] = swap2;</span>
<span class="fc" id="L214">            }</span>
<span class="fc" id="L215">            int swap = a[idxLo];</span>
<span class="fc" id="L216">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L217">            a[idxMid] = swap;</span>
<span class="fc" id="L218">            int swap2 = b[idxLo];</span>
<span class="fc" id="L219">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L220">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L222">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L224">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L226">    }</span>

    /**
     * use mergesort to sort by decreasing value a1 and apply 
       same changes to a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     */
    public static void sortByDecr(int[] a1, int[] a2) {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (a1 == null) {</span>
<span class="nc" id="L239">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (a2 == null) {</span>
<span class="nc" id="L242">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
        
<span class="fc" id="L249">        sortByDecr(a1, a2, 0, a1.length - 1);</span>
              
<span class="fc" id="L251">    }</span>
    
    public static void sortBy1stArgDecrThen2ndIncr(int[] a1, int[] a2) {
        
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (a1 == null) {</span>
<span class="nc" id="L256">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (a2 == null) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L262">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
        
<span class="fc" id="L266">        sortBy1stArgDecrThen2ndIncr(a1, a2, 0, a1.length - 1);</span>
<span class="fc" id="L267">    }</span>

    /**
     * use mergesort to sort by decreasing value a1 and apply 
       same changes to a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     */
    public static void sortByDecr(float[] a1, int[] a2) {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (a1 == null) {</span>
<span class="nc" id="L280">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (a2 == null) {</span>
<span class="nc" id="L283">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
        
<span class="fc" id="L290">        sortByDecr(a1, a2, 0, a1.length - 1);</span>
              
<span class="fc" id="L292">    }</span>
    
/**
     * sort by increasing value a1 and apply same changes to a2.
     * 
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     */
    public static void sortBy1stArg(float[] a1, float[] a2) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (a1 == null) {</span>
<span class="nc" id="L304">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (a2 == null) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L310">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
<span class="nc" id="L313">        sortBy1stArg(a1, a2, 0, a1.length - 1);</span>
<span class="nc" id="L314">    }</span>
    
    /**
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     * @param idxLo starting index of sorting of a1, inclusive
     * @param idxHi stopping index of sorting of a1, inclusive
     */
    public static void sortBy1stArg(float[] a1, float[] a2, int idxLo, 
        int idxHi) {

<span class="fc" id="L325">        int indexMid = -1;</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L329">            indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
<span class="fc" id="L330">            sortBy1stArg(a1, a2, idxLo, indexMid);</span>
<span class="fc" id="L331">            sortBy1stArg(a1, a2, indexMid + 1, idxHi);</span>
<span class="fc" id="L332">            mergeBy1stArg(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L334">    }</span>
    
    private static void mergeBy1stArg(float[] a1, float[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L339">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L340">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L342">        float[] a2Left = new float[nLeft + 1];</span>
<span class="fc" id="L343">        float[] a1Left = new float[nLeft + 1];</span>

<span class="fc" id="L345">        float[] a2Right = new float[nRight + 1];</span>
<span class="fc" id="L346">        float[] a1Right = new float[nRight + 1];</span>

<span class="fc" id="L348">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L349">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L351">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L352">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L354">        a2Left[nLeft] = Float.MAX_VALUE;</span>
<span class="fc" id="L355">        a1Left[nLeft] = Float.MAX_VALUE;</span>
<span class="fc" id="L356">        a2Right[nRight] = Float.MAX_VALUE;</span>
<span class="fc" id="L357">        a1Right[nRight] = Float.MAX_VALUE;</span>

<span class="fc" id="L359">        int leftPos = 0;</span>
<span class="fc" id="L360">        int rightPos = 0;</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L363">            float l = a1Left[leftPos];</span>
<span class="fc" id="L364">            float r = a1Right[rightPos];</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (l &lt;= r) {</span>
<span class="fc" id="L367">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L368">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L369">                leftPos++;</span>
            } else {
<span class="fc" id="L371">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L372">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L373">                rightPos++;</span>
            }
        }
<span class="fc" id="L376">    }</span>
    
    /**
     * use mergesort to sort a1 by increasing values and apply same changes to
     * a2.
     * @param a1
     * @param a2
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg2(int[] a1, int[] a2, int idxLo, int idxHi) {

<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L390">            int indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
            
<span class="fc" id="L392">            sortBy1stArg2(a1, a2, idxLo, indexMid);</span>
            
<span class="fc" id="L394">            sortBy1stArg2(a1, a2, indexMid + 1, idxHi);</span>
            
<span class="fc" id="L396">            mergeBy1stArg(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L398">    }</span>
    
    public static void sortBy1stArg(int[] a1, float[] a2, int idxLo, int idxHi) {

<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L404">            int indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
            
<span class="fc" id="L406">            sortBy1stArg(a1, a2, idxLo, indexMid);</span>
            
<span class="fc" id="L408">            sortBy1stArg(a1, a2, indexMid + 1, idxHi);</span>
            
<span class="fc" id="L410">            mergeBy1stArg(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L412">    }</span>
    
    public static void sortBy1stArgDecrThen2ndIncr(int[] a1, int[] a2, 
        int idxLo, int idxHi) {

<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L419">            int indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
            
<span class="fc" id="L421">            sortBy1stArgDecrThen2ndIncr(a1, a2, idxLo, indexMid);</span>
            
<span class="fc" id="L423">            sortBy1stArgDecrThen2ndIncr(a1, a2, indexMid + 1, idxHi);</span>
            
<span class="fc" id="L425">            mergeBy1stArgDecrThen2ndIncr(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L427">    }</span>

    /**
     * use mergesort to sort by decreasing value a1 and apply 
       same changes to a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
       @param idxLo smallest index to participate in sort
       @param idxHi largest index to participate n sort
    */
    public static void sortByDecr(int[] a1, int[] a2, int idxLo, int idxHi) {

<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L444">            int indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
            
<span class="fc" id="L446">            sortByDecr(a1, a2, idxLo, indexMid);</span>
            
<span class="fc" id="L448">            sortByDecr(a1, a2, indexMid + 1, idxHi);</span>
            
<span class="fc" id="L450">            mergeByDecr(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L452">    }</span>

    /**
     * use mergesort to sort by decreasing value a1 and apply 
       same changes to a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
       @param idxLo smallest index to participate in sort
       @param idxHi largest index to participate n sort
    */
    public static void sortByDecr(float[] a1, int[] a2, int idxLo, int idxHi) {

<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L469">            int indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
            
<span class="fc" id="L471">            sortByDecr(a1, a2, idxLo, indexMid);</span>
            
<span class="fc" id="L473">            sortByDecr(a1, a2, indexMid + 1, idxHi);</span>
            
<span class="fc" id="L475">            mergeByDecr(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L477">    }</span>
    
    private static void mergeByDecr(int[] a1, int[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L482">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L483">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L485">        int[] a2Left = new int[nLeft + 1];</span>
<span class="fc" id="L486">        int[] a1Left = new int[nLeft + 1];</span>

<span class="fc" id="L488">        int[] a2Right = new int[nRight + 1];</span>
<span class="fc" id="L489">        int[] a1Right = new int[nRight + 1];</span>

<span class="fc" id="L491">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L492">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L494">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L495">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L497">        int sentinel = Integer.MIN_VALUE;</span>
<span class="fc" id="L498">        a2Left[nLeft] = sentinel;</span>
<span class="fc" id="L499">        a1Left[nLeft] = sentinel;</span>
<span class="fc" id="L500">        a2Right[nRight] = sentinel;</span>
<span class="fc" id="L501">        a1Right[nRight] = sentinel;</span>
        
<span class="fc" id="L503">        int leftPos = 0;</span>
<span class="fc" id="L504">        int rightPos = 0;</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L507">            int l = a1Left[leftPos];</span>
<span class="fc" id="L508">            int r = a1Right[rightPos];</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (l &gt;= r) {</span>
<span class="fc" id="L510">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L511">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L512">                leftPos++;</span>
            } else {
<span class="fc" id="L514">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L515">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L516">                rightPos++;</span>
            }
        }
<span class="fc" id="L519">    }</span>
    
    private static void mergeBy1stArg(int[] a1, float[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L524">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L525">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L527">        float[] a2Left = new float[nLeft + 1];</span>
<span class="fc" id="L528">        int[] a1Left = new int[nLeft + 1];</span>

<span class="fc" id="L530">        float[] a2Right = new float[nRight + 1];</span>
<span class="fc" id="L531">        int[] a1Right = new int[nRight + 1];</span>

<span class="fc" id="L533">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L534">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L536">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L537">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L539">        int sentinel = Integer.MAX_VALUE;</span>
<span class="fc" id="L540">        float sentinel2 = Float.POSITIVE_INFINITY;</span>
<span class="fc" id="L541">        a2Left[nLeft] = sentinel2;</span>
<span class="fc" id="L542">        a1Left[nLeft] = sentinel;</span>
<span class="fc" id="L543">        a2Right[nRight] = sentinel2;</span>
<span class="fc" id="L544">        a1Right[nRight] = sentinel;</span>
        
<span class="fc" id="L546">        int leftPos = 0;</span>
<span class="fc" id="L547">        int rightPos = 0;</span>

<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L550">            int l = a1Left[leftPos];</span>
<span class="fc" id="L551">            int r = a1Right[rightPos];</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            if (l &lt;= r) {</span>
<span class="fc" id="L553">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L554">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L555">                leftPos++;</span>
            } else {
<span class="fc" id="L557">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L558">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L559">                rightPos++;</span>
            }
        }
<span class="fc" id="L562">    }</span>
    
    private static void mergeBy1stArg(int[] a1, int[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L567">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L568">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L570">        int[] a2Left = new int[nLeft + 1];</span>
<span class="fc" id="L571">        int[] a1Left = new int[nLeft + 1];</span>

<span class="fc" id="L573">        int[] a2Right = new int[nRight + 1];</span>
<span class="fc" id="L574">        int[] a1Right = new int[nRight + 1];</span>

<span class="fc" id="L576">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L577">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L579">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L580">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L582">        int sentinel = Integer.MAX_VALUE;</span>
<span class="fc" id="L583">        a2Left[nLeft] = sentinel;</span>
<span class="fc" id="L584">        a1Left[nLeft] = sentinel;</span>
<span class="fc" id="L585">        a2Right[nRight] = sentinel;</span>
<span class="fc" id="L586">        a1Right[nRight] = sentinel;</span>
        
<span class="fc" id="L588">        int leftPos = 0;</span>
<span class="fc" id="L589">        int rightPos = 0;</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L592">            int l = a1Left[leftPos];</span>
<span class="fc" id="L593">            int r = a1Right[rightPos];</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            if (l &lt;= r) {</span>
<span class="fc" id="L595">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L596">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L597">                leftPos++;</span>
            } else {
<span class="fc" id="L599">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L600">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L601">                rightPos++;</span>
            }
        }
<span class="fc" id="L604">    }</span>
    
    private static void mergeBy1stArgDecrThen2ndIncr(int[] a1, int[] a2, 
        int idxLo, int idxMid, int idxHi) {

<span class="fc" id="L609">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L610">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L612">        int[] a2Left = new int[nLeft + 1];</span>
<span class="fc" id="L613">        int[] a1Left = new int[nLeft + 1];</span>

<span class="fc" id="L615">        int[] a2Right = new int[nRight + 1];</span>
<span class="fc" id="L616">        int[] a1Right = new int[nRight + 1];</span>

<span class="fc" id="L618">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L619">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L621">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L622">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L624">        int sentinel = Integer.MIN_VALUE;</span>
<span class="fc" id="L625">        a2Left[nLeft] = sentinel;</span>
<span class="fc" id="L626">        a1Left[nLeft] = sentinel;</span>
<span class="fc" id="L627">        a2Right[nRight] = sentinel;</span>
<span class="fc" id="L628">        a1Right[nRight] = sentinel;</span>
        
<span class="fc" id="L630">        int leftPos = 0;</span>
<span class="fc" id="L631">        int rightPos = 0;</span>
<span class="fc" id="L632">        boolean lft = false;</span>
        
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L635">            int l = a1Left[leftPos];</span>
<span class="fc" id="L636">            int r = a1Right[rightPos];</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (l &gt; r) {</span>
<span class="fc" id="L638">                lft = true;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">            } else if (l == r) {</span>
<span class="fc" id="L640">                int l2 = a2Left[leftPos];</span>
<span class="fc" id="L641">                int r2 = a2Right[rightPos];</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">                if (l2 &lt;= r2) {</span>
<span class="fc" id="L643">                    lft = true;</span>
                } else {
<span class="nc" id="L645">                    lft = false;</span>
                }
<span class="fc" id="L647">            } else {</span>
<span class="fc" id="L648">                lft = false;</span>
            }
            
<span class="fc bfc" id="L651" title="All 2 branches covered.">            if (lft) {</span>
<span class="fc" id="L652">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L653">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L654">                leftPos++;</span>
            } else {
<span class="fc" id="L656">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L657">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L658">                rightPos++;</span>
            }
        }
<span class="fc" id="L661">    }</span>
    
    private static void mergeByDecr(float[] a1, int[] a2, int idxLo, 
        int idxMid, int idxHi) {

<span class="fc" id="L666">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L667">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L669">        int[] a2Left = new int[nLeft + 1];</span>
<span class="fc" id="L670">        float[] a1Left = new float[nLeft + 1];</span>

<span class="fc" id="L672">        int[] a2Right = new int[nRight + 1];</span>
<span class="fc" id="L673">        float[] a1Right = new float[nRight + 1];</span>

<span class="fc" id="L675">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L676">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>
        
<span class="fc" id="L678">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L679">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>
        
<span class="fc" id="L681">        int sentinel = Integer.MIN_VALUE;</span>
<span class="fc" id="L682">        float sentinel1 = Float.NEGATIVE_INFINITY;</span>
<span class="fc" id="L683">        a2Left[nLeft] = sentinel;</span>
<span class="fc" id="L684">        a1Left[nLeft] = sentinel1;</span>
<span class="fc" id="L685">        a2Right[nRight] = sentinel;</span>
<span class="fc" id="L686">        a1Right[nRight] = sentinel1;</span>
        
<span class="fc" id="L688">        int leftPos = 0;</span>
<span class="fc" id="L689">        int rightPos = 0;</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L692">            float l = a1Left[leftPos];</span>
<span class="fc" id="L693">            float r = a1Right[rightPos];</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            if (l &gt;= r) {</span>
<span class="fc" id="L695">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L696">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L697">                leftPos++;</span>
            } else {
<span class="fc" id="L699">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L700">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L701">                rightPos++;</span>
            }
        }
<span class="fc" id="L704">    }</span>
    
    /**
     * sort by increasing value a1 for ties sort by a2.
     * Ties are further sorted by increasing values of a2.
     * runtime is O(N * log_2(N))
     *
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     */
    public static void sortBy1stArgThen2nd(int[] a1, int[] a2) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (a1 == null) {</span>
<span class="fc" id="L716">            throw new IllegalArgumentException(&quot;a1 cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (a2 == null) {</span>
<span class="fc" id="L719">            throw new IllegalArgumentException(&quot;a2 cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L721" title="All 2 branches covered.">        if (a1.length != a2.length) {</span>
<span class="fc" id="L722">            throw new IllegalArgumentException(</span>
            &quot;number of items in a1 must be the same as in a2&quot;);
        }
<span class="fc" id="L725">        sortBy1stArgThen2nd(a1, a2, 0, a1.length - 1);</span>
<span class="fc" id="L726">    }</span>
    
    /**
     * @param a1 array of points to be sorted
     * @param a2 array of points to apply a1 sorting to also
     * @param idxLo starting index of sorting of a1, inclusive
     * @param idxHi stopping index of sorting of a1, inclusive
     */
    public static void sortBy1stArgThen2nd(int[] a1, int[] a2, int idxLo,
        int idxHi) {

<span class="fc" id="L737">        int indexMid = -1;</span>
        
<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L741">            indexMid = (idxLo + idxHi) &gt;&gt; 1;</span>
<span class="fc" id="L742">            sortBy1stArgThen2nd(a1, a2, idxLo, indexMid);</span>
<span class="fc" id="L743">            sortBy1stArgThen2nd(a1, a2, indexMid + 1, idxHi);</span>
<span class="fc" id="L744">            mergeBy1stArgThen2nd(a1, a2, idxLo, indexMid, idxHi);</span>
        }
<span class="fc" id="L746">    }</span>
    
    private static void mergeBy1stArgThen2nd(int[] a1, int[] a2, int idxLo,
        int idxMid, int idxHi) {

<span class="fc" id="L751">        int nLeft = idxMid - idxLo + 1;</span>
<span class="fc" id="L752">        int nRight = idxHi - idxMid;</span>

<span class="fc" id="L754">        int[] a2Left = new int[nLeft + 1];</span>
<span class="fc" id="L755">        int[] a1Left = new int[nLeft + 1];</span>

<span class="fc" id="L757">        int[] a2Right = new int[nRight + 1];</span>
<span class="fc" id="L758">        int[] a1Right = new int[nRight + 1];</span>

<span class="fc" id="L760">        System.arraycopy(a1, idxLo, a1Left, 0, nLeft);</span>
<span class="fc" id="L761">        System.arraycopy(a2, idxLo, a2Left, 0, nLeft);</span>

<span class="fc" id="L763">        System.arraycopy(a1, idxMid + 1, a1Right, 0, nRight);</span>
<span class="fc" id="L764">        System.arraycopy(a2, idxMid + 1, a2Right, 0, nRight);</span>

<span class="fc" id="L766">        int sentinel = Integer.MAX_VALUE;</span>
<span class="fc" id="L767">        a2Left[nLeft] = sentinel;</span>
<span class="fc" id="L768">        a1Left[nLeft] = sentinel;</span>
<span class="fc" id="L769">        a2Right[nRight] = sentinel;</span>
<span class="fc" id="L770">        a1Right[nRight] = sentinel;</span>

<span class="fc" id="L772">        int leftPos = 0;</span>
<span class="fc" id="L773">        int rightPos = 0;</span>

<span class="fc bfc" id="L775" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc" id="L776">            float l = a1Left[leftPos];</span>
<span class="fc" id="L777">            float r = a1Right[rightPos];</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (l == r) {</span>
<span class="fc" id="L780">                float lx = a2Left[leftPos];</span>
<span class="fc" id="L781">                float rx = a2Right[rightPos];</span>

<span class="fc bfc" id="L783" title="All 2 branches covered.">                if (lx &lt;= rx) {</span>
<span class="fc" id="L784">                    a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L785">                    a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L786">                    leftPos++;</span>
                } else {
<span class="fc" id="L788">                    a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L789">                    a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L790">                    rightPos++;</span>
                }
<span class="fc bfc" id="L792" title="All 2 branches covered.">            } else if (l &lt; r) {</span>
<span class="fc" id="L793">                a2[k] = a2Left[leftPos];</span>
<span class="fc" id="L794">                a1[k] = a1Left[leftPos];</span>
<span class="fc" id="L795">                leftPos++;</span>
            } else {
<span class="fc" id="L797">                a2[k] = a2Right[rightPos];</span>
<span class="fc" id="L798">                a1[k] = a1Right[rightPos];</span>
<span class="fc" id="L799">                rightPos++;</span>
            }
        }
<span class="fc" id="L802">    }</span>
 
               
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>