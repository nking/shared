<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KNearestNeighbors.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.search</a> &gt; <span class="el_source">KNearestNeighbors.java</span></div><h1>KNearestNeighbors.java</h1><pre class="source lang-java linenums">package algorithms.search;

import thirdparty.voronoi.VoronoiFortunesSweep;
import algorithms.FixedSizeSortedVector;
import algorithms.util.PairFloat;
import algorithms.util.PolygonAndPointPlotter;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import thirdparty.voronoi.VoronoiFortunesSweep.GraphEdge;
import thirdparty.voronoi.VoronoiFortunesSweep.Site;

/**
 * A class to find the k nearest neighbors of a given
 * query point.  Internally, it uses a voronoi diagram
 * to find the neighbors of the nearest point to the
 * query point and returns the k closest to the query 
 * point by adjacent voronoi sites.
 * 
  &lt;pre&gt;
  constructor, one time cost, runtime complexity:
      O(N * log_2(N))
  kNN query best runtime complexity:
      O(log_2(N)) + O(n_nearest_edges * log_2(k))
      (compare to KDTree O(sqrt(N) + k)?)
  kNN query worse runtime complexity:
      O(N) + O(n_nearest_edges * log_2(k))
      (compare to KD Tree worse runtime is O(N)?)
  &lt;/pre&gt;
  first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

 * @author nichole
 */
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">public class KNearestNeighbors {</span>
    
<span class="pc" id="L46">    private VoronoiFortunesSweep voronoi = null;</span>
    
<span class="pc" id="L48">    private Map&lt;PairFloat, Set&lt;Integer&gt;&gt; siteIndexesMap = null;</span>
    
    // TODO: may want to swap this out for a faster means of
    //    finding the nearest (x[i], y[i]) for a query point
<span class="pc" id="L52">    private KDTreeFloat kdTree = null;</span>
    
<span class="pc" id="L54">    private float xmin = Float.MAX_VALUE;</span>
<span class="pc" id="L55">    private float xmax = Float.NEGATIVE_INFINITY;</span>
<span class="pc" id="L56">    private float ymin = Float.MAX_VALUE;</span>
<span class="pc" id="L57">    private float ymax = Float.NEGATIVE_INFINITY;</span>
        
<span class="nc" id="L59">    public KNearestNeighbors(int[] x, int[] y) {</span>
<span class="nc" id="L60">        init(x, y);</span>
<span class="nc" id="L61">    }</span>
    
<span class="fc" id="L63">    public KNearestNeighbors(float[] x, float[] y) {</span>
<span class="fc" id="L64">        init(x, y);</span>
<span class="fc" id="L65">    }</span>
    
    private void init(int[] x, int[] y) {
        
<span class="nc bnc" id="L69" title="All 10 branches missed.">        if (x == null || x.length == 0 || y == null</span>
            || y.length == 0 || (x.length != y.length)) {
<span class="nc" id="L71">            throw new IllegalArgumentException(</span>
                &quot;x and y cannot be null or empty &quot;
                    + &quot;and must be same lengths&quot;);
        }
        
<span class="nc" id="L76">        int n = x.length;</span>
        
<span class="nc" id="L78">        float[] x2 = new float[n];</span>
<span class="nc" id="L79">        float[] y2 = new float[n];</span>
    
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L82">            x2[i] = x[i];</span>
<span class="nc" id="L83">            y2[i] = y[i];</span>
        }
        
<span class="nc" id="L86">        init(x2, y2);</span>
<span class="nc" id="L87">    }</span>
    
    private void init(float[] x, float[] y) {
        
<span class="pc bpc" id="L91" title="5 of 10 branches missed.">        if (x == null || x.length == 0 || y == null</span>
            || y.length == 0 || (x.length != y.length)) {
<span class="nc" id="L93">            throw new IllegalArgumentException(</span>
                &quot;x and y cannot be null or empty &quot;
                    + &quot;and must be same lengths&quot;);
        }
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (x.length &lt; 3) {</span>
<span class="nc" id="L98">            throw new IllegalArgumentException(&quot;x and y &quot;</span>
            + &quot; must be at least length 3 in size&quot;);
        }
        
<span class="fc" id="L102">        int n = x.length;</span>
        
<span class="fc" id="L104">        xmin = Float.MAX_VALUE;</span>
<span class="fc" id="L105">        xmax = Float.NEGATIVE_INFINITY;</span>
<span class="fc" id="L106">        ymin = Float.MAX_VALUE;</span>
<span class="fc" id="L107">        ymax = Float.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L109">            float xp = x[i];</span>
<span class="fc" id="L110">            float yp = y[i];</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (xp &lt; xmin) {</span>
<span class="fc" id="L112">                xmin = xp;</span>
            }
<span class="fc bfc" id="L114" title="All 2 branches covered.">            if (xp &gt; xmax) {</span>
<span class="fc" id="L115">                xmax = xp;</span>
            }
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (yp &lt; ymin) {</span>
<span class="fc" id="L118">                ymin = yp;</span>
            }
<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (yp &gt; ymax) {</span>
<span class="fc" id="L121">                ymax = yp;</span>
            }
        }
        
<span class="fc" id="L125">        int minDist = 0;</span>

<span class="fc" id="L127">        voronoi = new VoronoiFortunesSweep();</span>
    
        // O(N * log_2(N)) to build
<span class="fc" id="L130">        voronoi.generateVoronoi(x, y, xmin, xmax, ymin, ymax,</span>
            minDist);
        
<span class="fc" id="L133">        LinkedList&lt;GraphEdge&gt; edges = voronoi.getAllEdges();</span>
        
<span class="fc" id="L135">        Site[] sites = voronoi.getSites();</span>
        
<span class="fc" id="L137">        siteIndexesMap = new HashMap&lt;PairFloat, Set&lt;Integer&gt;&gt;();</span>
    
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">        assert (!edges.isEmpty());</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (GraphEdge edge : edges) {</span>
<span class="fc" id="L141">            int s1 = edge.site1;</span>
<span class="fc" id="L142">            int s2 = edge.site2;</span>

<span class="fc" id="L144">            PairFloat p1 = sites[s1].getCoord();</span>
<span class="fc" id="L145">            PairFloat p2 = sites[s2].getCoord();</span>

<span class="fc" id="L147">            Set&lt;Integer&gt; indexes = siteIndexesMap.get(p1);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L149">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L150">                siteIndexesMap.put(p1, indexes);</span>
            }
<span class="fc" id="L152">            indexes.add(Integer.valueOf(s2));</span>

<span class="fc" id="L154">            indexes = siteIndexesMap.get(p2);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L156">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L157">                siteIndexesMap.put(p2, indexes);</span>
            }
<span class="fc" id="L159">            indexes.add(Integer.valueOf(s1));</span>
<span class="fc" id="L160">        }</span>

<span class="pc bpc" id="L162" title="3 of 4 branches missed.">        assert(sites.length == x.length);</span>

        // points closer than minDist are not present,
        // so the map is possibly smaller than all points.
        // therefore, for this use of voronoi, need minDist=0.
        {//DEBUG
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            if (siteIndexesMap.size() != x.length) {</span>
<span class="nc" id="L169">                Logger.getLogger(this.getClass().getName())</span>
<span class="nc" id="L170">                    .warning(&quot;siteMap.size=&quot; + siteIndexesMap.size()</span>
                    + &quot; x.length=&quot; + x.length);
            }
        }
        //assert(siteIndexesMap.size() == x.length);
        
        // retrieve the points from voronoi sites because they are sorted
<span class="fc" id="L177">        n = sites.length;</span>
<span class="fc" id="L178">        float[] xp = new float[n];</span>
<span class="fc" id="L179">        float[] yp = new float[n];</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L181">            PairFloat p = sites[i].getCoord();</span>
<span class="fc" id="L182">            xp[i] = p.getX();</span>
<span class="fc" id="L183">            yp[i] = p.getY();</span>
        }
        
        //O(N*lg_2(N)
<span class="fc" id="L187">        kdTree = new KDTreeFloat(xp, yp, true);</span>
<span class="fc" id="L188">    }</span>

    private float dist(float x, float y, PairFloat p) {
<span class="fc" id="L191">        float diffX = x - p.getX();</span>
<span class="fc" id="L192">        float diffY = y - p.getY();</span>
<span class="fc" id="L193">        return (float)Math.sqrt(diffX * diffX) + (diffY * diffY);</span>
    }
    
    private class PairDist implements Comparable&lt;PairDist&gt;{
        PairFloat s1;
        float dist;
        @Override
        public int compareTo(PairDist other) {
            if (dist &lt; other.dist) {
                return -1;
            } else if (dist &gt; other.dist) {
                return 1;
            }
            return 0;
        }
    }
    
    public List&lt;PairFloat&gt; findNearest(int k, float x, float y) {
<span class="fc" id="L211">        return findNearest(k, x, y, Float.MAX_VALUE);</span>
    }
        
    public List&lt;PairFloat&gt; findNearest(int k, float x, float y,
        float maxDistance) {
       
        // O(log_2(N) at best, but some extreme queries are O(N).
        // nearest site(s). (if same distances, returns more than one).
<span class="fc" id="L219">        Set&lt;PairFloat&gt; nearest = kdTree.findNearestNeighbor(x, y);</span>
      
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (nearest == null) {</span>
<span class="nc" id="L222">            return null;</span>
        }
        
        /*
        a fixed vector of size k tracks the nearest and nearest
        adjacent.
        
        the search for k nearest continues in the adjacent sites
        as long as the adjacent site (whose neighbors should be
        searched) is nearer than the last item in the fixed vector.
        
        */
        
        // each fixed size vector comparison on insert is O(log_2(k))
<span class="fc" id="L236">        FixedSizeSortedVector&lt;PairDist&gt; vec = </span>
            new FixedSizeSortedVector&lt;PairDist&gt;(k, PairDist.class);
        
<span class="fc" id="L239">        Site[] sites = voronoi.getSites();</span>
        
<span class="fc" id="L241">        Set&lt;PairFloat&gt; visited = new HashSet&lt;PairFloat&gt;();</span>
        
<span class="fc" id="L243">        ArrayDeque&lt;PairFloat&gt; queue = new ArrayDeque&lt;PairFloat&gt;();</span>
<span class="fc" id="L244">        queue.addAll(nearest);</span>
        
<span class="fc bfc" id="L246" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
            
<span class="fc" id="L248">            PairFloat site = queue.pop();</span>
                 
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (visited.contains(site)) {</span>
<span class="fc" id="L251">                continue;</span>
            }
<span class="fc" id="L253">            visited.add(site);</span>
            
<span class="fc" id="L255">            float dist = dist(x, y, site);</span>

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (dist &gt; maxDistance) {</span>
<span class="nc" id="L258">                continue;</span>
            }
            
            // if vec is not full or if site is closer than
            //  last full vec member, add site and add it's neighbors
            //  to queue
            
<span class="fc" id="L265">            int nV = vec.getNumberOfItems();</span>
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">            if ((nV &lt; k) || ((nV &gt; 0) &amp;&amp; </span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                (dist &lt; vec.getArray()[nV-1].dist))) {</span>
            
<span class="fc" id="L269">                PairDist pd = new PairDist();</span>
<span class="fc" id="L270">                pd.s1 = site;</span>
<span class="fc" id="L271">                pd.dist = dist;</span>
<span class="fc" id="L272">                vec.add(pd);                </span>
            
                // add neighbors to queue
                
<span class="fc" id="L276">                Set&lt;Integer&gt; siteIndexes = siteIndexesMap.get(site);</span>
            
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                if (siteIndexes == null) {</span>
<span class="nc" id="L279">                    throw new IllegalStateException(&quot;error in algorithm:&quot;</span>
                        + &quot; voronoi diagram has no neighbors for &quot;
<span class="nc" id="L281">                        + &quot; (&quot; + site.getX() + &quot;,&quot; + site.getY() + &quot;)&quot;);</span>
                }
            
<span class="fc bfc" id="L284" title="All 2 branches covered.">                for (Integer index2 : siteIndexes) {</span>
<span class="fc" id="L285">                    PairFloat site2 = sites[index2.intValue()].getCoord();</span>
<span class="fc" id="L286">                    queue.add(site2);</span>
<span class="fc" id="L287">                }</span>
            }
<span class="fc" id="L289">        }</span>
        
<span class="fc" id="L291">        List&lt;PairFloat&gt; output = new ArrayList&lt;PairFloat&gt;();</span>
<span class="fc" id="L292">        PairDist[] a = vec.getArray();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; vec.getNumberOfItems(); ++i) {</span>
<span class="fc" id="L294">            output.add(a[i].s1);</span>
        }
        
<span class="fc" id="L297">        return output;</span>
    }
    
    public void debug(int fileNumber) throws IOException {
        
<span class="nc" id="L302">        Site[] sites = voronoi.getSites();</span>
<span class="nc" id="L303">        int n = sites.length;</span>
<span class="nc" id="L304">        float[] x = new float[n];</span>
<span class="nc" id="L305">        float[] y = new float[n];</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L307">            x[i] = sites[i].getCoord().getX();</span>
<span class="nc" id="L308">            y[i] = sites[i].getCoord().getY();</span>
        }
        
<span class="nc" id="L311">        LinkedList&lt;GraphEdge&gt; edges = voronoi.getAllEdges();</span>
        
<span class="nc" id="L313">        PolygonAndPointPlotter plotter = </span>
            new PolygonAndPointPlotter(xmin, xmax, ymin, ymax);
        
<span class="nc" id="L316">        float[] xPolygon = null;</span>
<span class="nc" id="L317">        float[] yPolygon = null;</span>
        
<span class="nc" id="L319">        plotter.addPlot(x, y, xPolygon, yPolygon, &quot;points&quot;);</span>
        
<span class="nc" id="L321">        int n2 = edges.size();</span>
<span class="nc" id="L322">        xPolygon = new float[2*n2];</span>
<span class="nc" id="L323">        yPolygon = new float[2*n2];</span>
<span class="nc" id="L324">        int count = 0;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
<span class="nc" id="L326">            xPolygon[count] = edge.x1;</span>
<span class="nc" id="L327">            yPolygon[count] = edge.y1;</span>
<span class="nc" id="L328">            xPolygon[count + 1] = edge.x2;</span>
<span class="nc" id="L329">            yPolygon[count + 1] = edge.y2;</span>
<span class="nc" id="L330">            count += 2;</span>
<span class="nc" id="L331">        }</span>
<span class="nc" id="L332">        plotter.addPlotWithLines(x, y, xPolygon, yPolygon, </span>
            &quot;edges&quot;);
<span class="nc" id="L334">        String filePath = plotter.writeFile(&quot;debug_voron_&quot; + fileNumber);</span>
<span class="nc" id="L335">        System.out.println(&quot;wrote file=&quot; + filePath);</span>
<span class="nc" id="L336">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>