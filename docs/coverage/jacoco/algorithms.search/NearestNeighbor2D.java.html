<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NearestNeighbor2D.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.search</a> &gt; <span class="el_source">NearestNeighbor2D.java</span></div><h1>NearestNeighbor2D.java</h1><pre class="source lang-java linenums">package algorithms.search;

import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;
import thirdparty.ods.Integerizer;
import thirdparty.ods.XFastTrie;
import thirdparty.ods.XFastTrieNode;

/**
 * a nearest neighbor's algorithm using XFastTrie
 * for predecessor and successor queries
 * on spatially indexed numbers.
 * 
 * The algorithm performs better on dense data
 * (that is because the base of the prefix tree
 * is filled, leaving smaller number of nodes to
 * create in linear time).
 * The queries depend upon the maximum of x and
 * maximum of y to be entered.
 * 
 * At this time, all entries must be non-negative numbers and
 * so must inquiries.
 * 
 * A worst case query would be when column 0 is
 * filled with points and no others filled elsewhere, 
 * and the last point in the last row and last 
 * column is the query point.
 * In this worst case, the query time would scale
 * roughly as maxY * O(log_2(w))
 
  The algorithm starts with a predecessor and successor 
  call on the query point.  The minimum distance among
  those 2 becomes the goal to search to for completeness
  as rows above and below the query in the same column.
  The search continues to higher rows making predecessor and
  successor calls until the goal is reached.  The next higher
  row is one less than the predecessor result.
  The goal to the complete search is reduced by smaller distance
  answers.  The same is repeated for lower rows.
  &lt;pre&gt;
  an example would be:
  
     0   1   2   3   4

     5   6   7   8   9

     10  11 *12  13  14     q='18'.  pred='15', succ='null' --&gt; goals(3, 23)
                                     13.pred='12'
    *15  16  17 *18  19              goals change to (13,23)
                                     13.succ='15', not closer than 12.
     20  21  22  23  24              23.pred and 23.succ not closer than 12
                             ans='12'.  queries: 3 pred, 3 succ queries.
                                     at O(log_2(w)) each
                                     complexity was 
                                           6 * O(log_2(w))
                                     for max index = 24, have w = 6 
 &lt;/ore&gt;

   first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright

 * @author nichole
 */
public class NearestNeighbor2D {
    
    private final XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt; xbt;
            
    private final int width;
    
    private final int height;
    
    private final int maxIndex;
    
<span class="fc" id="L85">    private boolean useCache = true;</span>
    
<span class="fc" id="L87">    private TIntIntMap pCache = new TIntIntHashMap();</span>
<span class="fc" id="L88">    private TIntIntMap sCache = new TIntIntHashMap();</span>
    
<span class="fc" id="L90">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    /**
     * 
     * @param points non-negative coordinates
     * @param maxX maximum x value of any data point including
     *    those to be queries
     * @param maxY maximum y value of any data point including
     *    those to be queries
     */
    public NearestNeighbor2D(Set&lt;PairInt&gt; points,
<span class="fc" id="L101">        int maxX, int maxY) {</span>
        
<span class="fc" id="L103">        this.width = maxX + 1;</span>
<span class="fc" id="L104">        this.height = maxY + 1;</span>
                
<span class="fc" id="L106">        maxIndex = width * height;</span>
        
<span class="fc" id="L108">        Integerizer&lt;Integer&gt; it = new Integerizer&lt;Integer&gt;() {</span>
            @Override
            public int intValue(Integer x) {
                return x;
            }
        };
        
<span class="fc" id="L115">        int maxW = 1 + (int)Math.ceil(Math.log(maxIndex)/Math.log(2));</span>
        
<span class="fc" id="L117">        xbt = new XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt;(</span>
            new XFastTrieNode&lt;Integer&gt;(), it, maxW);
        
<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (PairInt p : points) {</span>
            
<span class="fc" id="L122">            int x = p.getX();</span>
<span class="fc" id="L123">            int y = p.getY();</span>
            
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">            if (x &gt; width || x &lt; 0) {</span>
<span class="nc" id="L126">                throw new IllegalArgumentException(</span>
                    &quot;x cannot be larger than &quot;
                    + &quot; maxX given in constructor &quot; + width
                    + &quot;. x=&quot; + x);
            }

<span class="pc bpc" id="L132" title="2 of 4 branches missed.">            if (y &gt; height || y &lt; 0) {</span>
<span class="nc" id="L133">                throw new IllegalArgumentException(</span>
                    &quot;y cannot be larger than &quot;
                    + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
            }
            
<span class="fc" id="L138">            int index = getInternalIndex(x, y);</span>
<span class="fc" id="L139">            xbt.add(Integer.valueOf(index));</span>
<span class="fc" id="L140">        }</span>
<span class="fc" id="L141">    }</span>
    
    public void doNotUseCache() {
<span class="fc" id="L144">        useCache = false;</span>
<span class="fc" id="L145">    }</span>
    
    protected int getInternalIndex(int col, int row) {
<span class="fc" id="L148">        return (row * width) + col;</span>
    }
    
    protected int getRow(int internalIndex) {
<span class="fc" id="L152">        int row = internalIndex/width;        </span>
<span class="fc" id="L153">        return row;</span>
    }
    
    protected int getCol(int internalIndex) {
<span class="fc" id="L157">        int row = internalIndex/width;</span>
<span class="fc" id="L158">        int col = internalIndex - (row * width);</span>
<span class="fc" id="L159">        return col;</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 2 * O(log_2(maxW)).
            Note that caching leads to an O(1) term
            over time instead of the logarithmic term.
            
         worst case: nRows * 2 * O(log_2(maxW))
         
         Note, worst case is: first column
         filled with points and all else is empty and
         the number of rows is same or larger than 
         number of columns and the
         query is for the point in the last column and
         last row... a predecessor call is necessary for
         each row in the worst case.
          
     Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));            
     &lt;/ore&gt;
    
     * @param x non-negative x coord to query for
     * @param y non-negative y coord to query for
     */
    public Set&lt;PairInt&gt; findClosest(final int x, final int y) {
        
<span class="fc" id="L187">        return findClosestWithinTolerance(x, y, 0);</span>
    }
    
    /**
     * NOTE: NOT READY FOR USE
     * method to return only the nearest point and any
     * that are at the same distance within a tolerance.
     * This is meant to be a nearest neighbor method
     * with a tolerance.  
     * TODO: calculate the runtime complexity bounds....
     * @param x non-negative x coord to query for
     * @param y non-negative y coord to query for
     * @param tolerance
     * @return 
     */
    public Set&lt;PairInt&gt; findClosestWithinTolerance(int x, int y,
        double tolerance) {
        
<span class="pc bpc" id="L205" title="2 of 4 branches missed.">        if (x &gt;= width || x &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L207">            log.fine(</span>
            &quot;x cannot be larger than &quot;
                + &quot; maxX given in constructor &quot; + width
                + &quot;. x=&quot; + x);
<span class="nc" id="L211">            return null;</span>
        }
        
<span class="pc bpc" id="L214" title="2 of 4 branches missed.">        if (y &gt;= height || y &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L216">            log.fine(</span>
                &quot;y cannot be larger than &quot;
                + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
<span class="nc" id="L219">            return null;</span>
        }
        
<span class="fc" id="L222">        double closestDist = Double.MAX_VALUE;</span>
<span class="fc" id="L223">        double closestDistPlusTol = Double.MAX_VALUE;</span>
        
<span class="fc" id="L225">        TIntSet closestIndexes = new TIntHashSet();</span>
        
<span class="fc" id="L227">        int idx = getInternalIndex(x, y);</span>
<span class="fc" id="L228">        Integer index = Integer.valueOf(idx);</span>
        
        //O(1)
<span class="fc" id="L231">        Integer q = xbt.find(index);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (q != null) {</span>
            // have found nearest, but still need to search
            // within tolerance distance for others.
<span class="fc" id="L235">            closestDist = 0;</span>
<span class="fc" id="L236">            closestDistPlusTol = tolerance;</span>
<span class="fc" id="L237">            closestIndexes.add(index.intValue());</span>
        }
                
<span class="fc" id="L240">        Integer predecessor = null;</span>
<span class="fc" id="L241">        Integer successor = null;</span>
        
<span class="pc bpc" id="L243" title="1 of 4 branches missed.">        if (useCache &amp;&amp; pCache.containsKey(idx)) {</span>
<span class="nc" id="L244">            predecessor = Integer.valueOf(pCache.get(idx));</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L247">            predecessor = xbt.predecessor(index);</span>
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">            if (useCache &amp;&amp; predecessor != null) {</span>
<span class="fc" id="L249">                pCache.put(idx, predecessor.intValue());</span>
            }
        }
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">        if (useCache &amp;&amp; sCache.containsKey(idx)) {</span>
<span class="nc" id="L253">            successor = Integer.valueOf(sCache.get(idx));</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L256">            successor = xbt.successor(index);</span>
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">            if (useCache &amp;&amp; successor != null){</span>
<span class="fc" id="L258">                sCache.put(idx, successor.intValue());</span>
            }
        }
        
<span class="fc" id="L262">        double dp2 = dist(x, y, predecessor);</span>
<span class="fc" id="L263">        double ds2 = dist(x, y, successor);</span>
<span class="fc" id="L264">        double dMin = Math.min(dp2, ds2);</span>
        
        /*
        if smallest is smaller than closest 
           if the new closest diff with current is greater 
               than tol, clear the indexes and reset closest 
               vars and add smallest to indexes
               also add the other if within tolerance
           else if closer is within tolerance,
              update closest vars and add whichever or both 
              s2 and p2 to indexes (delaying detailed checks 
              of indexes until end of method)
        else if smallest is &lt;= closestPlusTol
            add s2 and/or p2 to indexes
        */
        
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (dMin &lt;= closestDist) {</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="fc" id="L282">                closestIndexes.clear();</span>
<span class="fc" id="L283">                closestDist = dMin;</span>
<span class="fc" id="L284">                closestDistPlusTol = closestDist + tolerance;</span>
            }
<span class="pc bpc" id="L286" title="2 of 4 branches missed.">            if ((predecessor != null) &amp;&amp; </span>
                (dp2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L288">                closestIndexes.add(predecessor.intValue());</span>
            }
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">            if ((successor != null) &amp;&amp;</span>
                (ds2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L292">                closestIndexes.add(successor.intValue());</span>
            }
<span class="fc bfc" id="L294" title="All 2 branches covered.">        } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">            if ((predecessor != null) &amp;&amp; </span>
                (dp2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L297">                closestIndexes.add(predecessor.intValue());</span>
            }
<span class="pc bpc" id="L299" title="2 of 4 branches missed.">            if ((successor != null) &amp;&amp;</span>
                (ds2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L301">                closestIndexes.add(successor.intValue());</span>
            }
        }
        
        //add tolerance to goal
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        int goal = (closestDist != Double.MAX_VALUE) ?</span>
<span class="pc" id="L307">            (int)Math.ceil(closestDistPlusTol) : 0;</span>
        
<span class="fc" id="L309">        int yLow = estimateLowBound(y, goal);</span>
       
        int yCurrent;
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (predecessor == null) {</span>
<span class="nc" id="L313">            yCurrent = Integer.MIN_VALUE;</span>
        } else {
<span class="fc" id="L315">            int pRow = getRow(predecessor.intValue());</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (pRow &lt; y) {</span>
<span class="nc" id="L317">                yCurrent = pRow;</span>
            } else {
<span class="fc" id="L319">                yCurrent = pRow - 1;</span>
            }
        }
        
        // predecessor searches until reach yLow, adjusting goal by
        //   min distances
<span class="fc" id="L325">        Integer p2 = null; </span>
<span class="fc" id="L326">        Integer s2 = null;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        while (yCurrent &gt;= yLow) {</span>
<span class="fc" id="L328">            int cIdx = getInternalIndex(x, yCurrent);</span>
<span class="fc" id="L329">            Integer cIndex = Integer.valueOf(cIdx);</span>

            //O(1)
<span class="fc" id="L332">            q = xbt.find(cIndex);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            if (q != null) {</span>
<span class="fc" id="L334">                p2 = q;</span>
<span class="fc" id="L335">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L336">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="nc" id="L339">                    p2 = Integer.valueOf(pCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L342">                    p2 = xbt.predecessor(cIndex);</span>
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != null) {</span>
<span class="fc" id="L344">                        pCache.put(cIdx, p2.intValue());</span>
                    }
                }
<span class="pc bpc" id="L347" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="nc" id="L348">                    s2 = Integer.valueOf(sCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L351">                    s2 = xbt.successor(cIndex);</span>
<span class="pc bpc" id="L352" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != null) {</span>
<span class="fc" id="L353">                        sCache.put(cIdx, s2.intValue());</span>
                    }
                }
                
<span class="fc" id="L357">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L358">                ds2 = dist(x, y, s2);</span>
            }
        
<span class="fc" id="L361">            dMin = Math.min(dp2, ds2);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (dMin &lt;= closestDist) {</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">                if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="nc" id="L364">                    closestIndexes.clear();</span>
<span class="nc" id="L365">                    closestDist = dMin;</span>
<span class="nc" id="L366">                    closestDistPlusTol = closestDist + tolerance;</span>
<span class="nc" id="L367">                    goal = (int)Math.ceil(closestDistPlusTol);</span>
<span class="nc" id="L368">                    yLow = estimateLowBound(y, goal); </span>
                }
<span class="pc bpc" id="L370" title="2 of 4 branches missed.">                if ((p2 != null) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L371">                    closestIndexes.add(p2.intValue());</span>
                }
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">                if ((s2 != null) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="nc" id="L374">                    closestIndexes.add(s2.intValue());</span>
                }
<span class="fc bfc" id="L376" title="All 2 branches covered.">            } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L377" title="2 of 4 branches missed.">                if ((p2 != null) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L378">                    closestIndexes.add(p2.intValue());</span>
                }
<span class="pc bpc" id="L380" title="2 of 4 branches missed.">                if ((s2 != null) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="nc" id="L381">                    closestIndexes.add(s2.intValue());</span>
                }
            }    
            
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (p2 != null) {</span>
<span class="fc" id="L386">                int expectedNext = getInternalIndex(x, yCurrent - 1);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                if (p2.intValue() &gt; expectedNext) {</span>
<span class="fc" id="L388">                    yCurrent -= 1;</span>
                } else {
<span class="nc" id="L390">                    yCurrent = getRow(p2.intValue()) - 1;</span>
                }
<span class="fc" id="L392">            } else {</span>
<span class="nc" id="L393">                yCurrent = Integer.MIN_VALUE;</span>
            }
<span class="fc" id="L395">        }</span>
       
        // successor searches to higher bounds
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (successor == null) {</span>
<span class="nc" id="L399">            yCurrent = Integer.MAX_VALUE;</span>
        } else {
<span class="fc" id="L401">            int sr = getRow(successor.intValue());</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (sr &gt; y) {</span>
<span class="nc" id="L403">                yCurrent = sr;</span>
            } else {
<span class="fc" id="L405">                yCurrent = sr + 1;</span>
            }
        }
<span class="fc" id="L408">        int yHigh = estimateHighBound(y, goal);</span>
        
<span class="fc bfc" id="L410" title="All 2 branches covered.">        while (yCurrent &lt;= yHigh) {</span>
<span class="fc" id="L411">            int cIdx = getInternalIndex(x, yCurrent);</span>
<span class="fc" id="L412">            Integer cIndex = Integer.valueOf(cIdx);</span>
            
            //O(1)
<span class="fc" id="L415">            q = xbt.find(cIndex);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (q != null) {</span>
<span class="fc" id="L417">                p2 = q;</span>
<span class="fc" id="L418">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L419">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L421" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="nc" id="L422">                    p2 = Integer.valueOf(pCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L425">                    p2 = xbt.predecessor(cIndex);</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != null) {</span>
<span class="fc" id="L427">                        pCache.put(cIdx, p2.intValue());</span>
                    }
                }
<span class="pc bpc" id="L430" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="nc" id="L431">                    s2 = Integer.valueOf(sCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L434">                    s2 = xbt.successor(cIndex);</span>
<span class="pc bpc" id="L435" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != null) {</span>
<span class="fc" id="L436">                        sCache.put(cIdx, s2.intValue());</span>
                    }
                }
<span class="fc" id="L439">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L440">                ds2 = dist(x, y, s2);</span>
            }
            
<span class="fc" id="L443">            dMin = Math.min(dp2, ds2);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (dMin &lt;= closestDist) {</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">                if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="nc" id="L446">                    closestIndexes.clear();</span>
<span class="nc" id="L447">                    closestDist = dMin;</span>
<span class="nc" id="L448">                    closestDistPlusTol = closestDist + tolerance;</span>
<span class="nc" id="L449">                    goal = (int)Math.ceil(closestDistPlusTol);</span>
<span class="nc" id="L450">                    yHigh = estimateHighBound(y, goal); </span>
                }
<span class="pc bpc" id="L452" title="2 of 4 branches missed.">                if ((p2 != null) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L453">                    closestIndexes.add(p2.intValue());</span>
                }
<span class="pc bpc" id="L455" title="2 of 4 branches missed.">                if ((s2 != null) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="nc" id="L456">                    closestIndexes.add(s2.intValue());</span>
                }
<span class="fc bfc" id="L458" title="All 2 branches covered.">            } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L459" title="2 of 4 branches missed.">                if ((p2 != null) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L460">                    closestIndexes.add(p2.intValue());</span>
                }
<span class="pc bpc" id="L462" title="2 of 4 branches missed.">                if ((s2 != null) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="nc" id="L463">                    closestIndexes.add(s2.intValue());</span>
                }
            }    
            
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            if (s2 != null) {</span>
<span class="fc" id="L468">                int expectedNext = getInternalIndex(x, yCurrent + 1);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                if (s2.intValue() &lt; expectedNext) {</span>
<span class="fc" id="L470">                    yCurrent += 1;</span>
                } else {
<span class="nc" id="L472">                    yCurrent = getRow(s2.intValue()) + 1;</span>
                }
<span class="fc" id="L474">            } else {</span>
<span class="nc" id="L475">                yCurrent = Integer.MAX_VALUE;</span>
            }
<span class="fc" id="L477">        }</span>
        
        //filter results for closest and tolerance
<span class="fc" id="L480">        Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L481">        TIntIterator iter = closestIndexes.iterator();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L483">            int index2 = iter.next();</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (dist(x, y, index2) &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L485">                int x2 = getCol(index2);</span>
<span class="fc" id="L486">                int y2 = getRow(index2);</span>
<span class="fc" id="L487">                PairInt p3 = new PairInt(x2, y2);</span>
<span class="fc" id="L488">                results.add(p3);</span>
            }
<span class="fc" id="L490">        }</span>
 
<span class="fc" id="L492">        return results;</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 2 * O(log_2(maxW)).
            Note that caching leads to an O(1) term
            over time instead of the logarithmic term.
            
         worst case: dMax * 4 * O(log_2(maxW))
         
      Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));
     &lt;/ore&gt;
    
     * @param x
     * @param y
     * @param dMax
     * @return a set of points within dMax that are the 
     * closest points, else returns an empty set
     */
    public Set&lt;PairInt&gt; findClosest(int x, int y, int dMax) {
        
<span class="pc bpc" id="L515" title="2 of 4 branches missed.">        if (x &gt;= width || x &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L517">            log.fine(</span>
            &quot;x cannot be larger than &quot;
                + &quot; maxX given in constructor &quot; + width
                + &quot;. x=&quot; + x);
<span class="nc" id="L521">            return null;</span>
        }
        
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">        if (y &gt;= height || y &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L526">            log.fine(</span>
                &quot;y cannot be larger than &quot;
                + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
<span class="nc" id="L529">            return null;</span>
        }
        
<span class="fc" id="L532">        int idx = getInternalIndex(x, y);</span>
<span class="fc" id="L533">        Integer index = Integer.valueOf(idx);</span>
        
<span class="fc" id="L535">        Integer q = xbt.find(index);</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (q != null) {</span>
<span class="nc" id="L537">            Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L538">            results.add(new PairInt(x, y));</span>
<span class="nc" id="L539">            return results;</span>
        }
                
<span class="fc" id="L542">        TIntSet closestIndexes = new TIntHashSet();</span>
        
<span class="fc" id="L544">        double closestDist = Double.MAX_VALUE;</span>
        
<span class="fc" id="L546">        Integer predecessor = null;</span>
<span class="fc" id="L547">        Integer successor = null;</span>
        
<span class="pc bpc" id="L549" title="1 of 4 branches missed.">        if (useCache &amp;&amp; pCache.containsKey(idx)) {</span>
<span class="fc" id="L550">            predecessor = Integer.valueOf(pCache.get(idx));</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L553">            predecessor = xbt.predecessor(index);</span>
<span class="pc bpc" id="L554" title="3 of 4 branches missed.">            if (useCache &amp;&amp; predecessor != null) {</span>
<span class="nc" id="L555">                pCache.put(idx, predecessor.intValue());</span>
            }
        }
<span class="pc bpc" id="L558" title="1 of 4 branches missed.">        if (useCache &amp;&amp; sCache.containsKey(idx)) {</span>
<span class="fc" id="L559">            successor = Integer.valueOf(sCache.get(idx));</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L562">            successor = xbt.successor(index);</span>
<span class="pc bpc" id="L563" title="3 of 4 branches missed.">            if (useCache &amp;&amp; successor != null) {</span>
<span class="nc" id="L564">                sCache.put(idx, successor.intValue());</span>
            }
        }
        
<span class="fc" id="L568">        double dp2 = dist(x, y, predecessor);</span>
<span class="fc" id="L569">        double ds2 = dist(x, y, successor);</span>
<span class="pc bpc" id="L570" title="1 of 4 branches missed.">        if (dp2 &lt;= ds2 &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="fc" id="L571">            closestDist = dp2;</span>
<span class="fc" id="L572">            closestIndexes.add(predecessor.intValue());</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            if (dp2 == ds2) {</span>
<span class="fc" id="L574">                closestIndexes.add(successor.intValue());</span>
            }
<span class="pc bpc" id="L576" title="3 of 4 branches missed.">        } else if (ds2 &lt; dp2 &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="nc" id="L577">            closestDist = ds2;</span>
<span class="nc" id="L578">            closestIndexes.add(successor.intValue());</span>
        }
        
<span class="fc bfc" id="L581" title="All 2 branches covered.">        int goal = (closestDist != Double.MAX_VALUE) ?</span>
<span class="fc" id="L582">            (int)Math.ceil(closestDist) : dMax;</span>
        
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (goal &gt; dMax) {</span>
<span class="nc" id="L585">            goal = dMax;</span>
        }
        
<span class="fc" id="L588">        int yLow = estimateLowBound(y, goal);</span>
       
        int yCurrent;
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (predecessor == null) {</span>
<span class="nc" id="L592">            yCurrent = Integer.MIN_VALUE;</span>
        } else {
<span class="fc" id="L594">            int pRow = getRow(predecessor.intValue());</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            if (pRow &lt; y) {</span>
<span class="nc" id="L596">                yCurrent = pRow;</span>
            } else {
<span class="fc" id="L598">                yCurrent = pRow - 1;</span>
            }
        }
        
        // predecessor searches until reach yLow, adjusting goal by
        //   min distances
<span class="fc" id="L604">        Integer p2 = null; </span>
<span class="fc" id="L605">        Integer s2 = null;</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        while (yCurrent &gt;= yLow) {</span>
<span class="fc" id="L607">            int cIdx = getInternalIndex(x, yCurrent);</span>
<span class="fc" id="L608">            Integer cIndex = Integer.valueOf(cIdx);</span>
            
<span class="fc" id="L610">            q = xbt.find(cIndex);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (q != null) {</span>
<span class="fc" id="L612">                p2 = q;</span>
<span class="fc" id="L613">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L614">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L616" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="fc" id="L617">                    p2 = Integer.valueOf(pCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L620">                    p2 = xbt.predecessor(cIndex);</span>
<span class="pc bpc" id="L621" title="3 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != null) {</span>
<span class="nc" id="L622">                        pCache.put(cIdx, p2.intValue());</span>
                    }
                }
<span class="pc bpc" id="L625" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="fc" id="L626">                    s2 = Integer.valueOf(sCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L629">                    s2 = xbt.successor(cIndex);</span>
<span class="pc bpc" id="L630" title="3 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != null) {</span>
<span class="nc" id="L631">                        sCache.put(cIdx, s2.intValue());</span>
                    }
                }
<span class="fc" id="L634">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L635">                ds2 = dist(x, y, s2);</span>
            }
<span class="pc bpc" id="L637" title="3 of 6 branches missed.">            if ((dp2 &lt; ds2) &amp;&amp; (dp2 &lt; closestDist) &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="nc" id="L638">                closestIndexes.clear();</span>
<span class="nc" id="L639">                closestDist = dp2;</span>
<span class="nc" id="L640">                closestIndexes.add(p2);</span>
<span class="nc" id="L641">                goal = (int)Math.ceil(closestDist);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L643">                    goal = dMax;</span>
                }
<span class="nc" id="L645">                yLow = estimateLowBound(y, goal);                </span>
<span class="pc bpc" id="L646" title="1 of 6 branches missed.">            } else if ((ds2 &lt; dp2) &amp;&amp; (ds2 &lt; closestDist) &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="nc" id="L647">                closestIndexes.clear();</span>
<span class="nc" id="L648">                closestDist = ds2;</span>
<span class="nc" id="L649">                closestIndexes.add(s2);</span>
<span class="nc" id="L650">                goal = (int)Math.ceil(closestDist);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L652">                    goal = dMax;</span>
                }
<span class="nc" id="L654">                yLow = estimateLowBound(y, goal);</span>
<span class="pc bpc" id="L655" title="2 of 6 branches missed.">            } else if (dp2 == closestDist &amp;&amp; (dp2 != Double.MAX_VALUE)</span>
                &amp;&amp; (dp2 &lt;= dMax)) {
<span class="fc" id="L657">                closestIndexes.add(p2.intValue());</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">                if (dp2 == ds2) {</span>
<span class="nc" id="L659">                    closestIndexes.add(s2.intValue());</span>
                }
<span class="pc bpc" id="L661" title="5 of 6 branches missed.">            } else if (ds2 == closestDist &amp;&amp; (ds2 != Double.MAX_VALUE)</span>
                &amp;&amp; (ds2 &lt;= dMax)) {
<span class="nc" id="L663">                closestIndexes.add(s2.intValue());</span>
            }
            
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (p2 != null) {</span>
<span class="fc" id="L667">                int expectedNext = getInternalIndex(x, yCurrent - 1);</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">                if (p2.intValue() &gt; expectedNext) {</span>
<span class="fc" id="L669">                    yCurrent -= 1;</span>
                } else {
<span class="nc" id="L671">                    yCurrent = getRow(p2.intValue()) - 1;</span>
                }
<span class="fc" id="L673">            } else {</span>
<span class="nc" id="L674">                yCurrent = Integer.MIN_VALUE;</span>
            }
<span class="fc" id="L676">        }</span>
        
        // successor searches to higher bounds
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">        if (successor == null) {</span>
<span class="nc" id="L680">            yCurrent = Integer.MAX_VALUE;</span>
        } else {
<span class="fc" id="L682">            int sr = getRow(successor.intValue());</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">            if (sr &gt; y) {</span>
<span class="nc" id="L684">                yCurrent = sr;</span>
            } else {
<span class="fc" id="L686">                yCurrent = sr + 1;</span>
            }
        }
<span class="fc" id="L689">        int yHigh = estimateHighBound(y, goal);</span>
        
<span class="fc bfc" id="L691" title="All 2 branches covered.">        while (yCurrent &lt;= yHigh) {</span>
<span class="fc" id="L692">            int cIdx = getInternalIndex(x, yCurrent);</span>
<span class="fc" id="L693">            Integer cIndex = Integer.valueOf(cIdx);            </span>
<span class="fc" id="L694">            q = xbt.find(cIndex);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">            if (q != null) {</span>
<span class="fc" id="L696">                p2 = q;</span>
<span class="fc" id="L697">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L698">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L700" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="fc" id="L701">                    p2 = Integer.valueOf(pCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L704">                    p2 = xbt.predecessor(cIndex);</span>
<span class="pc bpc" id="L705" title="3 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != null) {</span>
<span class="nc" id="L706">                        pCache.put(cIdx, p2.intValue());</span>
                    }
                }
<span class="pc bpc" id="L709" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="fc" id="L710">                    s2 = Integer.valueOf(sCache.get(cIdx));</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L713">                    s2 = xbt.successor(cIndex);</span>
<span class="pc bpc" id="L714" title="3 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != null) {</span>
<span class="nc" id="L715">                        sCache.put(cIdx, s2.intValue());</span>
                    }
                }
<span class="fc" id="L718">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L719">                ds2 = dist(x, y, s2);</span>
            }
<span class="pc bpc" id="L721" title="2 of 6 branches missed.">            if ((dp2 &lt; ds2) &amp;&amp; (dp2 &lt; closestDist) &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="nc" id="L722">                closestIndexes.clear();</span>
<span class="nc" id="L723">                closestDist = dp2;</span>
<span class="nc" id="L724">                closestIndexes.add(p2);</span>
<span class="nc" id="L725">                goal = (int)Math.ceil(closestDist);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L727">                    goal = dMax;</span>
                }
<span class="nc" id="L729">                yHigh = estimateHighBound(y, goal);</span>
<span class="pc bpc" id="L730" title="5 of 6 branches missed.">            } else if ((ds2 &lt; dp2) &amp;&amp; (ds2 &lt; closestDist) &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="nc" id="L731">                closestIndexes.clear();</span>
<span class="nc" id="L732">                closestDist = ds2;</span>
<span class="nc" id="L733">                closestIndexes.add(s2);</span>
<span class="nc" id="L734">                goal = (int)Math.ceil(closestDist);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L736">                    goal = dMax;</span>
                }
<span class="nc" id="L738">                yHigh = estimateHighBound(y, goal);</span>
<span class="pc bpc" id="L739" title="2 of 6 branches missed.">            } else if (dp2 == closestDist &amp;&amp; (dp2 != Double.MAX_VALUE)</span>
                &amp;&amp; (dp2 &lt;= dMax)) {
<span class="fc" id="L741">                closestIndexes.add(p2.intValue());</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">                if (dp2 == ds2) {</span>
<span class="nc" id="L743">                    closestIndexes.add(s2.intValue());</span>
                }
<span class="pc bpc" id="L745" title="5 of 6 branches missed.">            } else if (ds2 == closestDist &amp;&amp; (ds2 != Double.MAX_VALUE)</span>
                &amp;&amp; (ds2 &lt;= dMax)) {
<span class="nc" id="L747">                closestIndexes.add(s2.intValue());</span>
            } 
            
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            if (s2 != null) {</span>
<span class="fc" id="L751">                int expectedNext = getInternalIndex(x, yCurrent + 1);</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                if (s2.intValue() &lt; expectedNext) {</span>
<span class="fc" id="L753">                    yCurrent += 1;</span>
                } else {
<span class="nc" id="L755">                    yCurrent = getRow(s2.intValue()) + 1;</span>
                }
<span class="fc" id="L757">            } else {</span>
<span class="nc" id="L758">                yCurrent = Integer.MAX_VALUE;</span>
            }
<span class="fc" id="L760">        }</span>
        
<span class="fc" id="L762">        Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L763">        TIntIterator iter = closestIndexes.iterator();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L765">            int index2 = iter.next();</span>
<span class="fc" id="L766">            int x2 = getCol(index2);</span>
<span class="fc" id="L767">            int y2 = getRow(index2);</span>
<span class="fc" id="L768">            results.add(new PairInt(x2, y2));</span>
<span class="fc" id="L769">        }</span>
        
<span class="fc" id="L771">        return results;</span>
    }

    private double dist(int x, int y, Integer p2) {
        
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (p2 == null) {</span>
<span class="nc" id="L777">            return Double.MAX_VALUE;</span>
        }
        
<span class="fc" id="L780">        int x2 = getCol(p2.intValue());</span>
<span class="fc" id="L781">        int y2 = getRow(p2.intValue());</span>
        
<span class="fc" id="L783">        int diffX = x2 - x;</span>
<span class="fc" id="L784">        int diffY = y2 - y;</span>
<span class="fc" id="L785">        double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>
        
<span class="fc" id="L787">        return dist;</span>
    }

    private int estimateLowBound(int y, int goal) {

<span class="fc" id="L792">        int low = y - goal;</span>
        
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">        if (low &lt; 0) {</span>
<span class="nc" id="L795">            low = 0;</span>
        }
        
<span class="fc" id="L798">        return low;</span>
    }
    
    private int estimateHighBound(int y, int goal) {

<span class="fc" id="L803">        int high = y + goal;</span>
        
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (high &gt; height) {</span>
<span class="nc" id="L806">            high = height;</span>
        }
        
<span class="fc" id="L809">        return high;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>