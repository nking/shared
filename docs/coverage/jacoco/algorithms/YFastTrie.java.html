<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>YFastTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">YFastTrie.java</span></div><h1>YFastTrie.java</h1><pre class="source lang-java linenums">package algorithms;

import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.util.Map.Entry;
import java.util.TreeMap;
import thirdparty.ods.Integerizer;
import thirdparty.ods.XFastTrie;
import thirdparty.ods.XFastTrieNode;

/**
 * NOTE: has not been tuned for best runtime complexity yet.  
 * 
 * from wikipedia
 *     https://en.wikipedia.org/wiki/Y-fast_trie
 *  
 * a y-fast trie is a data structure for storing 
 * integers from a bounded domain. It supports exact and predecessor 
 * or successor queries in time O(log log M), using O(n) space, 
 * where n is the number of stored values and M is the maximum 
 * value in the domain. 
 * The structure was proposed by Dan Willard in 1982[1] to decrease 
 * the O(n log M) space used by an x-fast trie.
   
   The Y-Fast trie has the ordered associative array operations + successor and
   predecessor.
   
   NOTE that the runtime complexities listed are not yet achieved.
   The current operations depend upon settings, but should be 
   constant runtime complexity .lte. O(10).

   Find(k): find the value associated with the given key.
       runtime complexity is O(log log(M))
   Successor(k): find the key/value pair with the smallest key larger than or 
       equal to the given key.
       runtime complexity is O(log log(M))
   Predecessor(k): find the key/value pair with the largest key less than or 
       equal to the given key.
       runtime complexity is O(log log(M))
   Insert(k, v): insert the given key/value pair.
       runtime complexity is O(log log(M))
   Delete(k): remove the key/value pair with the given key.
       runtime complexity is O(log log(M))
 
 * Note, have not read the Willard paper yet, just a few online
 * lecture notes to implement this.  
 *  
    first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright

 * @author nichole
 */
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">public class YFastTrie {</span>

    /*    
    designing from browsing a few different lecture notes
    online. the yfast trie uses same w and maxC as
    the XFastTrie.
      - creates w red black trees to hold inserted heap nodes.
        the w trees each have range size of maxC/w and
        start from 0 extending to last one holding maxC.
      - each tree has a representative if it has any nodes
        and those are stored
        in the XFastTrie of this YFastTrie.
      - because the XFastTrie only holds w xft values,
        the space complexity is reduced.
-------------------------------
YFastTrie

   - w bits set by maximum expected value to be added.
   - one XFastTrie to hold the representives (at most w in number)
   - w red black trees to keep ordered points.
     - because some of the items added may have more than
       one with same key value, the values in the red black tree
       will be linked lists.

    NOTE: topics to consider for improvements:
          the distribution of rb trees, that is their partitions,
          could be improved dynamically.
          For example, if maxC were value 127, but the majority
          of nodes at some point in time were in bin 0 at values
          near 4, one would prefer to divide that tree 
          into more than one tree to speed up searches.
          This begins to look like a good reason to
          compare to multi-level-buckets.  The only implementation
          I could find was the Andrew Goldberg MLB offered 
          under a license that is freely available for non-commercial
          use, else need to contact for permission... not wanting
          to include mixed license restrictions for now...
          (so I didn't download and read the code.  am reading
          his 2 papers on the subject, but they depend upon other
          papers too, so gathering all the specs for the MLB
          algorithms is not complete...)
          -- one possible work around without making dynamic
          partitions in the YFastTrie would be to know or 
          estimate the population of data ahead of time and 
          then make separate YFastTrie's for manually partitioned 
          data (changing zero-points, a.k.a. bias levels as needed
          before and after use of more than one YFastTrie)
    */
    
<span class="fc" id="L110">    private int n = 0;</span>
    
    private final int w;
    
    private final int maxC;
    
    private final int binSz;
    
    private int nBins;

    private final XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt; xft;
    
    // key = bin index, value = repr value.
    // each repr value is the minimum stored in the bin.
<span class="fc" id="L124">    private final TIntIntMap xftReps = new TIntIntHashMap();</span>
    
    // there are w items in rbs
    // each list item is a sorted binary search tree of numbers in that bin.
    //    the value is the tree holds the number of times that number is present.
    private final TIntObjectMap&lt;TreeMap&lt;Integer, Integer&gt;&gt; rbs;

<span class="fc" id="L131">    private boolean chooseByN = true;</span>

<span class="fc" id="L133">    public YFastTrie(int wBits) {</span>
        
<span class="pc bpc" id="L135" title="2 of 4 branches missed.">        if (wBits &lt; 31 &amp;&amp; wBits &gt; 1) {</span>
<span class="fc" id="L136">            this.w = wBits;</span>
        } else {
<span class="nc" id="L138">            throw new IllegalStateException(&quot;wBits &quot;</span>
                + &quot; should be greater than 1 and less than 32&quot;
                + &quot; wBits=&quot; + wBits);
        }
<span class="fc" id="L142">        maxC = (1 &lt;&lt; w) - 1;</span>
        
        /*
        LG binsize = (int)Math.ceil((float)maxC/(float)w);
        MID binsize = 10
        
        w,     binsz,     n,             rt
        31,    69273666,  31,            26.   LG
        31,    5.0,       429496729.6,   2.32  MID
        
        10,    102,       10,            6.67  LG
        10,    4.0,       256.0,         2.0   MID
        
        aiming for a runtime of about O(10) or better without increasing n too
        much.
        
        alternatively, could keep n as large as possible within good
        performance range, hence the binsz will be small, hence the
        runtime will be small.
        
        n            TreeMaps
        n * binSz    objects in TreeMaps
        
        heapsize: 100's or more MB
        */
        
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (chooseByN) {</span>
<span class="fc" id="L169">            binSz = chooseBinSizeByN();</span>
        } else {
<span class="nc" id="L171">            int tmpLg = (int) Math.ceil((float) maxC / (float) w);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if ((Math.log(tmpLg) / Math.log(2)) &lt; 10) {</span>
<span class="nc" id="L173">                binSz = tmpLg;</span>
            } else {
<span class="nc" id="L175">                binSz = 1024;</span>
            }
        }
        
<span class="fc" id="L179">        nBins = (int)Math.ceil((float)maxC/(float)binSz);</span>
                
<span class="fc" id="L181">        System.out.println(&quot;nBins=&quot; + nBins + &quot;  rt of ops=&quot; +</span>
<span class="fc" id="L182">            (Math.log(binSz)/Math.log(2)));</span>
        
<span class="fc" id="L184">        rbs = new TIntObjectHashMap&lt;TreeMap&lt;Integer, Integer&gt;&gt;();</span>
         
<span class="fc" id="L186">        XFastTrieNode&lt;Integer&gt; clsNode = new XFastTrieNode&lt;Integer&gt;();</span>
<span class="fc" id="L187">        Integerizer&lt;Integer&gt; it = new Integerizer&lt;Integer&gt;() {</span>
            @Override
            public int intValue(Integer x) {
                return x;
            }
        };
        
<span class="fc" id="L194">        xft = new XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt;(clsNode, it, w);</span>
<span class="fc" id="L195">    }</span>
    
<span class="fc" id="L197">    public YFastTrie() {</span>
        
<span class="fc" id="L199">        this.w = 30;</span>
        
<span class="fc" id="L201">        maxC = (1 &lt;&lt; w) - 1;</span>
        
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (chooseByN) {</span>
<span class="fc" id="L204">            binSz = chooseBinSizeByN();</span>
        } else {
<span class="nc" id="L206">            int tmpLg = (int) Math.ceil((float) maxC / (float) w);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if ((Math.log(tmpLg) / Math.log(2)) &lt; 10) {</span>
<span class="nc" id="L208">                binSz = tmpLg;</span>
            } else {
<span class="nc" id="L210">                binSz = 1024;</span>
            }
        }
        
<span class="fc" id="L214">        nBins = (int)Math.ceil((float)maxC/(float)binSz);</span>
                
<span class="fc" id="L216">        System.out.println(&quot;nBins=&quot; + nBins + &quot;  rt of ops=&quot; +</span>
<span class="fc" id="L217">            (Math.log(binSz)/Math.log(2)));</span>
        
<span class="fc" id="L219">        rbs = new TIntObjectHashMap&lt;TreeMap&lt;Integer, Integer&gt;&gt;();</span>
        
<span class="fc" id="L221">        XFastTrieNode&lt;Integer&gt; clsNode = new XFastTrieNode&lt;Integer&gt;();</span>
<span class="fc" id="L222">        Integerizer&lt;Integer&gt; it = new Integerizer&lt;Integer&gt;() {</span>
            @Override
            public int intValue(Integer x) {
                return x;
            }
        };
        
<span class="fc" id="L229">        xft = new XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt;(clsNode, it, w);</span>
<span class="fc" id="L230">    }</span>
    
    protected TreeMap&lt;Integer, Integer&gt; getTreeMap(int index) {
<span class="fc" id="L233">        Integer key = Integer.valueOf(index);</span>
<span class="fc" id="L234">        TreeMap&lt;Integer, Integer&gt; map = rbs.get(key);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L236">            map = new TreeMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L237">            rbs.put(key, map);</span>
        }
<span class="fc" id="L239">        return map;</span>
    }

    /**
     * 
     * @param node
     * @param index 
     */
    private void addToRBTree(int node, int index) {
        
<span class="fc" id="L249">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(index);</span>
        
<span class="pc bpc" id="L251" title="3 of 4 branches missed.">        assert(map != null);</span>
        
<span class="fc" id="L253">        Integer key = Integer.valueOf(node);</span>
        
<span class="fc" id="L255">        Integer multiplicity = map.get(key);</span>
    
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (multiplicity == null) {</span>
<span class="fc" id="L258">            multiplicity = Integer.valueOf(1);</span>
        } else {
<span class="fc" id="L260">            multiplicity = Integer.valueOf(1 + multiplicity.intValue());</span>
        }
        
<span class="fc" id="L263">        map.put(key, multiplicity);        </span>
<span class="fc" id="L264">    }</span>
    
    /**
     * 
     * @param node
     * @param index 
     */
    private boolean deleteFromRBTree(int node, int index) {
                
<span class="fc" id="L273">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(index);</span>
        
<span class="pc bpc" id="L275" title="3 of 4 branches missed.">        assert(map != null);</span>
        
<span class="fc" id="L277">        Integer key = Integer.valueOf(node);</span>

<span class="fc" id="L279">        Integer multiplicity = map.get(key);</span>
    
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (multiplicity == null) {</span>
<span class="nc" id="L282">            return false;</span>
        }
        
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (multiplicity.intValue() &gt; 0) {</span>
<span class="fc" id="L286">            multiplicity = Integer.valueOf(multiplicity.intValue() - 1);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (multiplicity.intValue() &gt; 0) {</span>
<span class="fc" id="L288">                map.put(key, multiplicity);</span>
            }
        }
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (multiplicity.intValue() == 0) {</span>
<span class="fc" id="L292">            map.remove(key);</span>
        }
        
<span class="fc" id="L295">        return true;</span>
    }
    
    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @param node a number &gt;= 0 and having bit length 
     * less than or equal to w.
     * @return 
     */
    public boolean add(int node) {

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (node &lt; 0) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be greater than or equal to 0&quot;);
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        } else if (node &gt; maxC) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;node.key must &quot;</span>
                + &quot;be less than &quot; + maxC + &quot; node=&quot; + node);
        }
        
<span class="fc" id="L318">        int index = node/binSz;</span>
        
<span class="fc" id="L320">        int existingRepr = xftReps.get(index);</span>
                
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (!xftReps.containsKey(index)) {</span>
            // insert is O(log_2(w)) + O(l-w)
<span class="fc" id="L324">            xft.add(Integer.valueOf(node));</span>
<span class="fc" id="L325">            xftReps.put(index, node);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        } else if (node &lt; existingRepr) {</span>
            // delete is O(log_2(w)) + O(l-w)
            // insert is O(log_2(w)) + O(l-w)
<span class="fc" id="L329">            xft.remove(Integer.valueOf(existingRepr));</span>
<span class="fc" id="L330">            xft.add(Integer.valueOf(node));</span>
<span class="fc" id="L331">            xftReps.put(index, node);</span>
        }
                
<span class="fc" id="L334">        addToRBTree(node, index);</span>
        
<span class="fc" id="L336">        n++;</span>
        
<span class="fc" id="L338">        return true;</span>
    }

    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @param node
     * @return 
     */
    public boolean remove(int node) {
        
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (node &lt; 0) {</span>
<span class="nc" id="L353">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be greater than or equal to 0&quot;);
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        } else if (node &gt; maxC) {</span>
<span class="nc" id="L356">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be less than &quot; + maxC);
        }
        
<span class="fc" id="L360">        int index = node/binSz;</span>
                
<span class="fc" id="L362">        boolean removed = deleteFromRBTree(node, index);</span>
                
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (!removed) {</span>
<span class="nc" id="L365">            return false;</span>
        }
        
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (!xftReps.containsKey(index)) {</span>
<span class="nc" id="L369">            return false;</span>
        }
        
<span class="fc" id="L372">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(index);</span>
      
<span class="fc" id="L374">        int existingRepr = xftReps.get(index);</span>
      
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
            // just deleted the last item so remove from rbs
            // delete is O(log_2(w)) + O(w-l)
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (xftReps.containsKey(index)) {</span>
<span class="fc" id="L380">                xft.remove(Integer.valueOf(existingRepr));</span>
<span class="fc" id="L381">                xftReps.remove(index);</span>
            }
<span class="fc bfc" id="L383" title="All 2 branches covered.">        } else if (node == existingRepr) {</span>
            
            //existingRepr is maintained as the minimum in the bin,
            //   so if a node w/ this value is removed and the multiplicity
            //      was 1, need to assign a new repr
            
            // O(log_2(N/w))
<span class="fc" id="L390">            Integer multiplicity = map.get(Integer.valueOf(node));</span>
    
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (multiplicity == null) {</span>
                // remove the current repr and assign a new one
                // delete is O(log_2(w)) + O(w-l)
<span class="fc" id="L395">                xft.remove(Integer.valueOf(existingRepr));</span>
<span class="fc" id="L396">                xftReps.remove(index);</span>
            
                // O(log_2(N/w))
<span class="fc" id="L399">                Entry&lt;Integer, Integer&gt; minEntry = map.firstEntry(); </span>
<span class="fc" id="L400">                xft.add(minEntry.getKey());</span>
<span class="fc" id="L401">                xftReps.put(index, minEntry.getKey()); </span>
            }            
        }
        
<span class="fc" id="L405">        n--;</span>
        
<span class="fc" id="L407">        return true;</span>
    }

    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @param node
     * @return 
     */
    public int find(int node) {
                
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (node &lt; 0) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be greater than or equal to 0&quot;);
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        } else if (node &gt; maxC) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be less than &quot; + maxC + &quot;. node=&quot; + node);
        }
                
<span class="fc" id="L429">        int index = node/binSz;</span>
                
<span class="fc" id="L431">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(index);</span>
        
<span class="fc" id="L433">        Integer multiplicity = map.get(Integer.valueOf(node));</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (multiplicity == null) {</span>
<span class="fc" id="L435">            return -1;</span>
        }
        
<span class="fc" id="L438">        return node;</span>
    }

    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @param node
     * @return value preceding node, else -1 if there is not one
     */
    public int predecessor(int node) {
    
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        if (node &lt; 0) {</span>
<span class="nc" id="L453">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be greater than or equal to 0&quot;);
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        } else if (node &gt; maxC) {</span>
<span class="nc" id="L456">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be less than &quot; + maxC);
        }
        
<span class="fc" id="L460">        Integer nodeKey = Integer.valueOf(node);</span>
        
<span class="fc" id="L462">        int nodeIndex = node/binSz;</span>
        
        // the repr is stored in xft and it is always the minium for the bin
<span class="fc bfc" id="L465" title="All 2 branches covered.">        boolean isAMinimum = xft.find(nodeKey) != null;</span>
        
        /*
        if the node is not a minima, the answer is in
           the node's map if its size is larger &gt; 1
        */
        
<span class="fc" id="L472">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(nodeIndex);</span>
        
<span class="fc bfc" id="L474" title="All 4 branches covered.">        if (!isAMinimum &amp;&amp; (map.size() &gt; 1)) {</span>
<span class="fc" id="L475">            Entry&lt;Integer, Integer&gt; pred = map.lowerEntry(nodeKey);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            if (pred != null) {</span>
<span class="fc" id="L477">                return pred.getKey().intValue();</span>
            }
        }
       
        // else, predeccessor is in the closest bin &lt; nodeIndex that has
        //    items in it.
                
<span class="fc" id="L484">        Integer prev = xft.predecessor(nodeKey);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (prev == null) {</span>
<span class="fc" id="L486">            return -1;</span>
        }
        
<span class="fc" id="L489">        int prev0Index = prev.intValue()/binSz;</span>
            
<span class="fc" id="L491">        map = getTreeMap(prev0Index);</span>
                
<span class="fc" id="L493">        Entry&lt;Integer, Integer&gt; lastItem = map.lastEntry();</span>
               
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (lastItem == null) {</span>
<span class="nc" id="L496">            return -1;</span>
        }
        
<span class="fc" id="L499">        return lastItem.getKey();</span>
    }
    
    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @param node
     * @return 
     */
    public int successor(int node) {
                
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">        if (node &lt; 0) {</span>
<span class="nc" id="L514">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be greater than or equal to 0&quot;);
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        } else if (node &gt; maxC) {</span>
<span class="nc" id="L517">            throw new IllegalArgumentException(&quot;node must &quot;</span>
                + &quot;be less than &quot; + maxC);
        }
        
<span class="fc" id="L521">        Integer nodeKey = Integer.valueOf(node);</span>
        
<span class="fc" id="L523">        int nodeIndex = node/binSz;</span>
        
<span class="fc bfc" id="L525" title="All 2 branches covered.">        boolean isAMinimum = xft.find(nodeKey) != null;</span>
        
<span class="fc" id="L527">        TreeMap&lt;Integer, Integer&gt; nodeMap = getTreeMap(nodeIndex);</span>
        
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (isAMinimum) {</span>
            // if tree size &gt; 1, the next key is the successor
            // else, the xft sucessor to nodeIndex is the successor
            
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (nodeMap.size() &gt; 1) {</span>
<span class="fc" id="L534">                Entry&lt;Integer, Integer&gt; successor = nodeMap.higherEntry(nodeKey);</span>
<span class="pc bpc" id="L535" title="3 of 4 branches missed.">                assert(successor != null);</span>
<span class="fc" id="L536">                return successor.getKey();</span>
            }
            
<span class="nc" id="L539">            Integer successorRepr = xft.successor(nodeKey);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (successorRepr == null) {</span>
<span class="nc" id="L541">                return -1;</span>
            }
            
            // the successor representative is then the next value
<span class="nc" id="L545">            return successorRepr;</span>
        }
        
        // else, the node is not a repr
        //   if there is a tree successor to the node, that is the successor
        //   else, the xft successor to nodeIndex is the successor
                    
<span class="fc" id="L552">        Entry&lt;Integer, Integer&gt; sEntry = nodeMap.higherEntry(nodeKey);</span>
        
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (sEntry != null) {</span>
<span class="fc" id="L555">            return sEntry.getKey();</span>
        }
        
<span class="fc" id="L558">        Integer successorRepr = xft.successor(nodeKey);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (successorRepr == null) {</span>
<span class="nc" id="L560">            return -1;</span>
        }

        // the successor representative is then the next value
<span class="fc" id="L564">        return successorRepr;</span>
    }

    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * runtime complexity is O(log_2(w)) 
     * @return minimum, else -1 if empty
     */
    public int minimum() {
        
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">        if (xft.size() == 0) {</span>
<span class="nc" id="L579">            return -1;</span>
        }
        
<span class="fc" id="L582">        Integer repr = xft.minimum();</span>
        
<span class="pc bpc" id="L584" title="3 of 4 branches missed.">        assert(repr != null);</span>
       
<span class="fc" id="L586">        return repr.intValue();</span>
    }

    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * @return maximum, else -1 if empty
     */
    public int maximum() {
        
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        if (xft.size() == 0) {</span>
<span class="nc" id="L600">            return -1;</span>
        }
        
<span class="fc" id="L603">        Integer maxRepr = xft.maximum();</span>
        
<span class="pc bpc" id="L605" title="3 of 4 branches missed.">        assert(maxRepr != null);</span>
        
<span class="fc" id="L607">        int index = maxRepr.intValue()/binSz;</span>
        
<span class="fc" id="L609">        TreeMap&lt;Integer, Integer&gt; map = getTreeMap(index);</span>
        
<span class="pc bpc" id="L611" title="3 of 4 branches missed.">        assert(map != null);</span>
        
<span class="fc" id="L613">        Entry&lt;Integer, Integer&gt; lastItem = map.lastEntry();</span>
        
<span class="pc bpc" id="L615" title="3 of 4 branches missed.">        assert(lastItem != null);</span>
        
<span class="fc" id="L617">        return lastItem.getKey();</span>
    }
    
    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * TODO: calc runtime complexity again
     * 
     * @return minumum, else -1 if empty
     */
    public int extractMinimum() {
        
        //O(log_2(w))
<span class="fc" id="L633">        int min = minimum();</span>

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (min == -1) {</span>
<span class="nc bnc" id="L636" title="All 4 branches missed.">            assert(xft.size() == 0);</span>
<span class="nc" id="L637">            return -1;</span>
        }
                
<span class="fc" id="L640">        remove(min);</span>
        
<span class="fc" id="L642">        return min;</span>
    }
    
    /**
     * runtime complexity is roughly .lte. O(10) and may be better than this
     * for some datasets.  The runtime is dependent on the bit length of the
     * largest number to hold or query, and the balance between the number
     * of bins and number of items per bin.
     * 
     * TODO: calc runtime complexity again
     * 
     * @return maximum, else -1 if empty
     */
    public int extractMaximum() {
        
<span class="fc" id="L657">        int max = maximum();</span>

<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (max == -1) {</span>
<span class="nc bnc" id="L660" title="All 4 branches missed.">            assert(xft.size() == 0);</span>
<span class="nc" id="L661">            return -1;</span>
        }
                
<span class="fc" id="L664">        remove(max);</span>
        
<span class="fc" id="L666">        return max;</span>
    }
    
    public int size() {
<span class="fc" id="L670">        return n;</span>
    }

    private int chooseBinSizeByN() {
        
<span class="fc" id="L675">        long totalMemory = Runtime.getRuntime().totalMemory();</span>
<span class="fc" id="L676">        MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();</span>
<span class="fc" id="L677">        long heapUsage = mbean.getHeapMemoryUsage().getUsed();</span>
<span class="fc" id="L678">        long avail = totalMemory - heapUsage;</span>

<span class="fc" id="L680">        long n = avail/32;</span>
        
        // n = maxC/binsz
<span class="fc" id="L683">        int bs = (int)(maxC/n);</span>
        
<span class="fc" id="L685">        double rt = Math.log(bs)/Math.log(2);</span>
        
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (rt &lt; 10) {</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">            if (bs &gt; 10) {</span>
                //this is the number of items, that is capacity, of each map
<span class="fc" id="L690">                return bs;</span>
            }
        }
        
        // else, fall back to using the default for rt = O(10)
        
<span class="fc" id="L696">        return (int)Math.ceil((float)maxC/(float)w);</span>
        
        /*
        LG binsize = (int)Math.ceil((float)maxC/(float)w);
        MID binsize = 10
        
        w,     binsz,     n,             rt
        31,    69273666,  31,            26.   LG
        31,    5.0,       429496729.6,   2.32  MID
        
        10,    102,       10,            6.67  LG
        10,    4.0,       256.0,         2.0   MID
        
        aiming for a runtime of about O(10) or better without increasing n too
        much.
        
        alternatively, could keep n as large as possible within good
        performance range, hence the binsz will be small, hence the
        runtime will be small.
        
        n            TreeMaps
        n * binSz    objects in TreeMaps
        
        heapsize: 100's or more MB
        */
        
    }
    
    protected int getBinSz() {
<span class="nc" id="L725">        return binSz;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>