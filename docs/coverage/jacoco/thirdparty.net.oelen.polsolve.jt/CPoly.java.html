<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CPoly.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.net.oelen.polsolve.jt</a> &gt; <span class="el_source">CPoly.java</span></div><h1>CPoly.java</h1><pre class="source lang-java linenums">/*
 *   CPoly  -- A class that represents a polynomial equation.
 *
 *   Copyright (C) 2000-2004  by Joseph A. Huwaldt   
 *                 2014-2016  by Wilco Oelen
 *   All rights reserved.
 *   
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Lesser General Public
 *   License as published by the Free Software Foundation; either
 *   version 2 of the License, or (at your option) any later version.
 *   
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *   Or visit:  http://www.gnu.org/licenses/lgpl.html
 **/
package thirdparty.net.oelen.polsolve.jt;


/**
 * &lt;p&gt;
 * Represents a polynomial equation of the form 
 *           p(x) = A + B*x + C*x^2 + D*x^3 + ...
 * where A, B, C, etc are either real or complex coefficients.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Includes a method for finding the zeros of a complex polynomial by the three
 * stage complex algorithm of Jenkins and Traub. The method finds the zeros one
 * at a time in roughly increasing order of modulus and deflates the polynomial
 * to one of lower degree. This method is extremely fast and timing is quite
 * insensitive to distribution of zeros.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Zero finder ported from FORTRAN version of algorithm 419 courtesy &lt;a
 * href=&quot;http://www.netlib.org/&quot;&gt;Netlib Repository&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This class is not thread-safe. &lt;/p&gt;
 *
 * &lt;p&gt;
 * Modified by: Joseph A. Huwaldt 
 *              Wilco Oelen         &lt;/p&gt;
 * 
 * @author Joseph A. Huwaldt    Date: July 15, 2000
 * @author Wilco Oelen
 * @version October 6, 2015
 *
 */
public strictfp class CPoly {
    // Array of complex coefficients in order of increasing power.
    private final double[] coef_re;
    private final double[] coef_im;

    //-----------------------------------------------------------------------------------
    
    
    // Default constructor made unavailable for calling environments.
<span class="nc" id="L66">    private CPoly() {</span>
<span class="nc" id="L67">        coef_re = null;</span>
<span class="nc" id="L68">        coef_im = null;</span>
<span class="nc" id="L69">    }</span>

    
    
    /**
     * Constructor that takes an array of real coefficients. Coefficients are
     * supplied in order of increasing power. Example: p(x) = A + B*x + C*x^2 +
     * D*x^3 + E*x^4 gives coefficients[] = {A, B, C, D, E}. The degree of the
     * polynomial is equal to the length of the supplied array minus 1.
     *
     * @param coef An array of real coefficients in order of increasing power.
     */
<span class="fc" id="L81">    public CPoly(double[] coef) {</span>
<span class="fc" id="L82">        coef_re = coef.clone();</span>
<span class="fc" id="L83">        coef_im = new double[coef_re.length];</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        for (int i=0; i&lt;coef_im.length; i++) {</span>
<span class="fc" id="L85">            coef_im[i] = 0.0;</span>
        }
<span class="fc" id="L87">    }</span>

    
    
    
    /**
     * Constructor that takes an array with the real part of coefficients and 
     * an array with the imaginary part of the coefficients. Coefficients are
     * supplied in order of increasing power. Example: p(x) = A + B*x + C*x^2 +
     * D*x^3 + E*x^4 gives coefficients[] = {A, B, C, D, E}.
     * The degree of the polynomial is determined by the length of the longest
     * supplied array. If the longest supplied array has N elements, then the
     * degree of the polynomial equals N-1. The shorter array is extended with
     * zero values for the higher powers. E.g. a polynomial with arrays
     * {1,2,3} and {11,22,33,44,55} has degree 4 and can be written as
     * (1+11i) + (2+22i)*x + (3+33i)*x^2 + 44i*x^3 + 55i*x^4
     *
     * @param coef_re An array containing the real part of the coefficients 
     * in order of increasing power. If the supplied array equals null, then
     * the degree is determined by the length of the other array and the real
     * part of all coefficients equals 0 in that case.
     * @param coef_im An array containing the imaginary part of the coefficients
     * in order of increasing power. If the supplied array equals null, then
     * the degree is determined by the length of the other array and the imaginary
     * part of all coefficients equals 0 in that case.
     */
<span class="fc" id="L113">    public CPoly(double[] coef_re, double[] coef_im) {</span>
<span class="pc bpc" id="L114" title="6 of 8 branches missed.">        if ((coef_re == null || coef_re.length==0) &amp;&amp; </span>
            (coef_im == null || coef_im.length==0)) {
<span class="nc" id="L116">            throw new RuntimeException(&quot;Construction of CPoly with empty coefficient set.&quot;);</span>
        }
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (coef_re == null) {</span>
<span class="nc" id="L119">            coef_re = new double[0];</span>
        }
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (coef_im == null) {</span>
<span class="nc" id="L122">            coef_im = new double[0];</span>
        }
        
<span class="fc" id="L125">        int degRe = coef_re.length - 1;</span>
<span class="fc" id="L126">        int degIm = coef_im.length - 1;</span>
        
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (degRe == degIm) {</span>
<span class="fc" id="L129">            this.coef_re = coef_re.clone();</span>
<span class="fc" id="L130">            this.coef_im = coef_im.clone();</span>
<span class="fc" id="L131">            return;</span>
        }
        
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (degRe &lt; degIm) {</span>
<span class="nc" id="L135">            this.coef_re = new double[coef_im.length];</span>
            int i;
<span class="nc bnc" id="L137" title="All 2 branches missed.">            for (i=0; i&lt;=degRe; i++) {</span>
<span class="nc" id="L138">                this.coef_re[i] = coef_re[i];</span>
            }
<span class="nc bnc" id="L140" title="All 2 branches missed.">            for (; i&lt;coef_im.length; i++) {</span>
<span class="nc" id="L141">                this.coef_re[i] = 0.0;</span>
            }
<span class="nc" id="L143">            this.coef_im = coef_im.clone();</span>
<span class="nc" id="L144">        }</span>
        else {
<span class="nc" id="L146">            this.coef_re = coef_re.clone();</span>
<span class="nc" id="L147">            this.coef_im = new double[coef_re.length];</span>
            int i;
<span class="nc bnc" id="L149" title="All 2 branches missed.">            for (i=0; i&lt;=degIm; i++) {</span>
<span class="nc" id="L150">                this.coef_im[i] = coef_im[i];</span>
            }
<span class="nc bnc" id="L152" title="All 2 branches missed.">            for (; i&lt;coef_re.length; i++) {</span>
<span class="nc" id="L153">                this.coef_im[i] = 0.0;</span>
            }
        }
<span class="nc" id="L156">    }</span>
    
    
    
    
    /**
     * Evaluates the polynomial at a complex point, specified by the
     * arguments.
     * @param xre The real part of the point at which the polynomial
     * is evaluated.
     * @param xim The imaginary part of the point at which the polynomial
     * is evaluated.
     * @return A double[] array, with the value at index 0 being the
     * real part of the evaluated value and the value at index 1 being
     * the imaginary part of the evaluated value.
     */
    public double[] eval(double xre, double xim) {
<span class="nc" id="L173">        int deg = coef_re.length - 1;</span>
<span class="nc" id="L174">        double re = coef_re[deg];</span>
<span class="nc" id="L175">        double im = coef_im[deg];</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (int i=deg-1; i&gt;=0; i--) {</span>
<span class="nc" id="L177">            double re2 = re*xre - im*xim + coef_re[i];</span>
<span class="nc" id="L178">            double im2 = re*xim + im*xre + coef_im[i];</span>
<span class="nc" id="L179">            re = re2;</span>
<span class="nc" id="L180">            im = im2;</span>
        }
<span class="nc" id="L182">        return new double[] {re, im};</span>
    }

    
    
    
    
    /**
     * Evaluates the polynomial at the given complex argument. This is
     * like the other eval() method, but in this one the result of the
     * evaluation is put in an array, which already is allocated in the
     * calling environment. This method allows many evaluations of the
     * polynomial without the need to allocate many small 2-element arrays
     * for storing the result.
     *
     * @param result A double-array with at least two elements, in which
     * the result of the evaluation is stored. The value at index 0 is
     * replaced by the real part of the polynomial value and the value at
     * index 1 is replaced by the imaginary part of the polynomial value.
     * If the supplied array contains more than 2 elements, then the elements
     * with index 2 or larger are not touched at all.
     * @param xre The real part of the argument at which the polynomial is
     * evaluated.
     * @param xim The imaginary part of the argument at which the polynomial is
     * evaluated.
     */
    public void eval(double[] result, double xre, double xim) {
<span class="nc" id="L209">        int deg = coef_re.length - 1;</span>
<span class="nc" id="L210">        double re = coef_re[deg];</span>
<span class="nc" id="L211">        double im = coef_im[deg];</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (int i=deg-1; i&gt;=0; i--) {</span>
<span class="nc" id="L213">            double re2 = re*xre - im*xim + coef_re[i];</span>
<span class="nc" id="L214">            double im2 = re*xim + im*xre + coef_im[i];</span>
<span class="nc" id="L215">            re = re2;</span>
<span class="nc" id="L216">            im = im2;</span>
        }
<span class="nc" id="L218">        result[0] = re;</span>
<span class="nc" id="L219">        result[1] = im;</span>
<span class="nc" id="L220">    }</span>

    
    
    
    
    /**
     * Evaluates the polynomial and the derivative of the polynomial
     * simultaneously for the given value of x.
     *
     * @param result A double-array with at least two elements, in which
     * the result of the evaluation is stored. The value at index 0 is
     * replaced by the real part of the polynomial value and the value at
     * index 1 is replaced by the imaginary part of the polynomial value.
     * If the supplied array contains more than 2 elements, then the elements
     * with index 2 or larger are not touched at all.
     * @param dresult A double-array with at least two elements, in which
     * the result of the evaluation is stored. The value at index 0 is
     * replaced by the real part of the derivative value and the value at
     * index 1 is replaced by the imaginary part of the derivative value.
     * If the supplied array contains more than 2 elements, then the elements
     * with index 2 or larger are not touched at all.
     * @param xre The real part of the argument at which the derivative is
     * evaluated.
     * @param xim The imaginary part of the argument at which the derivative is
     * evaluated.
     */
    public void eval_deriv(double[] result, double[] dresult, double xre, double xim) {
<span class="nc" id="L248">        int deg = coef_re.length - 1;</span>
        
        // p = coef[deg]
<span class="nc" id="L251">        double pre = coef_re[deg];</span>
<span class="nc" id="L252">        double pim = coef_im[deg];</span>
        
        // dp = 0
<span class="nc" id="L255">        double dpre = 0.0;</span>
<span class="nc" id="L256">        double dpim = 0.0;</span>
        
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (int i = deg - 1; i &gt;= 0; i--) {</span>
            // dp = dp*x + p
<span class="nc" id="L260">            double dpre2 = dpre * xre - dpim * xim + pre;</span>
<span class="nc" id="L261">            double dpim2 = dpre * xim + dpim * xre + pim;</span>
<span class="nc" id="L262">            dpre = dpre2;</span>
<span class="nc" id="L263">            dpim = dpim2;</span>
            
            // p = p*x + coef[i];
<span class="nc" id="L266">            double pre2 = pre * xre - pim * xim + coef_re[i];</span>
<span class="nc" id="L267">            double pim2 = pre * xim + pim * xre + coef_im[i];</span>
<span class="nc" id="L268">            pre = pre2;</span>
<span class="nc" id="L269">            pim = pim2;</span>
        }
<span class="nc" id="L271">        result[0] = pre;</span>
<span class="nc" id="L272">        result[1] = pim;</span>
<span class="nc" id="L273">        dresult[0] = dpre;</span>
<span class="nc" id="L274">        dresult[1] = dpim;</span>
<span class="nc" id="L275">    }</span>
    
    
    
    
    /**
     * Get the degree of the polynomial.
     * @return The degree of the polynomial.
     */
    public int degree() {
<span class="nc" id="L285">        return coef_re.length - 1;</span>
    }
    
    

    
    
    
    /**
     * Creates a String representation of this polynomial.
     *
     * @return The String representation of this object.
	*
     */
    @Override
    public String toString() {
<span class="fc" id="L301">        StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L302">        int NN = coef_re.length;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int i=0; i&lt;NN; i++) {</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (Math.abs(coef_re[i]) + Math.abs(coef_im[i]) &gt; 0.0) {</span>
<span class="fc" id="L305">                String term = &quot;       x^&quot; + i + &quot; * (&quot; + toString(coef_re[i], coef_im[i]) + &quot;)\n&quot;;</span>
<span class="fc" id="L306">                buffer.append(term);</span>
            }
        }
<span class="fc" id="L309">        return buffer.toString();</span>
    }
    
    
    static private String toString(double re, double im) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (im == 0.0) {</span>
<span class="fc" id="L315">            return &quot;&quot; + re;</span>
        }
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (re == 0.0) {</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (im &lt; 0) {</span>
<span class="fc" id="L319">                return &quot;-i*&quot; + (-im);</span>
            }
<span class="fc" id="L321">            return &quot;i*&quot; + im;</span>
        }
        
<span class="fc" id="L324">        double r = re;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (r &lt; 0) {</span>
<span class="fc" id="L326">            r = -r;</span>
        }
        
<span class="fc" id="L329">        double i = im;</span>
<span class="fc" id="L330">        boolean imIsNeg = false;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L332">            i = -i;</span>
<span class="fc" id="L333">            imIsNeg = true;</span>
        }
        
<span class="fc" id="L336">        double r_i = r/i;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (r_i &gt; 4e15) {</span>
<span class="nc" id="L338">            return &quot;&quot; + re;</span>
        }
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        if (r_i &lt; 2.5e-16) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            return (imIsNeg ? &quot;i*&quot; : &quot;-i*&quot;) + i;</span>
        }
        
<span class="fc bfc" id="L344" title="All 2 branches covered.">        return &quot;&quot; + re + (imIsNeg ? &quot; + i*&quot; : &quot; - i*&quot;) + i;</span>
    }

    
    
    
    
    /**
     * This method computes the roots of the polynomial and stores the roots
     * in preallocated arrays, which are passed as arguments.
     * @param zeror Array, in which the real parts of the zeros will be stored
     * after computation of the zeros. This array must have a length of at
     * least N elements, where N is the degree of the polynomial.
     * @param zeroi Array, in which the imaginary parts of the zeros will be stored
     * after computation of the zeros. This array must have a length of at
     * least N elements, where N is the degree of the polynomial.
     * @return Returns the degree of the polynomial if the computation succeeds,
     * and returns a value less than the degree of the polynomial if an error
     * occurs (e.g. convergence failure). When a value less than the degree of
     * the polynomial is returned, then only part (or none) of the roots could
     * be determined.
     */
    public int solve(double[] zeror, double[] zeroi) {
<span class="fc" id="L367">        int nzeros = cpoly(zeror, zeroi);</span>
<span class="fc" id="L368">        return nzeros;</span>
    }

    
    
    
    /***********************************************************************/
    /***********************************************************************/
    /********* Below follows the port of the original Fortran  *************/
    /********* program. It is all private to this module!     *************/
    /********* The code above is a wrapper for easy usage. *************/
    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/
    
    


    // The base of the number system being used.
    private static final double BASE = 2;

    // The number of base digits in each floating-point number (double precision)
    private static final double kT = 53;

    // The maximum relative representation error.  Fortran code:  BASE**(1-T)
<span class="fc" id="L393">    private static final double ETA = Math.pow(BASE, 1 - kT);</span>

    // Infinity.  FORTRAN code:  BASE*(1.0D0-BASE**(-T))*BASE**(M-1)
    private static final double INFIN = 1e40;   // Double.MAX_VALUE;  

    // The smallest number that can be represented.  Fortran code:  (BASE**(N+3))/BASE**3
    private static final double SMALNO = 1e-40; // Double.MIN_NORMAL; 

    // Error bounds on complex addition.
<span class="fc" id="L402">    private static final double ARE = ETA;</span>

    // Error bounds on complex multiplication.
<span class="fc" id="L405">    private static final double MRE = 2.0 * Math.sqrt(2.0) * ETA;</span>
    
    private static final double DEG_TO_RAD = 3.14159265358979323846 / 180;  // Degrees-to-radians conversion factor = PI/180
<span class="fc" id="L408">    private static final double COSR = Math.cos(94.0 * DEG_TO_RAD);         // = -0.069756474;</span>
<span class="fc" id="L409">    private static final double SINR = Math.sin(94.0 * DEG_TO_RAD);         // = 0.99756405</span>

    
    // **** The following are used only by the root finding routines below. ****
    // Temporary storage space for complex numbers with real and imaginary parts.
    private double PVr, PVi, Tr, Ti, Sr, Si, Zr, Zi;
    
    
    //-----------------------------------------------------------------------------------
    /*
     * &lt;p&gt;
     * Finds all the zeros of a complex polynomial. &lt;/p&gt;
     *
     * &lt;p&gt;
     * This program finds all the zeros of a complex polynomial by the three
     * stage complex algorithm of Jenkins and Traub. The program finds the zeros
     * one at a time in roughly increasing order of modulus and deflates the
     * polynomial to one of lower degree. The program is extremely fast and
     * timing is quite insenstive to distribution of zeros.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Ported from FORTRAN to Java by Joseph A. Huwaldt, July 20, 2000 and
     * further enhanced by Wilco Oelen, 2014, 2015. 
     * Changes by Wilco Oelen:
     *   - When the iteration can be stopped, then one more iteration step
     *     is performed. This increases the accuracy of the found roots in
     *     nearly all cases. This solves a known old problem of inaccurately
     *     determined roots, even for well-conditioned polynomials.
     *   - Introduced tighter error bounds for termination of iteration. 
     *     This strongly improves the accuracy of the roots in many cases.
     *   - Added some wrapper code to make the use of the software easier
     *     and really 'black box'.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * FORTRAN version from &lt;a href=&quot;http://www.netlib.org/&quot;&gt;Netlib
     * Repository&lt;/a&gt;
     * where it is listed as &quot;419.f&quot;. A PDF file describing the algorithm and
     * its history with references is also available from Netlib.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * FORTRAN version had the following note at the top. ALGORITHM 419
     * COLLECTED ALGORITHMS FROM ACM. ALGORITHM APPEARED IN COMM. ACM, VOL. 15,
     * NO. 02, P. 097. Original Algol 60 zpolyzerofinder version by Jenkins,
     * 1969. (as noted in PDF scan of original ACM document).
     * &lt;/p&gt;
     *
     * @param zeros_re Array, which will be filled with the real part of the zeros.
     * @param zeros_im Array, which will be filled with the imaginary part of the zeros.
     * @return The degree of the polynomial if all is OK.
	*
     */
    private int cpoly(double[] zeros_re, double[] zeros_im) {
        
<span class="fc" id="L465">        int NN = coef_re.length;</span>
<span class="fc" id="L466">        int degree = NN - 1;</span>
<span class="fc" id="L467">        double[] Pr = new double[NN];</span>
<span class="fc" id="L468">        double[] Pi = new double[NN];</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L470">            Pr[i] = coef_re[degree - i];</span>
<span class="fc" id="L471">            Pi[i] = coef_im[degree - i];</span>
        }

        //  Algorithm fails if the leading coefficient is zero.
<span class="pc bpc" id="L475" title="1 of 4 branches missed.">        if (Pr[0] == 0.0 &amp;&amp; Pi[0] == 0.0) {</span>
<span class="nc" id="L476">            return -1;</span>
        }

        //  Allocate memory for arrays used by this method.
<span class="fc" id="L480">        double[] Hr = new double[NN];</span>
<span class="fc" id="L481">        double[] Hi = new double[NN];</span>
<span class="fc" id="L482">        double[] QPr = new double[NN];</span>
<span class="fc" id="L483">        double[] QPi = new double[NN];</span>
<span class="fc" id="L484">        double[] QHr = new double[NN];</span>
<span class="fc" id="L485">        double[] QHi = new double[NN];</span>
<span class="fc" id="L486">        double[] SHr = new double[NN];</span>
<span class="fc" id="L487">        double[] SHi = new double[NN];</span>

        //  Initialization of variables.
<span class="fc" id="L490">        double XX = Math.sqrt(0.5);</span>
<span class="fc" id="L491">        double YY = -XX;</span>

        //  Remove zeros at the origin, if any.
<span class="pc bpc" id="L494" title="1 of 4 branches missed.">        while (Pr[NN - 1] == 0.0 &amp;&amp; Pi[NN - 1] == 0.0) {</span>
<span class="nc" id="L495">            int idNN2 = degree - NN + 1;</span>
<span class="nc" id="L496">            zeros_re[idNN2] = 0.0;</span>
<span class="nc" id="L497">            zeros_im[idNN2] = 0.0;</span>
<span class="nc" id="L498">            --NN;</span>
<span class="nc" id="L499">        }</span>

        //  Calculate the modulus of the coefficients.
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L503">            SHr[i] = cmod(Pr[i], Pi[i]);</span>
        }

        //  Scale the polynomial if needed.
<span class="fc" id="L507">        int factorExponent = scale(NN, SHr);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (factorExponent != 0) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L510">                Pr[i] = Math.scalb(Pr[i], factorExponent);</span>
<span class="fc" id="L511">                Pi[i] = Math.scalb(Pi[i], factorExponent);</span>
            }
        }

        // Start the algorithm for one zero.
outer:
        while (true) {
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (NN &lt;= 2) {</span>
                // Calculate the final zero and return.
<span class="fc" id="L520">                cdiv(-Pr[1], -Pi[1], Pr[0], Pi[0]);       // Outputs Tr, Ti.</span>
<span class="fc" id="L521">                zeros_re[degree - 1] = Tr;                // Outputs Tr, Ti.</span>
<span class="fc" id="L522">                zeros_im[degree - 1] = Ti;</span>
<span class="fc" id="L523">                return degree;</span>
            }

            //  Calculate a lower bound on the modulus of the zeros.
<span class="fc bfc" id="L527" title="All 2 branches covered.">            for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L528">                SHr[i] = cmod(Pr[i], Pi[i]);</span>
            }
<span class="fc" id="L530">            double bound = cauchy(NN, SHr, SHi);</span>

            // Outer loop to control 2 major passes with different sequences of shifts.
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            for (int cnt1 = 1; cnt1 &lt;= 2; ++cnt1) {</span>

                // First stage calculation, no shift.
<span class="fc" id="L536">                noShift(NN, 5, Pr, Pi, Hr, Hi);</span>

                // Inner loop to select a shift.
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                for (int cnt2 = 1; cnt2 &lt;= 9; ++cnt2) {</span>
                    //  Shift is chosen with a modulus bound and amplitude rotated
                    //  by 94 degrees from the previous shift.
<span class="fc" id="L542">                    double XXX = COSR * XX - SINR * YY;</span>
<span class="fc" id="L543">                    YY = SINR * XX - COSR * YY;</span>
<span class="fc" id="L544">                    XX = XXX;</span>
<span class="fc" id="L545">                    Sr = bound * XX;</span>
<span class="fc" id="L546">                    Si = bound * YY;</span>

                    //  Second stage calculation, fixed shift.
<span class="fc" id="L549">                    boolean conv = fxShift(NN, 10 * cnt2, Pr, Pi, QPr, QPi, Hr, Hi,</span>
                            QHr, QHi, SHr, SHi);		// Outputs Zr, Zi.
<span class="fc bfc" id="L551" title="All 2 branches covered.">                    if (conv) {</span>
                        //  If successful the zero is stored and the polynomial deflated.
<span class="fc" id="L553">                        int idNN2 = degree - NN + 1;</span>
<span class="fc" id="L554">                        zeros_re[idNN2] = Zr;</span>
<span class="fc" id="L555">                        zeros_im[idNN2] = Zi;</span>
<span class="fc" id="L556">                        --NN;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                        for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L558">                            Pr[i] = QPr[i];</span>
<span class="fc" id="L559">                            Pi[i] = QPi[i];</span>
                        }

                        // The 2nd stage jumps directly back to 3rd stage iteration.
<span class="fc" id="L563">                        continue outer;</span>
                    }

                    //  If iteration is unsuccessful, another shift is chosen.
                }

                //  If 9 shifts fail, the outer loop is repeated with another
                //  sequence of shifts.
            }

            //  The zero finder has failed on two major passes.  Return empty handed.
<span class="nc" id="L574">            return degree - (NN - 1);</span>
        }

        // We can never get here.
    }
    
    
    

    /**
     * Evaluate this polynomial at a complex x and returns the generally complex
     * result as a pair of class variables. Class variables are used to avoid
     * the overhead of creating a &quot;Complex&quot; object during root finding. Sets the
     * class variables PVr, and PVi with the real and imaginary parts of the
     * result. Uses the method of Horner Recurrence.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param Sr The real component of the point at which to evaluate this
     * polynomial.
     * @param Si The imaginary component of the point at which to evaluate this
     * polynomial.
     * @param Pr, Pi Real &amp; Imaginary coefficients of the polynomial.
     * @param Qr, Qi Arrays to contain partial sums.
	*
     */
    private void polyEv(int NN, double Sr, double Si, double[] Pr, double[] Pi,
                        double[] Qr, double[] Qi) {
        // Begin evaluation.
<span class="fc" id="L602">        double pvr = Qr[0] = Pr[0];</span>
<span class="fc" id="L603">        double pvi = Qi[0] = Pi[0];</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">        for (int i = 1; i &lt; NN; ++i) {</span>
<span class="fc" id="L606">            double temp = pvr;</span>
<span class="fc" id="L607">            pvr = pvr * Sr - pvi * Si + Pr[i];</span>
<span class="fc" id="L608">            pvi = temp * Si + pvi * Sr + Pi[i];</span>

<span class="fc" id="L610">            Qr[i] = pvr;</span>
<span class="fc" id="L611">            Qi[i] = pvi;</span>
        }

        // Use a class variable to pass results back when doing root finding.
<span class="fc" id="L615">        PVr = pvr;</span>
<span class="fc" id="L616">        PVi = pvi;</span>
<span class="fc" id="L617">    }</span>

    
    
    
    /**
     * Bounds the error in evaluating the polynomial by the method of Horner
     * Recurrance.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param Qr Real part of partial sum from evaluate().
     * @param Qi Imaginary part of partial sum from evaluate().
     * @param MS Modulus of the point being evaluated.
     * @param MP Modulus of the polynomial value.
     * @param ARE Error bounds on complex addition.
     * @param MRE Error bounds on complex multiplication.
     *
     */
    private static double errEv(int NN, double[] Qr, double[] Qi, double MS, double MP,
                                double ARE, double MRE) {
<span class="fc" id="L637">        double E = cmod(Qr[0], Qi[0]) * MRE / (ARE + MRE);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L639">            E = E * MS + cmod(Qr[i], Qi[i]);</span>
        }

<span class="fc" id="L642">        return E*(ARE + MRE) - MP*MRE;</span>
    }

    
    
    
    /**
     * Computes a lower bound on the moduli of the zeros of a polynomial.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param PT The modulus of the coefficients of the polynomial.
     * @param Q Array filled in on output.
     *
     */
    private static double cauchy(int NN, double[] PT, double[] Q) {
<span class="fc" id="L657">        int NNm1 = NN - 1;</span>

<span class="fc" id="L659">        PT[NNm1] = -PT[NNm1];</span>

        //	Compute the upper estimate of bound.
<span class="fc" id="L662">        int N = NN - 1;</span>
<span class="fc" id="L663">        int Nm1 = N - 1;</span>
<span class="fc" id="L664">        double X = Math.exp((Math.log(-PT[NNm1]) - Math.log(PT[0])) / N);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (PT[Nm1] != 0.) {</span>
            // If newton step at the origin is better, use it.
<span class="fc" id="L667">            double XM = -PT[NNm1] / PT[Nm1];</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (XM &lt; X) {</span>
<span class="fc" id="L669">                X = XM;</span>
            }
        }
        // Chop the interval (0,X) until F &lt;= 0.
        while (true) {
<span class="fc" id="L674">            double XM = X * 0.1;</span>
<span class="fc" id="L675">            double F = PT[0];</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">            for (int i = 1; i &lt; NN; ++i) {</span>
<span class="fc" id="L677">                F = F * XM + PT[i];</span>
            }
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (F &lt;= 0.) {</span>
<span class="fc" id="L680">                break;</span>
            }
<span class="fc" id="L682">            X = XM;</span>
<span class="fc" id="L683">        }</span>
<span class="fc" id="L684">        double DX = X;</span>

        // Do newton iteration until X converges to two decimal places.
<span class="fc bfc" id="L687" title="All 2 branches covered.">        while (Math.abs(DX / X) &gt; 0.005) {</span>
<span class="fc" id="L688">            Q[0] = PT[0];</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            for (int i = 1; i &lt; NN; ++i) {</span>
<span class="fc" id="L690">                Q[i] = Q[i - 1] * X + PT[i];</span>
            }
<span class="fc" id="L692">            double F = Q[NNm1];</span>
<span class="fc" id="L693">            double DF = Q[0];</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            for (int i = 1; i &lt; N; ++i) {</span>
<span class="fc" id="L695">                DF = DF * X + Q[i];</span>
            }
<span class="fc" id="L697">            DX = F / DF;</span>
<span class="fc" id="L698">            X = X - DX;</span>
<span class="fc" id="L699">        }</span>

<span class="fc" id="L701">        return X;</span>
    }

    
    
    
    /**
     * Returns a scale factor to multiply the coefficients of the polynomial.
     * The scaling is done to avoid overflow and to avoid undetected underflow
     * interfering with the convergence criterion. The factor is a power of the
     * BASE.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param PT The modulus of the coefficients of the polynomial.
     *
     */
    private static int scale(int NN, double[] PT) {
        // Find the largest and the smallest moduli of coefficients.
<span class="fc" id="L719">        double hi = Math.sqrt(INFIN);</span>
<span class="fc" id="L720">        double lo = SMALNO / ETA;</span>
<span class="fc" id="L721">        double max = 0.;</span>
<span class="fc" id="L722">        double min = INFIN;</span>
        double X, sc;
<span class="fc bfc" id="L724" title="All 2 branches covered.">        for (int i = 0; i &lt; NN; ++i) {</span>
<span class="fc" id="L725">            X = PT[i];</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (X &gt; max) {</span>
<span class="fc" id="L727">                max = X;</span>
            }
<span class="fc bfc" id="L729" title="All 4 branches covered.">            if (X != 0.0 &amp;&amp; X &lt; min) {</span>
<span class="fc" id="L730">                min = X;</span>
            }
        }

        // Scale only if there are very large or very small components.
<span class="fc bfc" id="L735" title="All 4 branches covered.">        if (min &gt;= lo &amp;&amp; max &lt;= hi) {</span>
<span class="fc" id="L736">            return 0;</span>
        }

<span class="fc" id="L739">        X = lo / min;</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (X &gt; 1.0) {</span>
<span class="fc" id="L741">            sc = X;</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">            if (INFIN / sc &gt; max) {</span>
<span class="fc" id="L743">                return 0;</span>
            }
        } else {
<span class="fc" id="L746">            sc = 1.0 / Math.sqrt(max * min);</span>
        }

        // Compute a scale factor, close to sc, but in such a way
        // that the factor is exact and a power of 2, such that
        // multiplication with this factor does not lead to loss
        // of any precision in the coefficients. Not the scale 
        // factor itself, but the exponent of 2 is returned.
<span class="fc" id="L754">        return Math.getExponent(sc) + 1;</span>
    }

    
    
    
    /**
     * Complex division C = A/B, avoiding overflow. Results are stored in class
     * variables Tr and Ti to avoid overhead of creating a Complex object during
     * root finding. Results are stored in class variables Tr and Ti.
     *
     * @param Ar The real part of the complex numerator.
     * @param Ai The imaginary part of the complex numerator.
     * @param Br The real part of the complex denominator.
     * @param Bi The imaginary part of the complex denominator.
     *
     */
    private void cdiv(double Ar, double Ai, double Br, double Bi) {
<span class="pc bpc" id="L772" title="1 of 4 branches missed.">        if (Br == 0. &amp;&amp; Bi == 0.) {</span>
            // Division by zero, result = infinity.
<span class="nc" id="L774">            Tr = INFIN;</span>
<span class="nc" id="L775">            Ti = INFIN;</span>
<span class="nc" id="L776">            return;</span>
        }

<span class="fc bfc" id="L779" title="All 2 branches covered.">        if (Math.abs(Br) &gt;= Math.abs(Bi)) {</span>
<span class="fc" id="L780">            double R = Bi / Br;</span>
<span class="fc" id="L781">            double D = Br + R * Bi;</span>
<span class="fc" id="L782">            Tr = (Ar + Ai * R) / D;</span>
<span class="fc" id="L783">            Ti = (Ai - Ar * R) / D;</span>

<span class="fc" id="L785">        } </span>
        else {
<span class="fc" id="L787">            double R = Br / Bi;</span>
<span class="fc" id="L788">            double D = Bi + R * Br;</span>
<span class="fc" id="L789">            Tr = (Ar * R + Ai) / D;</span>
<span class="fc" id="L790">            Ti = (Ai * R - Ar) / D;</span>
        }

<span class="fc" id="L793">    }</span>

    
    
    
    /**
     * Calculates the modulus or magnitude of a complex number avoiding
     * overflow.
     *
     * Adapted from &quot;Numerical Recipes in C: The Art of Scientific Computing&quot;
     * 2nd Edition, pg 949, ISBN 0-521-43108-5. The NR algorithm is only
     * slightly different from the ACM algorithm, but the NR version appears to
     * be slightly more robust.
     *
     * @param re The real part of the complex number.
     * @param im The imaginary part of the complex number.
     *
     */
    private static double cmod(double re, double im) {
        double ans;
<span class="fc" id="L813">        re = Math.abs(re);</span>
<span class="fc" id="L814">        im = Math.abs(im);</span>

<span class="fc bfc" id="L816" title="All 2 branches covered.">        if (re == 0.0) {</span>
<span class="fc" id="L817">            ans = im;</span>
        } 
<span class="fc bfc" id="L819" title="All 2 branches covered.">        else if (im == 0.0) {</span>
<span class="fc" id="L820">            ans = re;</span>
        } 
<span class="fc bfc" id="L822" title="All 2 branches covered.">        else if (re &gt; im) {</span>
<span class="fc" id="L823">            double temp = im / re;</span>
<span class="fc" id="L824">            ans = re * Math.sqrt(1.0 + temp * temp);</span>
<span class="fc" id="L825">        } </span>
        else {
<span class="fc" id="L827">            double temp = re / im;</span>
<span class="fc" id="L828">            ans = im * Math.sqrt(1.0 + temp * temp);</span>
        }

<span class="fc" id="L831">        return ans;</span>
    }

    
    
    
    /**
     * Computes the derivative polynomial as the intial H polynomial and
     * computes L1 no-shift H polynomials.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param L1 Number of Level 1 shifts to make.
     * @param Pr, Pi The coefficients of the polynomial.
     * @param Hr, Hi Arrays containing output ?
     *
     */
    private void noShift(int NN, int L1, double[] Pr, double[] Pi, double[] Hr, double[] Hi) {
<span class="fc" id="L848">        int N = NN - 1;</span>
<span class="fc" id="L849">        int Nm1 = N - 1;</span>
<span class="fc" id="L850">        int NNm1 = NN - 1;</span>

<span class="fc bfc" id="L852" title="All 2 branches covered.">        for (int i = 0; i &lt; N; ++i) {</span>
<span class="fc" id="L853">            double XNi = NNm1 - i;</span>
<span class="fc" id="L854">            Hr[i] = XNi * Pr[i] / N;</span>
<span class="fc" id="L855">            Hi[i] = XNi * Pi[i] / N;</span>
        }

<span class="fc bfc" id="L858" title="All 2 branches covered.">        for (int jj = 1; jj &lt;= L1; ++jj) {</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (cmod(Hr[Nm1], Hi[Nm1]) &gt; ETA * 10.0 * cmod(Pr[Nm1], Pi[Nm1])) {</span>
                // Divide the negative coefficient by the derivative.
<span class="fc" id="L861">                cdiv(-Pr[NNm1], -Pi[NNm1], Hr[Nm1], Hi[Nm1]);	// Outputs Tr, Ti.</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                for (int i = 1; i &lt;= Nm1; ++i) {</span>
<span class="fc" id="L863">                    int j = NNm1 - i;</span>
<span class="fc" id="L864">                    double T1 = Hr[j - 1];</span>
<span class="fc" id="L865">                    double T2 = Hi[j - 1];</span>
<span class="fc" id="L866">                    Hr[j] = Tr * T1 - Ti * T2 + Pr[j];</span>
<span class="fc" id="L867">                    Hi[j] = Tr * T2 + Ti * T1 + Pi[j];</span>
                }
<span class="fc" id="L869">                Hr[0] = Pr[0];</span>
<span class="fc" id="L870">                Hi[0] = Pi[0];</span>

            } 
            else {
                // If the constant term is essentially zero, shift H coefficients.
<span class="fc bfc" id="L875" title="All 2 branches covered.">                for (int i = 1; i &lt;= Nm1; ++i) {</span>
<span class="fc" id="L876">                    int j = NNm1 - i;</span>
<span class="fc" id="L877">                    Hr[j] = Hr[j - 1];</span>
<span class="fc" id="L878">                    Hi[j] = Hi[j - 1];</span>
                }
<span class="fc" id="L880">                Hr[0] = 0.;</span>
<span class="fc" id="L881">                Hi[0] = 0.;</span>
            }
        }

<span class="fc" id="L885">    }</span>

    
    
    
    /**
     * Computes T = -P(S)/H(S). Sets class variables Tr, Ti.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param Sr The real part of the point we are evaluating the polynomial at.
     * @param Si The imaginary part of the point we are evaluating the
     * polynomial at.
     * @param Hr, Hi Arrays containing ?
     * @param QHr, QHi Arrays containing partial sums of H(S) polynomial.
     * @return True if H(S) is essentially zero.
     *
     */
    private boolean calcT(int NN, double Sr, double Si, double[] Hr, double[] Hi,
            double[] QHr, double[] QHi) {
<span class="fc" id="L904">        int N = NN - 1;</span>
<span class="fc" id="L905">        int Nm1 = N - 1;</span>

        //	Evaluate H(S).
<span class="fc" id="L908">        double tempR = PVr;</span>
<span class="fc" id="L909">        double tempI = PVi;</span>
<span class="fc" id="L910">        polyEv(N, Sr, Si, Hr, Hi, QHr, QHi);</span>
<span class="fc" id="L911">        double HVr = PVr;</span>
<span class="fc" id="L912">        double HVi = PVi;</span>
<span class="fc" id="L913">        PVr = tempR;</span>
<span class="fc" id="L914">        PVi = tempI;</span>

        // Is H(S) essentially zero?
<span class="fc bfc" id="L917" title="All 2 branches covered.">        boolean nearZero = cmod(HVr, HVi) &lt;= ARE * 10.0 * cmod(Hr[Nm1], Hi[Nm1]);</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">        if (nearZero) {</span>
<span class="fc" id="L919">            Tr = 0.;</span>
<span class="fc" id="L920">            Ti = 0.;</span>
        } 
        else {
<span class="fc" id="L923">            cdiv(-PVr, -PVi, HVr, HVi);		// Outputs Tr, Ti.</span>
        }
<span class="fc" id="L925">        return nearZero;</span>
    }

    
    
    
    
    /**
     * Calculates the next shifted H polynomial.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param bool Set to true if H(S) is essentially zero.
     * @param Hr, Hi Arrays containing ?
     * @param QPr, QPi
     * @param QHr, QHi
     *
     */
    private void nextH(int NN, boolean bool, double[] Hr, double[] Hi,
            double[] QPr, double[] QPi, double[] QHr, double[] QHi) {
<span class="fc" id="L944">        int N = NN - 1;</span>

<span class="fc bfc" id="L946" title="All 2 branches covered.">        if (!bool) {</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">            for (int j = 1; j &lt; N; ++j) {</span>
<span class="fc" id="L948">                double T1 = QHr[j - 1];</span>
<span class="fc" id="L949">                double T2 = QHi[j - 1];</span>
<span class="fc" id="L950">                Hr[j] = Tr * T1 - Ti * T2 + QPr[j];</span>
<span class="fc" id="L951">                Hi[j] = Tr * T2 + Ti * T1 + QPi[j];</span>
            }
<span class="fc" id="L953">            Hr[0] = QPr[0];</span>
<span class="fc" id="L954">            Hi[0] = QPi[0];</span>

        } 
        else {
            // If H(S) is zero, replace H with QH.
<span class="fc bfc" id="L959" title="All 2 branches covered.">            for (int j = 1; j &lt; N; ++j) {</span>
<span class="fc" id="L960">                Hr[j] = QHr[j - 1];</span>
<span class="fc" id="L961">                Hi[j] = QHi[j - 1];</span>
            }
<span class="fc" id="L963">            Hr[0] = 0.;</span>
<span class="fc" id="L964">            Hi[0] = 0.;</span>
        }

<span class="fc" id="L967">    }</span>

    
    
    
    
    /**
     * Carries out the third stage iteration. On entry Zr, Zi contains the
     * initial iteration. If the iteration converges it contains the final
     * iteration on exit. Also uses and sets class variables Sr, Si.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param L3 Limit of steps in stage 3.
     * @param Pr, Pi The coefficients of the polynomial.
     * @param QPr, QPi
     * @param Hr, Hi Arrays containing ?
     * @param QHr, QHi
     * @return True if iteration converges.
     *
     */
    private boolean vrShift(int NN, int L3, double[] Pr, double[] Pi,
                            double QPr[], double QPi[],
                            double Hr[], double Hi[], double QHr[], double QHi[]) {
<span class="fc" id="L990">        boolean conv = false;</span>
<span class="fc" id="L991">        boolean B = false;</span>
<span class="fc" id="L992">        double OMP = 0., RelSTP = 0.;</span>

<span class="fc" id="L994">        Sr = Zr;</span>
<span class="fc" id="L995">        Si = Zi;</span>

        // Main loop for stage three.
        // WILCO: Added nOK-logic to force one additional iteration
        // after it is decided that iteration can be terminated.
<span class="fc" id="L1000">        int nOK = 0;</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        for (int i = 1; i &lt;= L3; ++i) {</span>
            //	Evaluate P at S and test for convergence.
<span class="fc" id="L1003">            polyEv(NN, Sr, Si, Pr, Pi, QPr, QPi);     // Outputs PVr, PVi.</span>

<span class="fc" id="L1005">            double MP = cmod(PVr, PVi);</span>
<span class="fc" id="L1006">            double MS = cmod(Sr, Si);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (MP &lt;= 20.0 * errEv(NN, QPr, QPi, MS, MP, ARE, MRE)) {</span>
<span class="fc" id="L1008">                nOK++;</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">                if (nOK == 2) {</span>
                    // Polynomial value is smaller in value than a bound on the error
                    // in evaluating P, terminate the iteration.
<span class="fc" id="L1012">                    Zr = Sr;</span>
<span class="fc" id="L1013">                    Zi = Si;</span>
<span class="fc" id="L1014">                    return true;</span>
                }
            }
            else {
<span class="fc" id="L1018">                nOK = 0;</span>
            }

<span class="fc bfc" id="L1021" title="All 2 branches covered.">            if (i == 1) {</span>
<span class="fc" id="L1022">                OMP = MP;</span>
            }
            else {
<span class="fc bfc" id="L1025" title="All 6 branches covered.">                if (!B &amp;&amp; MP &gt;= OMP &amp;&amp; RelSTP &lt; 0.05) {</span>
                    //	Iteration has stalled. Probably a cluster of zeros. Do 5 fixed
                    //	shift steps into the cluster to force one zero to dominate.
<span class="fc" id="L1028">                    double TP = RelSTP;</span>
<span class="fc" id="L1029">                    B = true;</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">                    if (RelSTP &lt; ETA) {</span>
<span class="nc" id="L1031">                        TP = ETA;</span>
                    }
<span class="fc" id="L1033">                    double R1 = Math.sqrt(TP);</span>
<span class="fc" id="L1034">                    double R2 = Sr * (1. + R1) - Si * R1;</span>
<span class="fc" id="L1035">                    Si = Sr * R1 + Si * (1. + R1);</span>
<span class="fc" id="L1036">                    Sr = R2;</span>
<span class="fc" id="L1037">                    polyEv(NN, Sr, Si, Pr, Pi, QPr, QPi);             // Outputs PVr, PVi.</span>

<span class="fc bfc" id="L1039" title="All 2 branches covered.">                    for (int j = 0; j &lt; 5; ++j) {</span>
<span class="fc" id="L1040">                        boolean bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);   // Outputs Tr, Ti.</span>
<span class="fc" id="L1041">                        nextH(NN, bool, Hr, Hi, QPr, QPi, QHr, QHi);</span>
                    }

<span class="fc" id="L1044">                    OMP = INFIN;</span>
<span class="fc" id="L1045">                } </span>
                else {
                    // Exit if polynomial value increases significantly.
<span class="fc bfc" id="L1048" title="All 2 branches covered.">                    if (MP * 0.1 &gt; OMP) {</span>
<span class="fc" id="L1049">                        return conv;</span>
                    }
<span class="fc" id="L1051">                    OMP = MP;</span>
                }
            }

            // Calculate next iteration.
<span class="fc" id="L1056">            boolean bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);       // Outputs Tr, Ti.</span>
<span class="fc" id="L1057">            nextH(NN, bool, Hr, Hi, QPr, QPi, QHr, QHi);</span>
<span class="fc" id="L1058">            bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);       // Outputs Tr, Ti.</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            if (!bool) {</span>
<span class="fc" id="L1060">                RelSTP = cmod(Tr, Ti) / cmod(Sr, Si);</span>
<span class="fc" id="L1061">                Sr = Sr + Tr;</span>
<span class="fc" id="L1062">                Si = Si + Ti;</span>
            }
        }

<span class="fc" id="L1066">        return conv;</span>
    }

    
    
    
    /**
     * Computes L2 fixed-shift H polynomials and tests for convergence.
     * Initiates a variable-shift iteration and returns with the approximate
     * zero if successfull. Uses and sets the class variables Sr and Si. Sets
     * class variables Zr, Zi to approximate zero if convergence is true.
     *
     * @param NN The number of coefficients to use in the evaluation.
     * @param L2 Limit of fixed shift steps.
     * @param Pr, Pi The coefficients of the polynomial.
     * @param QPr, QPi
     * @param Hr, Hi Arrays containing ?
     * @param QHr, QHi
     * @return True if convergence of stage 3 iteration is successfull.
     *
     */
    private boolean fxShift(int NN, int L2, double[] Pr, double[] Pi,
            double QPr[], double QPi[],
            double Hr[], double Hi[], double QHr[], double QHi[],
            double SHr[], double SHi[]) {
<span class="fc" id="L1091">        int N = NN - 1;</span>

        // Evaluate Polynomial at S.
<span class="fc" id="L1094">        polyEv(NN, Sr, Si, Pr, Pi, QPr, QPi);	// Outputs PVr, PVi.</span>
<span class="fc" id="L1095">        boolean test = true;</span>
<span class="fc" id="L1096">        boolean pasd = false;</span>

        // Calculate 1st T = -P(S)/H(S).
<span class="fc" id="L1099">        boolean bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);   // Outputs Tr, Ti.</span>

        // Main loop for one 2nd stage step.
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        for (int j = 1; j &lt;= L2; ++j) {</span>
<span class="fc" id="L1103">            double OTr = Tr;</span>
<span class="fc" id="L1104">            double OTi = Ti;</span>

            // Compute next H polynomial and new T.
<span class="fc" id="L1107">            nextH(NN, bool, Hr, Hi, QPr, QPi, QHr, QHi);</span>
<span class="fc" id="L1108">            bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);    // Outputs Tr, Ti.</span>
<span class="fc" id="L1109">            Zr = Sr + Tr;</span>
<span class="fc" id="L1110">            Zi = Si + Ti;</span>

            // Test for convergence unless stage 3 has failed once or
            // this is the last H polynomial.
<span class="pc bpc" id="L1114" title="1 of 6 branches missed.">            if (!bool &amp;&amp; test &amp;&amp; j != L2) {</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">                if (cmod(Tr - OTr, Ti - OTi) &lt; 0.5 * cmod(Zr, Zi)) {</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">                    if (pasd) {</span>
                        // The weak convergence test has been passed twice, start
                        // the third stage iteration, after saving the current H
                        // polynomial and shift.
<span class="fc bfc" id="L1120" title="All 2 branches covered.">                        for (int i = 0; i &lt; N; ++i) {</span>
<span class="fc" id="L1121">                            SHr[i] = Hr[i];</span>
<span class="fc" id="L1122">                            SHi[i] = Hi[i];</span>
                        }
<span class="fc" id="L1124">                        double SVSr = Sr;</span>
<span class="fc" id="L1125">                        double SVSi = Si;</span>
<span class="fc" id="L1126">                        boolean conv = vrShift(NN, 10, Pr, Pi, QPr, QPi, Hr, Hi, QHr, QHi);    // Outputs Zr, Zi.</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                        if (conv) {</span>
<span class="fc" id="L1128">                            return conv;</span>
                        }

                        // The iteration failed to converge.  Turn off testing and
                        // restore H, S, PV and T.
<span class="fc" id="L1133">                        test = false;</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                        for (int i = 0; i &lt; N; ++i) {</span>
<span class="fc" id="L1135">                            Hr[i] = SHr[i];</span>
<span class="fc" id="L1136">                            Hi[i] = SHi[i];</span>
                        }
<span class="fc" id="L1138">                        Sr = SVSr;</span>
<span class="fc" id="L1139">                        Si = SVSi;</span>

<span class="fc" id="L1141">                        polyEv(NN, Sr, Si, Pr, Pi, QPr, QPi);        // Outputs PVr, PVi.</span>
<span class="fc" id="L1142">                        bool = calcT(NN, Sr, Si, Hr, Hi, QHr, QHi);  // Outputs Tr, Ti.</span>
<span class="fc" id="L1143">                        continue;</span>
                    }
<span class="fc" id="L1145">                    pasd = true;</span>
                } 
                else {
<span class="fc" id="L1148">                    pasd = false;</span>
                }
            }
        }

        // Attempt an iteration with final H polynomial from second stage.
<span class="fc" id="L1154">        boolean conv = vrShift(NN, 10, Pr, Pi, QPr, QPi, Hr, Hi, QHr, QHi);    // Outputs Zr, Zi.</span>
<span class="fc" id="L1155">        return conv;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>