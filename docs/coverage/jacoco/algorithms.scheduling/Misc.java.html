<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Misc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.scheduling</a> &gt; <span class="el_source">Misc.java</span></div><h1>Misc.java</h1><pre class="source lang-java linenums">package algorithms.scheduling;

import algorithms.sort.MiscSorter;
import algorithms.util.FormatArray;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.Arrays;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 *
 * @author nichole
 */
<span class="fc" id="L16">public class Misc {</span>
        
     /**
     * schedule a set of n tasks where each task is associated with a execution time 
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be amount 
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity O(N * log_2(N)).
     * 
     * @param duration duration of task
     * @param deadline deadline for task
     * @param outputStart output array to hold start times for the resulting scheduled index order 
     * @param outputLate output array to hold lateness for the resulting scheduled index order.
     * if is on time, element will be 0.
     * @return indexes for scheduling order
     */
    public int[] unweightedIntervalMinimizeLateGreedy(double[] duration, double[] deadline,
        double[] outputStart, double[] outputLate) {
<span class="fc" id="L45">        int n = duration.length;</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">        if (deadline.length != n) {</span>
<span class="nc" id="L47">            throw new IllegalArgumentException(&quot;d.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        if (outputStart.length != n) {</span>
<span class="nc" id="L50">            throw new IllegalArgumentException(&quot;outputStart.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        if (outputLate.length != n) {</span>
<span class="nc" id="L53">            throw new IllegalArgumentException(&quot;outputLate.length must equal t.length&quot;);</span>
        }
<span class="fc" id="L55">        duration = Arrays.copyOf(duration, duration.length);</span>
<span class="fc" id="L56">        deadline = Arrays.copyOf(deadline, deadline.length);</span>
<span class="fc" id="L57">        Arrays.fill(outputStart, 0);</span>
<span class="fc" id="L58">        Arrays.fill(outputLate, 0);</span>
        
        //sort tasks by increasing deadline 
<span class="fc" id="L61">        int[] indexes = MiscSorter.mergeBy1stArgThen2nd(deadline, duration);</span>
<span class="fc" id="L62">        double f_prev = 0; // f is the finish time of previous task</span>
        int i; 
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (i = 0; i &lt; duration.length; ++i) {</span>
            //assign task i to start at 
<span class="fc" id="L66">            outputStart[i] = f_prev;  // start next task</span>
<span class="fc" id="L67">            f_prev = /*f[i] =*/ outputStart[i] + duration[i];  // its finish time</span>
            //lateness[i] = max(0, f[i] - d[i])     // its lateness
<span class="fc" id="L69">            outputLate[i] = Math.max(0, f_prev - deadline[i]);</span>
        }
<span class="fc" id="L71">        return indexes;</span>
    }
    
    /**
     * schedule a set of n tasks where each task is associated with a execution time 
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be amount 
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * The algorithm is aka Earliest Finish First (EFF) and Earliest Deadline First (EDF)
     *    (1) sort tasks by finish time
     *    (2) iterate over tasks, scheduling each that starts after the previous ended
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity is O(N * log_2(N)).
     * 
     * @param s start times for tasks
     * @param f finish times for tasks
     * @return indexes for scheduled non-conflicting tasks
     */
    public int[] unweightedIntervalNoConflicts(double[] s, double[] f) {
<span class="fc" id="L101">        int n = s.length;</span>
<span class="fc" id="L102">        s = Arrays.copyOf(s, s.length);</span>
<span class="fc" id="L103">        f = Arrays.copyOf(f, f.length);</span>
        
        //sort tasks by increasing finish times .  O(N * log_2(N))
<span class="fc" id="L106">        int[] indexes = MiscSorter.mergeBy1stArgThen2nd(f, s);</span>
<span class="fc" id="L107">        double f_prev = -1; // f is the finish time of previous task</span>
        int i; 
<span class="fc" id="L109">        int[] scheduled = new int[n];</span>
<span class="fc" id="L110">        int count = 0;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (s[i] &gt; f_prev) {</span>
<span class="fc" id="L113">                scheduled[count++] = indexes[i];</span>
<span class="fc" id="L114">                f_prev = f[i];</span>
            }
        }
<span class="fc" id="L117">        scheduled = Arrays.copyOfRange(scheduled, 0, count);</span>
<span class="fc" id="L118">        return scheduled;</span>
    }
    
       /**
     * The objective is to compute any maximum sized subset of non-overlapping intervals.
     * Weighted Interval Scheduling: 
     * given a set S = {1, . . . , n} of n activity requests, 
     * where each activity is expressed as an interval [s_i, f_i] from a given 
     * start time si to a given finish time f_i
     * and each request is associated with a numeric weight or value v_i.
     * 
     * The objective is to find a set of non-overlapping requests such that sum 
     * of values of the scheduled requests is maximum.
     * 
     * This code uses dynamic programming and has runtime complexity O(N * log_2(N)).
     * 
     * The code follows the lecture notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf
     * 
     * @param s interval start times
     * @param f interval finish times
     * @param w interval weights
     * @return indexes of scheduled intervals.
     */
    public int[] weightedIntervalBottomUp(double[] s, double[] f, double[] w) {
        //interval [si, fi] of start and finish times
<span class="fc" id="L145">        s = Arrays.copyOf(s, s.length);</span>
<span class="fc" id="L146">        f = Arrays.copyOf(f, f.length);</span>
<span class="fc" id="L147">        w = Arrays.copyOf(w, w.length);</span>
        
<span class="fc" id="L149">        int n = f.length;</span>
        
        // ascending order sort by f
        // runtime complexity is O(log_2(n))
<span class="fc" id="L153">        int[] origIndexes = sort2(f, s, w);</span>
        
        // p[i] is the largest index such that f[p(i)] &lt; s[i]
        //     p[i] is &lt; i
        // runtime complexity is less than O(n^2)
<span class="fc" id="L158">        int[] p = calcP(s, f);</span>
        
<span class="fc" id="L160">        int[] pred = new int[n+1];</span>
        
<span class="fc" id="L162">        double[] memo = new double[n+1];</span>
<span class="fc" id="L163">        Arrays.fill(memo, -1);</span>
<span class="fc" id="L164">        memo[0] = 0;</span>
        int j;
        double leaveWeight, takeWeight;
        // runtime complexity is O(n)
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L169">            leaveWeight = memo[j];                // total weight if we leave j</span>
<span class="fc" id="L170">            takeWeight = w[j] + memo[p[j]];         // total weight if we take j</span>
        //    System.out.printf(&quot;j=%d lw=M[j]=%.2f tw=v[j]+M[p[j]]=%.2f+%.2f=%.2f (where p[j]=%d) &quot;, 
        //        j, leaveWeight, v[j], M[p[j]], takeWeight, p[j]);
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (leaveWeight &gt; takeWeight) {</span>
<span class="fc" id="L174">                memo[j + 1] = leaveWeight;              // better to leave j</span>
<span class="fc" id="L175">                pred[j+1] = j;                   // previous is j-1</span>
            } else {
<span class="fc" id="L177">                memo[j + 1] = takeWeight;               // better to take j</span>
<span class="fc" id="L178">                pred[j+1] = p[j];                  // previous is p[j]</span>
            }
        //    System.out.printf(&quot;  M[j+1]=%.2f\n&quot;, M[j+1]);
        }
         
        //System.out.printf(&quot;memo=%s\n&quot;, FormatArray.toString(memo, &quot;%.3f&quot;));
        //System.out.printf(&quot;p=%s\n&quot;, Arrays.toString(p));
        //System.out.printf(&quot;pred=%s\n&quot;, Arrays.toString(pred));
        
<span class="fc" id="L187">        int[] sched = new int[j];</span>
<span class="fc" id="L188">        int count = 0;</span>
<span class="fc" id="L189">        j = pred.length-1;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (j &gt; 0) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (pred[j] == p[j-1]) {</span>
                //System.out.printf(&quot;  sched[%d]=%d\n&quot;, j, origIndexes[j]);
<span class="fc" id="L193">                sched[count++] = origIndexes[j];</span>
            }
<span class="fc" id="L195">            j = pred[j];</span>
        }
<span class="fc" id="L197">        sched = Arrays.copyOfRange(sched, 0, count);</span>
<span class="fc" id="L198">        return sched;</span>
    }

    
    private int[] calcP(double[] s, double[] f) {
        // iterating from highest index to lowest,
        // find for each s, highest previous index in which f[i-...] &lt; s_i
        int i, j;
<span class="fc" id="L206">        int[] p = new int[f.length+1];</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (i = s.length - 1; i &gt; -1; i--) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for (j = i - 1; j &gt; -1; j--) {</span>
<span class="fc" id="L209">                System.out.printf(&quot;%d,%d) f[%d]=%.2f s[%d]=%.2f\n&quot;, i,j, j, f[j], i, s[i]);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                if (f[j] &lt;= s[i]) {</span>
<span class="fc" id="L211">                    p[i] = j+1;</span>
<span class="fc" id="L212">                    System.out.printf(&quot;   p[%d]=%d\n&quot;, i, p[i]);</span>
<span class="fc" id="L213">                    break;</span>
                }
            }
        }
<span class="fc" id="L217">        return p;</span>
    }
    
    /**
     * sect 16.5 of Cormen et al.
     * 
     * there are numTasks number of tasks, each of which takes 1 unit of time
     * and has its own deadline and penalty for missing the deadline.
     * 
     * minimize the total penalty incurred for missed deadlines.
     * 
     * early tasks: finishes before or at deadline.
     * 
     * late tasks: finish after their deadlines.
     * 
     * early-first form:  early tasks precede late tasks.
     * 
     * canonical form: 
     *     early tasks precede late tasks
     *     and early tasks are in monotonically increasing order of deadlines.
     *     (1) put schedule in early first form
     *     (2) swap sequential pairs in the early list when d_{k} &gt; d_{k+1}
     *     (3) list the early tasks
     *     (4) list the late tasks in any order
     * 
     * if no tasks are late, the set is independent.
     * 
     * the early set by themselves is an independent set.
     * 
     * let L = set of all sets on independent tasks.
     * 
     * N_t(A) = number of tasks t=0,1,2...n in set A whose deadline is t or earlier.
     * 
     * if N_t(A) &gt; t then there is no way to schedule all tasks within deadline.
     * 
     * the problem of maximizing the sum of penalties for the early tasks
     *  is the same as minimizing the sum of penalties for the late tasks.
     * 
     * algorithm with r.t. O(N * log_2(N)):
     * 
     * (1) Use the Greedy algorithm to find a maximum weight independent set of
     *     tasks A.
     * (2) create an optimal schedule having the tasks in A as its early tasks.
    
     * @param deadlines values must be between 1 and numTasks, inclusive
     * @param penalties
     * @return 
     */
    public int[] weightedGreedy(int[] deadlines, int[] penalties) {
        
        //O(N * log_2(N))
        //System.out.println(&quot;starting greedy algorithm to find indep sets&quot;);
<span class="fc" id="L269">        int[] indexes2 = greedy(Arrays.copyOf(deadlines, deadlines.length), </span>
<span class="fc" id="L270">            Arrays.copyOf(penalties, penalties.length));</span>
        //System.out.println(&quot;greedy algorithm resulting indexes=&quot; + Arrays.toString(indexes2));
        
        // rewrite d2 and p2 to be only the greedy results
<span class="fc" id="L274">        int[] d2 = new int[indexes2.length];</span>
<span class="fc" id="L275">        int[] p2 = new int[indexes2.length];</span>
<span class="fc" id="L276">        int[] i2 = new int[indexes2.length];</span>
        int i;
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (i = 0; i &lt; d2.length; ++i) {</span>
<span class="fc" id="L279">            d2[i] = deadlines[indexes2[i]];</span>
<span class="fc" id="L280">            p2[i] = penalties[indexes2[i]];</span>
<span class="fc" id="L281">            i2[i] = indexes2[i];</span>
        }
        
        // sort by increasing deadlines. O(N2 * log_2(N2))
        //these indexes are w.r.t. the truncated d2 and p2, that is, i2
<span class="fc" id="L286">        indexes2 = mergesortIncreasingADecreasingB(d2, p2); </span>
        
<span class="fc" id="L288">        int[] scheduled = new int[deadlines.length];</span>
<span class="fc" id="L289">        TIntSet allI = new TIntHashSet();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (i = 0; i &lt; deadlines.length; ++i) {</span>
<span class="fc" id="L291">            allI.add(i);</span>
        }
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (i = 0; i &lt; indexes2.length; ++i) {</span>
            // transform indexes back to original array indexes
<span class="fc" id="L295">            scheduled[i] = i2[indexes2[i]];</span>
            //System.out.printf(&quot;  a%d (%d, %d)\n&quot;, 
            //    scheduled[i]+1, deadlines[scheduled[i]], penalties[scheduled[i]]);
<span class="fc" id="L298">            allI.remove(scheduled[i]);</span>
        }
        //System.out.println(&quot;appending late tasks in any order:&quot;);
<span class="fc" id="L301">        TIntIterator iter = allI.iterator();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L303">            scheduled[i] = iter.next();</span>
            //System.out.printf(&quot;  a%d (%d, %d)\n&quot;, 
            //    scheduled[i]+1, deadlines[scheduled[i]], penalties[scheduled[i]]);
<span class="fc" id="L306">            i++;</span>
        }
        
<span class="fc" id="L309">        return scheduled;</span>
    }
  
    /**
     * schedule largest penalties first if they fit before deadline (duration of
     * each task is a time unit of 1).
     * runtime complexity is O(N * log_2(N))
     * @param deadlines
     * @param penalties
     * @return 
     */
    private int[] greedy(int[] deadlines, int[] penalties) {
               
<span class="fc" id="L322">        deadlines = Arrays.copyOf(deadlines, deadlines.length);</span>
<span class="fc" id="L323">        penalties = Arrays.copyOf(penalties, penalties.length);</span>
        
        //O(N * log_2(N))
        // sort w, m into monotonically decreasing order by penalties w
<span class="fc" id="L327">        int[] origIndexes = sortDecr(penalties, deadlines);</span>
        int i, oIdx;
        
        /*
        System.out.println(&quot;sorted by decr penalty:&quot;);
        for(i = 0; i &lt; penalties.length; ++i) {
            oIdx = origIndexes[i];
            System.out.printf(&quot;a%d deadline=%d penalty=%d\n&quot;, oIdx+1, deadlines[i], penalties[i]);
        }
        */
       
        // the schedule of indexes, in a datastructure that sorts upon insert
<span class="fc" id="L339">        SortedSet&lt;Integer&gt; a = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        for(i = 0; i &lt; deadlines.length; ++i) {</span>
<span class="fc" id="L341">            oIdx = origIndexes[i];</span>
            //System.out.printf(&quot;a%d f_i=%d, (%d,%d): &quot;, oIdx+1, (a.size()+1), deadlines[i], penalties[i]);
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (deadlines[i] &gt;= (a.size()+1)) {</span>
                //done early
<span class="fc" id="L345">                a.add(i);</span>
            //    System.out.println(&quot;  accept&quot;);
<span class="pc bpc" id="L347" title="1 of 4 branches missed.">            } else if (!a.isEmpty() &amp;&amp; (deadlines[i] &lt; deadlines[a.last()])) {</span>
                
                // check whether this increase of start time by 1 unit would push
                //    out the last item (which is the same last item that we just
                //    compared in this conditional clause.
                //    if that were true, do not add this item because it conflicts.
<span class="fc bfc" id="L353" title="All 2 branches covered.">                if (deadlines[a.last()] &gt;= (a.size() + 1)) {</span>
<span class="fc" id="L354">                    a.add(i);</span>
            //        System.out.println(&quot;  accept&quot;);
            //    } else {
            //        System.out.println(&quot;  reject&quot;);
                }                
            //} else {
            //    System.out.println(&quot;  reject&quot;);
            }
        }
        // rewrite indexes in context of original array indexes:
<span class="fc" id="L364">        int[] ao = new int[a.size()];</span>
<span class="fc" id="L365">        int count = 0;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (Integer ai : a) {</span>
<span class="fc" id="L367">            ao[count++] = origIndexes[ai];</span>
<span class="fc" id="L368">        }</span>
<span class="fc" id="L369">        return ao;</span>
    }

    private int[] sort2(double[] a, double[] b, double[] c) {
<span class="fc" id="L373">        int[] oIdxs = new int[a.length];</span>
        int i;
<span class="fc bfc" id="L375" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L376">            oIdxs[i] = i;</span>
        }
<span class="fc" id="L378">        mergesort(a, oIdxs, 0, a.length - 1);</span>
<span class="fc" id="L379">        double[] t = new double[b.length];</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L381">            t[i] = b[oIdxs[i]];</span>
        }
<span class="fc" id="L383">        System.arraycopy(t, 0, b, 0, b.length);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L385">            t[i] = c[oIdxs[i]];</span>
        }
<span class="fc" id="L387">        System.arraycopy(t, 0, c, 0, c.length);</span>
<span class="fc" id="L388">        return oIdxs;</span>
    }
    
    private void mergesort(double[] a, int[] b, int idxLo, int idxHi) {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L393">            int idxMid = (idxLo + idxHi) &gt;&gt; 1;</span>
<span class="fc" id="L394">            mergesort(a, b, idxLo, idxMid);           </span>
<span class="fc" id="L395">            mergesort(a, b, idxMid + 1, idxHi);       </span>
<span class="fc" id="L396">            merge(a, b, idxLo, idxMid, idxHi);</span>
        }
<span class="fc" id="L398">    }</span>

    private void merge(double[] a, int[] b, int idxLo, int idxMid, int idxHi) {
<span class="fc" id="L401">        double[] aL = Arrays.copyOfRange(a, idxLo, idxMid + 2);</span>
<span class="fc" id="L402">        double[] aR = Arrays.copyOfRange(a, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L403">        aL[aL.length - 1] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L404">        aR[aR.length - 1] = Double.POSITIVE_INFINITY;</span>

<span class="fc" id="L406">        int[] bL = Arrays.copyOfRange(b, idxLo, idxMid + 2);</span>
<span class="fc" id="L407">        int[] bR = Arrays.copyOfRange(b, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L408">        bL[bL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L409">        bR[bR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L411">        int posL = 0;</span>
<span class="fc" id="L412">        int posR = 0;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (aL[posL] &lt;= aR[posR]) {</span>
<span class="fc" id="L415">                a[k] = aL[posL];</span>
<span class="fc" id="L416">                b[k] = bL[posL];</span>
<span class="fc" id="L417">                posL++;</span>
            } else {
<span class="fc" id="L419">                a[k] = aR[posR];</span>
<span class="fc" id="L420">                b[k] = bR[posR];</span>
<span class="fc" id="L421">                posR++;</span>
            }
        }
<span class="fc" id="L424">    }</span>

    private int[] mergesortIncreasingADecreasingB(int[] a, int[] b) {
<span class="fc" id="L427">        int[] indexes = new int[a.length];</span>
        int i;
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L430">            indexes[i] = i;</span>
        }
<span class="fc" id="L432">        mergesortIncreasingADecreasingB(a, b, indexes, 0, a.length-1);</span>
<span class="fc" id="L433">        return indexes;</span>
    }

    private void mergesortIncreasingADecreasingB(int[] a, int[] b, int[] c, int idxLo, int idxHi) {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L438">            int idxMid = (idxHi + idxLo)/2;</span>
<span class="fc" id="L439">            mergesortIncreasingADecreasingB(a, b, c, 0, idxMid);</span>
<span class="fc" id="L440">            mergesortIncreasingADecreasingB(a, b, c, idxMid + 1, idxHi);</span>
<span class="fc" id="L441">            mergeIncreasingADecreasingB(a, b, c, idxLo, idxMid, idxHi);</span>
        }
<span class="fc" id="L443">    }</span>

    private void mergeIncreasingADecreasingB(int[] a, int[] b, int[] c, 
        int idxLo, int idxMid, int idxHi) {
        
<span class="fc" id="L448">        int[] aL = Arrays.copyOfRange(a, idxLo, idxMid + 2);</span>
<span class="fc" id="L449">        int[] aR = Arrays.copyOfRange(a, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L450">        aL[aL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L451">        aR[aR.length - 1] = Integer.MAX_VALUE;</span>

<span class="fc" id="L453">        int[] bL = Arrays.copyOfRange(b, idxLo, idxMid + 2);</span>
<span class="fc" id="L454">        int[] bR = Arrays.copyOfRange(b, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L455">        bL[bL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L456">        bR[bR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L458">        int[] cL = Arrays.copyOfRange(c, idxLo, idxMid + 2);</span>
<span class="fc" id="L459">        int[] cR = Arrays.copyOfRange(c, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L460">        cL[cL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L461">        cR[cR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L463">        int posL = 0;</span>
<span class="fc" id="L464">        int posR = 0;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; ++k) {</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (aL[posL] &lt; aR[posR]) {</span>
<span class="fc" id="L467">                a[k] = aL[posL];</span>
<span class="fc" id="L468">                b[k] = bL[posL];</span>
<span class="fc" id="L469">                c[k] = cL[posL];</span>
<span class="fc" id="L470">                posL++;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            } else if (aL[posL] &gt; aR[posR]) {</span>
<span class="fc" id="L472">                a[k] = aR[posR];</span>
<span class="fc" id="L473">                b[k] = bR[posR];</span>
<span class="fc" id="L474">                c[k] = cR[posR];</span>
<span class="fc" id="L475">                posR++;</span>
            } else {
                // they're equal, so break ties by values of b
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                if (bL[posL] &gt;= bR[posR]) {</span>
<span class="fc" id="L479">                    a[k] = aL[posL];</span>
<span class="fc" id="L480">                    b[k] = bL[posL];</span>
<span class="fc" id="L481">                    c[k] = cL[posL];</span>
<span class="fc" id="L482">                    posL++;</span>
                } else {
<span class="nc" id="L484">                    a[k] = aR[posR];</span>
<span class="nc" id="L485">                    b[k] = bR[posR];</span>
<span class="nc" id="L486">                    c[k] = cR[posR];</span>
<span class="nc" id="L487">                    posR++;</span>
                }
            }
        }
<span class="fc" id="L491">    }</span>
    
    
    private int[] sortDecr(int[] a, int[] b) {
<span class="fc" id="L495">        int[] oIdxs = new int[a.length];</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L497">            oIdxs[i] = i;</span>
        }
<span class="fc" id="L499">        quicksortDecr(a, oIdxs, 0, a.length - 1);</span>
<span class="fc" id="L500">        int[] t = new int[b.length];</span>
        int i;
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L503">            t[i] = b[oIdxs[i]];</span>
        }
<span class="fc" id="L505">        System.arraycopy(t, 0, b, 0, b.length);</span>
<span class="fc" id="L506">        return oIdxs;</span>
    }
    
    private void quicksortDecr(int[] a, int[] b, int idxLo, int idxHi) {
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L511">            int idxMid = partitionDecr(a, b, idxLo, idxHi);</span>
<span class="fc" id="L512">            quicksortDecr(a, b, idxLo, idxMid-1);</span>
<span class="fc" id="L513">            quicksortDecr(a, b, idxMid+1, idxHi);</span>
        }
<span class="fc" id="L515">    }</span>
    private int partitionDecr(int[] a, int[] b, int idxLo, int idxHi) {
<span class="fc" id="L517">        int xa = a[idxHi];</span>
<span class="fc" id="L518">        int i = idxLo - 1;  </span>
        int swap;
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (int j = idxLo; j &lt; idxHi ; j++ ) {</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (a[j] &gt;= xa) { </span>
<span class="fc" id="L522">                i++;</span>
<span class="fc" id="L523">                swap = a[i];</span>
<span class="fc" id="L524">                a[i] = a[j];</span>
<span class="fc" id="L525">                a[j] = swap;</span>
<span class="fc" id="L526">                swap = b[i];</span>
<span class="fc" id="L527">                b[i] = b[j];</span>
<span class="fc" id="L528">                b[j] = swap;</span>
            }
        }
<span class="fc" id="L531">        swap = a[i + 1];</span>
<span class="fc" id="L532">        a[i + 1] = a[idxHi];</span>
<span class="fc" id="L533">        a[idxHi] = swap;</span>
<span class="fc" id="L534">        swap = b[i + 1];</span>
<span class="fc" id="L535">        b[i + 1] = b[idxHi];</span>
<span class="fc" id="L536">        b[idxHi] = swap;</span>
<span class="fc" id="L537">        return i + 1;</span>
    }

    /**
    Interval Partitioning:
    Given an infinite number of possible exclusive resources to use, 
    schedule all the activities using the smallest number of resources.
    The activity requests each have a start and finish time.
    Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
    such that events of R_j are mutually non-conflicting, for each j: 0 ≤ j ≤ (d-1).

    References:
    &lt;pre&gt;
    lecture 7 notes of David Mount for CMSC 451       
    Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
    https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
    &lt;/pre&gt;

     runtime complexity is O(n^2)
     * 
     * Note: can compare this algorithm to the left-edge algorithms which
     * sorts by increasing finish times, then loops over each request
     * to add all sequential non-conflicting requests to a resource, then
     * start a new resource for a conflict.
     * Then one attempts to merge resources, by visiting them in reverse order.
     * After all requests have been placed in a resource, one attempts to
     * merge the non-conflicting resources by visiting them in reverse order
     * and comparing to the previous resource (that is, starting with the last resource
     * created, and then the one before it, etc until the first is visited).
     * The left-edge algorithm runtime is similar to this interval partitioning greedy algorithm.
     * 
     * @param s start times
     * @param f finish times
     * @return indexes of resources to schedule the requests on.
     */
    public int[] intervalPartitionGreedy(double[] s, double[] f) {     
        
<span class="fc" id="L574">        double[] s2 = Arrays.copyOf(s, s.length);</span>
        
        /*
        (1) sort the requests by increasing order of start times. 
        (2) assign to each request the smallest color (possibly a new color) 
            such that it conflicts with no other requests of this color class. 
        */
        
        // runtime complexity O(n)
        //sort requests by increasing start times
<span class="fc" id="L584">        int[] indexes = MiscSorter.mergeSortIncreasing(s2);</span>
<span class="fc" id="L585">        double[] f2 = new double[s2.length];</span>
        int i, j;
<span class="fc bfc" id="L587" title="All 2 branches covered.">        for (i = 0; i &lt; f.length; ++i) {</span>
<span class="fc" id="L588">            f2[i] = f[indexes[i]];</span>
        }
        
        //System.out.println(&quot;indexes sorted by start times = &quot; + Arrays.toString(indexes));
        
        // a color for each request
<span class="fc" id="L594">        int[] c = new int[s.length];</span>
        
        TIntSet excl;        
        int color;
        // runtime complexity O(n*n/2)
<span class="fc bfc" id="L599" title="All 2 branches covered.">        for (i = 0; i &lt; f2.length; ++i) {</span>
<span class="fc" id="L600">            excl = new TIntHashSet();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            for (j = 0; j &lt; i; ++j) {</span>
                //j is always smaller than i so s[j] &lt;= s[i].  
                //  then order is (sj,fj)  (si,fi)
                
                //if ([s[j],f[j]] overlaps [s[i],f[i]]) 
<span class="fc bfc" id="L606" title="All 2 branches covered.">                if (s2[i] &lt; f2[j]) {</span>
<span class="fc" id="L607">                    excl.add(c[j]);</span>
                    /*System.out.printf(&quot;conflict for i2=%d, j2=%d (s2[%d]&lt;f2[%d])=(%.1f, %.2f)\n&quot;,
                        i, j, i, j, s2[i], f2[i]);
                    System.out.printf(&quot;==&gt; i=%d, j=%d (s2[%d]&lt;f2[%d])=(%.1f, %.2f)\n&quot;,
                        indexes[i], indexes[j], indexes[i], indexes[j], 
                        s[indexes[i]], f[indexes[i]]);
                    */
                }
            }
            //Let c be the smallest color NOT in E
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">            for (color = 0; color &lt; f2.length; ++color) {</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (!excl.contains(color)) {</span>
<span class="fc" id="L619">                    break;</span>
                }
            }
<span class="fc" id="L622">            c[i] = color;</span>
        }
        //rewrite c in terms of original indexes of method argument's unsorted (s,f)
<span class="fc" id="L625">        int[] c2 = new int[f2.length];</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">        for (i = 0; i &lt; f2.length; ++i) {</span>
<span class="fc" id="L627">            c2[indexes[i]] = c[i];</span>
        }
<span class="fc" id="L629">        return c2;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>