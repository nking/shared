<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VertexCover.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.graphs</a> &gt; <span class="el_source">VertexCover.java</span></div><h1>VertexCover.java</h1><pre class="source lang-java linenums">package algorithms.graphs;

import algorithms.TreeTraversal;
import algorithms.DoublyLinkedList;
import algorithms.NAryTreeNode;
import algorithms.optimization.LinearProgramming;
import algorithms.optimization.LinearProgramming.SlackForm;
import algorithms.optimization.LinearProgramming.StandardForm;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 A vertex cover is a subset of a graph's vertices which represents at 
 least one vertex from every edge in the full graph.
 
 optimal vertex cover is np-hard (non-deterministic polynomial class
   problems at least as hard as the hardest problems in NP.  No known polynomial
   time algorithm, but one can guess a single solution and verify it.)    

 * @author nichole
 */
<span class="fc" id="L30">public class VertexCover {</span>
    
    /**
     * for a tree, find an exact vertex cover which does not include any leaves.
     * runtime complexity is O(|V|).
     &lt;pre&gt;
     implemented from pseudocode in lecture slides of Principal lecturer: Dr Thomas Sauerwald
        Advanced Algorithms, University of Cambridge.
        VII. Approximation Algorithms: Covering Problems
      https://www.cl.cam.ac.uk/teaching/1617/AdvAlgo/vertexcover.pdf
      who reference Cormen et al. &quot;Introduction to Algorithms&quot;
     &lt;/pre&gt;
     Note that a copy of the tree is made internally (excluding prev and next attributes)
     * and the copied nodes are returned in a Set.  At this time, the identity
     * of each NAryTreeNode in the original root and copied root will not be
     * the same, so only the data properties should be used for identity in the returned set.
     * @param root a n-ary tree root.
     * @return an exact vertex cover of the tree, excluding leaves.
     * Note that a copy of the tree is made internally (excluding prev and next attributes)
     * and the copied nodes are returned in a Set.  At this time, the identity
     * of each NAryTreeNode in the original root and copied root will not be
     * the same, so only the data properties should be used for identity in the returned set.
     */
    public Set&lt;NAryTreeNode&gt; exact(NAryTreeNode root) {
        
<span class="fc" id="L55">        root = NAryTreeNode.copyTree(root);</span>
        
        /*
        There exists an optimal vertex cover which does not include any leaves.
        VERTEX-COVER-TREES(G)
            C=∅ 
            while there exists leaves in G 
                Add all parents of leaves to C
                Remove all leaves and their parents from G 
            return C
        */
                
<span class="fc" id="L67">        TreeTraversal tt = new TreeTraversal();</span>
<span class="fc" id="L68">        DoublyLinkedList&lt;NAryTreeNode&gt; revLevelOrder = tt.getReverseLevelOrderIterative2(root);</span>
<span class="fc" id="L69">        Set&lt;NAryTreeNode&gt; c = new HashSet&lt;NAryTreeNode&gt;();</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (revLevelOrder.size() &lt; 1) {</span>
<span class="nc" id="L71">            return c;</span>
        }
        Set&lt;NAryTreeNode&gt; children;
        NAryTreeNode node;
<span class="fc" id="L75">        int i = 0;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        while (!revLevelOrder.isEmpty()) {</span>
<span class="fc" id="L77">            node = revLevelOrder.peekFirst();</span>
            //System.out.println(&quot;visiting &quot; + node.getData());
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (node.getParent() != null) {</span>
<span class="pc bpc" id="L80" title="2 of 4 branches missed.">                if (node.getChildren().isEmpty() &amp;&amp; !c.contains(node.getParent())) {</span>
                    // this is a leaf node.  
                    // add it's parent to set C
<span class="fc" id="L83">                    c.add(node.getParent());</span>
                    //System.out.println(&quot;  *C.add==&quot; + node.getParent().getData());
                    //  remove node and parent from LinkedList
                    //System.out.println(&quot;  unlink parent=&quot; + node.getParent().getData());
<span class="fc" id="L87">                    revLevelOrder.unlink(node.getParent());</span>
<span class="fc" id="L88">                    children = node.getParent().getChildren();</span>
                    // remove children of parent
<span class="fc bfc" id="L90" title="All 2 branches covered.">                    for (NAryTreeNode child : children) {</span>
                        //System.out.println(&quot;  unlink child=&quot; + child.getData());
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                        if (!c.contains(child)) {</span>
<span class="fc" id="L93">                            revLevelOrder.unlink(child);</span>
                        }
<span class="fc" id="L95">                    }</span>
                    // remove parent from it's parent's children
<span class="fc bfc" id="L97" title="All 2 branches covered.">                    if (node.getParent().getParent() != null) {</span>
<span class="fc" id="L98">                        children = node.getParent().getParent().getChildren();</span>
<span class="fc" id="L99">                        children.remove(node.getParent());</span>
                    }
                } else {
                    //System.out.println(&quot;  unlink &quot; + node.getData());
<span class="nc" id="L103">                    revLevelOrder.unlink(node);</span>
                }
<span class="nc bnc" id="L105" title="All 2 branches missed.">            } else if (revLevelOrder.size() == 1) {</span>
<span class="nc" id="L106">                c.add(node);</span>
                //System.out.println(&quot;  unlink root &quot; + node.getData());
<span class="nc" id="L108">                revLevelOrder.unlink(node);</span>
            }
        }
<span class="fc" id="L111">        return c;</span>
    }
    
    /**
     * find a vertex cover that is 2-approximate, that is no more than 2 times
     * as large as the optimal vertex cover.
     *
     * A vertex cover is a subset of a graph's vertices which represents at least one vertex 
     * from every edge in the full graph.
     * 
     * The runtime complexity is O(|E| + |V|).

     * &lt;pre&gt;
     * The algorithm implements pseudocode from
     *  from https://www.ics.uci.edu/~goodrich/teach/graph/notes/Approximation.pdf
     * Also see Section 35.1 of Cormen et al. &quot;Introduction to Algorithms&quot;.
     * &lt;/pre&gt;
     * @param adjMap adjacency map for an undirected graph.
     * @return the vertex cover for undirected graph adjMap, no larger than twice that of optimal.
     */
    public TIntSet approx2(TIntObjectMap&lt;TIntSet&gt; adjMap) {
        
        // make a copy of the graph to edit it
<span class="fc" id="L134">        TIntObjectMap&lt;TIntSet&gt; g = copy(adjMap);</span>
        
        // make a reverse mapping of the graph in order to find edges incident
        //    on to a given vertex.
<span class="fc" id="L138">        TIntObjectMap&lt;TIntSet&gt; reverseMap = reverse(adjMap);</span>
        
        //TIntIntMap c = new TIntIntHashMap();
<span class="fc" id="L141">        TIntSet c = new TIntHashSet();</span>
        
        int u, v, incident;
        TIntSet uEdges, revEdgesU, revEdgesV;
        TIntIterator iter;
<span class="fc bfc" id="L146" title="All 2 branches covered.">        while (!g.isEmpty()) {</span>
            //(1) select an edge e = (u,v) of G
<span class="fc" id="L148">            u = g.keySet().iterator().next();</span>
<span class="fc" id="L149">            uEdges = g.get(u);</span>
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">            if (uEdges == null || uEdges.isEmpty()) {</span>
<span class="nc" id="L151">                g.remove(u);</span>
<span class="nc" id="L152">                continue;</span>
            }
<span class="fc" id="L154">            v = uEdges.iterator().next();</span>
            
            //(2) add vertices u and v to C
<span class="fc" id="L157">            c.add(u);</span>
<span class="fc" id="L158">            c.add(v);</span>
            
            // remove all edges u-&gt;other
<span class="fc" id="L161">            g.remove(u);</span>
            // remove all edges v-&gt;other
<span class="fc" id="L163">            g.remove(v);</span>

            // remove all edges other-&gt;u
            //   can use reverse map to find those links                        
<span class="fc" id="L167">            revEdgesU = reverseMap.get(u);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            if (revEdgesU != null) {</span>
<span class="fc" id="L169">                iter = revEdgesU.iterator();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                while (iter.hasNext()) {</span>
<span class="fc" id="L171">                    incident = iter.next();</span>
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">                    if (g.containsKey(incident) &amp;&amp; g.get(incident).contains(u)) {</span>
<span class="fc" id="L173">                        g.get(incident).remove(u);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                        if (g.get(incident).isEmpty()) {</span>
<span class="fc" id="L175">                            g.remove(incident);</span>
                        }
                    }
                }
            }
            
            // remove all edges other-&gt;v
            //   can use reverse map to find those links
<span class="fc" id="L183">            revEdgesV = reverseMap.get(v);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            if (revEdgesV != null) {</span>
<span class="fc" id="L185">                iter = revEdgesV.iterator();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                while (iter.hasNext()) {</span>
<span class="fc" id="L187">                    incident = iter.next();</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">                    if (g.containsKey(incident) &amp;&amp; g.get(incident).contains(v)) {</span>
<span class="fc" id="L189">                        g.get(incident).remove(v);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                        if (g.get(incident).isEmpty()) {</span>
<span class="fc" id="L191">                            g.remove(incident);</span>
                        }
                    }
                }
            }
        }       
<span class="fc" id="L197">        return c;</span>
    }
    
    /**
     * find a minimum weighted vertex cover for a weighted undirected graph  
     * using a 2-approximate algorithm
     *(though the linear programming implementation used does not have polynomial runtime).
     *
     * A vertex cover is a subset of a graph's vertices which represents at least one vertex 
     * from every edge in the full graph.  The given vertexes have weights
     * associated with them.
     * 
     * &lt;pre&gt;
     * The algorithm implements pseudocode from
     * Section 35.4 of Cormen et al. &quot;Introduction to Algorithms&quot;.
     * &lt;/pre&gt;
     * @param adjMap adjacency map for an undirected graph.
     * @param weights the weights of each vertex
     * @return the minimum weighted vertex cover for graph G represented by adjMap with vertex weights.
     */
    public TIntSet approx2Weighted(TIntObjectMap&lt;TIntSet&gt; adjMap, double[] weights) {
        
        /*
        for the linear program:
            minimize: 
                summation_v_in_V( w(v)*x(v)
            subject to:
                x(u) + x(v) &gt;= 1 for each (u,v) in E
                x(v) &lt;= 1 for each v in V ----\
            non-negativity constraints:        \ these 2 rules are derived from x(v) ∈ [0,1]
                x(v) &gt;= 0 for each v in V ----/
        
        for the weighted vc:
            compute optimal x from linear programming.
            C = empty set
            for each v in V
                if (x(v) &gt;= 0.5)
                    add v to C
        */
        
<span class="fc" id="L237">        StandardForm standForm = createLinearProgramInStandardForm(adjMap, weights);</span>
<span class="fc" id="L238">        LinearProgramming lp = new LinearProgramming();</span>
<span class="fc" id="L239">        SlackForm soln = lp.solveUsingSimplexMethod(standForm);</span>
<span class="fc" id="L240">        double[] x = soln.computeBasicSolution();</span>
        
        //System.out.printf(&quot;x=%s\n&quot;, FormatArray.toString(x, &quot;%.3f&quot;));
        
<span class="fc" id="L244">        TIntSet c = new TIntHashSet();</span>
        int i;
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (i = 0; i &lt; weights.length; ++i) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (x[i] &gt;= 0.5) {</span>
<span class="fc" id="L248">                c.add(i);</span>
            }
        }
<span class="fc" id="L251">        return c;</span>
    }

    protected TIntObjectMap&lt;TIntSet&gt; copy(TIntObjectMap&lt;TIntSet&gt; adjMap) {
        
<span class="fc" id="L256">        TIntObjectMap&lt;TIntSet&gt; c = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
<span class="fc" id="L257">        TIntObjectIterator&lt;TIntSet&gt; iter = adjMap.iterator();</span>
        TIntSet v;
        int k;
<span class="fc bfc" id="L260" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L261">            iter.advance();</span>
<span class="fc" id="L262">            k = iter.key();</span>
<span class="fc" id="L263">            v = iter.value();</span>
<span class="fc" id="L264">            c.put(k, new TIntHashSet(v.toArray()));</span>
        }
<span class="fc" id="L266">        return c;</span>
    }

    protected TIntObjectMap&lt;TIntSet&gt; reverse(TIntObjectMap&lt;TIntSet&gt; adjMap) {
        
<span class="fc" id="L271">        TIntObjectMap&lt;TIntSet&gt; r = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
<span class="fc" id="L273">        TIntObjectIterator&lt;TIntSet&gt; iter = adjMap.iterator();</span>
        TIntIterator iterV;
        TIntSet vSet, rVSet;
        int u, v;
<span class="fc bfc" id="L277" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L278">            iter.advance();</span>
<span class="fc" id="L279">            u = iter.key();</span>
<span class="fc" id="L280">            vSet = iter.value();</span>
            
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">            if (vSet != null &amp;&amp; !vSet.isEmpty()) {</span>
<span class="fc" id="L283">                iterV = vSet.iterator();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                while (iterV.hasNext()) {</span>
<span class="fc" id="L285">                    v = iterV.next();</span>
<span class="fc" id="L286">                    rVSet = r.get(v);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                    if (rVSet == null) {</span>
<span class="fc" id="L288">                        rVSet = new TIntHashSet();</span>
<span class="fc" id="L289">                        r.put(v, rVSet);</span>
                    }
<span class="fc" id="L291">                    rVSet.add(u);</span>
                }
            }
        }
<span class="fc" id="L295">        return r;</span>
    }

    protected StandardForm createLinearProgramInStandardForm(
        TIntObjectMap&lt;TIntSet&gt; adjMap, double[] weights) {
        
        /*
         minimize: 
                summation_v_in_V( w(v)*x(v) )
            subject to:
                x(u) + x(v) &gt;= 1 for each (u,v) in E
                x(v) &lt;= 1 for each v in V
            non-negativity constraints:
                x(v) &gt;= 0 for each v in V
        */
<span class="fc" id="L310">        double[] c = Arrays.copyOf(weights, weights.length);</span>
        
        // rows are pairs of u, v, e.g. edges[0][0] = u, edges[0][1] = v
<span class="fc" id="L313">        int[][] edges = extractEdges(adjMap);</span>
<span class="fc" id="L314">        int nE = edges.length;</span>
<span class="fc" id="L315">        int nV = weights.length;</span>
        
<span class="fc" id="L317">        double[][] a = new double[nE + nV][nV];</span>
<span class="fc" id="L318">        double[] b = new double[nE + nV];</span>
<span class="fc" id="L319">        Arrays.fill(b, 1);</span>
        
        int i, u, v;
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (i = 0; i &lt; nE; ++i) {</span>
<span class="fc" id="L323">            u = edges[i][0];</span>
<span class="fc" id="L324">            v = edges[i][1];</span>
<span class="fc" id="L325">            a[i] = new double[nV];</span>
<span class="fc" id="L326">            a[i][u] = 1;</span>
<span class="fc" id="L327">            a[i][v] = 1;</span>
        }
        int i2;
<span class="fc bfc" id="L330" title="All 2 branches covered.">        for (i = 0, i2=nE; i &lt; nV; ++i, ++i2) {</span>
<span class="fc" id="L331">            a[i2] = new double[nV];</span>
<span class="fc" id="L332">            a[i2][i] = 1;</span>
        }
        
<span class="fc" id="L335">        boolean isMaximization = false;</span>
<span class="fc" id="L336">        int[] constraintComparisons = new int[nE + nV];</span>
<span class="fc" id="L337">        Arrays.fill(constraintComparisons, 0, nE, 1);</span>
<span class="fc" id="L338">        Arrays.fill(constraintComparisons, nE, nE+nV, -1);</span>
<span class="fc" id="L339">        boolean[] nonnegativityConstraints = new boolean[nV];</span>
<span class="fc" id="L340">        Arrays.fill(nonnegativityConstraints, true);</span>
        
<span class="fc" id="L342">        StandardForm standForm = LinearProgramming</span>
<span class="fc" id="L343">            .convertLinearProgramToStandardForm(isMaximization, a, b, c, </span>
            constraintComparisons, nonnegativityConstraints);
        
        //System.out.printf(&quot;graph as Linear Program in standard form=\n%s\n&quot;, standForm.toString());

<span class="fc" id="L348">        return standForm;</span>
    }

    /**
     * extract edges from the adjacency map and put them in a 2 dimensional array.
     * @param adjMap adjacency map of an undirected graph.  edge u-&gt;v and v-&gt;u are
     * considered the same edge.
     * @return two dimensional array of the edges.
     */
    protected int[][] extractEdges(TIntObjectMap&lt;TIntSet&gt; adjMap) {
<span class="fc" id="L358">        Set&lt;PairInt&gt; edges = new HashSet&lt;PairInt&gt;();</span>
        int u, v, i, k, k2;
        PairInt p;
        
<span class="fc" id="L362">        TIntObjectIterator&lt;TIntSet&gt; iter = adjMap.iterator();</span>
        TIntIterator iter2;
        TIntSet adj;
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (i = 0; i &lt; adjMap.size(); ++i) {</span>
<span class="fc" id="L366">            iter.advance();</span>
<span class="fc" id="L367">            adj = iter.value();</span>
<span class="pc bpc" id="L368" title="1 of 4 branches missed.">            if (adj == null || adj.isEmpty()) {</span>
<span class="fc" id="L369">                continue;</span>
            }
<span class="fc" id="L371">            k = iter.key();</span>
<span class="fc" id="L372">            iter2 = adj.iterator();</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L374">                k2 = iter2.next();</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if (k2 &lt; k) {</span>
<span class="nc" id="L376">                    p = new PairInt(k2, k);</span>
                } else {
<span class="fc" id="L378">                    p = new PairInt(k, k2);</span>
                }
<span class="fc" id="L380">                edges.add(p);</span>
            }
        }
<span class="fc" id="L383">        int[][] out = new int[edges.size()][];</span>
<span class="fc" id="L384">        i = 0;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (PairInt p2 : edges) {</span>
<span class="fc" id="L386">            out[i] = new int[]{p2.getX(), p2.getY()};</span>
<span class="fc" id="L387">            i++;</span>
<span class="fc" id="L388">        }</span>
<span class="fc" id="L389">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>