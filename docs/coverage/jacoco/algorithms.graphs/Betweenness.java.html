<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Betweenness.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.graphs</a> &gt; <span class="el_source">Betweenness.java</span></div><h1>Betweenness.java</h1><pre class="source lang-java linenums">package algorithms.graphs;

import algorithms.util.PairInt;
import algorithms.util.SimpleLinkedListNode;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TObjectFloatIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TObjectFloatMap;
import gnu.trove.map.hash.TObjectFloatHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Queue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * &quot;Betweenness&quot; is an algorithm to find non-overlapping communities 
 * within an unweighted, undirected network.
 * 
 * &lt;pre&gt;
      for more information, see:
 
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
 
    The simplest form of the algorithm attempts to find the edges that are least 
    likely to be inside a community.

    Define the betweenness of an edge (a, b) to be the number of pairs of nodes
    x and y such that the edge (a, b) lies on the shortest path between x and y.
    To be more precise, since there can be several shortest paths between x and y,
    edge (a, b) is credited with the fraction of those shortest paths that 
    include the edge (a, b). As in golf, a high score is bad. 
    It suggests that the edge (a, b) runs between two different communities; 
    that is, a and b do not belong to the same community.
    
 * @author nichole
 */
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">public class Betweenness {</span>
    
<span class="fc" id="L58">    private Logger log = Logger.getLogger(getClass().getSimpleName());</span>
    
<span class="fc" id="L60">    private Level logLevel = Level.FINE;</span>
    
    /**
     * implementation of unweighted graph edge scoring from Girvan-Newman 
     * algorithm, accepting a DAG.   Each graph node without a predecessor
     * is iterated over to calculate node and edge weights.  
     * The choice of the src node as a method argument does not affect the 
     * final scored edge weights,
       but is present in case information about the graph provides a best src
       node to start with (e.g. when the graph only has one parent node).
     
     * Reference is 2004 Newman and Girvan,
     * &quot;Finding and evaluating community structure in networks&quot;.
     * 
     * The runtime complexity is &lt;em&gt;1 + the number of graph roots (i.e. nodes without predecessors)
     *   times  O(|V| + |E|)&lt;/em&gt;.
     * 
     * For more information and other graph scoring and distance algorithms and 
     * cluster finding (a.k.a. community finding) see also
      &lt;pre&gt;
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
     * @param adjacencyList an adjacency list for an unweighted DAG.
     * @param s source node to begin the graph traversal
     * @return scores for the edges of the graph, calculated using the Girvan-Newman algorithm.
     */
    public Results girvanNewmanDAG(SimpleLinkedListNode[] adjacencyList, final int s) {
        
        //avg O(|E|);  worst: O(|V| + |E|)
<span class="fc" id="L103">        int[] rootIndexes = findRoots(adjacencyList, s);</span>
        
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (rootIndexes.length == 0) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException(&quot;this algorithm operates on a &quot; </span>
            + &quot; DAG and has been given a graph without a true root node.  &quot; +
            &quot; If have a directionless adjacency list (i.e. u:v and v:u exist)&quot; +
            &quot; then use girvanNewmanDirectionless with a choise of a source node&quot;);
        }
        
        // print(adjacencyList);
<span class="fc" id="L113">        System.out.printf(&quot;nV=%d, roots=%s&quot;, adjacencyList.length, </span>
<span class="fc" id="L114">            Arrays.toString(rootIndexes));</span>
        
<span class="fc" id="L116">        final int nV = adjacencyList.length;</span>
        // init
<span class="fc" id="L118">        final int[] d = new int[nV];</span>
<span class="fc" id="L119">        final int[] dBest = new int[nV];</span>
<span class="fc" id="L120">        Arrays.fill(dBest, Integer.MAX_VALUE);</span>
<span class="fc" id="L121">        final TIntList[] p = new TIntList[nV];</span>
<span class="fc" id="L122">        final int[] color = new int[nV];</span>
        
        // index is vertex index
<span class="fc" id="L125">        final int[] w = new int[nV];</span>
<span class="fc" id="L126">        final int[] wG = new int[nV];</span>
        
        // key = edge vertexes (u, v) where u is closer to the root, value = edge weight
<span class="fc" id="L129">        final TObjectFloatMap&lt;PairInt&gt; wEdges = new TObjectFloatHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L131">        final TIntSet members = new TIntHashSet();</span>
        
        // runtime is # of roots * O(|V| + |E|)
        
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int src : rootIndexes) {</span>
        
<span class="fc" id="L137">            Arrays.fill(w, 0);</span>
<span class="fc" id="L138">            Arrays.fill(color, 0);</span>
<span class="fc" id="L139">            Arrays.fill(d, Integer.MAX_VALUE);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            for (int i = 0; i &lt; nV; ++i) {</span>
<span class="fc" id="L141">                p[i] = new TIntArrayList();</span>
            }
            
<span class="fc" id="L144">            color[src] = 1;</span>
<span class="fc" id="L145">            d[src] = 0;</span>
<span class="fc" id="L146">            dBest[src] = 0;</span>
<span class="fc" id="L147">            w[src] = 1;</span>
            
            /*
            1) d[s]=0  w[s]=1
            2) Every vertex i adjacent to s is given distance d[i]=d[s]+1 and w[i]=w[s]=1
            3) For each vertex j adjacent to one of those vertices i:
                a) If j has not yet been assigned a distance, 
                       it is assigned distance d[j]=d[i]+1 and weight w[j]=w[i]
                b) if j has already been assigned a distance and d[j]==d[1]+1 then w[j]=w[j]+w[i]
                c) if j has already been assigned a distance and d[j]&lt;d[i]+1, do nothing.
            */
<span class="fc" id="L158">            log.log(logLevel, &quot;root=&quot; + src);</span>
      
            // calc vertex weights
<span class="fc" id="L161">            final TIntList leaf = new TIntArrayList();</span>
<span class="fc" id="L162">            final Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span>
<span class="fc" id="L163">            queue.add(src);</span>
            int u;
            
<span class="fc bfc" id="L166" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
            //    log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
            //    log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
            //    log.log(logLevel, &quot;dBest=&quot; + Arrays.toString(dBest));
            //    log.log(logLevel, &quot;color=&quot; + Arrays.toString(color));
<span class="fc" id="L171">                u = queue.remove().intValue();</span>
<span class="fc" id="L172">                members.add(u);</span>
<span class="fc" id="L173">                log.log(logLevel, String.format(&quot;u=%d&quot;, u));</span>
<span class="fc" id="L174">                SimpleLinkedListNode vNode = adjacencyList[u];</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">                if (vNode == null || vNode.getKey() == -1) {</span>
<span class="fc" id="L176">                    leaf.add(u);</span>
<span class="fc" id="L177">                    color[u] = 2;</span>
<span class="fc" id="L178">                    log.log(logLevel, &quot;    LEAF&quot;);</span>
<span class="fc" id="L179">                    continue;</span>
                }
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">                while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L182">                    int v = vNode.getKey();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (color[v] == 0) {</span>
<span class="fc" id="L184">                        color[v] = 1;</span>
<span class="fc" id="L185">                        d[v] = d[u] + 1;</span>
<span class="fc" id="L186">                        w[v] = w[u];</span>
<span class="fc" id="L187">                        queue.add(v);</span>
<span class="fc" id="L188">                        log.log(logLevel, String.format(&quot;  v=%d&quot;, v));</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                        if (d[v] &lt; dBest[v]) {</span>
<span class="fc" id="L190">                            dBest[v] = d[v];</span>
                        }
<span class="fc bfc" id="L192" title="All 2 branches covered.">                    } else if (d[v] == (d[u] + 1)) {</span>
<span class="fc" id="L193">                        w[v] += w[u];</span>
                    }
                    //if (d[u] &lt; d[v]) {
<span class="fc" id="L196">                        p[v].add(u);</span>
<span class="fc" id="L197">                        log.log(logLevel, String.format(&quot;    p[%d]=%d&quot;, v, u));</span>
                    //}
<span class="fc" id="L199">                    vNode = vNode.getNext();</span>
<span class="fc" id="L200">                }</span>
<span class="fc" id="L201">                color[u] = 2;</span>
<span class="fc" id="L202">            }</span>
<span class="pc bpc" id="L203" title="3 of 4 branches missed.">            assert(queue.isEmpty());</span>
         
            //add weights from previous root traversals
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (rootIndexes.length &gt; 1) {</span>
            //    log.log(logLevel, &quot;\n  w=&quot; + Arrays.toString(w));
<span class="fc bfc" id="L208" title="All 2 branches covered.">                for (int i = 0; i &lt; w.length; ++i) {</span>
<span class="fc" id="L209">                    w[i] += wG[i];</span>
                }
            //    log.log(logLevel, &quot;  wG=&quot; + Arrays.toString(wG));
            //    log.log(logLevel, &quot;-&gt;w=&quot; + Arrays.toString(w));
            }        
            
            // calc edge weights
<span class="fc" id="L216">            TIntSet enqd = new TIntHashSet();</span>
            float e;
<span class="fc" id="L218">            TIntIterator tIter = leaf.iterator();</span>
            int t, i, ip;
            TIntIterator pIter;
            PairInt uv;
<span class="fc bfc" id="L222" title="All 2 branches covered.">            while (tIter.hasNext()) {</span>
<span class="fc" id="L223">                t = tIter.next();</span>
<span class="fc" id="L224">                log.log(logLevel, String.format(&quot;t leaf=%d&quot;, t));</span>
                // calc edge for all edges into leaf:
<span class="fc" id="L226">                pIter = p[t].iterator();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L228">                    i = pIter.next();</span>
<span class="fc" id="L229">                    log.log(logLevel, String.format(&quot;    p=%d&quot;, i));</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                    if (!enqd.contains(i)) {</span>
<span class="fc" id="L231">                        queue.add(i);</span>
<span class="fc" id="L232">                        enqd.add(i);</span>
                    }
<span class="fc" id="L234">                    e = (float) w[i] / (float) w[t];</span>
 //                   assert(d[i] &lt; d[t]);
<span class="fc" id="L236">                    uv = new PairInt(i, t);</span>
<span class="fc" id="L237">                    wEdges.put(uv, e);</span>
<span class="fc" id="L238">                    log.log(logLevel, String.format(&quot;  edge=(%d, %d) w=%.3e&quot;, i, t, e));</span>
                }
            }
         //   log.log(logLevel, &quot;w={0}&quot;, Arrays.toString(w));
         //   log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
<span class="fc" id="L243">            log.log(logLevel, &quot;q=&quot;+ queue.toString());</span>
            float e2;
            PairInt ij;
<span class="fc bfc" id="L246" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
<span class="fc" id="L247">                i = queue.remove();</span>
<span class="fc" id="L248">                e = 1;</span>
<span class="fc" id="L249">                log.log(logLevel, String.format(&quot;  e0[%d]=%.3f&quot;, i, e));</span>
<span class="fc" id="L250">                SimpleLinkedListNode jNode = adjacencyList[i];</span>
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">                while (jNode != null &amp;&amp; jNode.getKey() != -1) {</span>
<span class="fc" id="L252">                    int j = jNode.getKey();</span>
<span class="fc" id="L253">                    ij = new PairInt(i, j);</span>
<span class="fc" id="L254">                    log.log(logLevel, String.format(&quot;  i=%d j=%d&quot;, i, j));</span>
//                    assert(d[i] &lt; d[j]);
                    
                    //assert(wEdges.containsKey(ij));
<span class="fc bfc" id="L258" title="All 2 branches covered.">                    if (!wEdges.containsKey(ij)) {</span>
<span class="fc" id="L259">                        e += ((float) w[i] / (float) w[j]);</span>
                        //wEdges.put(ij, (float) w[i] / (float) w[j]);
                    } else {
<span class="fc" id="L262">                        e += wEdges.get(ij);</span>
                    }
                    
<span class="fc" id="L265">                    log.log(logLevel, String.format(&quot;  + (w[%d]/w[%d]=%.3f)&quot;, i, j, wEdges.get(ij)));</span>
<span class="fc" id="L266">                    jNode = jNode.getNext();</span>
<span class="fc" id="L267">                }</span>
<span class="fc" id="L268">                log.log(logLevel, String.format(&quot;     =&gt;%.3f&quot;, e));</span>

<span class="fc" id="L270">                pIter = p[i].iterator();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L272">                    ip = pIter.next();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                    if (!enqd.contains(ip)) {</span>
<span class="fc" id="L274">                        queue.add(ip);</span>
<span class="fc" id="L275">                        enqd.add(ip);</span>
                    }
<span class="fc" id="L277">                    log.log(logLevel, String.format(&quot;  d[%d]=%d,  d[%d]=%d&quot;, ip, d[ip], i, d[i]));</span>
                 //   assert(d[ip] &lt; d[i]);
<span class="fc" id="L279">                    e2 = (float) w[ip] / (float) w[i];</span>
<span class="fc" id="L280">                    e2 *= e;</span>
<span class="fc" id="L281">                    log.log(logLevel, String.format(&quot;    e=(%.3f)*(w[%d]/w[%d]=%.3f)&quot;, e, ip, i, (float) w[ip] / (float) w[i]));</span>
<span class="fc" id="L282">                    uv = new PairInt(ip, i);</span>
<span class="fc" id="L283">                    log.log(logLevel, String.format(&quot;    edge=(%d, %d) w=%.3e&quot;, ip, i, e2));</span>
<span class="fc" id="L284">                    wEdges.put(uv, e2);</span>
                }
<span class="fc" id="L286">            }</span>
            
            //update the total tree weights with current
<span class="fc bfc" id="L289" title="All 2 branches covered.">            for (int ii = 0; ii &lt; w.length; ++ii) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                if (w[ii] &gt; 0) {</span>
<span class="pc bpc" id="L291" title="3 of 4 branches missed.">                    assert(wG[ii] &lt;= w[ii]);</span>
<span class="fc" id="L292">                    wG[ii] = w[ii];</span>
                }
            }
        }
        
<span class="fc" id="L297">        Results results = new Results();</span>
<span class="fc" id="L298">        results.edges = wEdges;</span>
<span class="fc" id="L299">        results.rootIndexes = rootIndexes;</span>
<span class="fc" id="L300">        results.vertexes = members;</span>
<span class="fc" id="L301">        return results;</span>
    }

    /**
     * implementation of unweighted graph edge scoring from Girvan-Newman 
     * algorithm, accepting a directionless graph.   The given source node is
     * the root of the search.  Each graph node without a predecessor
     * is iterated over also to calculate node and edge weights.  
    
    * The directionless method here has a longer runtime complexity than the
    * DAG method because it has to check for leaf nodes as nodes without 
    * links further from source than it is, so this adds an iteration over edges.
     
     * Reference is 2004 Newman and Girvan,
     * &quot;Finding and evaluating community structure in networks&quot;.
     * 
     * The runtime complexity is &lt;em&gt;1 + the number of graph roots (i.e. nodes without predecessors)
     *   times (add here)&lt;/em&gt;.
     * 
     * For more information and other graph scoring and distance algorithms and 
     * cluster finding (a.k.a. community finding) see also
      &lt;pre&gt;
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
     * @param adjacencyList an adjacency list for an unweighted DAG.
     * @param s source node to begin the graph traversal
     * @return scores for the edges of the graph, calculated using the Girvan-Newman algorithm.
     */
    public Results girvanNewmanUndirected(SimpleLinkedListNode[] adjacencyList, final int s) {
        
        //avg O(|E|);  worst: O(|V| + |E|)
<span class="fc" id="L346">        int[] rootIndexes = findRoots(adjacencyList, s);</span>
        
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (rootIndexes.length == 0) {</span>
<span class="fc" id="L349">            rootIndexes = new int[]{s};</span>
        }
        
<span class="fc" id="L352">        final int nV = adjacencyList.length;</span>
        // init
<span class="fc" id="L354">        final int[] d = new int[nV];</span>
<span class="fc" id="L355">        final int[] dBest = new int[nV];</span>
<span class="fc" id="L356">        Arrays.fill(dBest, Integer.MAX_VALUE);</span>
        
        // holds parents of index.  e.g. for root node 0, p[0] is empty.
<span class="fc" id="L359">        final TIntList[] p = new TIntList[nV];</span>
<span class="fc" id="L360">        final int[] color = new int[nV];</span>
        
        // index is vertex index
<span class="fc" id="L363">        final int[] w = new int[nV];</span>
<span class="fc" id="L364">        final int[] wG = new int[nV];</span>
        
        // key = edge vertexes (u, v) where u is closer to the root, value = edge weight
<span class="fc" id="L367">        final TObjectFloatMap&lt;PairInt&gt; wEdges = new TObjectFloatHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L369">        final TIntSet members = new TIntHashSet();</span>
        
        // runtime is # of roots * O(|V| + |E|)
        
<span class="fc bfc" id="L373" title="All 2 branches covered.">        for (int src : rootIndexes) {</span>
        
<span class="fc" id="L375">            Arrays.fill(w, 0);</span>
<span class="fc" id="L376">            Arrays.fill(color, 0);</span>
<span class="fc" id="L377">            Arrays.fill(d, Integer.MAX_VALUE);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            for (int i = 0; i &lt; nV; ++i) {</span>
<span class="fc" id="L379">                p[i] = new TIntArrayList();</span>
            }
            
<span class="fc" id="L382">            color[src] = 1;</span>
<span class="fc" id="L383">            d[src] = 0;</span>
<span class="fc" id="L384">            dBest[src] = 0;</span>
<span class="fc" id="L385">            w[src] = 1;</span>
            
<span class="fc" id="L387">            log.log(logLevel, &quot;root=&quot; + src);</span>
      
            // calc vertex weights
<span class="fc" id="L390">            final TIntList leaf = new TIntArrayList();</span>
<span class="fc" id="L391">            final Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span>
<span class="fc" id="L392">            queue.add(src);</span>
            int u;
            
<span class="fc bfc" id="L395" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
                //log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
                //log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
                //log.log(logLevel, &quot;dBest=&quot; + Arrays.toString(dBest));
                //log.log(logLevel, &quot;color=&quot; + Arrays.toString(color));
<span class="fc" id="L400">                u = queue.remove().intValue();</span>
<span class="fc" id="L401">                members.add(u);</span>
<span class="fc" id="L402">                log.log(logLevel, String.format(&quot;u=%d\n&quot;, u));</span>
<span class="fc" id="L403">                SimpleLinkedListNode vNode = adjacencyList[u];</span>
                // for adjacencyLists that are directionless, edges from u to v and v to u exist,
                // so need to make one additional check for a pseudo-leaf:
                //     a pseudo-leaf has no descendants that are not also predecessors.
<span class="fc" id="L407">                boolean isALeafNode = isALeafNode(u, adjacencyList, d);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                if (isALeafNode) {</span>
<span class="fc" id="L409">                    leaf.add(u);</span>
<span class="fc" id="L410">                    color[u] = 2;</span>
<span class="fc" id="L411">                    log.log(logLevel, &quot;    LEAF\n&quot;);</span>
<span class="fc" id="L412">                    continue;</span>
                }
<span class="pc bpc" id="L414" title="1 of 4 branches missed.">                while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L415">                    int v = vNode.getKey();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                    if (color[v] == 0) {</span>
<span class="fc" id="L417">                        color[v] = 1;</span>
<span class="fc" id="L418">                        d[v] = d[u] + 1;</span>
<span class="fc" id="L419">                        w[v] = w[u];</span>
<span class="fc" id="L420">                        queue.add(v);</span>
<span class="fc" id="L421">                        log.log(logLevel, String.format(&quot;  v=%d\n&quot;, v));</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                        if (d[v] &lt; dBest[v]) {</span>
<span class="fc" id="L423">                            dBest[v] = d[v];</span>
                        }
<span class="fc bfc" id="L425" title="All 2 branches covered.">                    } else if (d[v] == (d[u] + 1)) {</span>
<span class="fc" id="L426">                        w[v] += w[u];</span>
                    }
<span class="fc bfc" id="L428" title="All 2 branches covered.">                    if (d[u] &lt; d[v]) {</span>
<span class="fc" id="L429">                        log.log(logLevel, String.format(&quot;adding parent=%d of node=%d (d[%d]=%d, d[%d]=%d])\n&quot;,</span>
<span class="fc" id="L430">                            u, v, u, d[u], v, d[v]));</span>
<span class="fc" id="L431">                        p[v].add(u);</span>
                    }
<span class="fc" id="L433">                    vNode = vNode.getNext();</span>
<span class="fc" id="L434">                }</span>
<span class="fc" id="L435">                color[u] = 2;</span>
<span class="fc" id="L436">            }</span>
<span class="pc bpc" id="L437" title="3 of 4 branches missed.">            assert(queue.isEmpty());</span>
         
            //add weights from previous root traversals
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (rootIndexes.length &gt; 1) {</span>
            //    log.log(logLevel, &quot;\n  w=&quot; + Arrays.toString(w));
<span class="nc bnc" id="L442" title="All 2 branches missed.">                for (int i = 0; i &lt; w.length; ++i) {</span>
<span class="nc" id="L443">                    w[i] += wG[i];</span>
                }
            //    log.log(logLevel, &quot;  wG=&quot; + Arrays.toString(wG));
            //    log.log(logLevel, &quot;-&gt;w=&quot; + Arrays.toString(w));
            }        
            
            // calc edge weights
<span class="fc" id="L450">            TIntSet enqd = new TIntHashSet();</span>
            float e;
<span class="fc" id="L452">            TIntIterator tIter = leaf.iterator();</span>
            int t, i, ip;
            TIntIterator pIter;
            PairInt uv;
<span class="fc bfc" id="L456" title="All 2 branches covered.">            while (tIter.hasNext()) {</span>
<span class="fc" id="L457">                t = tIter.next();</span>
<span class="fc" id="L458">                log.log(logLevel, String.format(&quot;t leaf=%d\n&quot;, t));</span>
<span class="fc" id="L459">                pIter = p[t].iterator();</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L461">                    i = pIter.next();</span>
<span class="fc" id="L462">                    log.log(logLevel, String.format(&quot;  p=%d\n&quot;, i));</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                    if (!enqd.contains(i)) {</span>
<span class="fc" id="L464">                        queue.add(i);</span>
<span class="fc" id="L465">                        enqd.add(i);</span>
                    }
<span class="fc" id="L467">                    e = (float) w[i] / (float) w[t];</span>
<span class="pc bpc" id="L468" title="3 of 4 branches missed.">                    assert(d[i] &lt; d[t]);</span>
<span class="fc" id="L469">                    uv = new PairInt(i, t);</span>
<span class="fc" id="L470">                    wEdges.put(uv, e);</span>
<span class="fc" id="L471">                    log.log(logLevel, String.format(&quot;  edge=(%d, %d) w=%.3e\n&quot;, i, t, e));</span>
                }
            }
          //  log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
          //  log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
          //  log.log(logLevel, &quot;q=&quot;+ queue.toString());
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            if (logLevel.equals(Level.INFO)) {</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                for (int iv=0; iv&lt;nV;++iv) {</span>
<span class="nc" id="L479">                    TIntList ps = p[iv];</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                    if (!ps.isEmpty()) {</span>
<span class="nc" id="L481">                        log.log(logLevel, String.format(&quot;   *p[%d]=%s&quot;, iv, ps.toString()));</span>
                    }
                }
            }
            float e2;
            PairInt ij;
<span class="fc bfc" id="L487" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
<span class="fc" id="L488">                i = queue.remove().intValue();</span>
<span class="fc" id="L489">                e = 1;</span>
<span class="fc" id="L490">                log.log(logLevel, String.format(&quot;  e0[%d]=%.3f&quot;, i, e));</span>
<span class="fc" id="L491">                SimpleLinkedListNode jNode = adjacencyList[i];</span>
<span class="pc bpc" id="L492" title="1 of 4 branches missed.">                while (jNode != null &amp;&amp; jNode.getKey() != -1) {</span>
<span class="fc" id="L493">                    int j = jNode.getKey();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                    if (d[i] &lt; d[j]) {</span>
<span class="fc" id="L495">                        ij = new PairInt(i, j);</span>
<span class="pc bpc" id="L496" title="3 of 4 branches missed.">                        assert (d[i] &lt; d[j]);</span>
<span class="pc bpc" id="L497" title="3 of 4 branches missed.">                        assert (wEdges.containsKey(ij));</span>
<span class="fc" id="L498">                        e += wEdges.get(ij);</span>
<span class="fc" id="L499">                        log.log(logLevel, String.format(&quot;  + (w[%d]/w[%d]=%.3f)&quot;, i, j, wEdges.get(ij)));</span>
                    }
<span class="fc" id="L501">                    jNode = jNode.getNext();</span>
<span class="fc" id="L502">                }</span>
<span class="fc" id="L503">                log.log(logLevel, String.format(&quot;  \n   =&gt;%.3f\n&quot;, e));</span>

<span class="fc" id="L505">                pIter = p[i].iterator();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L507">                    ip = pIter.next();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                    if (!enqd.contains(ip)) {</span>
<span class="fc" id="L509">                        queue.add(ip);</span>
<span class="fc" id="L510">                        enqd.add(ip);</span>
                    }
<span class="fc" id="L512">                    log.log(logLevel, String.format(&quot;  parent=d[%d]=%d,  child=d[%d]=%d\n&quot;, </span>
<span class="fc" id="L513">                        ip, d[ip], i, d[i]));</span>
<span class="pc bpc" id="L514" title="3 of 4 branches missed.">                    assert(d[ip] &lt; d[i]);</span>
<span class="fc" id="L515">                    e2 = (float) w[ip] / (float) w[i];</span>
<span class="fc" id="L516">                    e2 *= e;</span>
<span class="fc" id="L517">                    log.log(logLevel, String.format(&quot;    e=(%.3f)*(w[%d]/w[%d]=%.3f)\n&quot;, e, ip, i, (float) w[ip] / (float) w[i]));</span>
<span class="fc" id="L518">                    uv = new PairInt(ip, i);</span>
<span class="fc" id="L519">                    log.log(logLevel, String.format(&quot;    edge=(%d, %d) w=%.3e\n&quot;, ip, i, e2));</span>
<span class="fc" id="L520">                    wEdges.put(uv, e2);</span>
                }
<span class="fc" id="L522">            }</span>
            
            //update the total tree weights with current
<span class="fc bfc" id="L525" title="All 2 branches covered.">            for (int ii = 0; ii &lt; w.length; ++ii) {</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                if (w[ii] &gt; 0) {</span>
<span class="pc bpc" id="L527" title="3 of 4 branches missed.">                    assert(wG[ii] &lt;= w[ii]);</span>
<span class="fc" id="L528">                    wG[ii] = w[ii];</span>
                }
            }
        }
        
<span class="fc" id="L533">        Results results = new Results();</span>
<span class="fc" id="L534">        results.edges = wEdges;</span>
<span class="fc" id="L535">        results.rootIndexes = rootIndexes;</span>
<span class="fc" id="L536">        results.vertexes = members;</span>
<span class="fc" id="L537">        return results;</span>
    }
    
    private int[] findRoots(SimpleLinkedListNode[] adjacencyList, int s) {
         
        // walk all nodes in graph to get the predecessor nodes
        //   using DFS
<span class="fc" id="L544">        DFS dfs = new DFS(adjacencyList);</span>
<span class="fc" id="L545">        dfs.walk();</span>
        
<span class="fc" id="L547">        int[] p = dfs.getPredecessorIndexes();</span>
<span class="fc" id="L548">        int nRoots = 0;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (int i = 0; i &lt; p.length; ++i) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (p[i] == -1) {</span>
<span class="fc" id="L551">                nRoots++;</span>
            }
        }
<span class="fc" id="L554">        int[] roots = new int[nRoots];</span>
<span class="fc" id="L555">        nRoots = 0;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (int i = 0; i &lt; p.length; ++i) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            if (p[i] == -1) {</span>
<span class="fc" id="L558">                roots[nRoots] = i;</span>
<span class="fc" id="L559">                nRoots++;</span>
            }
        }
<span class="fc" id="L562">        return roots;</span>
    }

    private boolean isALeafNode(int u, SimpleLinkedListNode[] adjacencyList,
        int[] d) {
        
        // for directionless graphs, presumably the input adjacency list has been
        // created such that all U-&gt;V edges have V-&gt;U edges. 
        // Looking for the equivalent of a leaf w.r.t. a source node:
        //    would expect no u-&gt; pairs where d[u] &lt; d[v].
        
        //Set&lt;PairInt&gt; uvs = new HashSet&lt;PairInt&gt;();
<span class="fc" id="L574">        SimpleLinkedListNode vNode = adjacencyList[u];</span>
<span class="pc bpc" id="L575" title="1 of 4 branches missed.">        while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L576">            int v = vNode.getKey();</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (d[v] &gt; d[u]) {</span>
<span class="fc" id="L578">                return false;</span>
            }
<span class="fc" id="L580">            vNode = vNode.getNext();</span>
<span class="fc" id="L581">        }</span>
<span class="fc" id="L582">        return true;</span>
    }

    /*private void print(SimpleLinkedListNode[] adjacencyList) {
        
        StringBuffer sb = new StringBuffer();
        
        for (int u = 0; u &lt; adjacencyList.length; ++u) {
            sb.append(String.format(&quot;u=%d v=[&quot;, u));
            SimpleLinkedListNode vNode = adjacencyList[u];

            while (vNode != null &amp;&amp; vNode.getKey() != -1) {
                int v = vNode.getKey();
                sb.append(String.format(&quot;%d, &quot;, v));
                vNode = vNode.getNext();
            }
            sb.append(String.format(&quot;]\n&quot;));
        }
        System.out.println(sb.toString());
    }*/
    
    public static class Results {
        
        private TObjectFloatMap&lt;PairInt&gt; edges = null;
        
        private int[] rootIndexes = null;
        
        private TIntSet vertexes = null;
       
        /**
         * @return the betweenness scores for the edges
         */
        public TObjectFloatMap&lt;PairInt&gt; getEdges() {
            return edges;
        }

        /**
         * @return the src
         */
        public int[] getRootIndexes() {
            return rootIndexes;
        }

        /**
         * @return the vertexes visited by the algorithm.  any vertex given
         * to algorithm that was not connected to source s is not present in this.
         */
        public TIntSet getVertexes() {
            return vertexes;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;root indexes=&quot;);
            if (rootIndexes != null) {
                sb.append(Arrays.toString(rootIndexes));
            }
            sb.append(&quot;\nedges=&quot;);
            if (edges != null) {
                TObjectFloatIterator&lt;PairInt&gt; iter = edges.iterator();
                for (int i = 0; i &lt; edges.size(); ++i) {
                    iter.advance();
                    PairInt e = iter.key();
                    float w = iter.value();
                    sb.append(String.format(&quot;\n  (%d,%d)=%.3e&quot;, e.getX(), e.getY(), w));
                }
            }
            sb.append(&quot;\nvertex indexes=&quot;);
            if (vertexes != null) {
                sb.append(Arrays.toString(vertexes.toArray()));
            }
            return sb.toString();
        }
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>