<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VoronoiFortunesSweep.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.voronoi</a> &gt; <span class="el_source">VoronoiFortunesSweep.java</span></div><h1>VoronoiFortunesSweep.java</h1><pre class="source lang-java linenums">package thirdparty.voronoi;

import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PolygonAndPointPlotter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;

/**
 * A voronoi diagram is a partitioning of points
 * into cells defined by seed centers.  The cells
 * edges are defined as perpendicular bisectors
 * between 2 seeds, which results in the cells 
 * being regions which are closer to the seed
 * point than to any other seed point.
 * 
 * The sweep line algorithm runtime complexity
 * is  O(n log n).
 * 
  adapted from the following codes:
 
   a port to java of the C++ port of
 * Steven Fortune's original c code.
 * The C++ port by Shane O' Sullivan is at 
 * http://skynet.ie/~sos/mapviewer/voronoi.php
 * and uses a liberal AT&amp;T license.
 * Then 2 ports to java.  
 * https://sourceforge.net/projects/simplevoronoi/postdownload?source=dlp
 * All have liberal licenses listed here.
 
 * The author of this software is Steven Fortune.  Copyright (c) 1994 by AT&amp;T
 * Bell Laboratories.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 
 * This code was originally written by Stephan Fortune in C code.  I, Shane O'Sullivan,
 * have since modified it, encapsulating it in a C++ class and, fixing memory leaks and
 * adding accessors to the Voronoi Edges.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  
 * Java Version by Zhenyu Pan
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 * 
 * in this project:
 * changes to the above java port are essentially 
 * to the comparator and sorting, and an extra check for
 * zero length edges at the end of the method clipLine.
 * Format changes such as camel case are present 
 * here.  Also moved the data classes to inner classes
 * here, and am using specialized classes that already
 * existed in this project such as the PairFloat for 
 * coordinates.
 * 
 * first adapted in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

 */
public class VoronoiFortunesSweep {
    
<span class="fc" id="L88">    private static int LE = 0;</span>
<span class="fc" id="L89">    private static int RE = 1;</span>

<span class="fc" id="L91">    private HalfEdge ELleftend = null;</span>
<span class="fc" id="L92">    private HalfEdge ELrightend = null;</span>
    private int ELhashsize;
    private float xmin, xmax, ymin, ymax, deltax, deltay;

<span class="fc" id="L96">    private Site[] sites = null;</span>
<span class="fc" id="L97">    private int nSites = 0;</span>
<span class="fc" id="L98">    private int siteIdx = 0;</span>
    private int sqrtNSites;
<span class="fc" id="L100">    private int nVertices = 0;</span>
<span class="fc" id="L101">    private int nEdges = 0;</span>
    
    private Site bottomsite;
	
    private int	PQcount;
    private int	PQmin;
    private int PQhashsize;
    private HalfEdge[] PQhash;

    private float borderMinX, borderMaxX, borderMinY, borderMaxY;

<span class="fc" id="L112">    private LinkedList&lt;GraphEdge&gt; allEdges = null;</span>

<span class="fc" id="L114">    private float minDistanceBetweenSites = 0;</span>
    
<span class="fc" id="L116">    private HalfEdge[] ELhash = null;</span>
    
<span class="fc" id="L118">    public VoronoiFortunesSweep() {</span>
<span class="fc" id="L119">        allEdges = new LinkedList&lt;GraphEdge&gt;();</span>
<span class="fc" id="L120">    }</span>
    
    public LinkedList&lt;GraphEdge&gt; getAllEdges() {
<span class="fc" id="L123">        return allEdges;</span>
    }
    
    public boolean generateVoronoi(
        float[] xValues, float[] yValues, float minX, float maxX, 
        float minY, float maxY, float minDist) {
        
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (xValues.length != yValues.length) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must be same length&quot;);
        }
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (xValues.length == 0) {</span>
<span class="nc" id="L135">             throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must not be empty&quot;);
        }

<span class="fc" id="L139">        minDistanceBetweenSites = minDist;</span>
    
<span class="fc" id="L141">        siteIdx = 0;</span>
<span class="fc" id="L142">        nSites = xValues.length;</span>
<span class="fc" id="L143">        nVertices = 0;</span>
<span class="fc" id="L144">        nEdges = 0;</span>
<span class="fc" id="L145">        double sn = (double) nSites + 4;</span>
<span class="fc" id="L146">        sqrtNSites = (int) Math.sqrt(sn);</span>

<span class="fc" id="L148">        sites = new Site[nSites];</span>

<span class="fc" id="L150">        xmin = Float.MAX_VALUE;</span>
<span class="fc" id="L151">        ymin = Float.MAX_VALUE;</span>
<span class="fc" id="L152">        xmax = Float.MIN_VALUE;</span>
<span class="fc" id="L153">        ymax = Float.MIN_VALUE;</span>
        
        int i;
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for(i = 0; i &lt; nSites; i++) {</span>
<span class="fc" id="L157">            sites[i] = new Site();</span>
<span class="fc" id="L158">            sites[i].coord = new PairFloat(xValues[i], yValues[i]);</span>
            // this gets reset after sort:
<span class="fc" id="L160">            sites[i].sitenbr = i;</span>
<span class="fc" id="L161">            sites[i].refcnt = 0;</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (xValues[i] &lt; xmin) {</span>
<span class="fc" id="L164">                xmin = xValues[i];</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            } else if (xValues[i] &gt; xmax) {</span>
<span class="fc" id="L166">                xmax = xValues[i];</span>
            }
            
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (yValues[i] &lt; ymin) {</span>
<span class="fc" id="L170">                ymin = yValues[i];</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            } else if (yValues[i] &gt; ymax) {</span>
<span class="fc" id="L172">                ymax = yValues[i];</span>
            }
            
            //printf(&quot;\n%f %f\n&quot;,xValues[i],yValues[i]);
        }
        
        // N log_2 N
<span class="fc" id="L179">        qsort(sites);</span>
        
        // renumber site numbers
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int ii = 0; ii &lt; sites.length; ++ii) {</span>
<span class="fc" id="L183">            sites[ii].sitenbr = ii;</span>
        }
        
<span class="fc" id="L186">        float temp = 0;</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (minX &gt; maxX) {</span>
<span class="nc" id="L188">            temp = minX;</span>
<span class="nc" id="L189">            minX = maxX;</span>
<span class="nc" id="L190">            maxX = temp;</span>
        }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (minY &gt; maxY) {</span>
<span class="nc" id="L193">            temp = minY;</span>
<span class="nc" id="L194">            minY = maxY;</span>
<span class="nc" id="L195">            maxY = temp;</span>
        }
<span class="fc" id="L197">        borderMinX = minX;</span>
<span class="fc" id="L198">        borderMinY = minY;</span>
<span class="fc" id="L199">        borderMaxX = maxX;</span>
<span class="fc" id="L200">        borderMaxY = maxY;</span>
        
<span class="fc" id="L202">        deltay = ymax - ymin;</span>
<span class="fc" id="L203">        deltax = xmax - xmin;</span>
        
<span class="fc" id="L205">        return voronoi();        </span>
    }
    
    /*
       implicit parameters: nsites, sqrt_nsites, 
       xmin, xmax, ymin, ymax, deltax,
       deltay (can all be estimates). 
       Performance suffers if they are wrong;
       better to make nsites, deltax, 
       and deltay too big than too small. (?)
     */
    private boolean voronoi() {
        
        Site newsite, bot, top, temp, p;
        Site v;
<span class="fc" id="L220">        PairFloat newintstar = null;</span>
        int pm;
        HalfEdge lbnd, rbnd, llbnd, rrbnd, bisector;
        Edge e;

<span class="fc" id="L225">        PQInitialize();</span>
<span class="fc" id="L226">        ELInitialize();</span>

<span class="fc" id="L228">        bottomsite = nextOne();</span>
<span class="fc" id="L229">        newsite = nextOne();</span>
        
        while (true) {
            
<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (!PQEmpty()) {</span>
<span class="fc" id="L234">                newintstar = PQMin();</span>
            }
            
            // if the lowest site has a smaller y value than 
            // the lowest vector intersection,
            // process the site otherwise process the vector 
            // intersection

<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (newsite != null</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            &amp;&amp; (PQEmpty() || </span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                newsite.coord.getY() &lt; newintstar.getY() || </span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                (newsite.coord.getY() == newintstar.getY() &amp;&amp; </span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                newsite.coord.getX() &lt; newintstar.getX()))) {</span>
                
                // new site is smallest -this is a site event
                         
                // get the first HalfEdge to the LEFT of the new site
<span class="fc" id="L251">                lbnd = ELLeftBnd((newsite.coord));</span>
                
                // get the first HalfEdge to the RIGHT of the new site
<span class="fc" id="L254">                rbnd = lbnd.ELright;</span>
                
                // if this halfedge has no edge,bot =bottom site 
<span class="fc" id="L257">                bot = rightReg(lbnd);</span>
                
                // create a new edge that bisects
<span class="fc" id="L260">                e = bisect(bot, newsite);</span>

                // create a new HalfEdge, setting its ELpm field to 0
<span class="fc" id="L263">                bisector = HECreate(e, LE);</span>
                
                // insert this new bisector edge between the left 
                // and right vectors in a linked list
<span class="fc" id="L267">                ELInsert(lbnd, bisector);</span>

                // if the new bisector intersects with the left edge,
                // remove the left edge's vertex, and put in the new one
<span class="fc bfc" id="L271" title="All 2 branches covered.">                if ((p = intersect(lbnd, bisector)) != null) {</span>
<span class="fc" id="L272">                    PQDelete(lbnd);</span>
<span class="fc" id="L273">                    PQInsert(lbnd, p, dist(p, newsite));</span>
                }
<span class="fc" id="L275">                lbnd = bisector;</span>
                
                // create a new HalfEdge, setting its ELpm field to 1
<span class="fc" id="L278">                bisector = HECreate(e, RE);</span>
                 
                // insert the new HE to the right of the original bisector
                // earlier in the IF stmt
<span class="fc" id="L282">                ELInsert(lbnd, bisector);</span>
                
                // if this new bisector intersects with the new HalfEdge
<span class="fc bfc" id="L285" title="All 2 branches covered.">                if ((p = intersect(bisector, rbnd)) != null) {</span>
                    // push the HE into the ordered linked list of vertices
<span class="fc" id="L287">                    PQInsert(bisector, p, dist(p, newsite));</span>
                }
                
                /*System.out.println(
                &quot;  &quot; + bot.sitenbr + &quot; bot=&quot; 
                + sites[bot.sitenbr].coord
                + &quot;  &quot; + newsite.sitenbr + &quot; top=&quot; 
                + sites[newsite.sitenbr].coord);
                */
                
<span class="fc" id="L297">                newsite = nextOne();</span>
                
<span class="fc bfc" id="L299" title="All 2 branches covered.">            } else if (!PQEmpty()) {</span>
            
                // intersection is smallest - this is a vector event
            
                // pop the HalfEdge with the lowest vector off the ordered list
                // of vectors
<span class="fc" id="L305">                lbnd = PQExtractMin();</span>
                
                // get the HalfEdge to the left of the above HE
<span class="fc" id="L308">                llbnd = lbnd.ELleft;</span>
                
                // get the HalfEdge to the right of the above HE
<span class="fc" id="L311">                rbnd = lbnd.ELright;</span>
                
                // get the HalfEdge to the right of the HE to the right of the
                // lowest HE
<span class="fc" id="L315">                rrbnd = rbnd.ELright;</span>
                
                // get the Site to the left of the left HE which it bisects
<span class="fc" id="L318">                bot = leftReg(lbnd);</span>
                
                // get the Site to the right of the right HE which it bisects
<span class="fc" id="L321">                top = rightReg(rbnd);</span>

                // get the vertex that caused this event
<span class="fc" id="L324">                v = lbnd.vertex;</span>
                
                // set the vertex number - couldn't do this
<span class="fc" id="L327">                makeVertex(v);</span>
                
                // earlier since we didn't know when it would be processed
<span class="fc" id="L330">                endPoint(lbnd.ELedge, lbnd.ELpm, v);</span>
                
                // set the endpoint of
                // the left HalfEdge to be this vector
<span class="fc" id="L334">                endPoint(rbnd.ELedge, rbnd.ELpm, v);</span>
                
                // set the endpoint of the right HalfEdge to
                // be this vector
<span class="fc" id="L338">                ELDelete(lbnd); // mark the lowest HE for</span>
                
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
<span class="fc" id="L342">                PQDelete(rbnd);</span>
                
                // remove all vertex events to do with the right HE
<span class="fc" id="L345">                ELDelete(rbnd); </span>
                
                // mark the right HE for
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
                
                // set the pm variable to zero
<span class="fc" id="L352">                pm = LE;</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (bot.coord.getY() &gt; top.coord.getY()) {</span>
                    // if the site to the left of the event is 
                    // higher than the Site
                    // to the right of it, then swap them and 
                    // set the 'pm' variable to 1
<span class="fc" id="L359">                    temp = bot;</span>
<span class="fc" id="L360">                    bot = top;</span>
<span class="fc" id="L361">                    top = temp;</span>
<span class="fc" id="L362">                    pm = RE;</span>
                }
                
                // create an Edge (or line)
                // that is between the two Sites. This creates the formula of
                // the line, and assigns a line number to it
<span class="fc" id="L368">                e = bisect(bot, top); </span>
                
                // create a HE from the Edge 'e',
                // and make it point to that edge
                // with its ELedge field
<span class="fc" id="L373">                bisector = HECreate(e, pm); </span>
                
                // insert the new bisector to the
                // right of the left HE
<span class="fc" id="L377">                ELInsert(llbnd, bisector);               </span>
                
                // set one endpoint to the new edge
                // to be the vector point 'v'.
                // If the site to the left of this bisector is higher than the
                // right Site, then this endpoint
                // is put in position 0; otherwise in pos 1
<span class="fc" id="L384">                endPoint(e, RE - pm, v);</span>
                
                // if left HE and the new bisector intersect, then delete
                // the left HE, and reinsert it
<span class="fc bfc" id="L388" title="All 2 branches covered.">                if ((p = intersect(llbnd, bisector)) != null) {</span>
<span class="fc" id="L389">                    PQDelete(llbnd);</span>
<span class="fc" id="L390">                    PQInsert(llbnd, p, dist(p, bot));</span>
                }

                // if right HE and the new bisector intersect, then
                // reinsert it
<span class="fc bfc" id="L395" title="All 2 branches covered.">                if ((p = intersect(bisector, rrbnd)) != null) {</span>
<span class="fc" id="L396">                    PQInsert(bisector, p, dist(p, bot));</span>
                }
            } else {
                break;
            }
        }

<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (lbnd = ELleftend.ELright; lbnd != ELrightend; </span>
<span class="fc" id="L404">            lbnd = lbnd.ELright) {</span>
            
<span class="fc" id="L406">            e = lbnd.ELedge;</span>
<span class="fc" id="L407">            clipLine(e);</span>
        }

<span class="fc" id="L410">        return true;</span>
    }

    public void plot(int fileNumber) {
        
        try {
            
<span class="nc" id="L417">            PolygonAndPointPlotter plotter =</span>
                new PolygonAndPointPlotter(xmin - 1, xmax + 1,
                    ymin - 1, ymax + 1);
        
<span class="nc" id="L421">            LinkedList&lt;GraphEdge&gt; edges = getAllEdges();</span>
<span class="nc" id="L422">            int n = 2*edges.size();</span>
<span class="nc" id="L423">            float[] xPolygon = new float[n];</span>
<span class="nc" id="L424">            float[] yPolygon = new float[n];</span>

<span class="nc" id="L426">            int count = 0;                </span>
        
<span class="nc bnc" id="L428" title="All 2 branches missed.">            for (GraphEdge edge : edges) {</span>
<span class="nc" id="L429">                int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L430">                int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L431">                int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L432">                int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L434">                PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L435">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (p1.equals(p2)) {</span>
<span class="nc" id="L437">                    continue;</span>
                }

<span class="nc" id="L440">                float xp = p1.getX();</span>
<span class="nc" id="L441">                float yp = p1.getY();</span>
<span class="nc" id="L442">                xPolygon[count] = xp;</span>
<span class="nc" id="L443">                yPolygon[count] = yp;</span>
<span class="nc" id="L444">                count++;</span>
                
<span class="nc" id="L446">                xp = p2.getX();</span>
<span class="nc" id="L447">                yp = p2.getY();</span>
<span class="nc" id="L448">                xPolygon[count] = xp;</span>
<span class="nc" id="L449">                yPolygon[count] = yp;</span>
<span class="nc" id="L450">                count++;</span>
<span class="nc" id="L451">            }</span>
            
<span class="nc" id="L453">            xPolygon = Arrays.copyOf(xPolygon, count);</span>
<span class="nc" id="L454">            yPolygon = Arrays.copyOf(yPolygon, count);</span>
            
<span class="nc" id="L456">            n = sites.length;</span>
<span class="nc" id="L457">            float[] x = new float[n];</span>
<span class="nc" id="L458">            float[] y = new float[n];</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L460">                Site site = sites[i];</span>
<span class="nc" id="L461">                x[i] = site.coord.getX();</span>
<span class="nc" id="L462">                y[i] = site.coord.getY();</span>
            }
            
<span class="nc" id="L465">            plotter.addPlotWithLines(x, y, xPolygon, yPolygon,</span>
                &quot;edges&quot;);
            
<span class="nc" id="L468">            plotter.writeFile(fileNumber);</span>
            
<span class="nc" id="L470">        } catch(IOException e) {</span>
<span class="nc" id="L471">            System.err.println(e.getMessage());</span>
<span class="nc" id="L472">        }</span>
<span class="nc" id="L473">    }</span>

    private class SiteComp implements Comparator&lt;Site&gt; {
        @Override
        public int compare(Site o1, Site o2) {
            if (o1.coord.getY() &lt; o2.coord.getY()) {
                return -1;
            } else if (o1.coord.getY() &gt; o2.coord.getY()) {
                return 1;
            } else if (o1.coord.getX() &lt; o2.coord.getX()) {
                return -1;
            } else if (o1.coord.getX() &gt; o2.coord.getX()) {
                return 1;
            }
            return 0;
        }
    }

    private void qsort(Site[] sites) {
<span class="fc" id="L492">        SiteComp comp = new SiteComp();</span>
<span class="fc" id="L493">        Arrays.sort(sites, comp);</span>
<span class="fc" id="L494">    }</span>
    
    public class Site {
        PairFloat coord;
        int	sitenbr;
	    int	refcnt;
        public PairFloat getCoord() {
            return coord;
        }
    }

    private class Edge {
        float a = 0;
        float b = 0;
        float c = 0;
	    Site[] ep = new Site[2];
	    Site[] reg = new Site[2];
	    int edgenbr;
    }
    
    public class GraphEdge {
        public float x1, y1, x2, y2;
	    public int site1;
        public int site2;
    }
     
    private class HalfEdge {
	    HalfEdge ELleft = null; 
        HalfEdge ELright = null;
	    Edge ELedge = null;
        boolean deleted;
	    int ELpm;
	    Site vertex = null;
	    float ystar;
	    HalfEdge PQnext = null;
    }

    // return a single in-storage site
    private Site nextOne() {
        Site s;
<span class="fc bfc" id="L534" title="All 2 branches covered.">        if (siteIdx &lt; nSites) {</span>
<span class="fc" id="L535">            s = sites[siteIdx];</span>
<span class="fc" id="L536">            siteIdx += 1;</span>
<span class="fc" id="L537">            return (s);</span>
        } else {
<span class="fc" id="L539">            return (null);</span>
        }
    }

    private Edge bisect(Site s1, Site s2) {
        float dx, dy, adx, ady;
        Edge newEdge;

<span class="fc" id="L547">        newEdge = new Edge();</span>

        // store the sites that this edge is bisecting
<span class="fc" id="L550">        newEdge.reg[0] = s1;</span>
<span class="fc" id="L551">        newEdge.reg[1] = s2;</span>
        // to begin with, there are no endpoints on the bisector - it goes to
        // infinity
<span class="fc" id="L554">        newEdge.ep[0] = null;</span>
<span class="fc" id="L555">        newEdge.ep[1] = null;</span>

        // get the difference in x dist between the sites
<span class="fc" id="L558">        dx = s2.coord.getX() - s1.coord.getX();</span>
<span class="fc" id="L559">        dy = s2.coord.getY() - s1.coord.getY();</span>
    
        // make sure that the difference in positive
<span class="fc bfc" id="L562" title="All 2 branches covered.">        adx = dx &gt; 0 ? dx : -dx;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        ady = dy &gt; 0 ? dy : -dy;</span>
        
        // get the slope of the line
<span class="fc" id="L566">        newEdge.c = </span>
<span class="fc" id="L567">            (s1.coord.getX() * dx + s1.coord.getY() </span>
                * dy + (dx * dx + dy
                * dy) * 0.5f);

<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (adx &gt; ady) {</span>
            // set formula of line, with x fixed to 1
<span class="fc" id="L573">            newEdge.a = 1.0f;</span>
<span class="fc" id="L574">            newEdge.b = dy / dx;</span>
<span class="fc" id="L575">            newEdge.c /= dx;</span>
        } else {
            // set formula of line, with y fixed to 1
<span class="fc" id="L578">            newEdge.b = 1.0f;</span>
<span class="fc" id="L579">            newEdge.a = dx / dy;</span>
<span class="fc" id="L580">            newEdge.c /= dy;</span>
        }

<span class="fc" id="L583">        newEdge.edgenbr = nEdges;</span>

<span class="fc" id="L585">        nEdges += 1;</span>
        
<span class="fc" id="L587">        return newEdge;</span>
    }
    
    public Site[] getSites() {
<span class="fc" id="L591">        return sites;</span>
    }

    private void makeVertex(Site v) {
<span class="fc" id="L595">        v.sitenbr = nVertices;</span>
<span class="fc" id="L596">        nVertices += 1;</span>
<span class="fc" id="L597">    }</span>

    private void PQInitialize() {
<span class="fc" id="L600">        PQcount = 0;</span>
<span class="fc" id="L601">        PQmin = 0;</span>
<span class="fc" id="L602">        PQhashsize = 4 * sqrtNSites;</span>
<span class="fc" id="L603">        PQhash = new HalfEdge[PQhashsize];</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">        for (int i = 0; i &lt; PQhashsize; i += 1) {</span>
<span class="fc" id="L606">            PQhash[i] = new HalfEdge();</span>
        }
<span class="fc" id="L608">    }</span>

    private int PQBucket(HalfEdge he) {
        int bucket;

<span class="fc" id="L613">        bucket = (int) ((he.ystar - ymin) / deltay * PQhashsize);</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L615">            bucket = 0;</span>
        }
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (bucket &gt;= PQhashsize) {</span>
<span class="fc" id="L618">            bucket = PQhashsize - 1;</span>
        }
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (bucket &lt; PQmin) {</span>
<span class="fc" id="L621">            PQmin = bucket;</span>
        }
<span class="fc" id="L623">        return bucket;</span>
    }

    // push the HalfEdge into the ordered linked list of vertices
    private void PQInsert(HalfEdge he, Site v, float offset) {
        
        HalfEdge last;
        HalfEdge next;

<span class="fc" id="L632">        he.vertex = v;</span>
<span class="fc" id="L633">        he.ystar = (v.coord.getY() + offset);</span>
<span class="fc" id="L634">        last = PQhash[PQBucket(he)];</span>
  
        // TODO: for the cases where the number
        //  of items in the linked list is getting
        //  large enough that this is not approx O(1),
        //  could initialize a specialized comparator
        //  with v.coord.getX()
        //  and store the nodes in a java LinkedList in this bin
        //  instead of a linked list
        //  and use Collections.binarySearch and the comparator with
        //  a small scan to find the last node matching
        // the criteria.
<span class="fc bfc" id="L646" title="All 6 branches covered.">        while ((next = last.PQnext) != null</span>
            &amp;&amp; (he.ystar &gt; next.ystar
               || (he.ystar == next.ystar
<span class="fc bfc" id="L649" title="All 2 branches covered.">               &amp;&amp; v.coord.getX() &gt; next.vertex.coord.getX()))) {</span>
<span class="fc" id="L650">            last = next;</span>
        }
<span class="fc" id="L652">        he.PQnext = last.PQnext;</span>
<span class="fc" id="L653">        last.PQnext = he;</span>
<span class="fc" id="L654">        PQcount += 1;</span>
<span class="fc" id="L655">    }</span>

    // remove the HalfEdge from the list of vertices
    private void PQDelete(HalfEdge he) {
        
        HalfEdge last;

<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (he.vertex != null) {</span>
<span class="fc" id="L663">            last = PQhash[PQBucket(he)];</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">            while (last.PQnext != he) {</span>
<span class="fc" id="L665">                last = last.PQnext;</span>
            }

<span class="fc" id="L668">            last.PQnext = he.PQnext;</span>
<span class="fc" id="L669">            PQcount -= 1;</span>
<span class="fc" id="L670">            he.vertex = null;</span>
        }
<span class="fc" id="L672">    }</span>

    private boolean PQEmpty() {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        return (PQcount == 0);</span>
    }

    private PairFloat PQMin() {
        
<span class="fc bfc" id="L680" title="All 2 branches covered.">        while (PQhash[PQmin].PQnext == null) {</span>
<span class="fc" id="L681">            PQmin += 1;</span>
        }
        
<span class="fc" id="L684">        PairFloat answer = new PairFloat(</span>
<span class="fc" id="L685">            PQhash[PQmin].PQnext.vertex.coord.getX(),</span>
            PQhash[PQmin].PQnext.ystar);
        
<span class="fc" id="L688">        return answer;</span>
    }

    private HalfEdge PQExtractMin() {
        HalfEdge curr;

<span class="fc" id="L694">        curr = PQhash[PQmin].PQnext;</span>
<span class="fc" id="L695">        PQhash[PQmin].PQnext = curr.PQnext;</span>
<span class="fc" id="L696">        PQcount -= 1;</span>
<span class="fc" id="L697">        return curr;</span>
    }

    private HalfEdge HECreate(Edge e, int pm) {
        HalfEdge answer;
<span class="fc" id="L702">        answer = new HalfEdge();</span>
<span class="fc" id="L703">        answer.ELedge = e;</span>
<span class="fc" id="L704">        answer.ELpm = pm;</span>
<span class="fc" id="L705">        answer.PQnext = null;</span>
<span class="fc" id="L706">        answer.vertex = null;</span>
<span class="fc" id="L707">        return answer;</span>
    }

    private void ELInitialize() {
        
<span class="fc" id="L712">        ELhashsize = 2 * sqrtNSites;</span>
<span class="fc" id="L713">        ELhash = new HalfEdge[ELhashsize];</span>

<span class="fc" id="L715">        ELleftend = HECreate(null, 0);</span>
<span class="fc" id="L716">        ELrightend = HECreate(null, 0);</span>
        
<span class="fc" id="L718">        ELleftend.ELleft = null;</span>
<span class="fc" id="L719">        ELleftend.ELright = ELrightend;</span>
<span class="fc" id="L720">        ELrightend.ELleft = ELleftend;</span>
<span class="fc" id="L721">        ELrightend.ELright = null;</span>
        
<span class="fc" id="L723">        ELhash[0] = ELleftend;</span>
<span class="fc" id="L724">        ELhash[ELhashsize - 1] = ELrightend;</span>
<span class="fc" id="L725">    }</span>

    private Site leftReg(HalfEdge he) {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (he.ELedge == null) {</span>
<span class="nc" id="L729">            return bottomsite;</span>
        }
<span class="fc bfc" id="L731" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[LE] : </span>
            he.ELedge.reg[RE];
    }

    private void ELInsert(HalfEdge lb, HalfEdge newHe) {
<span class="fc" id="L736">        newHe.ELleft = lb;</span>
<span class="fc" id="L737">        newHe.ELright = lb.ELright;</span>
<span class="fc" id="L738">        (lb.ELright).ELleft = newHe;</span>
<span class="fc" id="L739">        lb.ELright = newHe;</span>
<span class="fc" id="L740">    }</span>

    /*
     * This delete routine can't reclaim node, since pointers from hash table
     * may be present.
     */
    private void ELDelete(HalfEdge he) {
<span class="fc" id="L747">        (he.ELleft).ELright = he.ELright;</span>
<span class="fc" id="L748">        (he.ELright).ELleft = he.ELleft;</span>
<span class="fc" id="L749">        he.deleted = true;</span>
<span class="fc" id="L750">    }</span>

    // Get entry from hash table, pruning any deleted nodes
    private HalfEdge ELGetHash(int b) {
        HalfEdge he;

<span class="pc bpc" id="L756" title="2 of 4 branches missed.">        if (b &lt; 0 || b &gt;= ELhashsize) {</span>
<span class="nc" id="L757">            return null;</span>
        }
<span class="fc" id="L759">        he = ELhash[b];</span>
<span class="fc bfc" id="L760" title="All 4 branches covered.">        if (he == null || !he.deleted) {</span>
<span class="fc" id="L761">            return he;</span>
        }

        // Hash table points to deleted half edge. Patch 
        // as necessary.
<span class="fc" id="L766">        ELhash[b] = null;</span>
        
<span class="fc" id="L768">        return null;</span>
    }

    private HalfEdge ELLeftBnd(PairFloat p) {
        int i, bucket;
        HalfEdge he;

        // Use hash table to get close to desired halfedge
        // use the hash function to find the place in the hash map that this
        // HalfEdge should be
<span class="fc" id="L778">        bucket = (int) ((p.getX() - xmin) / deltax * ELhashsize);</span>

        // make sure that the bucket position in within the range of the hash
        // array
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L783">            bucket = 0;</span>
        }
<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (bucket &gt;= ELhashsize) {</span>
<span class="fc" id="L786">            bucket = ELhashsize - 1;</span>
        }

<span class="fc" id="L789">        he = ELGetHash(bucket);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">        if (he == null) {</span>
            
            //TODO: could improve this with a datastructure
            // that has predecessor and successor
            
            // if the HE isn't found, search backwards and forwards in the hash map
            // for the first non-null entry
        
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">            for (i = 1; i &lt; ELhashsize; i += 1) {</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">                if ((he = ELGetHash(bucket - i)) != null) {</span>
<span class="fc" id="L800">                    break;</span>
                }
<span class="fc bfc" id="L802" title="All 2 branches covered.">                if ((he = ELGetHash(bucket + i)) != null) {</span>
<span class="fc" id="L803">                    break;</span>
                }
            }
        }
        
        // Now search linear list of halfedges for the correct one
<span class="fc bfc" id="L809" title="All 4 branches covered.">        if (he == ELleftend || </span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        (he != ELrightend &amp;&amp; rightOf(he, p))) {</span>
            // keep going right on the list until either the end is reached, or
            // you find the 1st edge which the point isn't to the right of
            do {
<span class="fc" id="L814">                he = he.ELright;</span>
<span class="fc bfc" id="L815" title="All 4 branches covered.">            } while (he != ELrightend &amp;&amp; rightOf(he, p));</span>
<span class="fc" id="L816">            he = he.ELleft;</span>
        } else {
            // if the point is to the left of the HalfEdge, then search left for
            // the HE just to the left of the point
        
            do {
<span class="fc" id="L822">                he = he.ELleft;</span>
<span class="fc bfc" id="L823" title="All 4 branches covered.">            } while (he != ELleftend &amp;&amp; !rightOf(he, p));</span>
        }

        // Update hash table and reference counts
<span class="fc bfc" id="L827" title="All 4 branches covered.">        if (bucket &gt; 0 &amp;&amp; bucket &lt; ELhashsize - 1) {</span>
<span class="fc" id="L828">            ELhash[bucket] = he;</span>
        }
<span class="fc" id="L830">        return he;</span>
    }

    private void pushGraphEdge(Site leftSite, Site rightSite, 
        float x1, float y1, float x2, float y2) {
      
<span class="fc" id="L836">        GraphEdge newEdge = new GraphEdge();</span>
<span class="fc" id="L837">        allEdges.add(newEdge);</span>
<span class="fc" id="L838">        newEdge.x1 = x1;</span>
<span class="fc" id="L839">        newEdge.y1 = y1;</span>
<span class="fc" id="L840">        newEdge.x2 = x2;</span>
<span class="fc" id="L841">        newEdge.y2 = y2;</span>

<span class="fc" id="L843">        newEdge.site1 = leftSite.sitenbr;</span>
<span class="fc" id="L844">        newEdge.site2 = rightSite.sitenbr;</span>
<span class="fc" id="L845">    }</span>

    private void clipLine(Edge e) {
        float pxmin, pxmax, pymin, pymax;
        Site s1, s2;
<span class="fc" id="L850">        float x1 = 0, x2 = 0, y1 = 0, y2 = 0;</span>

<span class="fc" id="L852">        x1 = e.reg[0].coord.getX();</span>
<span class="fc" id="L853">        x2 = e.reg[1].coord.getX();</span>
<span class="fc" id="L854">        y1 = e.reg[0].coord.getY();</span>
<span class="fc" id="L855">        y2 = e.reg[1].coord.getY();</span>

        // if the distance between the two points this line 
        // was created from is
        // less than the square root of 2, then ignore it
<span class="fc bfc" id="L860" title="All 2 branches covered.">        if (Math.sqrt(((x2 - x1) * (x2 - x1)) </span>
            + ((y2 - y1) * (y2 - y1))) &lt; minDistanceBetweenSites) {
<span class="fc" id="L862">            return;</span>
        }
<span class="fc" id="L864">        pxmin = borderMinX;</span>
<span class="fc" id="L865">        pxmax = borderMaxX;</span>
<span class="fc" id="L866">        pymin = borderMinY;</span>
<span class="fc" id="L867">        pymax = borderMaxY;</span>

<span class="fc bfc" id="L869" title="All 4 branches covered.">        if (e.a == 1.0 &amp;&amp; e.b &gt;= 0.0) {</span>
<span class="fc" id="L870">            s1 = e.ep[1];</span>
<span class="fc" id="L871">            s2 = e.ep[0];</span>
        } else {
<span class="fc" id="L873">            s1 = e.ep[0];</span>
<span class="fc" id="L874">            s2 = e.ep[1];</span>
        }

<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L878">            y1 = pymin;</span>
<span class="fc bfc" id="L879" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getY() &gt; pymin) {</span>
<span class="fc" id="L880">                y1 = s1.coord.getY();</span>
            }
<span class="fc bfc" id="L882" title="All 2 branches covered.">            if (y1 &gt; pymax) {</span>
<span class="fc" id="L883">                y1 = pymax;</span>
            }
<span class="fc" id="L885">            x1 = e.c - e.b * y1;</span>
<span class="fc" id="L886">            y2 = pymax;</span>
<span class="fc bfc" id="L887" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getY() &lt; pymax) {</span>
<span class="fc" id="L888">                y2 = s2.coord.getY();</span>
            }

<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (y2 &lt; pymin) {</span>
<span class="fc" id="L892">                y2 = pymin;</span>
            }
<span class="fc" id="L894">            x2 = (e.c) - (e.b) * y2;</span>
<span class="pc bpc" id="L895" title="1 of 10 branches missed.">            if (((x1 &gt; pxmax) &amp; (x2 &gt; pxmax)) | ((x1 &lt; pxmin) &amp; (x2 &lt; pxmin))) {</span>
<span class="nc" id="L896">                return;</span>
            }
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L899">                x1 = pxmax;</span>
<span class="fc" id="L900">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (x1 &lt; pxmin) {</span>
<span class="fc" id="L903">                x1 = pxmin;</span>
<span class="fc" id="L904">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L906" title="All 2 branches covered.">            if (x2 &gt; pxmax) {</span>
<span class="fc" id="L907">                x2 = pxmax;</span>
<span class="fc" id="L908">                y2 = (e.c - x2) / e.b;</span>
            }
<span class="fc bfc" id="L910" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L911">                x2 = pxmin;</span>
<span class="fc" id="L912">                y2 = (e.c - x2) / e.b;</span>
            }
        } else {
<span class="fc" id="L915">            x1 = pxmin;</span>
<span class="fc bfc" id="L916" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getX() &gt; pxmin) {</span>
<span class="fc" id="L917">                x1 = s1.coord.getX();</span>
            }
<span class="fc bfc" id="L919" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L920">                x1 = pxmax;</span>
            }
<span class="fc" id="L922">            y1 = e.c - e.a * x1;</span>
<span class="fc" id="L923">            x2 = pxmax;</span>
<span class="fc bfc" id="L924" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getX() &lt; pxmax) {</span>
<span class="fc" id="L925">                x2 = s2.coord.getX();</span>
            }
<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L928">                x2 = pxmin;</span>
            }
<span class="fc" id="L930">            y2 = e.c - e.a * x2;</span>
<span class="pc bpc" id="L931" title="4 of 10 branches missed.">            if (((y1 &gt; pymax) &amp; (y2 &gt; pymax)) | ((y1 &lt; pymin) &amp; (y2 &lt; pymin))) {</span>
<span class="nc" id="L932">                return;</span>
            }
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (y1 &gt; pymax) {</span>
<span class="nc" id="L935">                y1 = pymax;</span>
<span class="nc" id="L936">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">            if (y1 &lt; pymin) {</span>
<span class="nc" id="L939">                y1 = pymin;</span>
<span class="nc" id="L940">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="fc bfc" id="L942" title="All 2 branches covered.">            if (y2 &gt; pymax) {</span>
<span class="fc" id="L943">                y2 = pymax;</span>
<span class="fc" id="L944">                x2 = (e.c - y2) / e.a;</span>
            }
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">            if (y2 &lt; pymin) {</span>
<span class="nc" id="L947">                y2 = pymin;</span>
<span class="nc" id="L948">                x2 = (e.c - y2) / e.a;</span>
            }
        }
        
<span class="fc" id="L952">        float diffX = x2 - x1;</span>
<span class="fc" id="L953">        float diffY = y2 - y1;</span>
        //this, unfortunately, removes possible edges for
        // points composed of only a straight line
        //if (diffX == 0.f &amp;&amp; diffY == 0.f) {
        //    return;
        //}
<span class="fc bfc" id="L959" title="All 2 branches covered.">        if (Math.sqrt((diffX * diffX) + (diffY * diffY)) </span>
            &lt; minDistanceBetweenSites) {
<span class="fc" id="L961">            return;</span>
        }
        
<span class="fc" id="L964">        pushGraphEdge(e.reg[0], e.reg[1], x1, y1, x2, y2);</span>
<span class="fc" id="L965">    }</span>

    private void endPoint(Edge e, int lr, Site s) {
<span class="fc" id="L968">        e.ep[lr] = s;</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        if (e.ep[RE - lr] == null) {</span>
<span class="fc" id="L970">            return;</span>
        }
<span class="fc" id="L972">        clipLine(e);</span>
<span class="fc" id="L973">    }</span>

    // returns 1 if p is to right of halfedge e
    private boolean rightOf(HalfEdge el, PairFloat p) {
        Edge e;
        Site topsite;
        boolean rightOfSite;
        boolean above, fast;
        float dxp, dyp, dxs, t1, t2, t3, yl;

<span class="fc" id="L983">        e = el.ELedge;</span>
<span class="fc" id="L984">        topsite = e.reg[1];</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (p.getX() &gt; topsite.coord.getX()) {</span>
<span class="fc" id="L986">            rightOfSite = true;</span>
        } else {
<span class="fc" id="L988">            rightOfSite = false;</span>
        }
<span class="fc bfc" id="L990" title="All 4 branches covered.">        if (rightOfSite &amp;&amp; el.ELpm == LE) {</span>
<span class="fc" id="L991">            return true;</span>
        }
<span class="fc bfc" id="L993" title="All 4 branches covered.">        if (!rightOfSite &amp;&amp; el.ELpm == RE) {</span>
<span class="fc" id="L994">            return false;</span>
        }

<span class="fc bfc" id="L997" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L998">            dyp = p.getY() - topsite.coord.getY();</span>
<span class="fc" id="L999">            dxp = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L1000">            fast = false;</span>
<span class="fc bfc" id="L1001" title="All 8 branches covered.">            if ((!rightOfSite &amp; (e.b &lt; 0.0)) | (rightOfSite &amp; (e.b &gt;= 0.0))) {</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                above = dyp &gt;= e.b * dxp;</span>
<span class="fc" id="L1003">                fast = above;</span>
            } else {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                above = p.getX() + p.getY() * e.b &gt; e.c;</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">                    above = !above;</span>
                }
<span class="fc bfc" id="L1009" title="All 2 branches covered.">                if (!above) {</span>
<span class="fc" id="L1010">                    fast = true;</span>
                }
            }
<span class="fc bfc" id="L1013" title="All 2 branches covered.">            if (!fast) {</span>
<span class="fc" id="L1014">                dxs = topsite.coord.getX() - (e.reg[0]).coord.getX();</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">                above = e.b * (dxp * dxp - dyp * dyp) &lt; dxs * dyp</span>
                    * (1.0 + 2.0 * dxp / dxs + e.b * e.b);
<span class="fc bfc" id="L1017" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                    above = !above;</span>
                }
            }
        } else /* e.b==1.0 */ {
<span class="fc" id="L1022">            yl = e.c - e.a * p.getX();</span>
<span class="fc" id="L1023">            t1 = p.getY() - yl;</span>
<span class="fc" id="L1024">            t2 = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L1025">            t3 = yl - topsite.coord.getY();</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">            above = t1 * t1 &gt; t2 * t2 + t3 * t3;</span>
        }
<span class="fc bfc" id="L1028" title="All 4 branches covered.">        return el.ELpm == LE ? above : !above;</span>
    }

    private Site rightReg(HalfEdge he) {
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        if (he.ELedge == (Edge) null) {</span>
            // if this halfedge has no edge, return the bottom site (whatever
            // that is)
        
<span class="fc" id="L1036">            return bottomsite;</span>
        }

        // if the ELpm field is zero, return the site 0 that this edge bisects,
        // otherwise return site number 1
<span class="fc bfc" id="L1041" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[RE] : </span>
            he.ELedge.reg[LE];
    }

    private float dist(Site s, Site t) {
        float dx, dy;
<span class="fc" id="L1047">        dx = s.coord.getX() - t.coord.getX();</span>
<span class="fc" id="L1048">        dy = s.coord.getY() - t.coord.getY();</span>
<span class="fc" id="L1049">        return (float) (Math.sqrt(dx * dx + dy * dy));</span>
    }

    // create a new site where the HalfEdges el1 and el2 intersect - note that
    // the Point in the argument list is not used, don't know why it's there
    private Site intersect(HalfEdge el1, HalfEdge el2) {
        Edge e1, e2, e;
        HalfEdge el;
        float d, xint, yint;
        boolean rightOfSite;
        Site v;

<span class="fc" id="L1061">        e1 = el1.ELedge;</span>
<span class="fc" id="L1062">        e2 = el2.ELedge;</span>
<span class="fc bfc" id="L1063" title="All 4 branches covered.">        if (e1 == null || e2 == null) {</span>
<span class="fc" id="L1064">            return null;</span>
        }

        // if the two edges bisect the same parent, return null
<span class="fc bfc" id="L1068" title="All 2 branches covered.">        if (e1.reg[1].equals(e2.reg[1])) {</span>
<span class="fc" id="L1069">            return null;</span>
        }

<span class="fc" id="L1072">        d = e1.a * e2.b - e1.b * e2.a;</span>
<span class="fc bfc" id="L1073" title="All 4 branches covered.">        if (-1.0e-10 &lt; d &amp;&amp; d &lt; 1.0e-10) {</span>
<span class="fc" id="L1074">            return null;</span>
        }

<span class="fc" id="L1077">        xint = (e1.c * e2.b - e2.c * e1.b) / d;</span>
<span class="fc" id="L1078">        yint = (e2.c * e1.a - e1.c * e2.a) / d;</span>

<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if ((e1.reg[1].coord.getY() &lt; e2.reg[1].coord.getY())</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">            || (e1.reg[1].coord.getY() == e2.reg[1].coord.getY() </span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">            &amp;&amp; e1.reg[1].coord.getX() &lt; e2.reg[1].coord.getX())) {</span>
<span class="fc" id="L1083">            el = el1;</span>
<span class="fc" id="L1084">            e = e1;</span>
        } else {
<span class="fc" id="L1086">            el = el2;</span>
<span class="fc" id="L1087">            e = e2;</span>
        }

<span class="fc bfc" id="L1090" title="All 2 branches covered.">        rightOfSite = xint &gt;= e.reg[1].coord.getX();</span>
<span class="fc bfc" id="L1091" title="All 8 branches covered.">        if ((rightOfSite &amp;&amp; el.ELpm == LE)</span>
            || (!rightOfSite &amp;&amp; el.ELpm == RE)) {
<span class="fc" id="L1093">            return null;</span>
        }

        // create a new site at the point of intersection - this is a new vector
        // event waiting to happen
<span class="fc" id="L1098">        v = new Site();</span>
<span class="fc" id="L1099">        v.coord = new PairFloat(xint, yint);</span>
<span class="fc" id="L1100">        return v;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>