<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinearEquations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.matrix</a> &gt; <span class="el_source">LinearEquations.java</span></div><h1>LinearEquations.java</h1><pre class="source lang-java linenums">package algorithms.matrix;

import java.util.Arrays;
import no.uib.cipr.matrix.DenseCholesky;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.DenseVector;
import no.uib.cipr.matrix.LowerSPDDenseMatrix;
import no.uib.cipr.matrix.LowerTriangDenseMatrix;
import no.uib.cipr.matrix.Matrices;
import no.uib.cipr.matrix.NotConvergedException;

/**
 a class of utility methods for linear algebra.
 &lt;pre&gt;
 note, for solving linear least squares problems, a good resource aside
 * from Strang, Golub &amp; van Loan, and Cormen et al. is:
 “Algorithms for Linear Least Squares Problems”, 
 Bj̈orck 1991, published in Computer Algorithms for Solving Linear Algebraic Equations;
 The State of the Art., Vol. 77 of NATO-ASI Series F: Computer and Systems Sciences, pages 57–92.
 &lt;/pre&gt;
   LUPSolve, __, and __ follow
   pseudocode from Cormen, Leiserson, Rivest, and Stein, &quot;Introduction to
   Computer Algorithms&quot;.
*/
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class LinearEquations {</span>

    /**
     solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ... a_0_n*x_n     = b_0
       a_1_0*x_0   +  a_1_1*x_1   + ... a_1_n*x_n     = b_1
          ...
       a_n-1_0*x_0 +  a_n-1_1*x_1 + ... a_{n-1}_n*x_{n-1} = b_{n-1}
     where a is a square matrix, that is, there are n equations and n
     unknowns.
     LUP decomposition is more numerically stable than x = A^-1*b.
         can find L, U, and P such that P*A=L*U
     where L is a lower triangular matrix, U is an upper triangular matrix,
     and P is a permutation matrix.
     (a permutation matrix is all 0's excepting a single 1 in each column, uniquely.
     multiplying a vector by a permutation rearranges the members of the vector.)
     Uses forward substitution then back substitution.
       L*U*x=P*b.
         let y=U*x.
       L*y=P*b  (uses forward substitution with these results).
       U*x=y    (uses back substitution with these results).
       A*x=b    (then solves x_i=(y_i - summation_j=i_to_{n-1}(u_i_j*x_j))/u_i_i).
     runtime complexity is O(n^2) for backward and forward substitutions.
     * The method follows Cormet et al. Chap 28.3.
     @param ell is an nxn lower triangular matrix using row major format.
     @param u is an nxn upper triangular matrix using row major format.
     @param p is an array of length n holding permutation vector columns. 
            e.g. p_0=0 states that column 0 contains a 1 for row=0.
            e.g. p_1=2 states that column 2 contains a 1 for row=1.
            full_permutation_matrix = zeros everywhere except the row, col pairs in p
     @param b is an array of length n.
     @return array of x
    */
    public static double[] LUPSolve(double[][] ell, double[][] u, int[] p, double[] b) {
<span class="fc" id="L59">        int n = ell.length;</span>
<span class="fc" id="L60">        assertSquareMatrix(ell, &quot;ell&quot;);</span>
<span class="fc" id="L61">        assertSquareMatrix(u, &quot;u&quot;);</span>
<span class="fc" id="L62">        assertArrayLength(n, p, &quot;p&quot;);</span>
<span class="fc" id="L63">        assertArrayLength(n, b, &quot;b&quot;);</span>

<span class="fc" id="L65">        double[] y = new double[n];</span>
<span class="fc" id="L66">        double[] x = new double[n];</span>
<span class="fc" id="L67">        double tempsum = 0;</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L69">            tempsum = 0;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L71">                tempsum += ell[i][j]*y[j];</span>
            }
<span class="fc" id="L73">            y[i] = b[p[i]] - tempsum;</span>
        }
<span class="fc" id="L75">        tempsum = 0;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        for (int i = n-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L77">            tempsum = 0;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if (i != (n-1)) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                for (int j = i+1; j &lt; n; j++) {</span>
<span class="fc" id="L80">                    tempsum += u[i][j]*x[j];</span>
                }
            }
<span class="fc" id="L83">            x[i] = (y[i] - tempsum)/u[i][i];</span>
        }
<span class="fc" id="L85">        return x;</span>
    }
    
    /**
     * solve for x in A*x=b by LU decomposition
     * @param a
     * @param b
     * @return 
     */
    public static double[] solveXFromLUDecomposition(double[][] a, double[] b) {
        
<span class="fc" id="L96">        int n = a.length;</span>
        
<span class="fc" id="L98">        DenseVector x = new DenseVector(n);</span>
<span class="fc" id="L99">        DenseVector _b = new DenseVector(b);</span>
        
<span class="fc" id="L101">        DenseMatrix aa = new DenseMatrix(a);</span>
<span class="fc" id="L102">        x = (DenseVector)aa.solve(_b, x);</span>
                        
<span class="fc" id="L104">        return x.getData();</span>
    }

    /**
     * an efficient LUP decomposition for a being a square non-singular matrix and
     * P is the Identity matrix.   uses Gaussian elimination and the Schur
     * complement while making recursive subdivision subdivisions.
     * The runtime is O(n^3).
     * @param a square two dimensional array in row major format.  
     * a is a non-singular matrix(i.e. has exactly one solution).  the rank of
     * a is n (it's dimensions are m x n).
     * @return LU a wrapper holding the 2 two-dimensional row major output arrays.
     * L and U.  they are both size nXn where n=a.length.
     * L is a unit lower triangular matrix (has 1's on the diagonal) and U
     * is an upper triangular matrix whose diagonals are the matrix pivots.
     * Note that the determinant of A is the product of the U diagonals,
     * that is det(A) = u[0][0] * u[1][1]...*u[n-1][n-1].
     */
    public static LU LUDecomposition(double[][] a) {
<span class="fc" id="L123">        int n = a.length;</span>
<span class="fc" id="L124">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="fc" id="L126">        a = copy(a);</span>
        
        //nXn for both:
<span class="fc" id="L129">        double[][] ell = new double[n][];</span>
<span class="fc" id="L130">        double[][] u = new double[n][];</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L132">            ell[i] = new double[n];</span>
<span class="fc" id="L133">            u[i] = new double[n];</span>
<span class="fc" id="L134">            ell[i][i] = 1;</span>
<span class="fc" id="L135">            u[i][i] = 1;</span>
        }
        
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L139">            u[k][k] = a[k][k];</span>
            
<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc" id="L142">                ell[i][k] = a[i][k]/u[k][k];</span>
<span class="fc" id="L143">                u[k][i] = a[k][i];</span>
            }
            
<span class="fc bfc" id="L146" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                for (int j = k+1; j &lt; n; j++) {</span>
<span class="fc" id="L148">                    a[i][j] -= (ell[i][k] * u[k][j]); </span>
                }
            }
        }
                
<span class="fc" id="L153">        return new LU(ell, u);</span>
    }
    
    /**
     * for a symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-M decomposition which is a 
     * variation of L-U decomposition.  If all leading principal sub-matrices of 
     * A are non-singular then there exist lower unit triangular matrices
     * L and M and a diagonal matrix D = diag(d1, d2, ...d_n) where d_i = u_i_i.
     * A = L*D*M^T.
     * Note that D is non-singular and that M^T = D^-1*U is unit upper triangular.
     * (A=L*U = L*D*(D^-1*U = L*D*M^T).
     * &lt;pre&gt;
     * Once A = L*D*M^T is decomposed, one can solve A*x = b:
     * L*y = b   (in (n^2)/2 flops
     * D*z= y    (in n flops)
     * M^T*x = z (in (n^2)/2 flops)
     * 
     * References:
     * Golub and va Loan, &quot;MAtrix Computations&quot;, Section 5.1
     * &lt;/pre&gt;
     * 2n^3/3 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     */
    public static LDM LDMDecomposition(double[][] a) {
        
<span class="fc" id="L182">        int n = a.length;</span>
        
<span class="fc" id="L184">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
        // need to have a in row echelon reduced state for this:
        //assertSymmetrix(a);
        
<span class="fc" id="L189">        double[][] ell = MatrixUtil.zeros(n, n);</span>
<span class="fc" id="L190">        double[][] m = MatrixUtil.zeros(n, n);</span>
<span class="fc" id="L191">        double[] d = new double[n];</span>
        
        int k, i, p;
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (k = 1; k &lt;= n; ++k) {</span>
<span class="fc" id="L195">            d[k-1] = a[k-1][k-1];</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L197">                d[k-1] -= (ell[k-1][p-1]*d[p-1]*m[k-1][p-1]);</span>
            }
            // error in the 1st edition of Matrix Computations; i=k to n, but they use i=k+1 to n
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (i = k/*k+1*/; i &lt;= n; ++i) {</span>
                
<span class="fc" id="L202">                ell[i-1][k-1] = a[i-1][k-1];</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L204">                    ell[i-1][k-1] -= (ell[i-1][p-1]*d[p-1]*m[k-1][p-1]);</span>
                }
<span class="fc" id="L206">                ell[i-1][k-1] /= d[k-1];</span>
                
<span class="fc" id="L208">                m[i-1][k-1] = a[k-1][i-1];</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L210">                    m[i-1][k-1] -= (ell[k-1][p-1]*d[p-1]*m[i-1][p-1]);</span>
                }
<span class="fc" id="L212">                m[i-1][k-1] /= d[k-1];</span>
            }
        }
        
<span class="fc" id="L216">        LDM ldm = new LDM(ell, d, m);</span>
        
<span class="fc" id="L218">        return ldm;</span>
    }
    
    /**
     * compute the cholesky decomposition for symmetric positive definite matrix
     * a using the MTJ library.
     * @param a symmetric positive definite matrix 
     * @return lower triangular matrix G  which G is a lower triangular matrix with positive
    * diagonal entries.  a = G*G^T.
    */
    public static double[][] choleskyDecompositionViaMTJ(double[][] a) {
<span class="nc" id="L229">        int n = a.length;</span>
        
<span class="nc" id="L231">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="nc" id="L233">        DenseCholesky chol = new DenseCholesky(n, false);</span>
<span class="nc" id="L234">        chol = chol.factor(new LowerSPDDenseMatrix(new DenseMatrix(a)));</span>
<span class="nc" id="L235">        LowerTriangDenseMatrix ell = chol.getL();</span>
<span class="nc" id="L236">        return Matrices.getArray(ell);</span>
    }
    
    /**
     * compute the cholesky decomposition for symmetric positive definite matrix
     * a.
     * reference:
     * golub &amp; van loan &quot;matrix computations, theorem 5.2-3.
     * This method uses LDL decomposition to compute G in 
     * a = G*G^T where G is a lower triangular matrix with positive
    * diagonal entries.
    * 
     * @param a symmetric positive definite matrix 
     * @param eps value for an error tolerance around zero used in the LDL decomposition.
     * @return lower triangular matrix G  which G is a lower triangular matrix with positive
    * diagonal entries.  a = G*G^T.
    */
    public static double[][] choleskyDecompositionViaLDL(double[][] a, double eps) {
        
<span class="fc" id="L255">        int n = a.length;</span>
        
<span class="fc" id="L257">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
        //assertPositiveDefinite(a, &quot;a&quot;);
        
<span class="fc" id="L261">        LDL ldl = LDLDecomposition(a, eps);</span>
        
<span class="fc" id="L263">        double[] d = Arrays.copyOf(ldl.getD(), ldl.getD().length);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (int i = 0; i &lt; d.length; ++i) {</span>
<span class="fc" id="L265">            d[i] = Math.sqrt(d[i]);</span>
        }
<span class="fc" id="L267">        double[][] g = MatrixUtil.multiplyByDiagonal(ldl.getL(), d);</span>
        
<span class="fc" id="L269">        return g;</span>
    }
       
    /**
     * for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-L decomposition which is a 
     * variation of L-U decomposition.  Computes a unit lower triangular matrix
     * L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
     * A = L*D*L^T.
     * &lt;pre&gt;
     * 
     * References:
     * Golub and van Loan, &quot;Matrix Computations&quot;, Algorithm 5.1.2
     * &lt;/pre&gt;
     * n^3/6 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     */
    public static LDL LDLDecomposition(double[][] a) {
<span class="fc" id="L290">        double eps = 1.e-7;</span>
<span class="fc" id="L291">        return LDLDecomposition(a, eps);</span>
    }
        
    /**
     * for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-L decomposition which is a 
     * variation of L-U decomposition.  Computes a unit lower triangular matrix
     * L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
     * A = L*D*L^T.
     * &lt;pre&gt;
     * 
     * References:
     * Golub and van Loan, &quot;Matrix Computations&quot;, Algorithm 5.1.2
     * &lt;/pre&gt;
     * n^3/6 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @param eps value for a tolerance of an error around 0.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     * Note that the method will return null when an intermediary calculation 
     * is smaller than eps.
     */
    public static LDL LDLDecomposition(double[][] a, double eps) {
        
<span class="fc" id="L316">        int m = a.length;</span>
<span class="fc" id="L317">        int n = a[0].length;</span>
        
<span class="fc" id="L319">        assertSquareMatrix(a, &quot;a&quot;);</span>
                
        // need to have a in row echelon reduced state for this:
        //assertSymmetrix(a);
        
        //NOTE: if need to conserve memory, can remove the copy statement,
        //    and add to javadoc comments that a is modified in place.
<span class="fc" id="L326">        a = MatrixUtil.copy(a);</span>
<span class="fc" id="L327">        double[] r = new double[m];</span>
<span class="fc" id="L328">        double[] d = new double[m];</span>
        
        int k, i, p;
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (k = 1; k &lt;= m; ++k) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L333">                r[p-1] = d[p-1]*a[k-1][p-1];</span>
            }
<span class="fc" id="L335">            d[k-1] = a[k-1][k-1];</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L337">                d[k-1] -= a[k-1][p-1]*r[p-1];</span>
            }
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            if (Math.abs(d[k-1]) &lt; eps) {</span>
<span class="nc" id="L340">                System.err.printf(&quot;Error: number %.3e is smaller than %.3e\n&quot;, </span>
<span class="nc" id="L341">                    Math.abs(d[k-1]), eps);</span>
<span class="nc" id="L342">                return null;</span>
            }
<span class="fc bfc" id="L344" title="All 2 branches covered.">            for (i = k; i &lt;= m; ++i) {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L346">                    a[i-1][k-1] -= a[i-1][p-1]*r[p-1];</span>
                }
<span class="fc" id="L348">                a[i-1][k-1] /= d[k-1];</span>
            }
        }
        
<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            for (k = i+1; k &lt; m; ++k) {</span>
<span class="fc" id="L354">                a[i][k] = 0;</span>
            }
        }
        
<span class="fc" id="L358">        LDL ld = new LDL(a, d);</span>
        
<span class="fc" id="L360">        return ld;</span>
    }
    
    
    
    /**
     * an LUP decomposition for a being a square non-singular matrix that tries 
     * to reduce errors due to division by small numbers.  
     * creates a permutation matrix to pivot rows so that the row reduction
     * divisions are by the largest numbers.
     * uses Gaussian elimination and the Schur
     * complement while making recursive subdivision subdivisions.
     * The runtime is O(n^3).
     * @param a square two dimensional array in row major format.  
     * a is a non-singular matrix (i.e. has exactly one solution).  the rank of
     * a is n (it's dimensions are m x n).
     * @return LUP a wrapper holding the 2 two-dimensional row major output arrays.
     * L and U and the condensed permutation array p, where P*A=L*U.
     */
    public static LUP LUPDecomposition(double[][] a) {
<span class="fc" id="L380">        int n = a.length;</span>
<span class="fc" id="L381">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="fc" id="L383">        a = copy(a);</span>
        
<span class="fc" id="L385">        int[] pi = new int[n];</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {            </span>
<span class="fc" id="L387">            pi[i] = i;</span>
        }
        
        double p;
        double temp;
<span class="fc" id="L392">        int k2 = -1;</span>
        double swap;
        int swapI;
<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L396">            p = 0;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            for (int i = k; i &lt; n; i++) {</span>
<span class="fc" id="L398">                temp = Math.abs(a[i][k]);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                if (temp &gt; p) {</span>
<span class="fc" id="L400">                    p = temp;</span>
<span class="fc" id="L401">                    k2 = i;</span>
                }
            }
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (p == 0.) {</span>
<span class="nc" id="L405">                throw new IllegalStateException(&quot;Error: a is a singular matrix&quot;);</span>
            }
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">            assert(k2 &gt;= 0);</span>
<span class="fc" id="L408">            swapI = pi[k2];</span>
<span class="fc" id="L409">            pi[k2] = pi[k];</span>
<span class="fc" id="L410">            pi[k] = swapI;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L412">                swap = a[k2][i];</span>
<span class="fc" id="L413">                a[k2][i] = a[k][i];</span>
<span class="fc" id="L414">                a[k][i] = swap;</span>
            }
<span class="fc bfc" id="L416" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc" id="L417">                a[i][k] /= a[k][k];</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                for (int j = k+1; j &lt; n; j++) {</span>
<span class="fc" id="L419">                    a[i][j] -= (a[i][k] * a[k][j]);</span>
                }
            }
        }
       
        // setting the upper and lower triangles of a into ell and u to pass
        //   pack as arguments.
        //   the original pseudocode uses only a and modifies the original in place
        //     to conserve space.
<span class="fc" id="L428">        double[][] ell = new double[n][];</span>
<span class="fc" id="L429">        double[][] u = new double[n][];</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L431">            ell[i] = new double[n];</span>
<span class="fc" id="L432">            u[i] = new double[n];</span>
<span class="fc" id="L433">            u[i][i] = 1;</span>
<span class="fc" id="L434">            ell[i][i] = 1;</span>
        }
<span class="fc bfc" id="L436" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                if (i &gt; j) {</span>
<span class="fc" id="L439">                    ell[i][j] = a[i][j];</span>
                } else {
<span class="fc" id="L441">                    u[i][j] = a[i][j];</span>
                }
            }
        }
        
<span class="fc" id="L446">        return new LUP(ell, u, pi);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @param solveForFullRank
     * when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
     * and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
     * (see Chap 4.3 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang and Chap 28 from the book &quot;Introductionvto 
     * Algorithms&quot; by Cormen, Leiserson, Rivest, and Stein.)
     * when solveForFullRank is set to 'False' this method uses the SVD to
     * create a pseudoinverse (see Chap 7 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang.)
     *  
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     * @throws no.uib.cipr.matrix.NotConvergedException
     */
    public static double[] leastSquaresPolynomial(double[][] xy, int polyOrder, boolean
        solveForFullRank) throws NotConvergedException {
<span class="fc" id="L477">        return _leastSquaresPolynomial(xy, polyOrder, solveForFullRank);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     */
    public static double[] leastSquaresPolynomial(double[][] xy, int polyOrder) throws NotConvergedException {
<span class="nc" id="L496">        return _leastSquaresPolynomial(xy, polyOrder, false);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @param solveFullRank
     * when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
     * and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
     * (see Chap 4.3 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang and Chap 28 from the book &quot;Introductionvto 
     * Algorithms&quot; by Cormen, Leiserson, Rivest, and Stein.)
     * when solveForFullRank is set to 'False' this method uses the SVD to
     * create a pseudoinverse (see Chap 7 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang.)
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     */
    public static double[] _leastSquaresPolynomial(double[][] xy, int polyOrder,
        boolean solveFullRank) throws NotConvergedException {
        
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (polyOrder &lt; 0) {</span>
<span class="nc" id="L527">            throw new IllegalArgumentException(&quot;polyOrder must be 0 or larger&quot;);</span>
        }
<span class="fc" id="L529">        int nRows = xy.length;</span>
        
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (polyOrder &gt; nRows) {</span>
<span class="nc" id="L532">            throw new IllegalArgumentException(&quot;polyOrder should be smaller &quot;</span>
                    + &quot; than or equal to the number of data rows&quot;);
        }
        
        // create matrix A
<span class="fc" id="L537">        double[][] a = new double[nRows][];</span>
        double x;
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L540">            a[i] = new double[polyOrder + 1];</span>
<span class="fc" id="L541">            a[i][0] = 1;</span>
        }
<span class="fc bfc" id="L543" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L544">            x = xy[i][0];</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            for (int k = 0; k &lt; polyOrder; ++k) {</span>
<span class="fc" id="L546">                a[i][k + 1] = x * a[i][k];</span>
            }
        }
        
        double[][] aPInv;
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (solveFullRank) {</span>
            //AX=b has no solution
            //using A_pseudoinverse = inverse(A^T*A) * A^T
<span class="fc" id="L554">            aPInv = MatrixUtil.pseudoinverseFullRank(a);</span>
        } else {
            // uses SVD of a in pseudo-inverse
            // Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
            //inverse of A.
            // method is valid for  rows .lte. rank,
            // but for rows .gt. rank, the null-space needs to be solved instead.
<span class="fc" id="L561">            aPInv = MatrixUtil.pseudoinverseRankDeficient(a);</span>
        }
        
<span class="fc" id="L564">        double[] y = new double[nRows];</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L566">            y[i] = xy[i][1];</span>
        }
        
<span class="fc" id="L569">        double[] c = MatrixUtil.multiplyMatrixByColumnVector(aPInv, y);</span>
        
<span class="fc" id="L571">        return c;</span>
    }
    
    public static class LU {
        double[][] ell;
        double[][] u;
        public LU(double[][] ell, double[][] u) {
            this.ell = ell;
            this.u = u;
        }
    }
    
    public static class LUP {
        double[][] ell;
        double[][] u;
        int[] p;
        public LUP(double[][] ell, double[][] u, int[] p) {
            this.ell = ell;
            this.u = u;
            this.p = p;
        }
    }
    
    /**
     * lower triangular portion of A = L * D * M^T
     */
    public static class LDM {
        double[][] ell;
        double[] d;
        double[][] m;
        public LDM(double[][] ell, double[] d, double[][] m) {
            this.ell = ell;
            this.d = d;
            this.m = m;
        }
    }
    
    public static class LDL {
        private double[][] ell;
        private double[] d;
        public LDL(double[][] ell, double[] d) {
            this.ell = ell;
            this.d = d;
        }

        /**
         * @return the L
         */
        public double[][] getL() {
            return ell;
        }

        /**
         * @return the d
         */
        public double[] getD() {
            return d;
        }
    }
    
    private static void assertSquareMatrix(double[][] a, String name) {
<span class="fc" id="L632">        int n = a.length;</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (a[0].length != n) {</span>
<span class="nc" id="L634">            throw new IllegalArgumentException(name + &quot; must be a square matrix&quot;);</span>
        }
<span class="fc" id="L636">    }</span>
    
    private static void assertPositiveDefinite(double[][] a, String name) {
<span class="nc" id="L639">        int n = a.length;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (!MatrixUtil.isPositiveDefinite(a)) {</span>
<span class="nc" id="L641">            throw new IllegalArgumentException(name + &quot; must be a positive definite matrix&quot;);</span>
        }
<span class="nc" id="L643">    }</span>

    private static void assertArrayLength(int n, double[] a, String name) {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (a.length != n) {</span>
<span class="nc" id="L647">            throw new IllegalArgumentException(name + &quot; must be length &quot; + n);</span>
        }
<span class="fc" id="L649">    }</span>

    private static void assertArrayLength(int n, int[] a, String name) {
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (a.length != n) {</span>
<span class="nc" id="L653">            throw new IllegalArgumentException(name + &quot; must be length &quot; + n);</span>
        }
<span class="fc" id="L655">    }</span>
    
    private static double[][] copy(double[][] a) {
<span class="fc" id="L658">        int nrows = a.length;</span>
<span class="fc" id="L659">        double[][] c = new double[nrows][];</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        for (int i = 0; i &lt; nrows; ++i) {</span>
<span class="fc" id="L661">            c[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
<span class="fc" id="L663">        return c;</span>
    }
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>