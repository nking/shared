<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Wed Nov 23 15:52:47 PST 2022 -->
<title>KernelDensityEstimator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-11-23">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KernelDensityEstimator";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.misc</a></div>
<h2 title="Class KernelDensityEstimator" class="title">Class KernelDensityEstimator</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.misc.KernelDensityEstimator</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">KernelDensityEstimator</span>
extends java.lang.Object</pre>
<div class="block">TODO: consider implementing the Improved Sheather - Jones algorithm for estimating bandwidth:.
 can see implementations
 https://github.com/tommyod/KDEpy/blob/master/KDEpy/bw_selection.py
 and
 https://kdepy.readthedocs.io/en/latest/_modules/KDEpy/FFTKDE.html#FFTKDE

 TODO: consider implementing
 "Fast and Accurate Gaussian Kernel Density Estimation", Jeffrey Heer, University of Washiington.
 https://idl.cs.washington.edu/files/2021-FastKDE-VIS.pdf

 TODO: consider using MSER in a 2-D KDE estimator

 TODO: explore https://github.com/TasCL/cpda/ one day.
 Probability Density Approximation.
 The authors are Yi-Shin Lin yishin.lin@utas.edu.au, Andrew Heathcote, William Holmes
 The repository implements some of
 Holmes, W. (2015). A practical guide to the Probability Density Approximation (PDA) with improved implementation
 and error characterization. Journal of Mathematical Psychology, 68-69, 13--24, doi:
 http://dx.doi.org/10.1016/j.jmp.2015.08.006.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#BIG">BIG</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">KernelDensityEstimator</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#assertHistRange(double%5B%5D,double%5B%5D,double)">assertHistRange</a></span>&#8203;(double[]&nbsp;histBins,
               double[]&nbsp;dataMinMax,
               double&nbsp;h)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected static <a href="Complex.html" title="class in algorithms.misc">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertToComplex(double%5B%5D)">convertToComplex</a></span>&#8203;(double[]&nbsp;a)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createFineHistogram(double%5B%5D,double)">createFineHistogram</a></span>&#8203;(double[]&nbsp;x,
                   double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">calculate a fine resolution histogram for x, for a larger data range than x's.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createFineHistogram(double%5B%5D,double,int,double,double,double)">createFineHistogram</a></span>&#8203;(double[]&nbsp;x,
                   double&nbsp;h,
                   int&nbsp;nBins,
                   double&nbsp;binWidth,
                   double&nbsp;minBin,
                   double&nbsp;maxBin)</code></th>
<td class="colLast">
<div class="block">calculate a fine resolution histogram for x, for a larger data range than x's.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createFineHistogramSubstitute(double%5B%5D)">createFineHistogramSubstitute</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">calculate a substitute for the fine resolution histogram for x for use in the
 risk estimator that uses cross-validation.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#crossValidationScore(algorithms.misc.Complex%5B%5D,double%5B%5D,double)">crossValidationScore</a></span>&#8203;(<a href="Complex.html" title="class in algorithms.misc">Complex</a>[]&nbsp;u,
                    double[]&nbsp;histBins,
                    double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">a fast cross-validation method which can be used in choosing the bandwidth for the kernel density estimator.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimalBandwidthGaussianKernel(double,int)">optimalBandwidthGaussianKernel</a></span>&#8203;(double&nbsp;standardDeviation,
                              int&nbsp;nSample)</code></th>
<td class="colLast">
<div class="block">assuming a zero-centered mean gaussian kernel, return the bandwidth which minimizes the
 mean integrated squared error (MISE).</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#riskEstimatorDataSplitting()">riskEstimatorDataSplitting</a></span>()</code></th>
<td class="colLast">
<div class="block">calculate the risk estimator for the "data-splitting" V-fold or k-fold method of cross validation.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#riskEstimatorGaussianKernel()">riskEstimatorGaussianKernel</a></span>()</code></th>
<td class="colLast">
<div class="block">calculate the risk estimator for the "leave-one-out" method of cross validation.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#riskEstimatorLeaveOneOut()">riskEstimatorLeaveOneOut</a></span>()</code></th>
<td class="colLast">
<div class="block">calculate the risk estimator for the "leave-one-out" method of cross validation.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ruleOfThumbBandwidthGaussianKernel(double,double,int)">ruleOfThumbBandwidthGaussianKernel</a></span>&#8203;(double&nbsp;standardDeviation,
                                  double&nbsp;IQR,
                                  int&nbsp;nSample)</code></th>
<td class="colLast">
<div class="block">assuming a zero-centered mean gaussian kernel, return Silverman's "rule of thumb" bandwidth.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sumHistogram(double%5B%5D%5B%5D)">sumHistogram</a></span>&#8203;(double[][]&nbsp;hist)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>(package private) static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sumKDE(double%5B%5D,double)">sumKDE</a></span>&#8203;(double[]&nbsp;kde,
      double&nbsp;dk)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#univariateKernelDensityEstimate(algorithms.misc.IKernel,double,double%5B%5D,double)">univariateKernelDensityEstimate</a></span>&#8203;(<a href="IKernel.html" title="interface in algorithms.misc">IKernel</a>&nbsp;kernel,
                               double&nbsp;x,
                               double[]&nbsp;xTilde,
                               double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">estimate the KDE for a single value x.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static <a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaFFTGaussKernel(double%5B%5D,double)">viaFFTGaussKernel</a></span>&#8203;(double[]&nbsp;x,
                 double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">estimate the density by using properties of exponentials 
     (convolution, discrete FFT, fourier pairs ...) to make a faster algorithm.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static <a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaFFTGaussKernel(double%5B%5D,double,int,double,double,double)">viaFFTGaussKernel</a></span>&#8203;(double[]&nbsp;x,
                 double&nbsp;h,
                 int&nbsp;histNBins,
                 double&nbsp;histBinWidth,
                 double&nbsp;histMinBin,
                 double&nbsp;histMaxBin)</code></th>
<td class="colLast">
<div class="block">estimate the density by using properties of exponentials (convolution, discrete FFT, fourier pairs ...) 
     to make a faster algorithm.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static <a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaFFTGaussKernel(algorithms.misc.Complex%5B%5D,double%5B%5D,double)">viaFFTGaussKernel</a></span>&#8203;(<a href="Complex.html" title="class in algorithms.misc">Complex</a>[]&nbsp;u,
                 double[]&nbsp;histBins,
                 double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">estimate the density by using properties of exponentials 
     (convolution, discrete FFT, fourier pairs ...) to make a faster algorithm.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static <a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaGaussKernel(double%5B%5D,double)">viaGaussKernel</a></span>&#8203;(double[]&nbsp;x,
              double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">estimate the density of x using a Gaussian Kernel of bandwidth h.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static <a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaGaussKernel(double%5B%5D,double%5B%5D,double)">viaGaussKernel</a></span>&#8203;(double[]&nbsp;x,
              double[]&nbsp;xGrid,
              double&nbsp;h)</code></th>
<td class="colLast">
<div class="block">estimate the density of x using a Gaussian Kernel of bandwidth h.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="BIG">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>BIG</h4>
<pre>static final&nbsp;double BIG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#algorithms.misc.KernelDensityEstimator.BIG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>KernelDensityEstimator</h4>
<pre>public&nbsp;KernelDensityEstimator()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="optimalBandwidthGaussianKernel(double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimalBandwidthGaussianKernel</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;optimalBandwidthGaussianKernel&#8203;(double&nbsp;standardDeviation,
                                                    int&nbsp;nSample)</pre>
<div class="block">assuming a zero-centered mean gaussian kernel, return the bandwidth which minimizes the
 mean integrated squared error (MISE).
 NOTE, the method ruleOfThumbBandwidthGaussianKernel() is preferred.
 <pre>
     Silverman 1981, "Kernel Density Estimation Using theFast Fourier Transform"
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standardDeviation</code> - </dd>
<dd><code>nSample</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="ruleOfThumbBandwidthGaussianKernel(double,double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ruleOfThumbBandwidthGaussianKernel</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;ruleOfThumbBandwidthGaussianKernel&#8203;(double&nbsp;standardDeviation,
                                                        double&nbsp;IQR,
                                                        int&nbsp;nSample)</pre>
<div class="block">assuming a zero-centered mean gaussian kernel, return Silverman's "rule of thumb" bandwidth.
 This is considered an improvement over the optimal bandwidth for gaussian kernels.
 <pre>
     Silverman's ‘rule of thumb’, Silverman (1986, page 48, eqn (3.31))).
     and
     https://rdrr.io/r/stats/bandwidth.html
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standardDeviation</code> - </dd>
<dd><code>nSample</code> - </dd>
<dd><code>IQR</code> - the interquartile range which is the ordered statistic divided into 4 equal parts, each summed,
            then iqr = the 3rd quartile minus the first quartile = sum[3] - sum[0].
            see MiscMath0.calcMedianAndIQR()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="viaFFTGaussKernel(double[],double,int,double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaFFTGaussKernel</h4>
<pre class="methodSignature">public static&nbsp;<a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a>&nbsp;viaFFTGaussKernel&#8203;(double[]&nbsp;x,
                                                           double&nbsp;h,
                                                           int&nbsp;histNBins,
                                                           double&nbsp;histBinWidth,
                                                           double&nbsp;histMinBin,
                                                           double&nbsp;histMaxBin)</pre>
<div class="block">estimate the density by using properties of exponentials (convolution, discrete FFT, fourier pairs ...) 
     to make a faster algorithm.
     <pre>
     reference:
     Silverman, B. W. (1982). Algorithm as 176: Kernel density estimation using the fast Fourier transform. Journal of the Royal Statistical Society. Series C (Applied Statistics), 31(1), 93-99. https://dx.doi.org/10.2307/2347084.
     https://www.jstor.org/stable/2347084#metadata_info_tab_contents
     </pre>
     calculate the KDE in a fast manner by using discrete FFTs and using a grid of data points
     the kde = f_hat(x) ~ summation over i=1 to n of (K(|| x - X_i ||/h).
     the kernel estimate is a convolution of the data with the kernel.
     naive implementation is O(n^2).
     if the kernel K is chosen to be a Gaussian, one can use a property of exponentials 
     (convolution, discrete FFT, fourier pairs ...) to rewrite:
     exp(x - X_i) = exp(x) * exp(-X_i) (neglecting details)
     also note that the discrete FFT is a summation of exponentials.
     convolution theorem: one can use the pointwise multiplication between the fourier paired functions.
     (Chap 15.5, Boas "Mathematical Methods in the Physical Sciences")
     convolution to FFT:
     FFT(kde) ~ FFT(K(h*s)) * FFT( hist(X) )
     one can choose s to be the same spatial intervals (=grid) in the histogram
     and in the kernel, to avoid interpolation.  the multiplication is pointwise.
     then inverse FFT of FFT(kde) = kde.
     the runtime complexity is then O(n_s*log(n_s))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - observed data</dd>
<dd><code>h</code> - bandwidth</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="viaFFTGaussKernel(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaFFTGaussKernel</h4>
<pre class="methodSignature">public static&nbsp;<a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a>&nbsp;viaFFTGaussKernel&#8203;(double[]&nbsp;x,
                                                           double&nbsp;h)</pre>
<div class="block">estimate the density by using properties of exponentials 
     (convolution, discrete FFT, fourier pairs ...) to make a faster algorithm.
     <pre>
     reference:
     Silverman, B. W. (1982). Algorithm as 176: Kernel density estimation using the fast Fourier transform. Journal of the Royal Statistical Society. Series C (Applied Statistics), 31(1), 93-99. https://dx.doi.org/10.2307/2347084.
     https://www.jstor.org/stable/2347084#metadata_info_tab_contents
     </pre>
     calculate the KDE in a fast manner by using discrete FFTs and using a grid of data points
     the kde = f_hat(x) ~ summation over i=1 to n of (K(|| x - X_i ||/h).
     the kernel estimate is a convolution of the data with the kernel.
     naive implementation is O(n^2).
     if the kernel K is chosen to be a Gaussian, one can use a property of exponentials to rewrite:
     exp(x - X_i) = exp(x) * exp(-X_i) (neglecting details)
     also note that the discrete FFT is a summation of exponentials.
     convolution theorem: one can use the pointwise multiplication between the fourier paired functions.
     (Chap 15.5, Boas "Mathematical Methods in the Physical Sciences")
     convolution to FFT:
     FFT(kde) ~ FFT(K(h*s)) * FFT( hist(X) )
     one can choose s to be the same spatial intervals (=grid) in the histogram
     and in the kernel, to avoid interpolation.  the multiplication is pointwise.
     then inverse FFT of FFT(kde) = kde.
     the runtime complexity is then O(n_s*log(n_s))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - data observed</dd>
<dd><code>h</code> - bandwidth</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="viaGaussKernel(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaGaussKernel</h4>
<pre class="methodSignature">public static&nbsp;<a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a>&nbsp;viaGaussKernel&#8203;(double[]&nbsp;x,
                                                        double&nbsp;h)</pre>
<div class="block">estimate the density of x using a Gaussian Kernel of bandwidth h.
 note that the grid to which the kernel is applied is also x in this case.
     <pre>
     f_hat(x) ~ (1/n) * summation over i=1 to n of ( (1/h) * K(|| x - X_i ||/h) ).
     double[] kde = iter from j=1-1 to xGrid.length-1 estimating f_hat(xGrid[j]
     reference: Wasserman's "All of Statistics", eqn (20.21)
     </pre>
     runtime complexity is O(n^2) where n = x.length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - data observed</dd>
<dd><code>h</code> - bandwidth</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="viaGaussKernel(double[],double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaGaussKernel</h4>
<pre class="methodSignature">public static&nbsp;<a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a>&nbsp;viaGaussKernel&#8203;(double[]&nbsp;x,
                                                        double[]&nbsp;xGrid,
                                                        double&nbsp;h)</pre>
<div class="block">estimate the density of x using a Gaussian Kernel of bandwidth h.
 the grid to which the kernel is applied is xGrid in this case.
     <pre>
     f_hat(x) ~ (1/n) * summation over i=1 to n of ( (1/h) * K(|| x - X_i ||/h) ).
     double[] kde = iter from j=1-1 to xGrid.length-1 estimating f_hat(xGrid[j]
     reference: Wasserman's "All of Statistics", eqn (20.21)
     </pre>
     runtime complexity is O(n*m) where n = x.length and m=xGrid.length</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - data observed</dd>
<dd><code>xGrid</code> - the grid of data at which to apply the kernel.</dd>
<dd><code>h</code> - bandwidth</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="convertToComplex(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertToComplex</h4>
<pre class="methodSignature">protected static&nbsp;<a href="Complex.html" title="class in algorithms.misc">Complex</a>[]&nbsp;convertToComplex&#8203;(double[]&nbsp;a)</pre>
</li>
</ul>
<a id="createFineHistogram(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createFineHistogram</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createFineHistogram&#8203;(double[]&nbsp;x,
                                             double&nbsp;h)</pre>
<div class="block">calculate a fine resolution histogram for x, for a larger data range than x's.
 (NOTE that if the data are circular, a method can be created to calculate the histogram
 using the same data range as x, not larger)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2-dimensional array of the histogram where hist[0] holds the centers of the histogram bins,
 and hist[1] holds the counts within the bins.</dd>
</dl>
</li>
</ul>
<a id="createFineHistogram(double[],double,int,double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createFineHistogram</h4>
<pre class="methodSignature">protected static&nbsp;double[][]&nbsp;createFineHistogram&#8203;(double[]&nbsp;x,
                                                double&nbsp;h,
                                                int&nbsp;nBins,
                                                double&nbsp;binWidth,
                                                double&nbsp;minBin,
                                                double&nbsp;maxBin)</pre>
<div class="block">calculate a fine resolution histogram for x, for a larger data range than x's.
 (NOTE that if the data are circular, a method can be created to calculate the histogram
 using the same data range as x, not larger)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2-dimensional array of the histogram where hist[0] holds the centers of the histogram bins,
 and hist[1] holds the counts within the bins.</dd>
</dl>
</li>
</ul>
<a id="createFineHistogramSubstitute(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createFineHistogramSubstitute</h4>
<pre class="methodSignature">protected static&nbsp;double[]&nbsp;createFineHistogramSubstitute&#8203;(double[]&nbsp;x)</pre>
<div class="block">calculate a substitute for the fine resolution histogram for x for use in the
 risk estimator that uses cross-validation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 2-dimensional array of the histogram where hist[0] holds the centers of the histogram bins,
 and hist[1] holds the counts within the bins.</dd>
</dl>
</li>
</ul>
<a id="viaFFTGaussKernel(algorithms.misc.Complex[],double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaFFTGaussKernel</h4>
<pre class="methodSignature">public static&nbsp;<a href="KernelDensityEstimator.KDE.html" title="class in algorithms.misc">KernelDensityEstimator.KDE</a>&nbsp;viaFFTGaussKernel&#8203;(<a href="Complex.html" title="class in algorithms.misc">Complex</a>[]&nbsp;u,
                                                           double[]&nbsp;histBins,
                                                           double&nbsp;h)</pre>
<div class="block">estimate the density by using properties of exponentials 
     (convolution, discrete FFT, fourier pairs ...) to make a faster algorithm.
     <pre>
           reference:
           Silverman, B. W. (1982). Algorithm as 176: Kernel density estimation using the fast Fourier transform. Journal of the Royal Statistical Society. Series C (Applied Statistics), 31(1), 93-99. https://dx.doi.org/10.2307/2347084.
           https://www.jstor.org/stable/2347084#metadata_info_tab_contents
     </pre>
     calculate the KDE in a fast manner by using discrete FFTs and using a grid of data points
     the kde = f_hat(x) ~ summation over i=1 to n of (K(|| x - X_i ||/h).
     the kernel estimate is a convolution of the data with the kernel.
     A naive implementation such as the method viaGaussKernel() is O(n^2).
     If the kernel K is chosen to be a Gaussian, one can use a property of exponentials to rewrite:
     exp(x - X_i) = exp(x) * exp(-X_i) (neglecting details)
     also note that the discrete FFT is a summation of exponentials.
     convolution theorem: one can use the pointwise multiplication between the fourier paired functions.
     (Chap 15.5, Boas "Mathematical Methods in the Physical Sciences")
     convolution to FFT:
     FFT(kde) ~ FFT(K(h*s)) * FFT( hist(X) )
     one can choose s to be the same spatial intervals (=grid) in the histogram
     and in the kernel, to avoid interpolation.  the multiplication is pointwise.
     then inverse FFT of FFT(kde) = kde.
     the runtime complexity is then O(n_s*log(n_s))
 The Gaussian Kernel with discrete fast fourier transforms is O(s*log(s)).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>u</code> - the FFT of the histogram of the data.</dd>
<dd><code>histBins</code> - the x bins of the histogram of the data that were used to create u</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>kernel density estimate</dd>
</dl>
</li>
</ul>
<a id="sumKDE(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sumKDE</h4>
<pre class="methodSignature">static&nbsp;double&nbsp;sumKDE&#8203;(double[]&nbsp;kde,
                     double&nbsp;dk)</pre>
</li>
</ul>
<a id="assertHistRange(double[],double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>assertHistRange</h4>
<pre class="methodSignature">protected static&nbsp;boolean&nbsp;assertHistRange&#8203;(double[]&nbsp;histBins,
                                         double[]&nbsp;dataMinMax,
                                         double&nbsp;h)</pre>
</li>
</ul>
<a id="univariateKernelDensityEstimate(algorithms.misc.IKernel,double,double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>univariateKernelDensityEstimate</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;univariateKernelDensityEstimate&#8203;(<a href="IKernel.html" title="interface in algorithms.misc">IKernel</a>&nbsp;kernel,
                                                     double&nbsp;x,
                                                     double[]&nbsp;xTilde,
                                                     double&nbsp;h)</pre>
<div class="block">estimate the KDE for a single value x.
     NOTE that this method is not efficent if used to calculate many x.  one should instead use the FFT method.
     <pre>
     Wasserman chap 20:
     let X_0,...X_{N-1) denote the observed data which is a sample from f (= probability distribution).
     K is the kernel.
     the1-Dimensional  KDE estimator f_hat(x) = (1/n) * sum_i=0_to_{N-1} ( (1/h) * K((x - X_i)/h).
     runtime complexity is O(xTilde.length).
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>kernel</code> - </dd>
<dd><code>x</code> - </dd>
<dd><code>xTilde</code> - the observed data</dd>
<dd><code>h</code> - the kernel bandwidth</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the kde at x</dd>
</dl>
</li>
</ul>
<a id="crossValidationScore(algorithms.misc.Complex[],double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crossValidationScore</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;crossValidationScore&#8203;(<a href="Complex.html" title="class in algorithms.misc">Complex</a>[]&nbsp;u,
                                          double[]&nbsp;histBins,
                                          double&nbsp;h)</pre>
<div class="block">a fast cross-validation method which can be used in choosing the bandwidth for the kernel density estimator.
 the runtime complexity is max( O(n), O(n_s*log_2(ns)))
  where n is the data length, and n_s is the number of elements in the data histogram
 (which is equal to u.length).
 This method is implemented for 1-D only, but the references (eqn 27) provide a formula for multiple dimensions.

 NOTE: this method is not ready for use.  I altered the normalization of one of the terms,
 but the change is a fudge.  This comment will be removed when corrected.
     <pre>
     References:
     Wasserman, "All of Statistics", eqn (20.25)
     and
     https://www.stat.cmu.edu/~larry/=sml/densityestimation.pdf
     36-708 Statistical Methods for Machine Learning by Larry Wasserman, CMU
     eqn (27) (which is (27)+(28))
     and
     Indirect Cross-validation for Density Estimation
     Olga Y. Savchuk, Jeffrey D. Hart, Simon J. Sheather
     https://doi.org/10.48550/arxiv.0812.0051,
     https://arxiv.org/abs/0812.0051,
     eqn (2).
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>u</code> - fft of the histogram of the data.</dd>
<dd><code>histBins</code> - the x axis of the histogram of the data.</dd>
<dd><code>h</code> - the bandwidth to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cross validation score</dd>
</dl>
</li>
</ul>
<a id="riskEstimatorLeaveOneOut()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>riskEstimatorLeaveOneOut</h4>
<pre class="methodSignature">static&nbsp;double&nbsp;riskEstimatorLeaveOneOut()</pre>
<div class="block">calculate the risk estimator for the "leave-one-out" method of cross validation.
 This method can be used to select a kde bandwidth by minimizing the risk estimator for a range
 of bandwidths.  It is a data based method as the true probability distribution is unknown.
     <pre>
     see eqn (20.24) of Wasserman's "All of Statistics"
     see eqn (26) of
     https://www.stat.cmu.edu/~larry/=sml/densityestimation.pdf
     36-708 Statistical Methods for Machine Learning by Larry Wasserman, CMU
     </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="riskEstimatorDataSplitting()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>riskEstimatorDataSplitting</h4>
<pre class="methodSignature">static&nbsp;double&nbsp;riskEstimatorDataSplitting()</pre>
<div class="block">calculate the risk estimator for the "data-splitting" V-fold or k-fold method of cross validation.
 This method can be used to select a kde bandwidth by minimizing the risk estimator for a range
 of bandwidths.  It is a data based method as the true probability distribution is unknown.
     <pre>
     see eqn (20.24) of Wasserman's "All of Statistics".
     see eqn (26) of
     https://www.stat.cmu.edu/~larry/=sml/densityestimation.pdf
     36-708 Statistical Methods for Machine Learning by Larry Wasserman, CMU
     </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="riskEstimatorGaussianKernel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>riskEstimatorGaussianKernel</h4>
<pre class="methodSignature">static&nbsp;double&nbsp;riskEstimatorGaussianKernel()</pre>
<div class="block">calculate the risk estimator for the "leave-one-out" method of cross validation.
 This method can be used to select a kde bandwidth by minimizing the risk estimator for a range
 of bandwidths.  It is a data based method as the true probability distribution is unknown.
     <pre>
     see eqn (27), (28) of
     https://www.stat.cmu.edu/~larry/=sml/densityestimation.pdf
     36-708 Statistical Methods for Machine Learning by Larry Wasserman, CMU.
     see eqn (20.24) of Wasserman's "All of Statistics"
     </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sumHistogram(double[][])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>sumHistogram</h4>
<pre class="methodSignature">static&nbsp;double&nbsp;sumHistogram&#8203;(double[][]&nbsp;hist)</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
