<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Mon Oct 31 15:46:45 PDT 2022 -->
<title>WordLevelParallelism</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-10-31">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="WordLevelParallelism";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.misc</a></div>
<h2 title="Class WordLevelParallelism" class="title">Class WordLevelParallelism</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.misc.WordLevelParallelism</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">WordLevelParallelism</span>
extends java.lang.Object</pre>
<div class="block">word-level parallel operations.
 useful for classes such as the FusionTree.
 <pre>
  methods are implemented following lecture notes in
  http://web.stanford.edu/class/cs166/
  and
  ____ add other reference ---
  The MSB methods are ports of the c code at
  http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
  refactored here to use a variable tile size.
 </pre></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">WordLevelParallelism</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createTiledBitMask1(int,int)">createTiledBitMask1</a></span>&#8203;(int&nbsp;nTiles,
                   int&nbsp;bitstringLength)</code></th>
<td class="colLast">
<div class="block">create a bitmask array of set bits at the location of separators in the concatenation of
 nTiles of length bitstringLength.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createTiledBitstring0(int%5B%5D,int)">createTiledBitstring0</a></span>&#8203;(int[]&nbsp;values,
                     int&nbsp;bitstringLength)</code></th>
<td class="colLast">
<div class="block">given an array of bitstringLength values, concatenate them and insert 0's on the high
 end of each value.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createTiledBitstring1(int,int,int)">createTiledBitstring1</a></span>&#8203;(int&nbsp;value,
                     int&nbsp;nTiles,
                     int&nbsp;bitstringLength)</code></th>
<td class="colLast">
<div class="block">given a bitstring called value which is much smaller than a machine word,
 create a bitarray (word) with nTiles number of copies of value,
 concatenated, with 1's in between them and on the high end.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn(long,int)">highestBitSetIn</a></span>&#8203;(long&nbsp;value,
               int&nbsp;valueBitLength)</code></th>
<td class="colLast">
<div class="block">Given an n-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn1(long)">highestBitSetIn1</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn2(long)">highestBitSetIn2</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn3(long)">highestBitSetIn3</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given a 3-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn4(long)">highestBitSetIn4</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given a 4-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn5(long)">highestBitSetIn5</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given a 5-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn6(long)">highestBitSetIn6</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given a 6-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn7(long)">highestBitSetIn7</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given a 7-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBitSetIn8(long)">highestBitSetIn8</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Given an 8-bit value, returns the index of the highest 1 bit within that
 value.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestBlockSetIn(long,int,int)">highestBlockSetIn</a></span>&#8203;(long&nbsp;tiled,
                 int&nbsp;nTiles,
                 int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">Given a 64-bit integer, returns the index of the block within that integer
 that contains a 1 bit, where the index is zero-based numbering.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestOneBitIn(long)">highestOneBitIn</a></span>&#8203;(long&nbsp;tiled)</code></th>
<td class="colLast">
<div class="block">finds the highest set bit in the bitstring tiled.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#highestOneBitIn(long,int,int)">highestOneBitIn</a></span>&#8203;(long&nbsp;tiled,
               int&nbsp;nTiles,
               int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">finds the highest set bit in the bitstring tiled.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maxNumberOfTiles(int)">maxNumberOfTiles</a></span>&#8203;(int&nbsp;blockSize)</code></th>
<td class="colLast">
<div class="block">returns the maximum number of blockSize tiles that can fit into a java unsigned
 long (= 63 bits).</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelCompare00(long,long,int,int)">parallelCompare00</a></span>&#8203;(long&nbsp;tiled1,
                 long&nbsp;tiled2,
                 int&nbsp;nTiles,
                 int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelCompare008(long,long,int)">parallelCompare008</a></span>&#8203;(long&nbsp;tiled1,
                  long&nbsp;tiled2,
                  int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">parallel compare of tiled1 to tiled2 which both have block sizes of 8 and have flag bits
 of '0' separating the embedded 7-bit tiles.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelCompare108(long,long,int,long)">parallelCompare108</a></span>&#8203;(long&nbsp;tiled1,
                  long&nbsp;tiled2,
                  int&nbsp;nTiles,
                  long&nbsp;mask1)</code></th>
<td class="colLast">
<div class="block">parallel compare of tiled1 to tiled2 both of which have block size 8 and
 embedded tiles of size 7-bits.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelSum(long,int,int)">parallelSum</a></span>&#8203;(long&nbsp;comparison,
           int&nbsp;nTiles,
           int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">sum the set bits of bitstring comparison.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parallelSum8(long,int)">parallelSum8</a></span>&#8203;(long&nbsp;comparison,
            int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">sum the set bits of the comparison bitstring which has a block size of 8 and embedded tiles of
 size 7-bits.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rank(long,long,int,int)">rank</a></span>&#8203;(long&nbsp;tiled1,
    long&nbsp;tiled2,
    int&nbsp;nTiles,
    int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rank(long,long,int,int,long)">rank</a></span>&#8203;(long&nbsp;tiled1,
    long&nbsp;tiled2,
    int&nbsp;nTiles,
    int&nbsp;tileBitLength,
    long&nbsp;mask1)</code></th>
<td class="colLast">
<div class="block">calculate the rank of the replicated query tile in tiled1 with respect to the tiled keys
 in tiled2.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch(long,int,int)">sketch</a></span>&#8203;(long&nbsp;tiled,
      int&nbsp;nTiles,
      int&nbsp;tileBitLength)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags, extract and return the flags.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch2(long)">sketch2</a></span>&#8203;(long&nbsp;tiled)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of  bits
 and embedded tile size of 1 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch3(long,int)">sketch3</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch4(long,int)">sketch4</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch5(long,int)">sketch5</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch6(long,int)">sketch6</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch7(long,int)">sketch7</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sketch8(long,int)">sketch8</a></span>&#8203;(long&nbsp;tiled,
       int&nbsp;nTiles)</code></th>
<td class="colLast">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 8 bits
 and embedded tile size of 7 bits, extract and return the flags as consecutive bits.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn(long,int)">usedBlocksIn</a></span>&#8203;(long&nbsp;value,
            int&nbsp;blockSize)</code></th>
<td class="colLast">
<div class="block">Returns a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn1(long)">usedBlocksIn1</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn2(long)">usedBlocksIn2</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn3(long)">usedBlocksIn3</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn4(long)">usedBlocksIn4</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn5(long)">usedBlocksIn5</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn6(long)">usedBlocksIn6</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">For a tiled value whose block size = 6 bits (and hence, the embedded tile size is 5 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn7(long)">usedBlocksIn7</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">For a tiled value whose block size = 7 bits (and hence, the embedded tile size is 6 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>(package private) static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#usedBlocksIn8(long)">usedBlocksIn8</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">For a tiled value whose block size = 8 bits (and hence, the embedded tile size is 7 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>WordLevelParallelism</h4>
<pre>public&nbsp;WordLevelParallelism()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="highestOneBitIn(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestOneBitIn</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;highestOneBitIn&#8203;(long&nbsp;tiled)</pre>
<div class="block">finds the highest set bit in the bitstring tiled.  the method is a.k.a. MSB.
 MSB(tiled) is the largest value of k such that 2^k ≤ tiled.
 uses O(1) machine operations and O(1) space.
 <pre>
     reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     then edited here for variable block size and number of tiles packed into tiled.
     see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
 </pre>
 An example of where MSB is used:
 In the sparse table Range Minimum Queries (RMQ) structure,
 where computing RMQ(i, j) requires computing
 the largest number k where 2^k ≤ (j–i+1), k = msb(j – i + 1).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the index of the highest nonzero bit in tiled.  returns a negative number if no bits are set in tiled.</dd>
</dl>
</li>
</ul>
<a id="highestOneBitIn(long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestOneBitIn</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;highestOneBitIn&#8203;(long&nbsp;tiled,
                                   int&nbsp;nTiles,
                                   int&nbsp;tileBitLength)</pre>
<div class="block">finds the highest set bit in the bitstring tiled.  the method is a.k.a. MSB.
 MSB(tiled) is the largest value of k such that 2^k ≤ tiled.
 uses O(1) machine operations and O(1) space.
 <pre>
     reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     then edited here for variable block size and number of tiles packed into tiled.
     see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
 </pre>
 An example of where MSB is used:
 In the sparse table Range Minimum Queries (RMQ) structure,
 where computing RMQ(i, j) requires computing
 the largest number k where 2^k ≤ (j–i+1), k = msb(j – i + 1).
  The operation is ~33 to a few times that operations.
  Consider using instead Long.highestOneBitIn() which uses the Henry S. Warren, Jr.'s Hacker's Delight
  bit twiddling for 14 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dd><code>nTiles</code> - the number of tiles packed into the bitarray tiled.</dd>
<dd><code>tileBitLength</code> - the size of a tile before a gap is appended to it.  the block size is tileBitlength + 1.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the index of the highest nonzero bit in tiled.  returns a negative number if no bits are set in tiled.</dd>
</dl>
</li>
</ul>
<a id="highestBlockSetIn(long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBlockSetIn</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBlockSetIn&#8203;(long&nbsp;tiled,
                              int&nbsp;nTiles,
                              int&nbsp;tileBitLength)</pre>
<div class="block">Given a 64-bit integer, returns the index of the block within that integer
 that contains a 1 bit, where the index is zero-based numbering.
     <pre>
          reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
          then edited here for variable block size and number of tiles packed into tiled.
          see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     </pre>
 the method is ~ 21 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - the bitarray of tiled integers.</dd>
<dd><code>nTiles</code> - the number of tiles embedded in tiled.</dd>
<dd><code>tileBitLength</code> - the length of each tile in tiled, not counting the surrounding single flag bits.
                      the block size is tileBitLength + 1.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return the largest index of the block within tiled that contains a set bit, else returns a
 negative number if there are no set bits in tiled.  the block size is tileBitLength + 1.</dd>
</dl>
</li>
</ul>
<a id="createTiledBitstring0(int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createTiledBitstring0</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;createTiledBitstring0&#8203;(int[]&nbsp;values,
                                         int&nbsp;bitstringLength)</pre>
<div class="block">given an array of bitstringLength values, concatenate them and insert 0's on the high
 end of each value.
 e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
 tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
 each tileBitLength bitstring, making a bitstring of length 16.
 <p>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (values.length * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent values.length is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from values array in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>values</code> - array of bitstrings, each of length bitstringLength</dd>
<dd><code>bitstringLength</code> - the bitlength of each value in values.  the tile for each will be bitstringLength + 1
                        bits long.  the total tiled result will be values.length * (bitstringLength + 1) bits.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the bitarray holding the bitarray of replicated values with '0' separators.</dd>
</dl>
</li>
</ul>
<a id="createTiledBitMask1(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createTiledBitMask1</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;createTiledBitMask1&#8203;(int&nbsp;nTiles,
                                int&nbsp;bitstringLength)</pre>
<div class="block">create a bitmask array of set bits at the location of separators in the concatenation of
 nTiles of length bitstringLength.
 e.g. for nTiles=2 and bitstringLength=7, the resulting bitmask is 0b1000000010000000
 which is 16 bits.
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nTiles</code> - the number of tiles of bitstringLength for which this mask will be calculated.</dd>
<dd><code>bitstringLength</code> - the bit-length of each tile</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the bitarray holding the bitarray of '1' separators for nTiles of length bitstringLength.
 e.g. for nTiles=2 and bitstringLength=7, the resulting bitmask is 0b1000000010000000
 which is 16 bits.</dd>
</dl>
</li>
</ul>
<a id="createTiledBitstring1(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createTiledBitstring1</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;createTiledBitstring1&#8203;(int&nbsp;value,
                                         int&nbsp;nTiles,
                                         int&nbsp;bitstringLength)</pre>
<div class="block">given a bitstring called value which is much smaller than a machine word,
 create a bitarray (word) with nTiles number of copies of value,
 concatenated, with 1's in between them and on the high end.
 e.g. for 7-bit value 0b1100111 and nTiles=2, the returned bitarray would be 0b1110011111100111.
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - bitstring of length .lte. bitstringLength</dd>
<dd><code>nTiles</code> - the number of copies of value to set in the returned bitarray</dd>
<dd><code>bitstringLength</code> - the length of tiling before the 1's are concatenated as separators.
                        e.g. for a bitstringLength of 5 and nTiles=10, the resulting bitarray is length 10*(5+1)=60 bits</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the bitarray holding the bitarray of replicated values with '1' separators.</dd>
</dl>
</li>
</ul>
<a id="parallelCompare00(long,long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelCompare00</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;parallelCompare00&#8203;(long&nbsp;tiled1,
                                     long&nbsp;tiled2,
                                     int&nbsp;nTiles,
                                     int&nbsp;tileBitLength)</pre>
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - the number of tiles in the bitarray tiled1 or tiled2 (which should be the same number of tiles).</dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</li>
</ul>
<a id="parallelCompare008(long,long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelCompare008</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;parallelCompare008&#8203;(long&nbsp;tiled1,
                                      long&nbsp;tiled2,
                                      int&nbsp;nTiles)</pre>
<div class="block">parallel compare of tiled1 to tiled2 which both have block sizes of 8 and have flag bits
 of '0' separating the embedded 7-bit tiles.
 returns a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - the number of tiles in the bitarray tiled1 or tiled2 (which should be the same number of tiles).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</li>
</ul>
<a id="rank(long,long,int,int,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rank</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;rank&#8203;(long&nbsp;tiled1,
                        long&nbsp;tiled2,
                        int&nbsp;nTiles,
                        int&nbsp;tileBitLength,
                        long&nbsp;mask1)</pre>
<div class="block">calculate the rank of the replicated query tile in tiled1 with respect to the tiled keys
 in tiled2.  This method performs a parallel compare of tiled1 to tiled2,
 masks the result, and then sums the number of set bits in the masked result.
 The calculated rank requires that the keys embedded in tiled2 are ordered.
 The calculated rank is the number of flags of blocks in tiled2 that are less than or equal to those
 in the query (which is replicated in tiled1).
 The method is O(1) (5 operations).
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstring 0b0010100 replicated 2 times using a bitlength of 7 bits,
                      the resulting tiled1 is bitstring of length 16 bits which has 2 blocks of size 8 bits,
                      = 0b10010100_10010100.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled2 is 0b00100100_01100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dd><code>mask1</code> - the 1's mask (same used in setting the gap bits in tiled1)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The calculated rank is the number of flags of blocks in tiled2 that are less than or equal to those
 in the query (which is replicated in tiled1).</dd>
</dl>
</li>
</ul>
<a id="rank(long,long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rank</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;rank&#8203;(long&nbsp;tiled1,
                        long&nbsp;tiled2,
                        int&nbsp;nTiles,
                        int&nbsp;tileBitLength)</pre>
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b1010010011100111, where 1's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</li>
</ul>
<a id="parallelCompare108(long,long,int,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelCompare108</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;parallelCompare108&#8203;(long&nbsp;tiled1,
                               long&nbsp;tiled2,
                               int&nbsp;nTiles,
                               long&nbsp;mask1)</pre>
<div class="block">parallel compare of tiled1 to tiled2 both of which have block size 8 and
 embedded tiles of size 7-bits.
 this method returns a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b1010010011100111, where 1's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>mask1</code> - the 1's mask (same used in setting the gap bits in tiled1)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</li>
</ul>
<a id="parallelSum(long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelSum</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;parallelSum&#8203;(long&nbsp;comparison,
                        int&nbsp;nTiles,
                        int&nbsp;tileBitLength)</pre>
<div class="block">sum the set bits of bitstring comparison.  the flags that may have set bits are the MSB of each block.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 This is 3 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>comparison</code> - a bit array with flags at the MSB of each block.  The flags that are set bits
                      are summed in this method.</dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</li>
</ul>
<a id="parallelSum8(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallelSum8</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;parallelSum8&#8203;(long&nbsp;comparison,
                         int&nbsp;nTiles)</pre>
<div class="block">sum the set bits of the comparison bitstring which has a block size of 8 and embedded tiles of
 size 7-bits.  this method sums the set bits at the high end of each block and returns the result.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 this is ~ 6 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>comparison</code> - a bit array with flags at the MSB of each block.  The flags that are set bits
                      are summed in this method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sum of the set bits of the MSB of each 8-bit block.</dd>
</dl>
</li>
</ul>
<a id="sketch(long,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch&#8203;(long&nbsp;tiled,
                          int&nbsp;nTiles,
                          int&nbsp;tileBitLength)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags, extract and return the flags.
 e.g. if tiled were A0000000B0000000C0000000D0000000, this method would return ABCD.
 This is also known as "parallel pack".
     <pre>
     references:
     lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
          and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp

     https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge

     </pre>
     The method is ~ 3 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dd><code>nTiles</code> - the number of tiles packed into the bitarray tiled.</dd>
<dd><code>tileBitLength</code> - the size of a tile before a gap is appended to it.  the block size is tileBitlength + 1.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch8(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch8</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch8&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 8 bits
 and embedded tile size of 7 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0000000B0000000C0000000D0000000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch7(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch7</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch7&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A000000B000000C000000D000000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 7 embedded in tiled.  maximum nTiles is 9.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch6(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch6</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch6&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A00000B00000C00000D00000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge

     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 6 embedded in tiled.  the maximum number for the java unsigned
               long is 10 tiles of block size 6.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch5(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch5</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch5&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0000B0000C0000D0000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 5 embedded in tiled.  the maximum number of 12 for nTiles for
               block size of 5 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch4(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch4</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch4&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A000B000C000D000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 4 embedded in tiled.  the maximum number of 15 for nTiles for
               block size of 4 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch3(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch3</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch3&#8203;(long&nbsp;tiled,
                           int&nbsp;nTiles)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A00B00C00D00, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 3 embedded in tiled.  the maximum number of 21 for nTiles for
               block size of 3 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sketch2(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sketch2</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;sketch2&#8203;(long&nbsp;tiled)</pre>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of  bits
 and embedded tile size of 1 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0B0C0D0, this method would return ABCD.
     <pre>
     reference:
     https://stackoverflow.com/questions/30539347/2d-morton-code-encode-decode-64bits
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 2 bits
 and embedded tile size of 1 bits</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="highestBitSetIn(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;highestBitSetIn&#8203;(long&nbsp;value,
                                   int&nbsp;valueBitLength)</pre>
<div class="block">Given an n-bit value, returns the index of the highest 1 bit within that
 value.  the input is not tiled.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a bitlength number.</dd>
<dd><code>valueBitLength</code> - the bit length of value.  range is [1,8] inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest bit set in value.  the bit number is w.r.t. 0.
 e.g. if blockSize is 8, the return value range is [0,7] inclusive.
 the result is a negative number if there are no bits set in value.</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn8(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn8</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn8&#8203;(long&nbsp;value)</pre>
<div class="block">Given an 8-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 This subroutine is where much of the magic happens with regards to the
 overall algorithm. The idea is that if we can get down to an eight-bit
 number, we can manually check each power of two that could serve as the
 most-significant bit. This is actually done using a clever parallel
 comparison step, describe below.
 this is ~10 operations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - an 8-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn7(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn7</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn7&#8203;(long&nbsp;value)</pre>
<div class="block">Given a 7-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a 7-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn6(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn6</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn6&#8203;(long&nbsp;value)</pre>
<div class="block">Given a 6-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a 6-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn5(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn5</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn5&#8203;(long&nbsp;value)</pre>
<div class="block">Given a 5-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a 5-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn4(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn4</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn4&#8203;(long&nbsp;value)</pre>
<div class="block">Given a 4-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a 4-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn3(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn3</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn3&#8203;(long&nbsp;value)</pre>
<div class="block">Given a 3-bit value, returns the index of the highest 1 bit within that
 value.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - a 3-bit number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</li>
</ul>
<a id="highestBitSetIn2(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn2</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn2&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="highestBitSetIn1(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>highestBitSetIn1</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;highestBitSetIn1&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="usedBlocksIn(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn</h4>
<pre class="methodSignature">public static&nbsp;long&nbsp;usedBlocksIn&#8203;(long&nbsp;value,
                                int&nbsp;blockSize)</pre>
<div class="block">Returns a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh

 We'll return a 64-bit flag integer

   A0000000B0000000C0000000D0000000E0000000F0000000G0000000H0000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
</li>
</ul>
<a id="usedBlocksIn8(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn8</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn8&#8203;(long&nbsp;value)</pre>
<div class="block">For a tiled value whose block size = 8 bits (and hence, the embedded tile size is 7 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh

 We'll return a 64-bit flag integer

   A0000000B0000000C0000000D0000000E0000000F0000000G0000000H0000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
     The method is 5 operations.</div>
</li>
</ul>
<a id="usedBlocksIn7(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn7</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn7&#8203;(long&nbsp;value)</pre>
<div class="block">For a tiled value whose block size = 7 bits (and hence, the embedded tile size is 6 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaabbbbbbbcccccccdddddddeeeeeeefffffffggggggghhhhhhh

 We'll return a 64-bit flag integer

   A000000B000000C000000D000000E000000F000000G000000H000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
</li>
</ul>
<a id="usedBlocksIn6(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn6</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn6&#8203;(long&nbsp;value)</pre>
<div class="block">For a tiled value whose block size = 6 bits (and hence, the embedded tile size is 5 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaabbbbbbccccccddddddeeeeeeffffffgggggghhhhhh

 We'll return a 64-bit flag integer

   A00000B00000C00000D00000E00000F00000G00000H00000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
</li>
</ul>
<a id="usedBlocksIn5(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn5</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn5&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="usedBlocksIn4(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn4</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn4&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="usedBlocksIn3(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn3</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn3&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="usedBlocksIn2(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn2</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn2&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="usedBlocksIn1(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usedBlocksIn1</h4>
<pre class="methodSignature">static&nbsp;long&nbsp;usedBlocksIn1&#8203;(long&nbsp;value)</pre>
</li>
</ul>
<a id="maxNumberOfTiles(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>maxNumberOfTiles</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;maxNumberOfTiles&#8203;(int&nbsp;blockSize)</pre>
<div class="block">returns the maximum number of blockSize tiles that can fit into a java unsigned
 long (= 63 bits).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>blockSize</code> - the size of blocks</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the maximum number of blockSize tiles that can fit into a java unsigned
     long (= 63 bits).</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
