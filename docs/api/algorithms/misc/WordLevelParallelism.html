<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Mon Nov 25 09:43:20 PST 2024 -->
<title>WordLevelParallelism</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-11-25">
<meta name="description" content="declaration: package: algorithms.misc, class: WordLevelParallelism">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.misc</a></div>
<h1 title="Class WordLevelParallelism" class="title">Class WordLevelParallelism</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.misc.WordLevelParallelism</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">WordLevelParallelism</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">word-level parallel operations.
 useful for classes such as the FusionTree.
 <pre>
  methods are implemented following lecture notes in
  http://web.stanford.edu/class/cs166/
  and
  ____ add other reference ---
  The MSB methods are ports of the c code at
  http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
  refactored here to use a variable tile size.
 </pre></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">WordLevelParallelism</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createTiledBitMask1(int,int)" class="member-name-link">createTiledBitMask1</a><wbr>(int&nbsp;nTiles,
 int&nbsp;bitstringLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a bitmask array of set bits at the location of separators in the concatenation of
 nTiles of length bitstringLength.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createTiledBitstring0(int%5B%5D,int)" class="member-name-link">createTiledBitstring0</a><wbr>(int[]&nbsp;values,
 int&nbsp;bitstringLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given an array of bitstringLength values, concatenate them and insert 0's on the high
 end of each value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createTiledBitstring1(int,int,int)" class="member-name-link">createTiledBitstring1</a><wbr>(int&nbsp;value,
 int&nbsp;nTiles,
 int&nbsp;bitstringLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitstring called value which is much smaller than a machine word,
 create a bitarray (word) with nTiles number of copies of value,
 concatenated, with 1's in between them and on the high end.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn(long,int)" class="member-name-link">highestBitSetIn</a><wbr>(long&nbsp;value,
 int&nbsp;valueBitLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given an n-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn1(long)" class="member-name-link">highestBitSetIn1</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn2(long)" class="member-name-link">highestBitSetIn2</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn3(long)" class="member-name-link">highestBitSetIn3</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 3-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn4(long)" class="member-name-link">highestBitSetIn4</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 4-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn5(long)" class="member-name-link">highestBitSetIn5</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 5-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn6(long)" class="member-name-link">highestBitSetIn6</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 6-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn7(long)" class="member-name-link">highestBitSetIn7</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 7-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBitSetIn8(long)" class="member-name-link">highestBitSetIn8</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given an 8-bit value, returns the index of the highest 1 bit within that
 value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestBlockSetIn(long,int,int)" class="member-name-link">highestBlockSetIn</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 64-bit integer, returns the index of the block within that integer
 that contains a 1 bit, where the index is zero-based numbering.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestOneBitIn(long)" class="member-name-link">highestOneBitIn</a><wbr>(long&nbsp;tiled)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">finds the highest set bit in the bitstring tiled.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#highestOneBitIn(long,int,int)" class="member-name-link">highestOneBitIn</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">finds the highest set bit in the bitstring tiled.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#maxNumberOfTiles(int)" class="member-name-link">maxNumberOfTiles</a><wbr>(int&nbsp;blockSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">returns the maximum number of blockSize tiles that can fit into a java unsigned
 long (= 63 bits).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#parallelCompare00(long,long,int,int)" class="member-name-link">parallelCompare00</a><wbr>(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#parallelCompare008(long,long,int)" class="member-name-link">parallelCompare008</a><wbr>(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">parallel compare of tiled1 to tiled2 which both have block sizes of 8 and have flag bits
 of '0' separating the embedded 7-bit tiles.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#parallelCompare108(long,long,int,long)" class="member-name-link">parallelCompare108</a><wbr>(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 long&nbsp;mask1)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">parallel compare of tiled1 to tiled2 both of which have block size 8 and
 embedded tiles of size 7-bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#parallelSum(long,int,int)" class="member-name-link">parallelSum</a><wbr>(long&nbsp;comparison,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">sum the set bits of bitstring comparison.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#parallelSum8(long,int)" class="member-name-link">parallelSum8</a><wbr>(long&nbsp;comparison,
 int&nbsp;nTiles)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">sum the set bits of the comparison bitstring which has a block size of 8 and embedded tiles of
 size 7-bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(long,long,int,int)" class="member-name-link">rank</a><wbr>(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(long,long,int,int,long)" class="member-name-link">rank</a><wbr>(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength,
 long&nbsp;mask1)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the rank of the replicated query tile in tiled1 with respect to the tiled keys
 in tiled2.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch(long,int,int)" class="member-name-link">sketch</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags, extract and return the flags.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch2(long)" class="member-name-link">sketch2</a><wbr>(long&nbsp;tiled)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of  bits
 and embedded tile size of 1 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch3(long,int)" class="member-name-link">sketch3</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch4(long,int)" class="member-name-link">sketch4</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch5(long,int)" class="member-name-link">sketch5</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch6(long,int)" class="member-name-link">sketch6</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch7(long,int)" class="member-name-link">sketch7</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sketch8(long,int)" class="member-name-link">sketch8</a><wbr>(long&nbsp;tiled,
 int&nbsp;nTiles)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 8 bits
 and embedded tile size of 7 bits, extract and return the flags as consecutive bits.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn(long,int)" class="member-name-link">usedBlocksIn</a><wbr>(long&nbsp;value,
 int&nbsp;blockSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn1(long)" class="member-name-link">usedBlocksIn1</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn2(long)" class="member-name-link">usedBlocksIn2</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn3(long)" class="member-name-link">usedBlocksIn3</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn4(long)" class="member-name-link">usedBlocksIn4</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn5(long)" class="member-name-link">usedBlocksIn5</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn6(long)" class="member-name-link">usedBlocksIn6</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">For a tiled value whose block size = 6 bits (and hence, the embedded tile size is 5 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn7(long)" class="member-name-link">usedBlocksIn7</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">For a tiled value whose block size = 7 bits (and hence, the embedded tile size is 6 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#usedBlocksIn8(long)" class="member-name-link">usedBlocksIn8</a><wbr>(long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">For a tiled value whose block size = 8 bits (and hence, the embedded tile size is 7 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>WordLevelParallelism</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">WordLevelParallelism</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="highestOneBitIn(long)">
<h3>highestOneBitIn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestOneBitIn</span><wbr><span class="parameters">(long&nbsp;tiled)</span></div>
<div class="block">finds the highest set bit in the bitstring tiled.  the method is a.k.a. MSB.
 MSB(tiled) is the largest value of k such that 2^k ≤ tiled.
 uses O(1) machine operations and O(1) space.
 <pre>
     reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     then edited here for variable block size and number of tiles packed into tiled.
     see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
 </pre>
 An example of where MSB is used:
 In the sparse table Range Minimum Queries (RMQ) structure,
 where computing RMQ(i, j) requires computing
 the largest number k where 2^k ≤ (j–i+1), k = msb(j – i + 1).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dt>Returns:</dt>
<dd>the index of the highest nonzero bit in tiled.  returns a negative number if no bits are set in tiled.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestOneBitIn(long,int,int)">
<h3>highestOneBitIn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestOneBitIn</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">finds the highest set bit in the bitstring tiled.  the method is a.k.a. MSB.
 MSB(tiled) is the largest value of k such that 2^k ≤ tiled.
 uses O(1) machine operations and O(1) space.
 <pre>
     reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     then edited here for variable block size and number of tiles packed into tiled.
     see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
 </pre>
 An example of where MSB is used:
 In the sparse table Range Minimum Queries (RMQ) structure,
 where computing RMQ(i, j) requires computing
 the largest number k where 2^k ≤ (j–i+1), k = msb(j – i + 1).
  The operation is ~33 to a few times that operations.
  Consider using instead Long.highestOneBitIn() which uses the Henry S. Warren, Jr.'s Hacker's Delight
  bit twiddling for 14 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dd><code>nTiles</code> - the number of tiles packed into the bitarray tiled.</dd>
<dd><code>tileBitLength</code> - the size of a tile before a gap is appended to it.  the block size is tileBitlength + 1.</dd>
<dt>Returns:</dt>
<dd>the index of the highest nonzero bit in tiled.  returns a negative number if no bits are set in tiled.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBlockSetIn(long,int,int)">
<h3>highestBlockSetIn</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBlockSetIn</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">Given a 64-bit integer, returns the index of the block within that integer
 that contains a 1 bit, where the index is zero-based numbering.
     <pre>
          reference http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
          then edited here for variable block size and number of tiles packed into tiled.
          see also lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     </pre>
 the method is ~ 21 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - the bitarray of tiled integers.</dd>
<dd><code>nTiles</code> - the number of tiles embedded in tiled.</dd>
<dd><code>tileBitLength</code> - the length of each tile in tiled, not counting the surrounding single flag bits.
                      the block size is tileBitLength + 1.</dd>
<dt>Returns:</dt>
<dd>return the largest index of the block within tiled that contains a set bit, else returns a
 negative number if there are no set bits in tiled.  the block size is tileBitLength + 1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createTiledBitstring0(int[],int)">
<h3>createTiledBitstring0</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">createTiledBitstring0</span><wbr><span class="parameters">(int[]&nbsp;values,
 int&nbsp;bitstringLength)</span></div>
<div class="block">given an array of bitstringLength values, concatenate them and insert 0's on the high
 end of each value.
 e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
 tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
 each tileBitLength bitstring, making a bitstring of length 16.
 <p>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (values.length * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent values.length is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from values array in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>values</code> - array of bitstrings, each of length bitstringLength</dd>
<dd><code>bitstringLength</code> - the bitlength of each value in values.  the tile for each will be bitstringLength + 1
                        bits long.  the total tiled result will be values.length * (bitstringLength + 1) bits.</dd>
<dt>Returns:</dt>
<dd>the bitarray holding the bitarray of replicated values with '0' separators.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createTiledBitMask1(int,int)">
<h3>createTiledBitMask1</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">createTiledBitMask1</span><wbr><span class="parameters">(int&nbsp;nTiles,
 int&nbsp;bitstringLength)</span></div>
<div class="block">create a bitmask array of set bits at the location of separators in the concatenation of
 nTiles of length bitstringLength.
 e.g. for nTiles=2 and bitstringLength=7, the resulting bitmask is 0b1000000010000000
 which is 16 bits.
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nTiles</code> - the number of tiles of bitstringLength for which this mask will be calculated.</dd>
<dd><code>bitstringLength</code> - the bit-length of each tile</dd>
<dt>Returns:</dt>
<dd>the bitarray holding the bitarray of '1' separators for nTiles of length bitstringLength.
 e.g. for nTiles=2 and bitstringLength=7, the resulting bitmask is 0b1000000010000000
 which is 16 bits.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createTiledBitstring1(int,int,int)">
<h3>createTiledBitstring1</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">createTiledBitstring1</span><wbr><span class="parameters">(int&nbsp;value,
 int&nbsp;nTiles,
 int&nbsp;bitstringLength)</span></div>
<div class="block">given a bitstring called value which is much smaller than a machine word,
 create a bitarray (word) with nTiles number of copies of value,
 concatenated, with 1's in between them and on the high end.
 e.g. for 7-bit value 0b1100111 and nTiles=2, the returned bitarray would be 0b1110011111100111.
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - bitstring of length .lte. bitstringLength</dd>
<dd><code>nTiles</code> - the number of copies of value to set in the returned bitarray</dd>
<dd><code>bitstringLength</code> - the length of tiling before the 1's are concatenated as separators.
                        e.g. for a bitstringLength of 5 and nTiles=10, the resulting bitarray is length 10*(5+1)=60 bits</dd>
<dt>Returns:</dt>
<dd>the bitarray holding the bitarray of replicated values with '1' separators.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="parallelCompare00(long,long,int,int)">
<h3>parallelCompare00</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">parallelCompare00</span><wbr><span class="parameters">(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - the number of tiles in the bitarray tiled1 or tiled2 (which should be the same number of tiles).</dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.</dd>
<dt>Returns:</dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="parallelCompare008(long,long,int)">
<h3>parallelCompare008</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">parallelCompare008</span><wbr><span class="parameters">(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles)</span></div>
<div class="block">parallel compare of tiled1 to tiled2 which both have block sizes of 8 and have flag bits
 of '0' separating the embedded 7-bit tiles.
 returns a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bitstringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b0010010001100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - the number of tiles in the bitarray tiled1 or tiled2 (which should be the same number of tiles).</dd>
<dt>Returns:</dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rank(long,long,int,int,long)">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength,
 long&nbsp;mask1)</span></div>
<div class="block">calculate the rank of the replicated query tile in tiled1 with respect to the tiled keys
 in tiled2.  This method performs a parallel compare of tiled1 to tiled2,
 masks the result, and then sums the number of set bits in the masked result.
 The calculated rank requires that the keys embedded in tiled2 are ordered.
 The calculated rank is the number of flags of blocks in tiled2 that are less than or equal to those
 in the query (which is replicated in tiled1).
 The method is O(1) (5 operations).
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstring 0b0010100 replicated 2 times using a bitlength of 7 bits,
                      the resulting tiled1 is bitstring of length 16 bits which has 2 blocks of size 8 bits,
                      = 0b10010100_10010100.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled2 is 0b00100100_01100111, where 0's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>nTiles</code> - </dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dd><code>mask1</code> - the 1's mask (same used in setting the gap bits in tiled1)</dd>
<dt>Returns:</dt>
<dd>The calculated rank is the number of flags of blocks in tiled2 that are less than or equal to those
 in the query (which is replicated in tiled1).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rank(long,long,int,int)">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">parallel compare of tiled1 to tiled2 and return a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b1010010011100111, where 1's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - </dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dt>Returns:</dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="parallelCompare108(long,long,int,long)">
<h3>parallelCompare108</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">parallelCompare108</span><wbr><span class="parameters">(long&nbsp;tiled1,
 long&nbsp;tiled2,
 int&nbsp;nTiles,
 long&nbsp;mask1)</span></div>
<div class="block">parallel compare of tiled1 to tiled2 both of which have block size 8 and
 embedded tiles of size 7-bits.
 this method returns a masked bit array whose set bits indicate which
 tiles of tiled1 are .gte. the tiles of tiled2 in the same position.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 NOTE that there are some size restrictions to the packing especially in context of further use such as the compare
 operations.
 Let block size = (bistringLength + 1).
 The unsigned long restricts the total bit length of the tiled result of this method to 63 bits,
 and so (nTiles * block) must be less than or equal to 63.
 Also, regarding the number of values to be tiled: the compare operation has to be able to store the bit
 representation of the number of tiles into the highest blocks of a mask that is the same size as the
 total tiled bit length.  If the number of bits needed to represent nTiles is not less than or equal to
 block size, then more blocks are needed to hold that number and that number of extra blocks may need to be subtracted
 from nTiles in order for the compare bitMask to fit within the limits of the tiled bit length
 and the 63 bit limit.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled1</code> - a bit array holding numbers of length tileBitLength (called tiles) separated by 1's.
                      e.g. For bitstrings 0b0100100 and 0b1100111 which are 7 bits long,
                      tiled1 is 0b1010010011100111, where 1's have been concatenated onto the high end of
                      each tileBitLength bitstring, making a bitstring of length 16.</dd>
<dd><code>tiled2</code> - a bit array holding numbers of length tileBitLength separated by 0's.</dd>
<dd><code>nTiles</code> - </dd>
<dd><code>mask1</code> - the 1's mask (same used in setting the gap bits in tiled1)</dd>
<dt>Returns:</dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="parallelSum(long,int,int)">
<h3>parallelSum</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">parallelSum</span><wbr><span class="parameters">(long&nbsp;comparison,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">sum the set bits of bitstring comparison.  the flags that may have set bits are the MSB of each block.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 This is 3 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>comparison</code> - a bit array with flags at the MSB of each block.  The flags that are set bits
                      are summed in this method.</dd>
<dd><code>nTiles</code> - </dd>
<dd><code>tileBitLength</code> - the length of each tile in the bit arrays.  the block size is tileBitLength + 1
                      because it includes the gap bit between tiles.</dd>
<dt>Returns:</dt>
<dd>a bit array of same size as tiled1 and tiled2 in which the bit of each
 tile is 1 if the tile in tiled1 1 is greater than or equal to the tile at the same position
 in tiled2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="parallelSum8(long,int)">
<h3>parallelSum8</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">parallelSum8</span><wbr><span class="parameters">(long&nbsp;comparison,
 int&nbsp;nTiles)</span></div>
<div class="block">sum the set bits of the comparison bitstring which has a block size of 8 and embedded tiles of
 size 7-bits.  this method sums the set bits at the high end of each block and returns the result.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 this is ~ 6 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>comparison</code> - a bit array with flags at the MSB of each block.  The flags that are set bits
                      are summed in this method.</dd>
<dd><code>nTiles</code> - </dd>
<dt>Returns:</dt>
<dd>the sum of the set bits of the MSB of each 8-bit block.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch(long,int,int)">
<h3>sketch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles,
 int&nbsp;tileBitLength)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags, extract and return the flags.
 e.g. if tiled were A0000000B0000000C0000000D0000000, this method would return ABCD.
 This is also known as "parallel pack".
     <pre>
     references:
     lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
          and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp

     https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge

     </pre>
     The method is ~ 3 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray of concatenated bitstrings of length tileBitLength separated by flag bits.
                      the portion of tiled read is the first nTiles * (tileBitLength + 1) bits.</dd>
<dd><code>nTiles</code> - the number of tiles packed into the bitarray tiled.</dd>
<dd><code>tileBitLength</code> - the size of a tile before a gap is appended to it.  the block size is tileBitlength + 1.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch8(long,int)">
<h3>sketch8</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch8</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 8 bits
 and embedded tile size of 7 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0000000B0000000C0000000D0000000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits</dd>
<dd><code>nTiles</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch7(long,int)">
<h3>sketch7</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch7</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A000000B000000C000000D000000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 7 bits
 and embedded tile size of 6 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 7 embedded in tiled.  maximum nTiles is 9.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch6(long,int)">
<h3>sketch6</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch6</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A00000B00000C00000D00000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 6 bits
 and embedded tile size of 5 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 6 embedded in tiled.  the maximum number for the java unsigned
               long is 10 tiles of block size 6.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch5(long,int)">
<h3>sketch5</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch5</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0000B0000C0000D0000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 5 bits
 and embedded tile size of 4 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 5 embedded in tiled.  the maximum number of 12 for nTiles for
               block size of 5 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch4(long,int)">
<h3>sketch4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch4</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A000B000C000D000, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 4 bits
 and embedded tile size of 3 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 4 embedded in tiled.  the maximum number of 15 for nTiles for
               block size of 4 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch3(long,int)">
<h3>sketch3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch3</span><wbr><span class="parameters">(long&nbsp;tiled,
 int&nbsp;nTiles)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A00B00C00D00, this method would return ABCD.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     also used      https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 3 bits
 and embedded tile size of 2 bits</dd>
<dd><code>nTiles</code> - the number of tiles of block size 3 embedded in tiled.  the maximum number of 21 for nTiles for
               block size of 3 is limited by the java unsigned long and the location of the mask bits needed after
               the sketch multiplier.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sketch2(long)">
<h3>sketch2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">sketch2</span><wbr><span class="parameters">(long&nbsp;tiled)</span></div>
<div class="block">given a bitarray packed full of tiles separated by flags with a block size of  bits
 and embedded tile size of 1 bits, extract and return the flags as consecutive bits.
 e.g. if tiled were A0B0C0D0, this method would return ABCD.
     <pre>
     reference:
     https://stackoverflow.com/questions/30539347/2d-morton-code-encode-decode-64bits
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tiled</code> - a bitarray packed full of tiles separated by flags with a block size of 2 bits
 and embedded tile size of 1 bits</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn(long,int)">
<h3>highestBitSetIn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn</span><wbr><span class="parameters">(long&nbsp;value,
 int&nbsp;valueBitLength)</span></div>
<div class="block">Given an n-bit value, returns the index of the highest 1 bit within that
 value.  the input is not tiled.

     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a bitlength number.</dd>
<dd><code>valueBitLength</code> - the bit length of value.  range is [1,8] inclusive</dd>
<dt>Returns:</dt>
<dd>the highest bit set in value.  the bit number is w.r.t. 0.
 e.g. if blockSize is 8, the return value range is [0,7] inclusive.
 the result is a negative number if there are no bits set in value.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn8(long)">
<h3>highestBitSetIn8</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn8</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given an 8-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
 This subroutine is where much of the magic happens with regards to the
 overall algorithm. The idea is that if we can get down to an eight-bit
 number, we can manually check each power of two that could serve as the
 most-significant bit. This is actually done using a clever parallel
 comparison step, describe below.
 this is ~10 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - an 8-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn7(long)">
<h3>highestBitSetIn7</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn7</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given a 7-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a 7-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn6(long)">
<h3>highestBitSetIn6</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn6</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given a 6-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a 6-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn5(long)">
<h3>highestBitSetIn5</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn5</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given a 5-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a 5-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn4(long)">
<h3>highestBitSetIn4</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn4</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given a 4-bit value, returns the index of the highest 1 bit within that
 value.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a 4-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn3(long)">
<h3>highestBitSetIn3</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn3</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">Given a 3-bit value, returns the index of the highest 1 bit within that
 value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - a 3-bit number</dd>
<dt>Returns:</dt>
<dd>the highest set bit in value, or -1 for no set bits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn2(long)">
<h3>highestBitSetIn2</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn2</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="highestBitSetIn1(long)">
<h3>highestBitSetIn1</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">highestBitSetIn1</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn(long,int)">
<h3>usedBlocksIn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn</span><wbr><span class="parameters">(long&nbsp;value,
 int&nbsp;blockSize)</span></div>
<div class="block">Returns a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh

 We'll return a 64-bit flag integer

   A0000000B0000000C0000000D0000000E0000000F0000000G0000000H0000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - </dd>
<dd><code>blockSize</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn8(long)">
<h3>usedBlocksIn8</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn8</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">For a tiled value whose block size = 8 bits (and hence, the embedded tile size is 7 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh

 We'll return a 64-bit flag integer

   A0000000B0000000C0000000D0000000E0000000F0000000G0000000H0000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre>
     The method is 5 operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn7(long)">
<h3>usedBlocksIn7</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn7</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">For a tiled value whose block size = 7 bits (and hence, the embedded tile size is 6 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaaabbbbbbbcccccccdddddddeeeeeeefffffffggggggghhhhhhh

 We'll return a 64-bit flag integer

   A000000B000000C000000D000000E000000F000000G000000H000000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn6(long)">
<h3>usedBlocksIn6</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn6</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
<div class="block">For a tiled value whose block size = 6 bits (and hence, the embedded tile size is 5 bits in between
 flags of size 1), returns
 a bitmask where each block's high bit is 1 if that block contains a
 1 bit and is 0 otherwise. All remaining bits are 0.

 Stated differently, given the input

   aaaaaabbbbbbccccccddddddeeeeeeffffffgggggghhhhhh

 We'll return a 64-bit flag integer

   A00000B00000C00000D00000E00000F00000G00000H00000

 where each letter is 1 if any of the bits in the block were set and is
 0 otherwise.
     <pre>
     following lecture notes http://web.stanford.edu/class/cs166/lectures/16/Small16.pdf
     and code in http://web.stanford.edu/class/cs166/lectures/16/code/msb64/MSB64.cpp
     Then edited here to allow block sizes other than 8.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn5(long)">
<h3>usedBlocksIn5</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn5</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn4(long)">
<h3>usedBlocksIn4</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn4</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn3(long)">
<h3>usedBlocksIn3</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn3</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn2(long)">
<h3>usedBlocksIn2</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn2</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="usedBlocksIn1(long)">
<h3>usedBlocksIn1</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">usedBlocksIn1</span><wbr><span class="parameters">(long&nbsp;value)</span></div>
</section>
</li>
<li>
<section class="detail" id="maxNumberOfTiles(int)">
<h3>maxNumberOfTiles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">maxNumberOfTiles</span><wbr><span class="parameters">(int&nbsp;blockSize)</span></div>
<div class="block">returns the maximum number of blockSize tiles that can fit into a java unsigned
 long (= 63 bits).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>blockSize</code> - the size of blocks</dd>
<dt>Returns:</dt>
<dd>the maximum number of blockSize tiles that can fit into a java unsigned
     long (= 63 bits).</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
