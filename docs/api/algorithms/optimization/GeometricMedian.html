<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Tue Sep 06 17:33:27 PDT 2022 -->
<title>GeometricMedian</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-09-06">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GeometricMedian";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.optimization</a></div>
<h2 title="Class GeometricMedian" class="title">Class GeometricMedian</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.optimization.GeometricMedian</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">GeometricMedian</span>
extends java.lang.Object</pre>
<div class="block">the geometric median:
   a.k.a. spatial median, 1-median, Euclidean minisum point, and Torricelli point.
   the weighted version is a.k.a. L1-median (though it uses the euclidean distance)
   and the multivariate L1 -median (L1 -MM).
   
   definition: the point which minimizes the sum of the euclidean distance of that
     point to all other points in the set.
     the sum is a convex function (i.e. local search will work).
     Unfortunately, no algorithms are closed form, that is no algorithms have a
     finite number of computational operations.
     The geometric median is a rotation and translation invariant estimator that
     achieves the optimal breakdown point of 0.5, i.e. it is a good estimator
     even when up to half of the input data is arbitrarily corrupted.
     https://dl.acm.org/doi/pdf/10.1145/2897518.2897647
     
     From  https://www.pnas.org/content/pnas/97/4/1423.full.pdf
     "...the problem of minimizing the weighted sum of the
    Euclidean distances from m points, in Real space of dimension d (R^d). 
    In industrial applications, this is known as the optimal location problem 
    of Weber (2). In statistics, the solution of this optimization problem
    is the spatial median or L1-MM, considered by Brown (3) and
    Small (4). As noted by Kuhn (5), the problem goes back to
    Fermat in the early seventeenth century and was generalized
    to the current form by Simpson in his Doctrine and Application of Fluxions (6). 
    In the nineteenth century, Steiner made
    significant contributions to this problem and its extensions (cf.
    Courant and Robbins; ref. 7). Thus, the problem is known as
    the Fermat–Weber location problem and also as the Euclidean–
    Steiner problem."
     
 
 https://feb.kuleuven.be/public/u0017833/PDF-FILES/l1medianR2.pdf
 NOTE: the Vardi-Zhang 2000 update method with the author's implemented non-linear
 optimization, appears to have a runtime of O(N log_2 N)
 
 NOTE: that there is research on handling sparse matrices in other applications
 such as bundle adjustment where a sparse version of Levenberg-Marquardt is used.
 see papers by  Lourakis and Argyros, etc.
 http://users.ics.forth.gr/~lourakis/sba/PRCV_colloq.pdf
 https://www.researchgate.net/profile/Antonis_Argyros/publication/221111908_Is_Levenberg-Marquardt_the_Most_Efficient_Optimization_Algorithm_for_Implementing_Bundle_Adjustment/links/00b7d51c7d377ba56e000000/Is-Levenberg-Marquardt-the-Most-Efficient-Optimization-Algorithm-for-Implementing-Bundle-Adjustment.pdf</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">GeometricMedian</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newtonsMethod2(thirdparty.dlib.optimization.AbstractGeometricMedianFunction,double%5B%5D)">newtonsMethod2</a></span>&#8203;(thirdparty.dlib.optimization.AbstractGeometricMedianFunction&nbsp;function,
              double[]&nbsp;init)</code></th>
<td class="colLast">
<div class="block">use first derivative to find minimum sum of function defining geometric-median.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newtonsThenVardiZhang(thirdparty.dlib.optimization.GeometricMedianWeightedFunction,double%5B%5D)">newtonsThenVardiZhang</a></span>&#8203;(thirdparty.dlib.optimization.GeometricMedianWeightedFunction&nbsp;function,
                     double[]&nbsp;geoMedian)</code></th>
<td class="colLast">
<div class="block">this methods uses newtonsMethod2 to completion and then uses the 
 Vardi Zhang (2000) algorithm to update argmin X if it's a point in obs.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#verify(thirdparty.dlib.optimization.AbstractGeometricMedianFunction,double%5B%5D,double)">verify</a></span>&#8203;(thirdparty.dlib.optimization.AbstractGeometricMedianFunction&nbsp;function,
      double[]&nbsp;init,
      double&nbsp;errorTolerance)</code></th>
<td class="colLast">
<div class="block">if init is a root of the function, and error is errorTolerance or smaller,
       then the function derivative evaluated at the root plus and at the root minus
       the error will have opposing signs.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GeometricMedian</h4>
<pre>public&nbsp;GeometricMedian()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="newtonsMethod2(thirdparty.dlib.optimization.AbstractGeometricMedianFunction,double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newtonsMethod2</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;newtonsMethod2&#8203;(thirdparty.dlib.optimization.AbstractGeometricMedianFunction&nbsp;function,
                             double[]&nbsp;init)</pre>
<div class="block">use first derivative to find minimum sum of function defining geometric-median.
 Gauss-Newton's method has been altered to use back-tracking with a deceasing step size.
 The first derivative of the geometric-median is not zero so can use
 first order Householder methods, but cannot use 2nd order Householder methods
 because the 2nd derivative is 0.
 <pre>
       example for nDimensions = 2:
       f = summation_i=1_n( || X - obs_i || )/n
           where || X - obs_i ||_2 is ( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(1/2)
       df/dX_0 = d/dx( (1/n)*summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(1/2) ))
               = (1/n)*(1/2)*2*(X_0-obs_i_0)*(1)
                  / summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(1/2) )
               = (1./n)*(X_0-obs_i_0) / summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(1/2) )
       df/dX_1 = (1./n)*(X_1-obs_i_1) / summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(1/2) )

       d/dX_0 of df/dX_0 = (1./n) * (1) * (-1/2)*summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(-3/2) )
2*(X_0-obs_i_0)*(1)
                         = (-1./n)*(X_0-obs_i_0) / summation_i=1_n( (X_0-obs_i_0)^2 + (X_1-obs_i_1)^2 )^(3/2) )
       
       Hessian d/dX of d/dX where p is nDimensions and I is the identity matrix of size pxp:
                            ( (    I_p      )   ( (X - obs_i)*(X - obs_i)^T )
           = summation_i=1_n( (-------------) - ( --------------------------)
                            ( (||X - obs_i||)   (      ||X - obs_i||^3      )
         ...

 </pre>
 
 NOTE: if nDimensions == nDataPoints, the init is replaced with the
 euclidean centroid.  These are "colinear" cases extended to more than
 2 dimensions.  There are many solutions for these cases, but the 
 euclidean centroid is chosen here.
 
 NOTE, algorithm currently may fail to minimize if arrives at demand points.
 One should use instead, the method newtonsThenVardiZhang which checks for 
 that and updates the solution if needed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>function</code> - </dd>
<dd><code>init</code> - input output variable holding the estimates for the
 geometric median in all dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the minimum of the sum of the squared sum of thedifferences of
 the observed points from the geometric median.</dd>
</dl>
</li>
</ul>
<a id="verify(thirdparty.dlib.optimization.AbstractGeometricMedianFunction,double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verify</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;verify&#8203;(thirdparty.dlib.optimization.AbstractGeometricMedianFunction&nbsp;function,
                      double[]&nbsp;init,
                      double&nbsp;errorTolerance)</pre>
<div class="block">if init is a root of the function, and error is errorTolerance or smaller,
       then the function derivative evaluated at the root plus and at the root minus
       the error will have opposing signs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>function</code> - </dd>
<dd><code>init</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="newtonsThenVardiZhang(thirdparty.dlib.optimization.GeometricMedianWeightedFunction,double[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>newtonsThenVardiZhang</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;newtonsThenVardiZhang&#8203;(thirdparty.dlib.optimization.GeometricMedianWeightedFunction&nbsp;function,
                                    double[]&nbsp;geoMedian)</pre>
<div class="block">this methods uses newtonsMethod2 to completion and then uses the 
 Vardi Zhang (2000) algorithm to update argmin X if it's a point in obs.

 Vardi & Zhang 2000:
 "The multivariate L1-median and associated data depth",
       Yehuda Vardi and Cun-Hui Zhang
     https://www.pnas.org/content/pnas/97/4/1423.full.pdf</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>function</code> - </dd>
<dd><code>geoMedian</code> - input output variable holding the estimates for the
 geometric median in all dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the minimum of the sum of the squared sum of the differences of
 the observed points from the geometric median.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
