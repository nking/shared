<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Thu Dec 08 12:13:07 PST 2022 -->
<title>LinearProgramming</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-12-08">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LinearProgramming";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":9,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.optimization</a></div>
<h2 title="Class LinearProgramming" class="title">Class LinearProgramming</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.optimization.LinearProgramming</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">LinearProgramming</span>
extends java.lang.Object</pre>
<div class="block">A program to find the optimal values of x if possible given
 an objective and constraints in Standard Form.
 
 The Simplex Method is used and will return infeasible or unbounded
 if an optimal Basic feasible solution is not possible.
 The runtime complexity is exponential at worse, but often performs as
 a polynomial runtime complexity.
 (pivot operations can be expensive for large problems, having combinatorial
 complexity C(m+n, m) at worse.
 
 Alternative algorithms are ellipsoid, and interior-point.
 Interior-point is a class of algorithms that solve linear and nonlinear 
 convex optimization problems in provably polynomial time.
 https://en.m.wikipedia.org/wiki/Interior-point_method
 The interior-point algorithms can use linear algebra more effectively
 for large and sparse problems.

 Note that in the 4th edition of "Introduction to Algorithms", Cormen, Leiserson, Rivest, and Stein
 state that ellipsoid algorithms do not appear to be competitive with the simplex method in practice.
 (TODO: follow up on this with details of number of variables vs number of iterations or another measure of
 runtime complexity... Karmarkar's is O(N^3.5 * L) iterations where N is the number of variables and L is
 the number of bits of input to the algorithm)

 when all variables must be integers, the problem is more specifically, Linear Integer
       Programming problem and it is NP-hard, no known polynomial time algorithm.
       
 <pre>
 The algorithm implements Chap 29 of Cormen, Leiserson, Rivest, and Stein "Introduction to Algorithms"
 
  Some definitions:
   
   Standard Form:
       maximization of a linear function subject to linear *inequalities*

   Slack Form:
       maximization of a linear function subject to linear *equalities*

algebraic solution: write the linear program in slack form which express the equalities
        in terms of "basic variables" and "nonbasic variables".
        involves making a basic variable nonbasic and a nonbasic variable basic using
        "pivot" operations.
        
Simplex Method:
      Notation:  variables x1, x2, ... xn
                 a realization of the variables: xHat0, xHat1, ...xHatn
      `
      Standard Form:
          real numbers: c1...cn; b1,...bm; and aij for a=1:m and j=1:n.

                        Find numbers x1,...xn:
        objective :    maximize summation_j=1:n(cj*xj)
        constraints :   subject to: summation_j=1:n(aij*xj) .leq. bi for i=1:m
        constraints :   xj .geq. 0 for j=1:n
                         the later is a nonnegativity constraint
                         
              OR expressed more compactly:
          A = (aij) =  mXn matrix
          b = (bi) an m-dimensional vector
          c = (cj) an n-dimensional vector
          x = (xj) an n-dimensional vector
        objective :    maximize c^T*x
        constraints :   subject to: A*x .leq. b
                         x .leq. 0

       A feasible solution is the numbers xHat as x1,...xn that satisfy all constraints.

       An unfeasible solution fails to satisfy all constraints.

       The optimal solution is the feasible solution which maximizes the objective.

       An unbounded solution has feasible solution, but does not have finite optimal objective.
      
 </pre>
 <pre>
 More regarding the Simplex Method runtime complexity:
 From wikipedia: http://en.wikipedia.org/wiki/Simplex_algorithm
 
 '...Analyzing and quantifying the observation that the simplex algorithm is 
 efficient in practice, even though it has exponential worst-case complexity, 
 has led to the development of other measures of complexity. The simplex 
 algorithm has polyxnomial-time average-case complexity under various 
 probability distributions, with the precise average-case performance of the 
 simplex algorithm depending on the choice of a probability distribution for 
 the random matrices.   Another approach to studying "typical phenomena" uses 
 Baire category theory from general topology, and to show that (topologically) 
 "most" matrices can be solved by the simplex algorithm in a polynomial number 
 of steps. Another method to analyze the performance of the simplex algorithm 
 studies the behavior of worst-case scenarios under small perturbation â€“ are 
 worst-case scenarios stable under a small change (in the sense of structural 
 stability), or do they become tractable?   Formally, this method uses random 
 problems to which is added a Gaussian random vector 
 ("smoothed complexity")....'
 </pre>
 
 NOTE: some Simplex algorithms use a matrix composed of the objective function 
 (c, v) and the constraints (a, b) in a format called the "tableau". 
 The tableau format varies in some implementations.
 <pre>
     |  1  (-1*objective function coefficients)         0         |
     |  0  (constraint 1 coefficients)      (constraint 1 bound)  |
     |  0   ... through all constraints          ...              |
     
   
 notes from Linear Programming, CSE 6331 Algorithms Steve Lai:
 
 Another form frequently used for Standard Form tableau:
        |  x1         x2         ...        xn  |
  ------|---------------------------------------|------------
    y1  |  a11        a12      ...      a1n     |  .leq. b1
    y2  |  a21        a22      ...      a2n     |  .leq. b2
    ... |  ...        ...      ...      ...     |  ...
    ym  |  am1        am2      ...      amn     |  .leq. bm
  ------|---------------------------------------|-------------
        |.geq. c1    .geq. c2          .geq. cn |
</pre>
   The written text of the equations is "Dictionary" form.
 <pre>
 The original linear program before transformations is called "primal".
 
 Regarding duality:
 
 A Primal Standard Form LP:
     max: c^T*x
     subject to: A*x .leq. b and x .geq. 0
 A Primal Minimization LP:
     min: y^T*b
     subject to: y^T*A .geq. c^T and y .geq. 0    

Example:
   A Primal Standard Form LP  |  Dual Minimization LP
      max: x1 + x2            |    min: 4*y1 + 12*y2 + y3
      subject to:             |    subject to:
        x1 + 2*x2 .leq. 4     |      y1 + 4*y2 - y3 .geq. 1
      4*x1 + 2*x2 .leq. 12    |     2*y1+ 2*y2 + y3 .geq. 1
       -x1 +   x2 .leq. 1     |
      x1, x2 .geq. 0          |    y1, y2, y3 .geq. 0
 
        |  x1          x2 |
  ------|----------------------------
    y1  |  1           2  | .leq. 4
    y2  |  4           2  | .leq. 12
  ------|-----------------|----------
        |.geq. 1  .geq. 1 |
 </pre>
 The number of basic solutions is at most C(m+n, m).
 <pre>
 Basic feasible solutions are extreme points
     A set C is said to be convex if for all points x1, x2 in C 
         we have lambda*x1 + (1 - lambda)*x2 in C for all 0 .leq. lambda .leq. 1.
     A point x in a convex set C is called an extreme point if there exist no 
         x1, x2 in C, x1 != x2 , and 0 .lt. lambda .lt. 1,
         such that x = lambda*x1 + (1 - lambda)*x2.
     The feasible region of an LP is a convex set.
     Basic feasible solutions of an LP (in the equality form)
         are extreme points of the feasible region.
     If the LP is feasible bounded, then at least one
         optimum solution occurs at an extreme point.
 </pre></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearProgramming.FormTuple.html" title="class in algorithms.optimization">LinearProgramming.FormTuple</a></span></code></th>
<td class="colLast">
<div class="block">example Standard Form:
        
        Find numbers x1,...xn:
        objective :    maximize
                           c^T*x = summation_j=1:n(cj*xj)
        constraints :  subject to:
                           A*x .leq.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></span></code></th>
<td class="colLast">
<div class="block">maximization of a linear function subject to linear *equalities*</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a></span></code></th>
<td class="colLast">
<div class="block">maximization of a linear function subject to linear *inequalities*</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">LinearProgramming</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(long)">LinearProgramming</a></span>&#8203;(long&nbsp;randomSeed)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#chooseEnteringIndex(algorithms.optimization.LinearProgramming.SlackForm,gnu.trove.set.TIntSet)">chooseEnteringIndex</a></span>&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm,
                   gnu.trove.set.TIntSet&nbsp;positiveCIndexes)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertConstraints(algorithms.optimization.LinearProgramming.StandardForm)">convertConstraints</a></span>&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</code></th>
<td class="colLast">
<div class="block">given a standard form containing .leq.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertLinearProgramToStandardForm(boolean,double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,int%5B%5D,boolean%5B%5D)">convertLinearProgramToStandardForm</a></span>&#8203;(boolean&nbsp;isMaximization,
                                  double[][]&nbsp;a,
                                  double[]&nbsp;b,
                                  double[]&nbsp;c,
                                  int[]&nbsp;constraintComparisons,
                                  boolean[]&nbsp;nonnegativityConstraints)</code></th>
<td class="colLast">
<div class="block">Given a linear program L whose objective is minimization or maximization.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected <a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createAuxiliarySlackForm(algorithms.optimization.LinearProgramming.StandardForm)">createAuxiliarySlackForm</a></span>&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findMinIndex(double%5B%5D)">findMinIndex</a></span>&#8203;(double[]&nbsp;b)</code></th>
<td class="colLast">
<div class="block">finds the smallest value in b and returns its index;  if b.length is 0
 or if b contains only Double.POSITIVE_INFINITY, -1 is returned.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected gnu.trove.set.TIntSet</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPositiveCIndexes(algorithms.optimization.LinearProgramming.SlackForm)">findPositiveCIndexes</a></span>&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm)</code></th>
<td class="colLast">
<div class="block">find the indexes eligible to be entering variable indexes.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected <a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initializeSimplex(algorithms.optimization.LinearProgramming.StandardForm)">initializeSimplex</a></span>&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</code></th>
<td class="colLast">
<div class="block">given a linear program in Standard Form if the problem is unfeasible, 
        this method returns a slackform with state set to unfeasible, , else 
        if the problem is unbounded the method returns a slackform with state 
        set to unbounded, else
        returns a slack form for which a basic solution is feasible.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected <a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pivot(algorithms.optimization.LinearProgramming.SlackForm,int,int)">pivot</a></span>&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm,
     int&nbsp;lIdx,
     int&nbsp;eIdx)</code></th>
<td class="colLast">
<div class="block">given a slack form and the indices for a leaving and entering variable,
        the pivot returns another slack form.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solveUsingSimplexMethod(algorithms.optimization.LinearProgramming.StandardForm)">solveUsingSimplexMethod</a></span>&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</code></th>
<td class="colLast">
<div class="block">given a linear program in Standard Form if the problem is unfeasible, 
        this method returns a slackform with state set to unfeasible, else 
        if the problem is unbounded the method returns a slackform with state 
        set to unbounded, else
        returns a slack form for which a basic solution is feasible and optimal.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sortLHS(int%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">sortLHS</a></span>&#8203;(int[]&nbsp;bHatIndices,
       double[]&nbsp;bHat,
       double[][]&nbsp;aHat)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sortRHS(int%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">sortRHS</a></span>&#8203;(int[]&nbsp;nHatIndices,
       double[]&nbsp;cHat,
       double[][]&nbsp;aHat)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LinearProgramming</h4>
<pre>public&nbsp;LinearProgramming()</pre>
</li>
</ul>
<a id="&lt;init&gt;(long)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LinearProgramming</h4>
<pre>public&nbsp;LinearProgramming&#8203;(long&nbsp;randomSeed)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>randomSeed</code> - </dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="solveUsingSimplexMethod(algorithms.optimization.LinearProgramming.StandardForm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveUsingSimplexMethod</h4>
<pre class="methodSignature">public&nbsp;<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;solveUsingSimplexMethod&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</pre>
<div class="block">given a linear program in Standard Form if the problem is unfeasible, 
        this method returns a slackform with state set to unfeasible, else 
        if the problem is unbounded the method returns a slackform with state 
        set to unbounded, else
        returns a slack form for which a basic solution is feasible and optimal.
     <pre>
       The method is implemented from pseudocode in Section 29.3 of Cormen, Leiserson, Rivest, and Stein
       
       Some definitions:
           A feasible solution is the numbers xHat as x1,...xn that satisfy all constraints.

           An unfeasible solution fails to satisfy all constraints.

           The optimal solution is the feasible solution which maximizes the objective.

           An unbounded solution has feasible solution, but does not have finite optimal objective.
      
     </pre>
       NOTE: the random picking of the entering variable in the pivot of LinearProgramming,
       occasionally leads to a solution which is not optimal.
       TODO: consider a pattern for try again or at least document it for the user.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standForm</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="initializeSimplex(algorithms.optimization.LinearProgramming.StandardForm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initializeSimplex</h4>
<pre class="methodSignature">protected&nbsp;<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;initializeSimplex&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</pre>
<div class="block">given a linear program in Standard Form if the problem is unfeasible, 
        this method returns a slackform with state set to unfeasible, , else 
        if the problem is unbounded the method returns a slackform with state 
        set to unbounded, else
        returns a slack form for which a basic solution is feasible.
 <pre>
 The method is implemented from pseudocode in Section 29.3 of Cormen, Leiserson, Rivest, and Stein
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standForm</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="pivot(algorithms.optimization.LinearProgramming.SlackForm,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pivot</h4>
<pre class="methodSignature">protected&nbsp;<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;pivot&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm,
                                            int&nbsp;lIdx,
                                            int&nbsp;eIdx)</pre>
<div class="block">given a slack form and the indices for a leaving and entering variable,
        the pivot returns another slack form.
     Its the  geometrical operation of moving from a basic feasible solution to 
 an adjacent basic feasible solution.
 https://en.m.wikipedia.org/wiki/Simplex_algorithm
 <pre>
 The method is implemented from pseudocode in Section 29.3of Cormen, Leiserson, Rivest, and Stein
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>slackForm</code> - </dd>
<dd><code>lIdx</code> - the leaving index of x. the "leaving variable" is the basic 
 variable in the constraint, on the lhs (so it's an index in bIndices).</dd>
<dd><code>eIdx</code> - the exiting index of x.  the "entering variable" is the 
 non-basic variable in the constraint, on the rhs (so it's an index in nIndices).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sortRHS(int[],double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sortRHS</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;sortRHS&#8203;(int[]&nbsp;nHatIndices,
                       double[]&nbsp;cHat,
                       double[][]&nbsp;aHat)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nHatIndices</code> - </dd>
<dd><code>cHat</code> - </dd>
<dd><code>aHat</code> - </dd>
</dl>
</li>
</ul>
<a id="sortLHS(int[],double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sortLHS</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;sortLHS&#8203;(int[]&nbsp;bHatIndices,
                       double[]&nbsp;bHat,
                       double[][]&nbsp;aHat)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bHatIndices</code> - </dd>
<dd><code>bHat</code> - </dd>
<dd><code>aHat</code> - </dd>
</dl>
</li>
</ul>
<a id="findMinIndex(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findMinIndex</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findMinIndex&#8203;(double[]&nbsp;b)</pre>
<div class="block">finds the smallest value in b and returns its index;  if b.length is 0
 or if b contains only Double.POSITIVE_INFINITY, -1 is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>b</code> - an array of double numbers.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>returns the index of the smallest value in b, but if b.length is 0
 or if b contains only Double.POSITIVE_INFINITY, -1 is returned.</dd>
</dl>
</li>
</ul>
<a id="convertLinearProgramToStandardForm(boolean,double[][],double[],double[],int[],boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertLinearProgramToStandardForm</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;convertLinearProgramToStandardForm&#8203;(boolean&nbsp;isMaximization,
                                                                                double[][]&nbsp;a,
                                                                                double[]&nbsp;b,
                                                                                double[]&nbsp;c,
                                                                                int[]&nbsp;constraintComparisons,
                                                                                boolean[]&nbsp;nonnegativityConstraints)</pre>
<div class="block">Given a linear program L whose objective is minimization or maximization.
 and which has constraints that are .leq., .eq., or .geq. the 
 constants in b, convert L into standard maximum form.
 Standard form has a maximization objective, nonnegative constraints
 on all x_j's, and constraints which are all .leq. b_i's.
 The program implements material from Section 29.1 of Cormen, Leiserson, Rivest, and Stein
 "Introduction to Algorithms"
     <pre>
       Example Linear Program for minimization from Cormen, Leiserson, Rivest, and Stein, Chap 29.
             minimize:
               -2*x1 + 3*x2
             subject to constraints:
                  x1 +   x2  .eq. 7
                  x1 - 2*x2 .leq. 4
             nonnegativity constraints:
                  x1        .geq. 0
       Converted to a Standard Form:
              maximize:
                2*x1 - 3*x2 + 3*x3
              subject to constraints: 
                  x1 +   x2 - x3 .leq. 7
                 -x1 -   x2 + x3 .leq. -7
                  x1 - 2*x2 + 2*x3 .leq. 4
              nonnegativity constraints:
                  x1, x2, and x3 .geq. 0
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - constraint coefficients</dd>
<dd><code>b</code> - the constants in each constraint.</dd>
<dd><code>c</code> - objective coefficients</dd>
<dd><code>constraintComparisons</code> - an index of size c.length containing indicators
 for whether the constraint is .leq., .eq., or .geq..
 -1 is used for .leq., 0 for .eq. and +1 for .geq.
 <pre>
 e.g. constraints:
    x1 +   x2  .eq. 7
    x1 - 2*x2 .leq. 4
 would have constraintComparisons = [0, -1]
 </pre></dd>
<dd><code>isMaximization</code> - true if the linear program goal is to maximize the objective,
 else false if the goal is to minimize the objective.</dd>
<dd><code>nonnegativityConstraints</code> - indicates whether x_j has a non-negativity
 constraint</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="convertConstraints(algorithms.optimization.LinearProgramming.StandardForm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertConstraints</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;convertConstraints&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</pre>
<div class="block">given a standard form containing .leq. inequalities expressed by 
 standForm.a and standForm.b, convert the problem to a SlackForm
 of equality constraints and their slack variables.
 NOTE that the slack form 'a' matrix will have sign conventions
 that are the same as the signs of standForm.a.
 The slack form constraints are slack variable = b_i - summation_j=1:n(a_i_j * x_j),
 and so the negative sign read in the written slack form is not present
 in the matrix 'a'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standForm</code> - a linear program with an objective of maximization,
       subject to constraints that are inequality constraints of the form .leq.
       and non-negativity constraints on x.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createAuxiliarySlackForm(algorithms.optimization.LinearProgramming.StandardForm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createAuxiliarySlackForm</h4>
<pre class="methodSignature">protected&nbsp;<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;createAuxiliarySlackForm&#8203;(<a href="LinearProgramming.StandardForm.html" title="class in algorithms.optimization">LinearProgramming.StandardForm</a>&nbsp;standForm)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standForm</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="chooseEnteringIndex(algorithms.optimization.LinearProgramming.SlackForm,gnu.trove.set.TIntSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>chooseEnteringIndex</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;chooseEnteringIndex&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm,
                                  gnu.trove.set.TIntSet&nbsp;positiveCIndexes)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>slackForm</code> - </dd>
<dd><code>positiveCIndexes</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="findPositiveCIndexes(algorithms.optimization.LinearProgramming.SlackForm)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>findPositiveCIndexes</h4>
<pre class="methodSignature">protected&nbsp;gnu.trove.set.TIntSet&nbsp;findPositiveCIndexes&#8203;(<a href="LinearProgramming.SlackForm.html" title="class in algorithms.optimization">LinearProgramming.SlackForm</a>&nbsp;slackForm)</pre>
<div class="block">find the indexes eligible to be entering variable indexes.  They are
 found as the indexes of the c coefficients which are still positive.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>slackForm</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
