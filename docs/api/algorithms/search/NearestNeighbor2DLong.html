<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_131) on Fri Oct 15 16:14:57 PDT 2021 -->
<title>NearestNeighbor2DLong</title>
<meta name="date" content="2021-10-15">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="NearestNeighbor2DLong";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/search/NearestNeighbor2D.html" title="class in algorithms.search"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/search/NearestNeighbor2DLong.html" target="_top">Frames</a></li>
<li><a href="NearestNeighbor2DLong.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">algorithms.search</div>
<h2 title="Class NearestNeighbor2DLong" class="title">Class NearestNeighbor2DLong</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.search.NearestNeighbor2DLong</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">NearestNeighbor2DLong</span>
extends java.lang.Object</pre>
<div class="block">a nearest neighbor's algorithm using XFastTrie
 for predecessor and successor queries
 on spatially indexed numbers.
 
 The algorithm performs better on dense data
 (that is because the base of the prefix tree
 is filled, leaving smaller number of nodes to
 create in linear time).
 The queries depend upon the maximum of x and
 maximum of y to be entered.
 
 At this time, all entries must be non-negative numbers and
 so must inquiries.
 
 A worst case query would be when column 0 is
 filled with points and no others filled elsewhere, 
 and the last point in the last row and last 
 column is the query point.
 In this worst case, the query time would scale
 roughly as maxY * O(log_2(w))
 
  The algorithm starts with a predecessor and successor 
  call on the query point.  The minimum distance among
  those 2 becomes the goal to search to for completeness
  as rows above and below the query in the same column.
  The search continues to higher rows making predecessor and
  successor calls until the goal is reached.  The next higher
  row is one less than the predecessor result.
  The goal to the complete search is reduced by smaller distance
  answers.  The same is repeated for lower rows.
  <pre>
  an example would be:
  
     0   1   2   3   4

     5   6   7   8   9

     10  11 *12  13  14     q='18'.  pred='15', succ='null' --> goals(3, 23)
                                     13.pred='12'
15  16  17 *18  19              goals change to (13,23)
                                     13.succ='15', not closer than 12.
     20  21  22  23  24              23.pred and 23.succ not closer than 12
                             ans='12'.  queries: 3 pred, 3 succ queries.
                                     at O(log_2(w)) each
                                     complexity was 
                                           6 * O(log_2(w))
                                     for max index = 24, have w = 6 
 </ore>

   first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright

   TODO: consider for the y-axis, adding locality based hashing or similar</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#NearestNeighbor2DLong-java.util.Set-int-int-">NearestNeighbor2DLong</a></span>(java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;points,
                     int&nbsp;imgWidth,
                     int&nbsp;imgHeight)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#NearestNeighbor2DLong-gnu.trove.set.TLongSet-int-int-">NearestNeighbor2DLong</a></span>(gnu.trove.set.TLongSet&nbsp;pointIdxs,
                     int&nbsp;imgWidth,
                     int&nbsp;imgHeight)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#doNotUseCache--">doNotUseCache</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#estimateSizeOnHeap-int-int-">estimateSizeOnHeap</a></span>(int&nbsp;numberOfPoints,
                  int&nbsp;maxBitLength)</code>&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#findClosest-int-int-">findClosest</a></span>(int&nbsp;x,
           int&nbsp;y)</code>
<div class="block">
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#findClosest-int-int-int-">findClosest</a></span>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;dMax)</code>
<div class="block">
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#findClosestNotEqual-int-int-">findClosestNotEqual</a></span>(int&nbsp;x,
                   int&nbsp;y)</code>
<div class="block">
      runtime complexity is
         best case: 2 * O(log_2(maxW)).</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#findClosestWithinTolerance-int-int-double-">findClosestWithinTolerance</a></span>(int&nbsp;x,
                          int&nbsp;y,
                          double&nbsp;tolerance)</code>
<div class="block">NOTE: NOT READY FOR USE
 method to return only the nearest point and any
 that are at the same distance within a tolerance.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#getCol-long-">getCol</a></span>(long&nbsp;internalIndex)</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#getInternalIndex-int-int-">getInternalIndex</a></span>(int&nbsp;col,
                int&nbsp;row)</code>&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/search/NearestNeighbor2DLong.html#getRow-long-">getRow</a></span>(long&nbsp;internalIndex)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="NearestNeighbor2DLong-java.util.Set-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NearestNeighbor2DLong</h4>
<pre>public&nbsp;NearestNeighbor2DLong(java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;points,
                             int&nbsp;imgWidth,
                             int&nbsp;imgHeight)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - non-negative coordinates</dd>
<dd><code>imgWidth</code> - maximum x value of any data point + 1 including
    those to be queries</dd>
<dd><code>imgHeight</code> - maximum y value of any data point + 1 including
    those to be queries</dd>
</dl>
</li>
</ul>
<a name="NearestNeighbor2DLong-gnu.trove.set.TLongSet-int-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>NearestNeighbor2DLong</h4>
<pre>public&nbsp;NearestNeighbor2DLong(gnu.trove.set.TLongSet&nbsp;pointIdxs,
                             int&nbsp;imgWidth,
                             int&nbsp;imgHeight)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pointIdxs</code> - pixel indexes formed from relationship
   pixIdx = (row * width) + col</dd>
<dd><code>imgWidth</code> - maximum x value of any data point  + 1including
    those to be queries</dd>
<dd><code>imgHeight</code> - maximum y value of any data point  + 1including
    those to be queries</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="doNotUseCache--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doNotUseCache</h4>
<pre>public&nbsp;void&nbsp;doNotUseCache()</pre>
</li>
</ul>
<a name="getInternalIndex-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInternalIndex</h4>
<pre>protected&nbsp;long&nbsp;getInternalIndex(int&nbsp;col,
                                int&nbsp;row)</pre>
</li>
</ul>
<a name="getRow-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRow</h4>
<pre>protected&nbsp;int&nbsp;getRow(long&nbsp;internalIndex)</pre>
</li>
</ul>
<a name="getCol-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCol</h4>
<pre>protected&nbsp;int&nbsp;getCol(long&nbsp;internalIndex)</pre>
</li>
</ul>
<a name="findClosest-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findClosest</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;findClosest(int&nbsp;x,
                                          int&nbsp;y)</pre>
<div class="block"><pre>
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.
            
         worst case: 
         
         Note, worst case is: first column
         filled with points and all else is empty and
         the number of rows is same or larger than 
         number of columns and the
         query is for the point in the last column and
         last row... a predecessor call is necessary for
         each row in the worst case.
          
     Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));            
     </ore></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - non-negative x coord to query for</dd>
<dd><code>y</code> - non-negative y coord to query for</dd>
</dl>
</li>
</ul>
<a name="findClosestWithinTolerance-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findClosestWithinTolerance</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;findClosestWithinTolerance(int&nbsp;x,
                                                         int&nbsp;y,
                                                         double&nbsp;tolerance)</pre>
<div class="block">NOTE: NOT READY FOR USE
 method to return only the nearest point and any
 that are at the same distance within a tolerance.
 This is meant to be a nearest neighbor method
 with ability to return more than one at same distance within a tolerance
 of that distance.  
 TODO: calculate the runtime complexity bounds....</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - non-negative x coord to query for</dd>
<dd><code>y</code> - non-negative y coord to query for</dd>
<dd><code>tolerance</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="findClosestNotEqual-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findClosestNotEqual</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;findClosestNotEqual(int&nbsp;x,
                                                  int&nbsp;y)</pre>
<div class="block"><pre>
      runtime complexity is
         best case: 2 * O(log_2(maxW)).
            Note that caching leads to an O(1) term
            over time instead of the logarithmic term.
            
         worst case: nRows * 2 * O(log_2(maxW))
         
         Note, worst case is: first column
         filled with points and all else is empty and
         the number of rows is same or larger than 
         number of columns and the
         query is for the point in the last column and
         last row... a predecessor call is necessary for
         each row in the worst case.
          
     Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));            
     </ore></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - non-negative x coord to query for</dd>
<dd><code>y</code> - non-negative y coord to query for</dd>
</dl>
</li>
</ul>
<a name="findClosest-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findClosest</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;findClosest(int&nbsp;x,
                                          int&nbsp;y,
                                          int&nbsp;dMax)</pre>
<div class="block"><pre>
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.
            
         worst case: 
         
      Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));
     </ore></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - </dd>
<dd><code>y</code> - </dd>
<dd><code>dMax</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a set of points within dMax that are the 
 closest points, else returns an empty set</dd>
</dl>
</li>
</ul>
<a name="estimateSizeOnHeap-int-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>estimateSizeOnHeap</h4>
<pre>public static&nbsp;long&nbsp;estimateSizeOnHeap(int&nbsp;numberOfPoints,
                                      int&nbsp;maxBitLength)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/search/NearestNeighbor2D.html" title="class in algorithms.search"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/search/NearestNeighbor2DLong.html" target="_top">Frames</a></li>
<li><a href="NearestNeighbor2DLong.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
