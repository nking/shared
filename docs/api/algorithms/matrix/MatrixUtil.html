<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_131) on Fri Apr 01 15:51:26 PDT 2022 -->
<title>MatrixUtil</title>
<meta name="date" content="2022-04-01">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MatrixUtil";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":10,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":9,"i126":9,"i127":9,"i128":9,"i129":9,"i130":9,"i131":9,"i132":9,"i133":9,"i134":9,"i135":9,"i136":9,"i137":9,"i138":9,"i139":9,"i140":9,"i141":9,"i142":9,"i143":9,"i144":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/matrix/LinearEquations.LUP.html" title="class in algorithms.matrix"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../algorithms/matrix/MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/matrix/MatrixUtil.html" target="_top">Frames</a></li>
<li><a href="MatrixUtil.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">algorithms.matrix</div>
<h2 title="Class MatrixUtil" class="title">Class MatrixUtil</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.matrix.MatrixUtil</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">MatrixUtil</span>
extends java.lang.Object</pre>
<div class="block"><pre>
   misc notes:
 
   The eigenvalues can be determined in a few ways depending upon the matrix:
       If A is a positive definite matrix, can use the power method to find 
       the largest eigenvalue.  
          Caveat is that it performs best when the spectral gap is large 
          (diff between largest and 2nd largest eigenvalues).
       If A is symmetric, can diagonalize A.
       If A is not symmetric, can either diagonalize A^T*A and use the square root 
          of those eigenvalues or can use Singular Value Decomposition on A 
          (the singular values are the eigenvalues of A).
   Note that the eigenvectors are the same for the diagonalization of A, the 
   diagonalization of A^T*A, the SVD(A), and the same operations performed 
   on the CUR-Decompositions of A (=C) or on C^T*C.
   NOTE: for large-scale eigenvalue problems,consider cur decomposition,power 
 method, qr decomposition (which for general matrices might include the 
 schur decomposition followed by back substitution), or
 for hermetician matrices can use divide and conquer eigenvalue algorithms and they
 are parallelizable.
 </pre>
 
 TODO: implement Orthogonal Iteration from Morita and Kanade Sect 3.2.2
   "A straightforward generalization of the power method can be used to compute 
   several dominant eigenvectors of a symmetric matrix."
   A useful alternative to the singular value decomposition in situations 
   where B is a large matrix and only a few of its largest eigenvalues are needed.
 for p eigenvalues out of n, if lambda__(p_1)/lambda_p is very small,
 the computation of the eigenvectors should proceed quickly.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a></span></code>
<div class="block">holds data structures for having solved for the vector x which is the
 closest to a given vector b in the subspace defined by A which is
 n columns of linearly independent vectors of length m (they are in 
 real space R^m).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.QH.html" title="class in algorithms.matrix">MatrixUtil.QH</a></span></code>
<div class="block">a class to hold the results of a polar decomposition</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></span></code>
<div class="block">class to hold the results of the Singular Value Decomposition</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#MatrixUtil--">MatrixUtil</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#add-double:A-double:A-">add</a></span>(double[]&nbsp;m,
   double[]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#add-double-double:A-">add</a></span>(double&nbsp;s,
   double[]&nbsp;m)</code>
<div class="block">calculate s + m[i] for each i=[0, m.length).</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static float[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#add-float:A:A-float:A:A-">add</a></span>(float[][]&nbsp;m,
   float[][]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#add-float:A-float:A-">add</a></span>(float[]&nbsp;m,
   float[]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#add-int:A-int-">add</a></span>(int[]&nbsp;m,
   int&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#aMinusVectorTimesIdentity-double:A:A-double:A-">aMinusVectorTimesIdentity</a></span>(double[][]&nbsp;a,
                         double[]&nbsp;v)</code>
<div class="block">calculate a - v*I where A is square matrix and v is a vector.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#areColinear-double:A-double:A-double-">areColinear</a></span>(double[]&nbsp;p0,
           double[]&nbsp;p1,
           double&nbsp;eps)</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#areColinear-double:A-double:A-double:A-double-">areColinear</a></span>(double[]&nbsp;p0,
           double[]&nbsp;p1,
           double[]&nbsp;p2,
           double&nbsp;eps)</code>&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#backwardSubstitution-double:A:A-double:A-">backwardSubstitution</a></span>(double[][]&nbsp;upperTriangular,
                    double[]&nbsp;y)</code>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#backwardSubstitution-double:A:A-double:A-double:A-">backwardSubstitution</a></span>(double[][]&nbsp;upperTriangular,
                    double[]&nbsp;y,
                    double[]&nbsp;outX)</code>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#backwardSubstitution-no.uib.cipr.matrix.UpperTriangDenseMatrix-double:A-">backwardSubstitution</a></span>(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;upperTriangular,
                    double[]&nbsp;y)</code>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#calculateNormalizationMatrix2X3-double:A:A-">calculateNormalizationMatrix2X3</a></span>(double[][]&nbsp;xy)</code>
<div class="block">given data points xy, want to create a matrix usable to transform
 the data points by scaling and translation so that:
        a) points are translated so that their centroid is at the origin.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#calculatePreconditionerFromColumns-double:A:A-">calculatePreconditionerFromColumns</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate a pre-conditoner matrix based upon the columns of matrix a to 
 form a diagonal matrix:   D^(1/2) = diag( sqrt(d_1), ...</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#calculatePreconditionerFromLUP-double:A:A-">calculatePreconditionerFromLUP</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate a pre-conditoner matrix based upon the matrix U in
 the decompositon P*A = L*U where P is a permutation matrix,
 L is a lower triangular matrix, U is an upper triangular matrix.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#conditionNumber-double:A:A-">conditionNumber</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the condition number as the largest singular value divided
 by the singular value for i==(rank-1) of A where the singular values are
 found using the SVD.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#convertIntToDouble-int:A:A-">convertIntToDouble</a></span>(int[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static float[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#convertToFloat-double:A:A-">convertToFloat</a></span>(double[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#convertToRowMajor-no.uib.cipr.matrix.DenseMatrix-">convertToRowMajor</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#convertToRowMajor-no.uib.cipr.matrix.LowerSymmDenseMatrix-">convertToRowMajor</a></span>(no.uib.cipr.matrix.LowerSymmDenseMatrix&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#convertToRowMajor-no.uib.cipr.matrix.UpperTriangDenseMatrix-">convertToRowMajor</a></span>(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-double:A:A-">copy</a></span>(double[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-double:A:A-double:A:A-">copy</a></span>(double[][]&nbsp;source,
    double[][]&nbsp;destination)</code>&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static float[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-float:A:A-">copy</a></span>(float[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static gnu.trove.map.TIntIntMap</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-gnu.trove.map.TIntIntMap-">copy</a></span>(gnu.trove.map.TIntIntMap&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-gnu.trove.map.TIntObjectMap-">copy</a></span>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static gnu.trove.map.TObjectDoubleMap&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copy-gnu.trove.map.TObjectDoubleMap-">copy</a></span>(gnu.trove.map.TObjectDoubleMap&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copySubMatrix-double:A:A-int-int-int-int-">copySubMatrix</a></span>(double[][]&nbsp;a,
             int&nbsp;row0,
             int&nbsp;row1,
             int&nbsp;col0,
             int&nbsp;col1)</code>&nbsp;</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copySubMatrix-double:A:A-int-int-int-int-double:A:A-">copySubMatrix</a></span>(double[][]&nbsp;a,
             int&nbsp;row0,
             int&nbsp;row1,
             int&nbsp;col0,
             int&nbsp;col1,
             double[][]&nbsp;out)</code>
<div class="block">copy the section of matrix a from row0 to row1 (inclusive) and 
 col0 to col1 (inclusive) into output matrix out which must
 be size (row1-row0+1) X (col1-col0+1)</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#copyToSymmetricMap-gnu.trove.map.TIntObjectMap-">copyToSymmetricMap</a></span>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</code>
<div class="block">create a symmetric adjacency map from a</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#createATransposedTimesA-double:A:A-">createATransposedTimesA</a></span>(double[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#createCofactor-double:A:A-">createCofactor</a></span>(double[][]&nbsp;m)</code>&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#createIdentityMatrix-int-">createIdentityMatrix</a></span>(int&nbsp;nRows)</code>&nbsp;</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#createPermutationMatrix-int:A-">createPermutationMatrix</a></span>(int[]&nbsp;assignments)</code>
<div class="block">create a permutation matrix given the vector of permuted element indexes.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#createReverseMap-gnu.trove.map.TIntObjectMap-">createReverseMap</a></span>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;adj)</code>
<div class="block">given a map called adj having keys and values for each key, 
 create a map where the keys are adj.values and the
 values are the keys of adj.values.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#crossProduct-double:A-double:A-">crossProduct</a></span>(double[]&nbsp;p0,
            double[]&nbsp;p1)</code>&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#determinant-double:A:A-">determinant</a></span>(double[][]&nbsp;a)</code>
<div class="block">using cofactors and minors of the matrix, return the determinant.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#determinant-no.uib.cipr.matrix.Matrix-">determinant</a></span>(no.uib.cipr.matrix.Matrix&nbsp;a)</code>
<div class="block">using cofactors and minors of the matrix, return the determinant.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#determinantFromLU-double:A:A-">determinantFromLU</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the determinant of a using the diagonal of U from the
 LU decomposition.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#dot-double:A-double:A-">dot</a></span>(double[]&nbsp;a,
   double[]&nbsp;b)</code>
<div class="block">dot product, summation_over_i(a[i]*b[i])</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseAdd-double:A:A-double:A:A-">elementwiseAdd</a></span>(double[][]&nbsp;a,
              double[][]&nbsp;b)</code>
<div class="block">element-wise addition</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseAdd-double:A:A-double:A:A-double:A:A-">elementwiseAdd</a></span>(double[][]&nbsp;a,
              double[][]&nbsp;b,
              double[][]&nbsp;out)</code>
<div class="block">element-wise addition</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseDivision-double:A:A-double:A:A-">elementwiseDivision</a></span>(double[][]&nbsp;a,
                   double[][]&nbsp;b)</code>
<div class="block">right divide is element-wise division</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseDivision-double:A-double:A-">elementwiseDivision</a></span>(double[]&nbsp;a,
                   double[]&nbsp;b)</code>
<div class="block">right divide is element-wise division, that is a[i]/b[i] for i = [0, a.length).</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseMultiplication-double:A:A-double:A:A-">elementwiseMultiplication</a></span>(double[][]&nbsp;a,
                         double[][]&nbsp;b)</code>
<div class="block">element-wise multiplication</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseMultiplication-double:A-double:A-">elementwiseMultiplication</a></span>(double[]&nbsp;a,
                         double[]&nbsp;b)</code>
<div class="block">element-wise multiplication</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseMultiplication-int:A:A-int:A:A-">elementwiseMultiplication</a></span>(int[][]&nbsp;a,
                         int[][]&nbsp;b)</code>
<div class="block">element-wise multiplication</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseSubtract-double:A:A-double:A:A-">elementwiseSubtract</a></span>(double[][]&nbsp;a,
                   double[][]&nbsp;b)</code>
<div class="block">element-wise subtraction</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseSubtract-double:A:A-double:A:A-double:A:A-">elementwiseSubtract</a></span>(double[][]&nbsp;a,
                   double[][]&nbsp;b,
                   double[][]&nbsp;out)</code>
<div class="block">element-wise subtraction</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseSubtract-double:A-double:A-double:A-">elementwiseSubtract</a></span>(double[]&nbsp;a,
                   double[]&nbsp;b,
                   double[]&nbsp;out)</code>
<div class="block">element-wise subtraction</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#elementwiseSubtract-int:A:A-int:A:A-">elementwiseSubtract</a></span>(int[][]&nbsp;a,
                   int[][]&nbsp;b)</code>
<div class="block">element-wise subtraction</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#extractColumn-double:A:A-int-">extractColumn</a></span>(double[][]&nbsp;a,
             int&nbsp;col)</code>&nbsp;</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#extractColumn-double:A:A-int-double:A-">extractColumn</a></span>(double[][]&nbsp;a,
             int&nbsp;col,
             double[]&nbsp;out)</code>&nbsp;</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#fill-double:A:A-double-">fill</a></span>(double[][]&nbsp;a,
    double&nbsp;value)</code>&nbsp;</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#flipLR-double:A:A-">flipLR</a></span>(double[][]&nbsp;a)</code>
<div class="block">perform a left-right swap of the columns of a, flipping the matrix
 vertically.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#flipUD-double:A:A-">flipUD</a></span>(double[][]&nbsp;a)</code>
<div class="block">perform an up-down swap of the rows of a, flipping the matrix
 horizontally.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#forwardSubstitution-double:A:A-double:A-">forwardSubstitution</a></span>(double[][]&nbsp;lowerTriangular,
                   double[]&nbsp;b)</code>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#forwardSubstitution-double:A:A-double:A-double:A-">forwardSubstitution</a></span>(double[][]&nbsp;lowerTriangular,
                   double[]&nbsp;b,
                   double[]&nbsp;outX)</code>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#forwardSubstitution-no.uib.cipr.matrix.LowerTriangDenseMatrix-double:A-">forwardSubstitution</a></span>(no.uib.cipr.matrix.LowerTriangDenseMatrix&nbsp;lowerTriangular,
                   double[]&nbsp;b)</code>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#frobeniusNorm-double:A:A-">frobeniusNorm</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the Frobenius Norm of matrix a.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#innerProduct-double:A-double:A-">innerProduct</a></span>(double[]&nbsp;a,
            double[]&nbsp;b)</code>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#innerProduct-int:A-double:A-">innerProduct</a></span>(int[]&nbsp;a,
            double[]&nbsp;b)</code>&nbsp;</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#innerProduct-gnu.trove.list.array.TDoubleArrayList-gnu.trove.list.array.TDoubleArrayList-">innerProduct</a></span>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
            gnu.trove.list.array.TDoubleArrayList&nbsp;b)</code>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#inverse-double:A:A-">inverse</a></span>(double[][]&nbsp;m)</code>
<div class="block">find the equation for which A * A^(-1) = the identity matrix using cramer's rule.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isAPermutationMatrix-int:A:A-">isAPermutationMatrix</a></span>(int[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isInvertible-double:A:A-">isInvertible</a></span>(double[][]&nbsp;a)</code>
<div class="block">from Strang "Introduction to Linear Algebra":</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isOrthogonal-int:A:A-">isOrthogonal</a></span>(int[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isPositiveDefinite-double:A:A-">isPositiveDefinite</a></span>(double[][]&nbsp;a)</code>
<div class="block">A matrix is positive definite if itâ€™s symmetric and all its eigenvalues are positive</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isPositiveSymmetric-double:A:A-">isPositiveSymmetric</a></span>(double[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#isSquare-double:A:A-">isSquare</a></span>(double[][]&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#lp1Norm-int:A:A-">lp1Norm</a></span>(int[][]&nbsp;a)</code>
<div class="block">following the convention used by Matlab</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#lPSum-double:A-double-">lPSum</a></span>(double[]&nbsp;v,
     double&nbsp;p)</code>
<div class="block">summation = the (1/p) power of sum of 
 its (components)^p.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#mean-double:A:A-">mean</a></span>(double[][]&nbsp;a)</code>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A:A-double-">multiply</a></span>(double[][]&nbsp;m,
        double&nbsp;factor)</code>&nbsp;</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A:A-double:A:A-">multiply</a></span>(double[][]&nbsp;m,
        double[][]&nbsp;n)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A:A-double:A:A-double:A:A-">multiply</a></span>(double[][]&nbsp;m,
        double[][]&nbsp;n,
        double[][]&nbsp;out)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A:A-int:A:A-">multiply</a></span>(double[][]&nbsp;m,
        int[][]&nbsp;n)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A:A-int:A:A-double:A:A-">multiply</a></span>(double[][]&nbsp;m,
        int[][]&nbsp;n,
        double[][]&nbsp;out)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-double:A-double-">multiply</a></span>(double[]&nbsp;a,
        double&nbsp;f)</code>&nbsp;</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-float:A:A-float-">multiply</a></span>(float[][]&nbsp;a,
        float&nbsp;m)</code>
<div class="block">multiply matrix m by factor</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-int:A:A-double:A:A-">multiply</a></span>(int[][]&nbsp;m,
        double[][]&nbsp;n)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-int:A:A-double:A:A-double:A:A-">multiply</a></span>(int[][]&nbsp;m,
        double[][]&nbsp;n,
        double[][]&nbsp;out)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-int:A:A-int:A:A-">multiply</a></span>(int[][]&nbsp;m,
        int[][]&nbsp;n)</code>
<div class="block">multiply matrix m by matrix n</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-int:A-int-">multiply</a></span>(int[]&nbsp;m,
        int&nbsp;factor)</code>
<div class="block">multiply vector m by factor</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-int:A-int:A-">multiply</a></span>(int[]&nbsp;m,
        int[]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-no.uib.cipr.matrix.Matrix-double-">multiply</a></span>(no.uib.cipr.matrix.Matrix&nbsp;a,
        double&nbsp;b)</code>&nbsp;</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static no.uib.cipr.matrix.DenseMatrix</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-no.uib.cipr.matrix.Matrix-no.uib.cipr.matrix.Matrix-">multiply</a></span>(no.uib.cipr.matrix.Matrix&nbsp;m,
        no.uib.cipr.matrix.Matrix&nbsp;n)</code>
<div class="block">multiply matrices and return matrix of size mrows X ncols</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiply-gnu.trove.list.array.TDoubleArrayList-double-">multiply</a></span>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
        double&nbsp;f)</code>&nbsp;</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyByDiagonal-no.uib.cipr.matrix.DenseMatrix-double:A-">multiplyByDiagonal</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
                  double[]&nbsp;diag)</code>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyByDiagonal-double:A:A-double:A-">multiplyByDiagonal</a></span>(double[][]&nbsp;m,
                  double[]&nbsp;diag)</code>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-double:A:A-double:A-">multiplyMatrixByColumnVector</a></span>(double[][]&nbsp;m,
                            double[]&nbsp;n)</code>
<div class="block">multiply matrix m by vector n</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-double:A:A-double:A-double:A-">multiplyMatrixByColumnVector</a></span>(double[][]&nbsp;m,
                            double[]&nbsp;n,
                            double[]&nbsp;out)</code>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-double:A:A-int:A-">multiplyMatrixByColumnVector</a></span>(double[][]&nbsp;m,
                            int[]&nbsp;n)</code>
<div class="block">multiply matrix m by vector n</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-double:A:A-int:A-double:A-">multiplyMatrixByColumnVector</a></span>(double[][]&nbsp;m,
                            int[]&nbsp;n,
                            double[]&nbsp;out)</code>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-float:A:A-float:A-">multiplyMatrixByColumnVector</a></span>(float[][]&nbsp;m,
                            float[]&nbsp;n)</code>
<div class="block">multiply matrix m by vector n</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyMatrixByColumnVector-no.uib.cipr.matrix.Matrix-double:A-">multiplyMatrixByColumnVector</a></span>(no.uib.cipr.matrix.Matrix&nbsp;a,
                            double[]&nbsp;b)</code>&nbsp;</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multiplyRowVectorByMatrix-double:A-double:A:A-">multiplyRowVectorByMatrix</a></span>(double[]&nbsp;v,
                         double[][]&nbsp;m)</code>
<div class="block">multiply the row vector v by matrix m.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multisetIntersection-int:A-int:A-">multisetIntersection</a></span>(int[]&nbsp;orderedA,
                    int[]&nbsp;orderedB)</code>
<div class="block">given 2 non-decreasing ordered sequences of numbers, find their intersection.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#multisetUnorderedIntersection-int:A-int:A-">multisetUnorderedIntersection</a></span>(int[]&nbsp;a,
                             int[]&nbsp;b)</code>
<div class="block">given 2 sequences of numbers, find their intersection.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#nearestPositiveSemidefiniteToA-double:A:A-double-">nearestPositiveSemidefiniteToA</a></span>(double[][]&nbsp;a,
                              double&nbsp;eps)</code>
<div class="block">Given a matrix a that is not necessarily symmetric,
 and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#nearestPositiveSemidefiniteToASymmetric-double:A:A-double-">nearestPositiveSemidefiniteToASymmetric</a></span>(double[][]&nbsp;a,
                                       double&nbsp;eps)</code>
<div class="block">Given a symmetric matrix and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#normalizeColumnsL2-double:A:A-">normalizeColumnsL2</a></span>(double[][]&nbsp;a)</code>
<div class="block">normalize each column of matrix a by the square root of the sum of 
 its squared components.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#normalizeL2-double:A-">normalizeL2</a></span>(double[]&nbsp;v)</code>
<div class="block">normalize vector v by euclidean, that is the square root of the sum of 
 its squared components.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#normalizeLP-double:A-double-">normalizeLP</a></span>(double[]&nbsp;v,
           double&nbsp;p)</code>
<div class="block">normalize vector v by power p, that is the (1/p) power of sum of 
 its (components)^p.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#normalizeRowsL2-double:A:A-">normalizeRowsL2</a></span>(double[][]&nbsp;a)</code>
<div class="block">normalize each row of matrix a by the square root of the sum of 
 its squared components.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#outerProduct-double:A-double:A-">outerProduct</a></span>(double[]&nbsp;v1,
            double[]&nbsp;v2)</code>
<div class="block">the outer product of vectors v1 and v2, which is v1 as a single row matrix
 and v2 as a single column matrix, so is v1 * v2^T.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.QH.html" title="class in algorithms.matrix">MatrixUtil.QH</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performPolarDecomposition-double:A:A-">performPolarDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">perform a polar decomposition on square matrix a.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static no.uib.cipr.matrix.QR</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performQRDecomposition-double:A:A-">performQRDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">perform QR decomposition (a.k.a.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performSVD-no.uib.cipr.matrix.DenseMatrix-">performSVD</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;a)</code>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performSVD-double:A:A-">performSVD</a></span>(double[][]&nbsp;a)</code>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performSVDATransposeA-no.uib.cipr.matrix.DenseMatrix-">performSVDATransposeA</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;aTa)</code>&nbsp;</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#performSVDATransposeA-double:A:A-">performSVDATransposeA</a></span>(double[][]&nbsp;a)</code>
<div class="block">create matrix A^T*A then perform SVD on it.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#powerMethod-double:A:A-double-">powerMethod</a></span>(double[][]&nbsp;a,
           double&nbsp;tolerance)</code>
<div class="block">determine the largest eigenvalue using the power method.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#powerMethod-double:A:A-double-double:A-">powerMethod</a></span>(double[][]&nbsp;a,
           double&nbsp;tolerance,
           double[]&nbsp;x)</code>
<div class="block">determine the largest eigenvalue using the power method.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#powerMethod-double:A:A-int-">powerMethod</a></span>(double[][]&nbsp;a,
           int&nbsp;nIterations)</code>
<div class="block">determine the largest eigenvalue using the power method.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#powerMethodEigenPairs-double:A:A-double-">powerMethodEigenPairs</a></span>(double[][]&nbsp;a,
                     double&nbsp;tolerance)</code>
<div class="block">determine the eigenvalue pairs using the power method.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#powerOf-double:A:A-int-">powerOf</a></span>(double[][]&nbsp;a,
       int&nbsp;power)</code>
<div class="block">calculate (matrix A)^power using it's eigen decompostion:
 A^power = S * (Delta^power) * S^-1
 where S holds eigenvectors in its columns.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#projection-double:A:A-double:A-">projection</a></span>(double[][]&nbsp;a,
          double[]&nbsp;b)</code>
<div class="block">solve for the vector x which is the closest to a given vector b in the 
 subspace defined by A which is n columns of linearly independent vectors 
 of length m (they are in real space R^m).</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#pseudoinverseFullColumnRank-double:A:A-">pseudoinverseFullColumnRank</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 column rank matrix or overdetermined, 
 n >= rank.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#pseudoinverseFullRowRank-double:A:A-">pseudoinverseFullRowRank</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 row rank matrix, m >= rank.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#pseudoinverseRankDeficient-double:A:A-">pseudoinverseRankDeficient</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>(package private) static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#pseudoinverseRankDeficient-double:A:A-boolean-">pseudoinverseRankDeficient</a></span>(double[][]&nbsp;a,
                          boolean&nbsp;checkForFullRank)</code>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#rank-double:A:A-double-">rank</a></span>(double[][]&nbsp;a,
    double&nbsp;eps)</code>
<div class="block">determine the rank of martix A</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#reshapeToVector-double:A:A-">reshapeToVector</a></span>(double[][]&nbsp;a)</code>
<div class="block">rewrite matrix a into a vector using the order of all rows of column 0,
 then all rows of column 1, etc.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#skewSymmetric-double:A-">skewSymmetric</a></span>(double[]&nbsp;v)</code>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#skewSymmetric-double:A-double:A:A-">skewSymmetric</a></span>(double[]&nbsp;v,
             double[][]&nbsp;out)</code>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#spectralNorm-double:A:A-">spectralNorm</a></span>(double[][]&nbsp;r)</code>&nbsp;</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#squareRoot-double:A:A-">squareRoot</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the square root of symmetric positive definite matrix A using SVD.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#standardDeviation-double:A:A-">standardDeviation</a></span>(double[][]&nbsp;a)</code>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>static no.uib.cipr.matrix.DenseMatrix</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-no.uib.cipr.matrix.DenseMatrix-no.uib.cipr.matrix.DenseMatrix-">subtract</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
        no.uib.cipr.matrix.DenseMatrix&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-double:A-double-">subtract</a></span>(double[]&nbsp;m,
        double&nbsp;s)</code>
<div class="block">calculate m[i] - s for each i=[0, m.length).</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-double:A-double:A-">subtract</a></span>(double[]&nbsp;m,
        double[]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-double:A-double:A-double:A-">subtract</a></span>(double[]&nbsp;m,
        double[]&nbsp;n,
        double[]&nbsp;output)</code>&nbsp;</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-double-double:A-">subtract</a></span>(double&nbsp;s,
        double[]&nbsp;m)</code>
<div class="block">calculate s - m[i] for each i=[0, m.length).</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>static float[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-float:A:A-float:A:A-">subtract</a></span>(float[][]&nbsp;m,
        float[][]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>static float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-float:A-float:A-">subtract</a></span>(float[]&nbsp;m,
        float[]&nbsp;n)</code>&nbsp;</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>static gnu.trove.list.array.TDoubleArrayList</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#subtract-gnu.trove.list.array.TDoubleArrayList-gnu.trove.list.array.TDoubleArrayList-">subtract</a></span>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
        gnu.trove.list.array.TDoubleArrayList&nbsp;b)</code>&nbsp;</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#trace-double:A-">trace</a></span>(double[]&nbsp;v)</code>
<div class="block">calculate the sum of the diagonal elements of v*I (i.e.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#trace-double:A:A-">trace</a></span>(double[][]&nbsp;a)</code>
<div class="block">calculate the sum of the diagonal elements of a.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-algorithms.matrix.BlockMatrixIsometric-">transpose</a></span>(<a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a>&nbsp;a)</code>&nbsp;</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>static no.uib.cipr.matrix.DenseMatrix</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-no.uib.cipr.matrix.DenseMatrix-">transpose</a></span>(no.uib.cipr.matrix.DenseMatrix&nbsp;m)</code>&nbsp;</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-double:A:A-">transpose</a></span>(double[][]&nbsp;m)</code>&nbsp;</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-double:A:A-double:A:A-">transpose</a></span>(double[][]&nbsp;m,
         double[][]&nbsp;out)</code>
<div class="block">transpose matrix m into out matrix which must be size m[0].length X m.length.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>static float[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-float:A:A-">transpose</a></span>(float[][]&nbsp;m)</code>&nbsp;</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#transpose-int:A:A-">transpose</a></span>(int[][]&nbsp;m)</code>&nbsp;</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/MatrixUtil.html#zeros-int-int-">zeros</a></span>(int&nbsp;nRows,
     int&nbsp;nCols)</code>
<div class="block">create an array of zeros</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="MatrixUtil--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MatrixUtil</h4>
<pre>public&nbsp;MatrixUtil()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="multiplyRowVectorByMatrix-double:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyRowVectorByMatrix</h4>
<pre>public static&nbsp;double[]&nbsp;multiplyRowVectorByMatrix(double[]&nbsp;v,
                                                 double[][]&nbsp;m)</pre>
<div class="block">multiply the row vector v by matrix m.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dd><code>m</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result is size [1][m[0].length]</dd>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;double[]&nbsp;multiplyMatrixByColumnVector(double[][]&nbsp;m,
                                                    double[]&nbsp;n)</pre>
<div class="block">multiply matrix m by vector n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vector of length m.length</dd>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-double:A:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;double[]&nbsp;multiplyMatrixByColumnVector(double[][]&nbsp;m,
                                                    int[]&nbsp;n)</pre>
<div class="block">multiply matrix m by vector n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vector of length m.length</dd>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-double:A:A-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;void&nbsp;multiplyMatrixByColumnVector(double[][]&nbsp;m,
                                                double[]&nbsp;n,
                                                double[]&nbsp;out)</pre>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dd><code>out</code> - vector of length m.length to return results in</dd>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-double:A:A-int:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;void&nbsp;multiplyMatrixByColumnVector(double[][]&nbsp;m,
                                                int[]&nbsp;n,
                                                double[]&nbsp;out)</pre>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dd><code>out</code> - vector of length m.length to return results in</dd>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-float:A:A-float:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;float[]&nbsp;multiplyMatrixByColumnVector(float[][]&nbsp;m,
                                                   float[]&nbsp;n)</pre>
<div class="block">multiply matrix m by vector n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="multiplyMatrixByColumnVector-no.uib.cipr.matrix.Matrix-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyMatrixByColumnVector</h4>
<pre>public static&nbsp;double[]&nbsp;multiplyMatrixByColumnVector(no.uib.cipr.matrix.Matrix&nbsp;a,
                                                    double[]&nbsp;b)</pre>
</li>
</ul>
<a name="multiply-int:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(int[]&nbsp;m,
                            int&nbsp;factor)</pre>
<div class="block">multiply vector m by factor</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - one dimensional array that is input and output for result</dd>
<dd><code>factor</code> - factor to multiply m by</dd>
</dl>
</li>
</ul>
<a name="multiply-float:A:A-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(float[][]&nbsp;a,
                            float&nbsp;m)</pre>
<div class="block">multiply matrix m by factor</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in that is input and output for result</dd>
<dd><code>m</code> - factor to multiply m by</dd>
</dl>
</li>
</ul>
<a name="multiply-int:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(int[]&nbsp;m,
                            int[]&nbsp;n)</pre>
</li>
</ul>
<a name="multiply-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;double[][]&nbsp;multiply(double[][]&nbsp;m,
                                  double[][]&nbsp;n)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-double:A:A-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;double[][]&nbsp;multiply(double[][]&nbsp;m,
                                  int[][]&nbsp;n)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-int:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;double[][]&nbsp;multiply(int[][]&nbsp;m,
                                  double[][]&nbsp;n)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-double:A:A-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(double[][]&nbsp;m,
                            double[][]&nbsp;n,
                            double[][]&nbsp;out)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-double:A:A-int:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(double[][]&nbsp;m,
                            int[][]&nbsp;n,
                            double[][]&nbsp;out)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-int:A:A-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(int[][]&nbsp;m,
                            double[][]&nbsp;n,
                            double[][]&nbsp;out)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="multiply-int:A:A-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;int[][]&nbsp;multiply(int[][]&nbsp;m,
                               int[][]&nbsp;n)</pre>
<div class="block">multiply matrix m by matrix n</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>out the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</li>
</ul>
<a name="isOrthogonal-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOrthogonal</h4>
<pre>public static&nbsp;boolean&nbsp;isOrthogonal(int[][]&nbsp;a)</pre>
</li>
</ul>
<a name="isAPermutationMatrix-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isAPermutationMatrix</h4>
<pre>public static&nbsp;boolean&nbsp;isAPermutationMatrix(int[][]&nbsp;a)</pre>
</li>
</ul>
<a name="createATransposedTimesA-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createATransposedTimesA</h4>
<pre>public static&nbsp;double[][]&nbsp;createATransposedTimesA(double[][]&nbsp;a)</pre>
</li>
</ul>
<a name="multiply-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(double[]&nbsp;a,
                            double&nbsp;f)</pre>
</li>
</ul>
<a name="multiply-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(double[][]&nbsp;m,
                            double&nbsp;factor)</pre>
</li>
</ul>
<a name="multiply-no.uib.cipr.matrix.Matrix-no.uib.cipr.matrix.Matrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;no.uib.cipr.matrix.DenseMatrix&nbsp;multiply(no.uib.cipr.matrix.Matrix&nbsp;m,
                                                      no.uib.cipr.matrix.Matrix&nbsp;n)</pre>
<div class="block">multiply matrices and return matrix of size mrows X ncols</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="multiply-gnu.trove.list.array.TDoubleArrayList-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
                            double&nbsp;f)</pre>
</li>
</ul>
<a name="multiply-no.uib.cipr.matrix.Matrix-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(no.uib.cipr.matrix.Matrix&nbsp;a,
                            double&nbsp;b)</pre>
</li>
</ul>
<a name="multiplyByDiagonal-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyByDiagonal</h4>
<pre>public static&nbsp;double[][]&nbsp;multiplyByDiagonal(double[][]&nbsp;m,
                                            double[]&nbsp;diag)</pre>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>diag</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="multiplyByDiagonal-no.uib.cipr.matrix.DenseMatrix-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyByDiagonal</h4>
<pre>public static&nbsp;void&nbsp;multiplyByDiagonal(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
                                      double[]&nbsp;diag)</pre>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>diag</code> - </dd>
</dl>
</li>
</ul>
<a name="innerProduct-gnu.trove.list.array.TDoubleArrayList-gnu.trove.list.array.TDoubleArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProduct</h4>
<pre>public static&nbsp;double&nbsp;innerProduct(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
                                  gnu.trove.list.array.TDoubleArrayList&nbsp;b)</pre>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.  it's also known as the
 scalar product or dot product.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>scale result of a^T * b</dd>
</dl>
</li>
</ul>
<a name="innerProduct-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProduct</h4>
<pre>public static&nbsp;double&nbsp;innerProduct(double[]&nbsp;a,
                                  double[]&nbsp;b)</pre>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>scalar result of a^T * b</dd>
</dl>
</li>
</ul>
<a name="innerProduct-int:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProduct</h4>
<pre>public static&nbsp;double&nbsp;innerProduct(int[]&nbsp;a,
                                  double[]&nbsp;b)</pre>
</li>
</ul>
<a name="subtract-gnu.trove.list.array.TDoubleArrayList-gnu.trove.list.array.TDoubleArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;gnu.trove.list.array.TDoubleArrayList&nbsp;subtract(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
                                                             gnu.trove.list.array.TDoubleArrayList&nbsp;b)</pre>
</li>
</ul>
<a name="subtract-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;double[]&nbsp;subtract(double[]&nbsp;m,
                                double[]&nbsp;n)</pre>
</li>
</ul>
<a name="subtract-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;double[]&nbsp;subtract(double[]&nbsp;m,
                                double&nbsp;s)</pre>
<div class="block">calculate m[i] - s for each i=[0, m.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>s</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="subtract-double-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;double[]&nbsp;subtract(double&nbsp;s,
                                double[]&nbsp;m)</pre>
<div class="block">calculate s - m[i] for each i=[0, m.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>s</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="add-double-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;double[]&nbsp;add(double&nbsp;s,
                           double[]&nbsp;m)</pre>
<div class="block">calculate s + m[i] for each i=[0, m.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - </dd>
<dd><code>s</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="subtract-double:A-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(double[]&nbsp;m,
                            double[]&nbsp;n,
                            double[]&nbsp;output)</pre>
</li>
</ul>
<a name="add-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;double[]&nbsp;add(double[]&nbsp;m,
                           double[]&nbsp;n)</pre>
</li>
</ul>
<a name="add-float:A-float:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;float[]&nbsp;add(float[]&nbsp;m,
                          float[]&nbsp;n)</pre>
</li>
</ul>
<a name="subtract-float:A:A-float:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;float[][]&nbsp;subtract(float[][]&nbsp;m,
                                 float[][]&nbsp;n)</pre>
</li>
</ul>
<a name="add-float:A:A-float:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;float[][]&nbsp;add(float[][]&nbsp;m,
                            float[][]&nbsp;n)</pre>
</li>
</ul>
<a name="subtract-float:A-float:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;float[]&nbsp;subtract(float[]&nbsp;m,
                               float[]&nbsp;n)</pre>
</li>
</ul>
<a name="subtract-no.uib.cipr.matrix.DenseMatrix-no.uib.cipr.matrix.DenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;no.uib.cipr.matrix.DenseMatrix&nbsp;subtract(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
                                                      no.uib.cipr.matrix.DenseMatrix&nbsp;n)</pre>
</li>
</ul>
<a name="add-int:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(int[]&nbsp;m,
                       int&nbsp;n)</pre>
</li>
</ul>
<a name="transpose-float:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;float[][]&nbsp;transpose(float[][]&nbsp;m)</pre>
</li>
</ul>
<a name="transpose-no.uib.cipr.matrix.DenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;no.uib.cipr.matrix.DenseMatrix&nbsp;transpose(no.uib.cipr.matrix.DenseMatrix&nbsp;m)</pre>
</li>
</ul>
<a name="transpose-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;double[][]&nbsp;transpose(double[][]&nbsp;m)</pre>
</li>
</ul>
<a name="transpose-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;int[][]&nbsp;transpose(int[][]&nbsp;m)</pre>
</li>
</ul>
<a name="transpose-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;void&nbsp;transpose(double[][]&nbsp;m,
                             double[][]&nbsp;out)</pre>
<div class="block">transpose matrix m into out matrix which must be size m[0].length X m.length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - matrix to transpose</dd>
<dd><code>out</code> - output matrix to hold transposed m</dd>
</dl>
</li>
</ul>
<a name="convertToRowMajor-no.uib.cipr.matrix.DenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertToRowMajor</h4>
<pre>public static&nbsp;double[][]&nbsp;convertToRowMajor(no.uib.cipr.matrix.DenseMatrix&nbsp;a)</pre>
</li>
</ul>
<a name="convertToRowMajor-no.uib.cipr.matrix.UpperTriangDenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertToRowMajor</h4>
<pre>public static&nbsp;double[][]&nbsp;convertToRowMajor(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;a)</pre>
</li>
</ul>
<a name="convertToRowMajor-no.uib.cipr.matrix.LowerSymmDenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertToRowMajor</h4>
<pre>public static&nbsp;double[][]&nbsp;convertToRowMajor(no.uib.cipr.matrix.LowerSymmDenseMatrix&nbsp;a)</pre>
</li>
</ul>
<a name="pseudoinverseRankDeficient-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pseudoinverseRankDeficient</h4>
<pre>public static&nbsp;double[][]&nbsp;pseudoinverseRankDeficient(double[][]&nbsp;a)
                                             throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.
 Note that the term rank can be deceptive for cases when the 
 original matrix a was rank deficient and then is perturbed to become
 a full rank matrix leading to possibility of larger errors when treated as full rank.
 the term rank deficient can be replaced by the ter numerically rank deficient.
 (see Bjork 1991 Section 2, "Algorithms for linear least squares problems"
 and Chap 6 of Golub & Van Loan).
 This method uses the SVD of a,
 specifically, V*R*U^T where R is 1/diagonal of S for cases where
 rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
 Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
 inverse of A.
 
 Following Gilbert Strang's "Introduction to Linear Algebra".
 
 TODO: read "ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX" by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length >= a[0].length, the full rank pseudo-inverse
 is calculated instead of the rank-deficient;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>pseudo-inverse of matrix a. dimensions are those of a^T.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="pseudoinverseRankDeficient-double:A:A-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pseudoinverseRankDeficient</h4>
<pre>static&nbsp;double[][]&nbsp;pseudoinverseRankDeficient(double[][]&nbsp;a,
                                             boolean&nbsp;checkForFullRank)
                                      throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.
 Note that the term rank can be deceptive for cases when the 
 original matrix a was rank deficient and then is perturbed to become
 a full rank matrix leading to possibility of larger errors when treated as full rank.
 the term rank deficient can be replaced by the ter numerically rank deficient.
 (see Bjork 1991 Section 2, "Algorithms for linear least squares problems"
 and Chap 6 of Golub & Van Loan).
 This method uses the SVD of a,
 specifically, V*R*U^T where R is 1/diagonal of S for cases where
 rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
 Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
 inverse of A.
 
 Following Gilbert Strang's "Introduction to Linear Algebra".
 
 TODO: read "ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX" by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length >= a[0].length, the full rank pseudo-inverse
 is calculated instead of the rank-deficient;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - and m X n matrix</dd>
<dd><code>checkForFullRank</code> - if true, the method looks for a[0],length == rank
 and if it is full-rank, the method returns the results form pseudoinverseFullRank(a)
 instead.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>pseudo-inverse of matrix a. dimensions are those of a^T.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="pseudoinverseFullColumnRank-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pseudoinverseFullColumnRank</h4>
<pre>public static&nbsp;double[][]&nbsp;pseudoinverseFullColumnRank(double[][]&nbsp;a)
                                              throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 column rank matrix or overdetermined, 
 n >= rank.
 A_pseudoinverse for A being full column rank = inverse(A^T*A) * A^T.
 This particular pseudoinverse constitutes a left inverse.
 pseudoinv(A)*A = I.
 
 If inverting A^T*A fails, the methor returns results of pseudoinverseRankDeficient().
 
 NOTE that (A^T*A) (or (A * A^T)) has to be invertible, that is, 
 the reduced echelon form of A has linearly independent columns (rank==n).
 following pseudocode from Cormen et al. Introduction to Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format with dimensions
 m x n.  a is a full-rank matrix.
 a is a non-singular matrix(i.e. has exactly one solution).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>matrix of size [a[0].length][a.length]</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="pseudoinverseFullRowRank-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pseudoinverseFullRowRank</h4>
<pre>public static&nbsp;double[][]&nbsp;pseudoinverseFullRowRank(double[][]&nbsp;a)
                                           throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 row rank matrix, m >= rank.
 A_pseudoinverse for A being full row rank = a^T*inverse(A*A^T).
 This particular pseudoinverse constitutes a right inverse.
 A*pseudoinv(A) = I.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format with dimensions
 m x n.  a is a full-rank matrix.
 a is a non-singular matrix(i.e. has exactly one solution).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>matrix of size [a[0].length][a.length]</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="isInvertible-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInvertible</h4>
<pre>public static&nbsp;boolean&nbsp;isInvertible(double[][]&nbsp;a)</pre>
<div class="block">from Strang "Introduction to Linear Algebra":
      <pre>
       an inverse matrix may or may not exist.  
       (1) has to be a square matrix.
           A^-1 x A = I, where I is the identity matrix.
       (2) an inverse matrix has n pivots remaining after elimination,
                where pivot is the leftmost non-zero variable. i.e. the rank r
                is equal to the dimension of the square matrix which is n.
       (3) after elimination, next test for possible invertibility is 
             that the determinant is not zero

       if A is invertible, then A * x = b can be solved as x = A^-1 * b
       and (A * B)^-1 = B^-1 * A^-1
      </pre>
     NOTE: because this uses decomposition, each application using it should decide whether
 to perform the exterior operations at same time to avoid recomputing
 any matrices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if is invertible</dd>
</dl>
</li>
</ul>
<a name="rank-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rank</h4>
<pre>public static&nbsp;int&nbsp;rank(double[][]&nbsp;a,
                       double&nbsp;eps)
                throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">determine the rank of martix A
      <pre>
      If matrix A is a square matrix:
          uses LUP decomposition and counts the L diagonal 1's
      Else
          uses SVD and counts the non-zero diagonal singular values.
          
      NOTE: a positive tolerance level eps is used to find the number of singular values
      above eps instead of 0.
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>eps</code> - a positive number for the tolerance above zero of the pivots or
 singular values.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the rank of A</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="createReverseMap-gnu.trove.map.TIntObjectMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createReverseMap</h4>
<pre>public static&nbsp;gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;createReverseMap(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;adj)</pre>
<div class="block">given a map called adj having keys and values for each key, 
 create a map where the keys are adj.values and the
 values are the keys of adj.values.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>adj</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="performSVD-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performSVD</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;performSVD(double[][]&nbsp;a)
                                         throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.
 <pre>
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            
          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U 
          
          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="performSVD-no.uib.cipr.matrix.DenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performSVD</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;performSVD(no.uib.cipr.matrix.DenseMatrix&nbsp;a)
                                         throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.
 <pre>
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            
          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U 
          
          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="performSVDATransposeA-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performSVDATransposeA</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;performSVDATransposeA(double[][]&nbsp;a)
                                                    throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">create matrix A^T*A then perform SVD on it.  NOTE that the singular values
 returned in S will have the square of values of SVD(A).s.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - the matrix a (internally, a^T*a will be calculated and used)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="performSVDATransposeA-no.uib.cipr.matrix.DenseMatrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performSVDATransposeA</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;performSVDATransposeA(no.uib.cipr.matrix.DenseMatrix&nbsp;aTa)
                                                    throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="performQRDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performQRDecomposition</h4>
<pre>public static&nbsp;no.uib.cipr.matrix.QR&nbsp;performQRDecomposition(double[][]&nbsp;a)</pre>
<div class="block">perform QR decomposition (a.k.a. Francis algorithm, a.k.a. Francis QR step)
 on matrix a using the MTJ library.
 It's a sophisticated version of the "power method".
 A = Q*R of an orthonormal matrix Q and an upper triangular matrix R.
 The columns of Q are the eigenvectors of A.
 A*Q = Q * diag(eigenvalues of A).
 
 <pre>
 To calculate the product of eigenvalue or singular values using
 QR, see section "Connection to a determinant or a product of eigenvalues"
 in wikipedia:
 https://en.wikipedia.org/wiki/QR_decomposition
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square or rectangular matrix with independent columns.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="calculateNormalizationMatrix2X3-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateNormalizationMatrix2X3</h4>
<pre>public static&nbsp;double[][]&nbsp;calculateNormalizationMatrix2X3(double[][]&nbsp;xy)</pre>
<div class="block">given data points xy, want to create a matrix usable to transform
 the data points by scaling and translation so that:
        a) points are translated so that their centroid is at the origin.
        b) points are scaled so that the average distance from the
           origin is sqrt(2).
       Can use the transformation matrix with dot operator: Misc.multiply(xy, tMatrix).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a matrix for use for canonical transformation of the points.
 the format of the result is 
 <pre>
  t[0] = new double[]{scale,       0,     -centroidX*scale};
        t[1] = new double[]{0,           scale, -centroidY*scale};
       </pre></dd>
</dl>
</li>
</ul>
<a name="copy-float:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;float[][]&nbsp;copy(float[][]&nbsp;a)</pre>
</li>
</ul>
<a name="copy-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;double[][]&nbsp;copy(double[][]&nbsp;a)</pre>
</li>
</ul>
<a name="copy-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;void&nbsp;copy(double[][]&nbsp;source,
                        double[][]&nbsp;destination)</pre>
</li>
</ul>
<a name="copySubMatrix-double:A:A-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copySubMatrix</h4>
<pre>public static&nbsp;double[][]&nbsp;copySubMatrix(double[][]&nbsp;a,
                                       int&nbsp;row0,
                                       int&nbsp;row1,
                                       int&nbsp;col0,
                                       int&nbsp;col1)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>row0</code> - beginning index, inclusive</dd>
<dd><code>row1</code> - end index, inclusive</dd>
<dd><code>col0</code> - beginning index, inclusive</dd>
<dd><code>col1</code> - end index, inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="copySubMatrix-double:A:A-int-int-int-int-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copySubMatrix</h4>
<pre>public static&nbsp;void&nbsp;copySubMatrix(double[][]&nbsp;a,
                                 int&nbsp;row0,
                                 int&nbsp;row1,
                                 int&nbsp;col0,
                                 int&nbsp;col1,
                                 double[][]&nbsp;out)</pre>
<div class="block">copy the section of matrix a from row0 to row1 (inclusive) and 
 col0 to col1 (inclusive) into output matrix out which must
 be size (row1-row0+1) X (col1-col0+1)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>row0</code> - beginning index, inclusive</dd>
<dd><code>row1</code> - end index, inclusive</dd>
<dd><code>col0</code> - beginning index, inclusive</dd>
<dd><code>col1</code> - end index, inclusive</dd>
<dd><code>out</code> - output matrix to hold the copied section</dd>
</dl>
</li>
</ul>
<a name="extractColumn-double:A:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractColumn</h4>
<pre>public static&nbsp;double[]&nbsp;extractColumn(double[][]&nbsp;a,
                                     int&nbsp;col)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>col</code> - index of column to extract</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one dimensional array holding the column col of a</dd>
</dl>
</li>
</ul>
<a name="extractColumn-double:A:A-int-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractColumn</h4>
<pre>public static&nbsp;void&nbsp;extractColumn(double[][]&nbsp;a,
                                 int&nbsp;col,
                                 double[]&nbsp;out)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>col</code> - index of column to extract</dd>
<dd><code>out</code> - one dimensional array holding the column col of a</dd>
</dl>
</li>
</ul>
<a name="determinant-no.uib.cipr.matrix.Matrix-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determinant</h4>
<pre>public static&nbsp;double&nbsp;determinant(no.uib.cipr.matrix.Matrix&nbsp;a)</pre>
<div class="block">using cofactors and minors of the matrix, return the determinant.
 in practice one can use any row as the primary set of cofactors or
 any column.  this method may be optimized in the future, but for now,
 uses the first column as the cofactors.

 e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11
        + 135 + 2 = 148
         | 2   1  5 |
 <pre>
 Note that det(a) = 0 shows that matrix a is a singular matrix and is not
 invertible.
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the determinant of matrix a</dd>
</dl>
</li>
</ul>
<a name="determinant-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determinant</h4>
<pre>public static&nbsp;double&nbsp;determinant(double[][]&nbsp;a)</pre>
<div class="block">using cofactors and minors of the matrix, return the determinant.
 in practice one can use any row as the primary set of cofactors or
 any column.  this method may be optimized in the future, but for now,
 uses the first column as the cofactors.

 e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11 
        + 135 + 2 = 148
         | 2   1  5 |
 <pre>
 Note that det(a) = 0 shows that matrix a is a singular matrix and is not
 invertible.
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="determinantFromLU-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determinantFromLU</h4>
<pre>public static&nbsp;double&nbsp;determinantFromLU(double[][]&nbsp;a)</pre>
<div class="block">calculate the determinant of a using the diagonal of U from the
 LU decomposition.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="skewSymmetric-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skewSymmetric</h4>
<pre>public static&nbsp;double[][]&nbsp;skewSymmetric(double[]&nbsp;v)</pre>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.
 v cross product with w is v X w = [v]_x * w.
 Itâ€™s individual terms are a_j_i = -a_i_j.
       <pre>
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |
       
       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="skewSymmetric-double:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skewSymmetric</h4>
<pre>public static&nbsp;void&nbsp;skewSymmetric(double[]&nbsp;v,
                                 double[][]&nbsp;out)</pre>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.
 v cross product with w is v X w = [v]_x * w.
 Itâ€™s individual terms are a_j_i = -a_i_j.
       <pre>
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |
       
       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dd><code>out</code> - </dd>
</dl>
</li>
</ul>
<a name="crossProduct-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crossProduct</h4>
<pre>public static&nbsp;double[]&nbsp;crossProduct(double[]&nbsp;p0,
                                    double[]&nbsp;p1)</pre>
</li>
</ul>
<a name="areColinear-double:A-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>areColinear</h4>
<pre>public static&nbsp;boolean&nbsp;areColinear(double[]&nbsp;p0,
                                  double[]&nbsp;p1,
                                  double&nbsp;eps)</pre>
</li>
</ul>
<a name="areColinear-double:A-double:A-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>areColinear</h4>
<pre>public static&nbsp;boolean&nbsp;areColinear(double[]&nbsp;p0,
                                  double[]&nbsp;p1,
                                  double[]&nbsp;p2,
                                  double&nbsp;eps)</pre>
</li>
</ul>
<a name="normalizeL2-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizeL2</h4>
<pre>public static&nbsp;double[]&nbsp;normalizeL2(double[]&nbsp;v)</pre>
<div class="block">normalize vector v by euclidean, that is the square root of the sum of 
 its squared components.  notation is sometimes ||v||_2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="normalizeColumnsL2-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizeColumnsL2</h4>
<pre>public static&nbsp;void&nbsp;normalizeColumnsL2(double[][]&nbsp;a)</pre>
<div class="block">normalize each column of matrix a by the square root of the sum of 
 its squared components. ||v||_2 for each column...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - matrix</dd>
</dl>
</li>
</ul>
<a name="normalizeRowsL2-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizeRowsL2</h4>
<pre>public static&nbsp;void&nbsp;normalizeRowsL2(double[][]&nbsp;a)</pre>
<div class="block">normalize each row of matrix a by the square root of the sum of 
 its squared components. ||v||_2 for each row...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - matrix</dd>
</dl>
</li>
</ul>
<a name="conditionNumber-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conditionNumber</h4>
<pre>public static&nbsp;double&nbsp;conditionNumber(double[][]&nbsp;a)
                              throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the condition number as the largest singular value divided
 by the singular value for i==(rank-1) of A where the singular values are
 found using the SVD.
 
 from https://blogs.mathworks.com/cleve/2017/07/17/what-is-the-condition-number-of-a-matrix/
 A condition number for a matrix and computational task measures how 
 sensitive the answer is to perturbations in the input data and to roundoff 
 errors made during the solution process....If a matrix is singular, 
 then its condition number is infinite.
 ...(A large condition number means that the matrix is close to being singular).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="lPSum-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lPSum</h4>
<pre>public static&nbsp;double&nbsp;lPSum(double[]&nbsp;v,
                           double&nbsp;p)</pre>
<div class="block">summation = the (1/p) power of sum of 
 its (components)^p.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="lp1Norm-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lp1Norm</h4>
<pre>public static&nbsp;int&nbsp;lp1Norm(int[][]&nbsp;a)</pre>
<div class="block">following the convention used by Matlab
    <pre>
    https://www.mathworks.com/help/matlab/ref/norm.html#bvhji30-3

    For p-norm = 1, the L1-norm is the maximum absolute column sum of the matrix.
    ||X||_1 = max sum for an arg j where (0.lte.j.lte.n-1) sum_(i=0 to n-1) ( |a[i][j] )
    </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the maximum absolute column sum of the matrix</dd>
</dl>
</li>
</ul>
<a name="frobeniusNorm-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frobeniusNorm</h4>
<pre>public static&nbsp;double&nbsp;frobeniusNorm(double[][]&nbsp;a)</pre>
<div class="block">calculate the Frobenius Norm of matrix a.
 It's the square root of the sum of squares of each element.
 It can also be calculated as the square root of the
 trace of a_conjugate*a, or as
 the square root of the sums of the squares of the singular
 values of a.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="spectralNorm-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spectralNorm</h4>
<pre>public static&nbsp;double&nbsp;spectralNorm(double[][]&nbsp;r)
                           throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="nearestPositiveSemidefiniteToASymmetric-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nearestPositiveSemidefiniteToASymmetric</h4>
<pre>public static&nbsp;double[][]&nbsp;nearestPositiveSemidefiniteToASymmetric(double[][]&nbsp;a,
                                                                 double&nbsp;eps)
                                                          throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">Given a symmetric matrix and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.
 <pre>
 References:
 https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
 Cheng and Higham, 1998
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a symmetric matrix</dd>
<dd><code>eps</code> - a tolerance or error above 0 such as machine precision.  must
 be greater than or equal to 0.  If it is above 0, this method attempts
 to return a symmetric positive definite matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="nearestPositiveSemidefiniteToA-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nearestPositiveSemidefiniteToA</h4>
<pre>public static&nbsp;double[][]&nbsp;nearestPositiveSemidefiniteToA(double[][]&nbsp;a,
                                                        double&nbsp;eps)
                                                 throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">Given a matrix a that is not necessarily symmetric,
 and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.
 Note that this method attempts to make it symmetric positive definite by
 adding a small perturbation of size smallest eigenvalue to the diagonal
 of the resulting matrix.
 <pre>
 References:
 https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix which can be non-symmetric.</dd>
<dd><code>eps</code> - a tolerance or error above 0 such as machine precision.  must
 be greater than or equal to 0.  If it is above 0, this method attempts
 to return a symmetric positive definite matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="normalizeLP-double:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizeLP</h4>
<pre>public static&nbsp;double[]&nbsp;normalizeLP(double[]&nbsp;v,
                                   double&nbsp;p)</pre>
<div class="block">normalize vector v by power p, that is the (1/p) power of sum of 
 its (components)^p.  notation is sometimes ||v||_p.
 when p = 0, this is the manhattan normalization or taxi-cab normalization,
 when p = 2, this is the euclidean normalization.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="outerProduct-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerProduct</h4>
<pre>public static&nbsp;double[][]&nbsp;outerProduct(double[]&nbsp;v1,
                                      double[]&nbsp;v2)</pre>
<div class="block">the outer product of vectors v1 and v2, which is v1 as a single row matrix
 and v2 as a single column matrix, so is v1 * v2^T.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - </dd>
<dd><code>v2</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the outer product of v1 and v2 as double array of 
 size v1.length X v2.length.</dd>
</dl>
</li>
</ul>
<a name="powerMethod-double:A:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>powerMethod</h4>
<pre>public static&nbsp;double&nbsp;powerMethod(double[][]&nbsp;a,
                                 int&nbsp;nIterations)</pre>
<div class="block">determine the largest eigenvalue using the power method.  note that
 matrix A must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix A first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan 
 "Matrix Computations".
 
 calculates lambda in lambda * v = M * v for some constant eigenvalue lambda.
 
 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).
 TODO:consider implementing the inverse power method also to determine the
 smallest eigenvalue and its eigenvector</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>nIterations</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="powerMethod-double:A:A-double-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>powerMethod</h4>
<pre>public static&nbsp;double&nbsp;powerMethod(double[][]&nbsp;a,
                                 double&nbsp;tolerance,
                                 double[]&nbsp;x)</pre>
<div class="block">determine the largest eigenvalue using the power method.  note that
 matrix A must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix A first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan 
 "Matrix Computations".
 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dd><code>x</code> - an initialized vector of size a.length that will be filled by
 this method to hold the vector used to calculate eig = x^T * a * x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="powerMethod-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>powerMethod</h4>
<pre>public static&nbsp;double&nbsp;powerMethod(double[][]&nbsp;a,
                                 double&nbsp;tolerance)</pre>
<div class="block">determine the largest eigenvalue using the power method.  note that
 array a must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix a first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan 
 "Matrix Computations".
 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="powerMethodEigenPairs-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>powerMethodEigenPairs</h4>
<pre>public static&nbsp;double[]&nbsp;powerMethodEigenPairs(double[][]&nbsp;a,
                                             double&nbsp;tolerance)</pre>
<div class="block">determine the eigenvalue pairs using the power method.  note that
 array a must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix a first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method follows "Mining of Massive Datasets" by Leskovec, Rajaraman,
 and Ullman.  http://www.mmds.org/</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of a.length eigenvectors</dd>
</dl>
</li>
</ul>
<a name="powerOf-double:A:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>powerOf</h4>
<pre>public&nbsp;double[][]&nbsp;powerOf(double[][]&nbsp;a,
                          int&nbsp;power)
                   throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate (matrix A)^power using it's eigen decompostion:
 A^power = S * (Delta^power) * S^-1
 where S holds eigenvectors in its columns.  Delta is a diagonal matrix
 holding the eigenvalues.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix</dd>
<dd><code>power</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="squareRoot-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>squareRoot</h4>
<pre>public static&nbsp;double[][]&nbsp;squareRoot(double[][]&nbsp;a)
                             throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the square root of symmetric positive definite matrix A using SVD.
 
 <pre>
    [U, S, V] = svd(A)
    J = V * S^(1/2) * V^T is a symmetric nÃ—n matrix, such that square root of A = JJ.
    J is non-negative definite.
 </pre>
 from Allan Jepson's lecture on Gilbert Strang's SVD in machine learning
 http://www.cs.toronto.edu/~jepson/csc420/notes/introSVD.pdf
 Also see Chap 7.4 of "Introduction to LinearAlgebra" by Strang, the section
 on Polar Decomposition.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square symmetric non-negative definite matrix.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="isSquare-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isSquare</h4>
<pre>public static&nbsp;boolean&nbsp;isSquare(double[][]&nbsp;a)</pre>
</li>
</ul>
<a name="isPositiveSymmetric-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPositiveSymmetric</h4>
<pre>public static&nbsp;boolean&nbsp;isPositiveSymmetric(double[][]&nbsp;a)</pre>
</li>
</ul>
<a name="projection-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projection</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a>&nbsp;projection(double[][]&nbsp;a,
                                                      double[]&nbsp;b)
                                               throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">solve for the vector x which is the closest to a given vector b in the 
 subspace defined by A which is n columns of linearly independent vectors 
 of length m (they are in real space R^m).
 x is an approximation so is noted as x^{hat}.
 the projection p = A*x^{hat}.
 The matrix projection P = p*b.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - subspace defined by A which is n columns of linearly 
 independent vectors of length m (they are in real space R^m).</dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="isPositiveDefinite-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPositiveDefinite</h4>
<pre>public static&nbsp;boolean&nbsp;isPositiveDefinite(double[][]&nbsp;a)</pre>
<div class="block">A matrix is positive definite if itâ€™s symmetric and all its eigenvalues are positive</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="createCofactor-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createCofactor</h4>
<pre>public static&nbsp;double[][]&nbsp;createCofactor(double[][]&nbsp;m)</pre>
</li>
</ul>
<a name="inverse-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inverse</h4>
<pre>public static&nbsp;double[][]&nbsp;inverse(double[][]&nbsp;m)</pre>
<div class="block">find the equation for which A * A^(-1) = the identity matrix using cramer's rule.
 
 note that for a to be invertible, none of its eigenvalues can be 0.
 also note that if the number of linearly independent vectors os matrix
 A is equal to the number of columns of A, one can use the spectral
 decomposition: A^-1 = Q * (delta)^-1 * Q^-1
 where Q is a matrix whose columns hold eigenvectors and delta is a diagonal
 matrix holding the eigenvalues.

             1
 A^(-1) =  ------ C^(T)  where C_ij = cofactor of a_ij
            det A</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - a square invertible matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="mean-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mean</h4>
<pre>public static&nbsp;double[]&nbsp;mean(double[][]&nbsp;a)</pre>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables. 
 note that the format must be a[nSamples][nVariables],
 e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
 and nVariables = 3;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>mean of each column as an array of size a[0].length</dd>
</dl>
</li>
</ul>
<a name="standardDeviation-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>standardDeviation</h4>
<pre>public static&nbsp;double[]&nbsp;standardDeviation(double[][]&nbsp;a)</pre>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables. 
 note that the format must be a[nSamples][nVariables],
 e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
 and nVariables = 3;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="aMinusVectorTimesIdentity-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aMinusVectorTimesIdentity</h4>
<pre>public static&nbsp;double[][]&nbsp;aMinusVectorTimesIdentity(double[][]&nbsp;a,
                                                   double[]&nbsp;v)</pre>
<div class="block">calculate a - v*I where A is square matrix and v is a vector.  I is the identity
 matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix.</dd>
<dd><code>v</code> - a vector of length of a.length.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the matrix a - v*I.</dd>
</dl>
</li>
</ul>
<a name="trace-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trace</h4>
<pre>public static&nbsp;double&nbsp;trace(double[][]&nbsp;a)</pre>
<div class="block">calculate the sum of the diagonal elements of a.
 Note that the trace of matrix A equals the sum of its eigenvalues.
 Note: the trace of A is equal to the sum of its eigenvalues.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a square matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sum of the diagonal elements of a</dd>
</dl>
</li>
</ul>
<a name="trace-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trace</h4>
<pre>public static&nbsp;double&nbsp;trace(double[]&nbsp;v)</pre>
<div class="block">calculate the sum of the diagonal elements of v*I (i.e. sum of all elements of v)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - a vector to be treated as diagonal elements of an identity matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sum of the elements of v</dd>
</dl>
</li>
</ul>
<a name="elementwiseMultiplication-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseMultiplication</h4>
<pre>public static&nbsp;double[][]&nbsp;elementwiseMultiplication(double[][]&nbsp;a,
                                                   double[][]&nbsp;b)</pre>
<div class="block">element-wise multiplication</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="elementwiseMultiplication-int:A:A-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseMultiplication</h4>
<pre>public static&nbsp;int[][]&nbsp;elementwiseMultiplication(int[][]&nbsp;a,
                                                int[][]&nbsp;b)</pre>
<div class="block">element-wise multiplication</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="elementwiseAdd-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseAdd</h4>
<pre>public static&nbsp;double[][]&nbsp;elementwiseAdd(double[][]&nbsp;a,
                                        double[][]&nbsp;b)</pre>
<div class="block">element-wise addition</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="elementwiseAdd-double:A:A-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseAdd</h4>
<pre>public static&nbsp;void&nbsp;elementwiseAdd(double[][]&nbsp;a,
                                  double[][]&nbsp;b,
                                  double[][]&nbsp;out)</pre>
<div class="block">element-wise addition</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dd><code>out</code> - the results of element wise add of a + b. Note that it
 is safe to provide out as the same object as input argument a or b.</dd>
</dl>
</li>
</ul>
<a name="elementwiseSubtract-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseSubtract</h4>
<pre>public static&nbsp;double[][]&nbsp;elementwiseSubtract(double[][]&nbsp;a,
                                             double[][]&nbsp;b)</pre>
<div class="block">element-wise subtraction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="elementwiseSubtract-double:A:A-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseSubtract</h4>
<pre>public static&nbsp;void&nbsp;elementwiseSubtract(double[][]&nbsp;a,
                                       double[][]&nbsp;b,
                                       double[][]&nbsp;out)</pre>
<div class="block">element-wise subtraction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dd><code>out</code> - the results of element wise subtraction, a - b. Note that it
 is safe to provide out as the same object as input argument a or b.</dd>
</dl>
</li>
</ul>
<a name="elementwiseSubtract-int:A:A-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseSubtract</h4>
<pre>public static&nbsp;int[][]&nbsp;elementwiseSubtract(int[][]&nbsp;a,
                                          int[][]&nbsp;b)</pre>
<div class="block">element-wise subtraction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the results of element-wise subtraction, a - b.</dd>
</dl>
</li>
</ul>
<a name="elementwiseSubtract-double:A-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseSubtract</h4>
<pre>public static&nbsp;void&nbsp;elementwiseSubtract(double[]&nbsp;a,
                                       double[]&nbsp;b,
                                       double[]&nbsp;out)</pre>
<div class="block">element-wise subtraction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dd><code>out</code> - the results of element wise subtraction, a - b. Note that it
 is safe to provide out as the same object as input argument a or b.</dd>
</dl>
</li>
</ul>
<a name="elementwiseMultiplication-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseMultiplication</h4>
<pre>public static&nbsp;double[]&nbsp;elementwiseMultiplication(double[]&nbsp;a,
                                                 double[]&nbsp;b)</pre>
<div class="block">element-wise multiplication</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="dot-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dot</h4>
<pre>public static&nbsp;double&nbsp;dot(double[]&nbsp;a,
                         double[]&nbsp;b)</pre>
<div class="block">dot product, summation_over_i(a[i]*b[i])</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="zeros-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zeros</h4>
<pre>public static&nbsp;double[][]&nbsp;zeros(int&nbsp;nRows,
                               int&nbsp;nCols)</pre>
<div class="block">create an array of zeros</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nRows</code> - </dd>
<dd><code>nCols</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="createIdentityMatrix-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createIdentityMatrix</h4>
<pre>public static&nbsp;double[][]&nbsp;createIdentityMatrix(int&nbsp;nRows)</pre>
</li>
</ul>
<a name="elementwiseDivision-double:A:A-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseDivision</h4>
<pre>public static&nbsp;double[][]&nbsp;elementwiseDivision(double[][]&nbsp;a,
                                             double[][]&nbsp;b)</pre>
<div class="block">right divide is element-wise division</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="elementwiseDivision-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementwiseDivision</h4>
<pre>public static&nbsp;double[]&nbsp;elementwiseDivision(double[]&nbsp;a,
                                           double[]&nbsp;b)</pre>
<div class="block">right divide is element-wise division, that is a[i]/b[i] for i = [0, a.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="flipLR-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flipLR</h4>
<pre>public static&nbsp;void&nbsp;flipLR(double[][]&nbsp;a)</pre>
<div class="block">perform a left-right swap of the columns of a, flipping the matrix
 vertically.  the method mimics matlab's flipur.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
</dl>
</li>
</ul>
<a name="flipUD-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flipUD</h4>
<pre>public static&nbsp;void&nbsp;flipUD(double[][]&nbsp;a)</pre>
<div class="block">perform an up-down swap of the rows of a, flipping the matrix
 horizontally.  the method mimics matlab's flipud.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
</dl>
</li>
</ul>
<a name="forwardSubstitution-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forwardSubstitution</h4>
<pre>public static&nbsp;double[]&nbsp;forwardSubstitution(double[][]&nbsp;lowerTriangular,
                                           double[]&nbsp;b)</pre>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>x in equation L*x = b</dd>
</dl>
</li>
</ul>
<a name="forwardSubstitution-double:A:A-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forwardSubstitution</h4>
<pre>public static&nbsp;void&nbsp;forwardSubstitution(double[][]&nbsp;lowerTriangular,
                                       double[]&nbsp;b,
                                       double[]&nbsp;outX)</pre>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.
 method follows Golub & Van Loan algorithm 4.1-1.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dd><code>outX</code> - output variable x in equation L*x = b.  length is b.length.</dd>
</dl>
</li>
</ul>
<a name="forwardSubstitution-no.uib.cipr.matrix.LowerTriangDenseMatrix-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forwardSubstitution</h4>
<pre>public static&nbsp;double[]&nbsp;forwardSubstitution(no.uib.cipr.matrix.LowerTriangDenseMatrix&nbsp;lowerTriangular,
                                           double[]&nbsp;b)</pre>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.
 method follows Golub & Van Loan algorithm 4.1-1.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>x in equation L*x = b</dd>
</dl>
</li>
</ul>
<a name="backwardSubstitution-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backwardSubstitution</h4>
<pre>public static&nbsp;double[]&nbsp;backwardSubstitution(double[][]&nbsp;upperTriangular,
                                            double[]&nbsp;y)</pre>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.
 method follows Golub & Van Loan algorithm 4.1-2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>upperTriangular</code> - the upper triangular matrix
 (a_i_j=0 where i>j)
 <pre>
     0  1  2
        2  *  *  *
        1  *  *  
        0  *
           0  1  2
 </pre></dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>x in equation U*x = y</dd>
</dl>
</li>
</ul>
<a name="backwardSubstitution-double:A:A-double:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backwardSubstitution</h4>
<pre>public static&nbsp;void&nbsp;backwardSubstitution(double[][]&nbsp;upperTriangular,
                                        double[]&nbsp;y,
                                        double[]&nbsp;outX)</pre>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>upperTriangular</code> - the upper triangular matrix
 (a_i_j=0 where i>j)
 <pre>
     0  1  2
        2  *  *  *
        1  *  *  
        0  *
           0  1  2
 </pre></dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dd><code>outX</code> - output variable x in equation U*x = y.  must be length y.length.</dd>
</dl>
</li>
</ul>
<a name="backwardSubstitution-no.uib.cipr.matrix.UpperTriangDenseMatrix-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backwardSubstitution</h4>
<pre>public static&nbsp;double[]&nbsp;backwardSubstitution(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;upperTriangular,
                                            double[]&nbsp;y)</pre>
<div class="block">solves for vector x in the equation U*x = y where 
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>upperTriangular</code> - the upper triangular matrix</dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>x in equation U*x = y</dd>
</dl>
</li>
</ul>
<a name="fill-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fill</h4>
<pre>public static&nbsp;void&nbsp;fill(double[][]&nbsp;a,
                        double&nbsp;value)</pre>
</li>
</ul>
<a name="transpose-algorithms.matrix.BlockMatrixIsometric-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a>&nbsp;transpose(<a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a>&nbsp;a)</pre>
</li>
</ul>
<a name="reshapeToVector-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reshapeToVector</h4>
<pre>public static&nbsp;double[]&nbsp;reshapeToVector(double[][]&nbsp;a)</pre>
<div class="block">rewrite matrix a into a vector using the order of all rows of column 0,
 then all rows of column 1, etc.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="calculatePreconditionerFromLUP-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePreconditionerFromLUP</h4>
<pre>public static&nbsp;double[][]&nbsp;calculatePreconditionerFromLUP(double[][]&nbsp;a)
                                                 throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate a pre-conditoner matrix based upon the matrix U in
 the decompositon P*A = L*U where P is a permutation matrix,
 L is a lower triangular matrix, U is an upper triangular matrix.
 
 see Bjork 1991 Section 4.3, "Algorithms for linear least squares problems",
 especially the end of the section.
 
 from wikipedia:
 LU factorization with partial pivoting: It turns out that a proper 
 permutation in rows (or columns) is sufficient for LU factorization. 
 LU factorization with partial pivoting (LUP) refers often to LU 
 factorization with row permutations only.
 
 The choice of a good preconditioner may improve the speed of an iterative
 method.
 
 Note that if matrix a has full rank, the ideal choice of a preconditioner
 is instead of this method's results, is to use the Cholesky factor of 
 A^T*A. 
 Note that another preconditioner uses the columns of a to form a diagonal
 matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
   d_j = (||a_j||_2)^2  where a_j is column j of a.
 <pre>
 using a preconditioner involves reforming A*x = b into
 A * (M^-1) * y = b, solve for y
 and M * x = y, solve for x.
 
 Or the left precondition:
   (M^-1) * (A*x - b) = 0
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>matrix with dimensions of a^T</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="calculatePreconditionerFromColumns-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePreconditionerFromColumns</h4>
<pre>public static&nbsp;double[][]&nbsp;calculatePreconditionerFromColumns(double[][]&nbsp;a)
                                                     throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate a pre-conditoner matrix based upon the columns of matrix a to 
 form a diagonal matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
   d_j = (||a_j||_2)^2  where a_j is column j of a.
 
 see Bjork 1991 Section 4.3, "Algorithms for linear least squares problems",
 especially the end of the section.
 
 from wikipedia:
 LU factorization with partial pivoting: It turns out that a proper 
 permutation in rows (or columns) is sufficient for LU factorization. 
 LU factorization with partial pivoting (LUP) refers often to LU 
 factorization with row permutations only.
 
 The choice of a good preconditioner may improve the speed of an iterative
 method.
 
 Note that if matrix a has full rank, the ideal choice of a preconditioner
 is instead of this method's results, is to use the Cholesky factor of 
 A^T*A. 
 
 <pre>
 using a preconditioner involves reforming A*x = b into
 A * (M^-1) * y = b, solve for y
 and M * x = y, solve for x.
 
 Or the left precondition:
   (M^-1) * (A*x - b) = 0
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>matrix with dimensions of a^T</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="performPolarDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performPolarDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/MatrixUtil.QH.html" title="class in algorithms.matrix">MatrixUtil.QH</a>&nbsp;performPolarDecomposition(double[][]&nbsp;a)
                                               throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">perform a polar decomposition on square matrix a.
 A = Q*H where Q is orthogonal and H is a symmetric positive semidefinite matrix.  
     If A is invertible, then H is symmetric positive definite.
     The method follows Strang "Introduction to Linear Algebra" Chapter 7 section G.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - square matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="multisetIntersection-int:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multisetIntersection</h4>
<pre>public static&nbsp;int[]&nbsp;multisetIntersection(int[]&nbsp;orderedA,
                                         int[]&nbsp;orderedB)</pre>
<div class="block">given 2 non-decreasing ordered sequences of numbers, find their intersection.
 The method is called multiset because the sequences may contain more than
 one element having the same value... the method is used for multisets as multi-sequences.
 The runtime complexity is O(max(a.length, b.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>orderedA</code> - an increasing sequence of numbers (i.e. ascending sorted).</dd>
<dd><code>orderedB</code> - an increasing sequence of numbers (i.e. sorted by non-decreasing order)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="multisetUnorderedIntersection-int:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multisetUnorderedIntersection</h4>
<pre>public static&nbsp;int[]&nbsp;multisetUnorderedIntersection(int[]&nbsp;a,
                                                  int[]&nbsp;b)</pre>
<div class="block">given 2 sequences of numbers, find their intersection.
 The method is called multiset because the sequences may contain more than
 one element having the same value... the method is used for multisets as multi-sequences.
 The runtime complexity is O(N*log_2(N)) where N is max(a.length, b.length).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a sequence of numbers</dd>
<dd><code>b</code> - a sequence of numbers</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="copy-gnu.trove.map.TIntObjectMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;copy(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</pre>
</li>
</ul>
<a name="copy-gnu.trove.map.TObjectDoubleMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;gnu.trove.map.TObjectDoubleMap&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;copy(gnu.trove.map.TObjectDoubleMap&lt;<a href="../../algorithms/util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;a)</pre>
</li>
</ul>
<a name="copyToSymmetricMap-gnu.trove.map.TIntObjectMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyToSymmetricMap</h4>
<pre>public static&nbsp;gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;copyToSymmetricMap(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</pre>
<div class="block">create a symmetric adjacency map from a</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="copy-gnu.trove.map.TIntIntMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre>public static&nbsp;gnu.trove.map.TIntIntMap&nbsp;copy(gnu.trove.map.TIntIntMap&nbsp;a)</pre>
</li>
</ul>
<a name="convertToFloat-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertToFloat</h4>
<pre>public static&nbsp;float[][]&nbsp;convertToFloat(double[][]&nbsp;a)</pre>
</li>
</ul>
<a name="convertIntToDouble-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertIntToDouble</h4>
<pre>public static&nbsp;double[][]&nbsp;convertIntToDouble(int[][]&nbsp;a)</pre>
</li>
</ul>
<a name="createPermutationMatrix-int:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createPermutationMatrix</h4>
<pre>public static&nbsp;int[][]&nbsp;createPermutationMatrix(int[]&nbsp;assignments)</pre>
<div class="block">create a permutation matrix given the vector of permuted element indexes.
 Usage: pre-multiplying, P*A, results in permuting the rows of A.
 post-multiplying, A*P, results in permuting the columns of A.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>assignments</code> - the permutation vector.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/matrix/LinearEquations.LUP.html" title="class in algorithms.matrix"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../algorithms/matrix/MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/matrix/MatrixUtil.html" target="_top">Frames</a></li>
<li><a href="MatrixUtil.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
