<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Wed Feb 12 09:32:41 PST 2025 -->
<title>MatrixUtil</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2025-02-12">
<meta name="description" content="declaration: package: algorithms.matrix, class: MatrixUtil">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.matrix</a></div>
<h1 title="Class MatrixUtil" class="title">Class MatrixUtil</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.matrix.MatrixUtil</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">MatrixUtil</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block"><pre>
   misc notes:
 
   The eigenvalues can be determined in a few ways depending upon the matrix:
       If A is a positive definite matrix, can use the power method to find 
       the largest eigenvalue.  
          Caveat is that it performs best when the spectral gap is large 
          (diff between largest and 2nd largest eigenvalues).
       If A is symmetric, can diagonalize A.
       If A is not symmetric, can either diagonalize A^T*A and use the square root 
          of those eigenvalues or can use Singular Value Decomposition on A 
          (the singular values are the eigenvalues of A).
   Note that the eigenvectors are the same for the diagonalization of A, the 
   diagonalization of A^T*A, the SVD(A), and the same operations performed 
   on the CUR-Decompositions of A (=C) or on C^T*C.
   NOTE: for large-scale eigenvalue problems,consider cur decomposition, power
 method, qr decomposition (which for general matrices might include the 
 schur decomposition followed by back substitution), or
 for hermetician matrices can use divide and conquer eigenvalue algorithms and they
 are parallelizable.

 Some notes on the smallest eigenvalue of A:
 from Wirtz and Guhr 2014,
 “Distribution of the Smallest Eigenvalue in Complex and Real Correlated Wishart Ensembles”
 https://arxiv.org/pdf/1310.2467.pdf
 In linear discriminant analysis it [smallest eigenvalue] gives the leading contribution for the threshold estimate [21].
 It is most sensitive to noise in the data [18].
 In linear principal component analysis, the smallest eigenvalue determines the plane of closest fit [18].
 It is also crucial for the identification of single statistical outliers [17].
 In numerical studies involving large random matrices, the condition number is used, which depends
 on the smallest eigenvalue [22, 23]. In wireless communication the Multi–Input–Multi– Output (MIMO) channel matrix
 of an antenna system is modeled by a random matrix [24]. The smallest eigenvalue of C yields an estimate for the
 error of a received signal [25, 26, 27]. In finance, the optimal portfolio is associated with the eigenvector
 to the smallest eigenvalue of the covariance matrix, which is directly related to the correlation matrix [28].
 This incomplete list of examples shows the influence of the smallest eigenvalue in applications.
 Further information on the role of the smallest eigenvalue is given in Appendix A.
 [17] Barnett V, Lewis T. Outliers in Statistical Data. first edition ed. John Wiley &amp; Sons; 1980.
 [18] Gnanadesikan R. Methods for Statistical Data Analysis of Multivariate Oberservations.
 Second edition ed. John Wiley &amp; Sons; 1997.

 Note also, regarding finding the closest distance of a vector to a subspace in matrix A:
 One can use orthgoncal projection to solve for the distance, which is also called the residual
 or error vector.
     Given matrix A and vector b, we solve for x (i.e. x_est).
             A * x = b
        x_est is the subspace in A closest to b.   It's the best estimate for x.
        x_est = pseudoinverse(A) * b; [A=mxn, b=mx1, x_est=nx1]
        e.g. for full rank
             x_est = (A^T*A)^-1 * A^T * b

       The projection of b onto subspace x_est:
           p = A * x_est.  A=mxn, x_est=nx1, P=mx1

        The projection matrix in P = p*b is then
            P = A * pseudoinverse(A)
            e.g. for full rank
                P = A * (A^T*A)^-1 * A^T; A=mxn, P=mxm

        The vector that is perpendicular to the subspace of x_est is
            b - A * x_est
            this is called the residual, i.e. error vector

 Note that to estimate b - A * x_est, one could instead use eigenvectors (or singular value vectors):
    If an exact solution to b is possible (i.e. A is invertible, etc.), the eigenvectors are solved for matrix A,
    else the eigenvectors are solved for matrix A^T*A (which, if A is zero mean centered, is the covariance of A.
    see PCA for related, but different context).
    We want a vector of length n where A is mxn, so that means we use the right matrix of decomposed eigen/singular
    vectors (e.g. the V matrix in the SVD U, S, V matrices).
    The eigenvector associated with the smallest eigenvalue solves for the null space
    (eigenvalue is 0), and so it is perpendicular to the row space.
    This method is often used in optimization as total least squares regression.
    The x_est that minimizes ||b - A * x_est||^2 is the least squares solution for x_est when m > n.
 The projection matrix of A is A * pseudoinverse(A).


 Note that the eigenvector for the 2nd smallest eigenvalue of A, called the Fielder has distinct uses also,
 especially in community finding.
 Search for Fiedler vector in this code base.
 </pre>
 
 TODO: implement Orthogonal Iteration from Morita and Kanade Sect 3.2.2
   "A straightforward generalization of the power method can be used to compute 
   several dominant eigenvectors of a symmetric matrix."
   A useful alternative to the singular value decomposition in situations 
   where B is a large matrix and only a few of its largest eigenvalues are needed.
 for p eigenvalues out of n, if lambda__(p_1)/lambda_p is very small,
 the computation of the eigenvectors should proceed quickly.

 see https://netlib.org/lapack/explore-html/index.html for details of
 MTJ toolkit methods and LAPACK.getInstance() methods that might not be in MTJ

 Note that any rectangular matrix can be made into a square matrix by adding zero rows or columns,
 without changing the nonzero singular values.
 Bjorck 1991, "Algorithms for Linear Least Squares Problems"</div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="MatrixUtil.ConditionedMatrix.html" class="type-name-link" title="class in algorithms.matrix">MatrixUtil.ConditionedMatrix</a></code></div>
<div class="col-last even-row-color">
<div class="block">pre- and post- multiply using the diagonal matrices D_1 and D_2, depending upon the problem.</div>
</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="MatrixUtil.ProjectionResults.html" class="type-name-link" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a></code></div>
<div class="col-last odd-row-color">
<div class="block">holds data structures for having solved for the vector x which is the
 closest to a given vector b in the subspace defined by A which is
 n columns of linearly independent vectors of length m (they are in
 real space R^m).</div>
</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="MatrixUtil.QH.html" class="type-name-link" title="class in algorithms.matrix">MatrixUtil.QH</a></code></div>
<div class="col-last even-row-color">
<div class="block">a class to hold the results of a polar decomposition</div>
</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="MatrixUtil.SVDProducts.html" class="type-name-link" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></div>
<div class="col-last odd-row-color">
<div class="block">class to hold the results of the Singular Value Decomposition</div>
</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">MatrixUtil</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#add(double%5B%5D,double%5B%5D)" class="member-name-link">add</a><wbr>(double[]&nbsp;m,
 double[]&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#add(double,double%5B%5D)" class="member-name-link">add</a><wbr>(double&nbsp;s,
 double[]&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate s + m[i] for each i=[0, m.length).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#add(float%5B%5D%5B%5D,float%5B%5D%5B%5D)" class="member-name-link">add</a><wbr>(float[][]&nbsp;m,
 float[][]&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#add(float%5B%5D,float%5B%5D)" class="member-name-link">add</a><wbr>(float[]&nbsp;m,
 float[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#add(int%5B%5D,int)" class="member-name-link">add</a><wbr>(int[]&nbsp;m,
 int&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#allEigenValuesGEQ(double%5B%5D%5B%5D,double)" class="member-name-link">allEigenValuesGEQ</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tol)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">check whether all eigenvalues are >=  tol</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aMinusVectorTimesIdentity(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">aMinusVectorTimesIdentity</a><wbr>(double[][]&nbsp;a,
 double[]&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate a - v*I where A is square matrix and v is a vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#areColinear(double%5B%5D,double%5B%5D,double)" class="member-name-link">areColinear</a><wbr>(double[]&nbsp;p0,
 double[]&nbsp;p1,
 double&nbsp;eps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#areColinear(double%5B%5D,double%5B%5D,double%5B%5D,double)" class="member-name-link">areColinear</a><wbr>(double[]&nbsp;p0,
 double[]&nbsp;p1,
 double[]&nbsp;p2,
 double&nbsp;eps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#backwardSubstitution(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">backwardSubstitution</a><wbr>(double[][]&nbsp;upperTriangular,
 double[]&nbsp;y)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#backwardSubstitution(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">backwardSubstitution</a><wbr>(double[][]&nbsp;upperTriangular,
 double[]&nbsp;y,
 double[]&nbsp;outX)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#backwardSubstitution(no.uib.cipr.matrix.UpperTriangDenseMatrix,double%5B%5D)" class="member-name-link">backwardSubstitution</a><wbr>(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;upperTriangular,
 double[]&nbsp;y)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculateInfNormForColumns(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">calculateInfNormForColumns</a><wbr>(double[][]&nbsp;a,
 double[]&nbsp;output)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the infinity norm for each column of matrix a where the infinity norm
 for each col as a set is the maximum absolute value for that col.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculateInfNormForRows(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">calculateInfNormForRows</a><wbr>(double[][]&nbsp;a,
 double[]&nbsp;output)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the infinity norm for each row of matrix a where the infinity norm
 for each row as a set is the maximum absolute value for that row.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculateNormalizationMatrix2X3(double%5B%5D%5B%5D)" class="member-name-link">calculateNormalizationMatrix2X3</a><wbr>(double[][]&nbsp;xy)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given data points xy, want to create a matrix usable to transform
 the data points by scaling and translation so that:
        a) points are translated so that their centroid is at the origin.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePreconditionerFromColumns(double%5B%5D%5B%5D)" class="member-name-link">calculatePreconditionerFromColumns</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate a pre-conditoner matrix based upon the columns of matrix a to 
 form a diagonal matrix:   D^(1/2) = diag( sqrt(d_1), ...</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePreconditionerFromLUP(double%5B%5D%5B%5D)" class="member-name-link">calculatePreconditionerFromLUP</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate a pre-conditoner matrix based upon the matrix U in
 the decompositon P*A = L*U where P is a permutation matrix,
 L is a lower triangular matrix, U is an upper triangular matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#columnMeans(double%5B%5D%5B%5D)" class="member-name-link">columnMeans</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#conditionNumber(double%5B%5D%5B%5D)" class="member-name-link">conditionNumber</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the condition number as the largest singular value divided
 by the singular value for i==(rank-1) of A where the singular values are
 found using the SVD.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertIntToDouble(int%5B%5D%5B%5D)" class="member-name-link">convertIntToDouble</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertToDouble(float%5B%5D%5B%5D)" class="member-name-link">convertToDouble</a><wbr>(float[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertToFloat(double%5B%5D)" class="member-name-link">convertToFloat</a><wbr>(double[]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertToFloat(double%5B%5D%5B%5D)" class="member-name-link">convertToFloat</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertToFloat(int%5B%5D%5B%5D)" class="member-name-link">convertToFloat</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertToRowMajor(no.uib.cipr.matrix.Matrix)" class="member-name-link">convertToRowMajor</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(double%5B%5D)" class="member-name-link">copy</a><wbr>(double[]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(double%5B%5D%5B%5D)" class="member-name-link">copy</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">copy</a><wbr>(double[][]&nbsp;source,
 double[][]&nbsp;destination)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(float%5B%5D%5B%5D)" class="member-name-link">copy</a><wbr>(float[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(int%5B%5D%5B%5D)" class="member-name-link">copy</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.map.TIntIntMap</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(gnu.trove.map.TIntIntMap)" class="member-name-link">copy</a><wbr>(gnu.trove.map.TIntIntMap&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(gnu.trove.map.TIntObjectMap)" class="member-name-link">copy</a><wbr>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.map.TObjectDoubleMap&lt;<a href="../util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copy(gnu.trove.map.TObjectDoubleMap)" class="member-name-link">copy</a><wbr>(gnu.trove.map.TObjectDoubleMap&lt;<a href="../util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copyLongToDouble(long%5B%5D)" class="member-name-link">copyLongToDouble</a><wbr>(long[]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copyLongToFloat(long%5B%5D)" class="member-name-link">copyLongToFloat</a><wbr>(long[]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copySubMatrix(double%5B%5D%5B%5D,int,int,int,int)" class="member-name-link">copySubMatrix</a><wbr>(double[][]&nbsp;a,
 int&nbsp;row0,
 int&nbsp;row1,
 int&nbsp;col0,
 int&nbsp;col1)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copySubMatrix(double%5B%5D%5B%5D,int,int,int,int,double%5B%5D%5B%5D)" class="member-name-link">copySubMatrix</a><wbr>(double[][]&nbsp;a,
 int&nbsp;row0,
 int&nbsp;row1,
 int&nbsp;col0,
 int&nbsp;col1,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">copy the section of matrix a from row0 to row1 (inclusive) and
 col0 to col1 (inclusive) into output matrix out which must
 be size (row1-row0+1) X (col1-col0+1)</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#copyToSymmetricMap(gnu.trove.map.TIntObjectMap)" class="member-name-link">copyToSymmetricMap</a><wbr>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a symmetric adjacency map from a</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createATransposedTimesA(double%5B%5D%5B%5D)" class="member-name-link">createATransposedTimesA</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createATransposedTimesA(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">createATransposedTimesA</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createCofactor(double%5B%5D%5B%5D)" class="member-name-link">createCofactor</a><wbr>(double[][]&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createIdentityMatrix(int)" class="member-name-link">createIdentityMatrix</a><wbr>(int&nbsp;nRows)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createPermutationMatrix(int%5B%5D)" class="member-name-link">createPermutationMatrix</a><wbr>(int[]&nbsp;assignments)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a permutation matrix given the vector of permuted element indexes.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createReverseMap(gnu.trove.map.TIntObjectMap)" class="member-name-link">createReverseMap</a><wbr>(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;adj)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a map called adj having keys and values for each key, 
 create a map where the keys are adj.values and the
 values are the keys of adj.values.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#crossProduct(double%5B%5D,double%5B%5D)" class="member-name-link">crossProduct</a><wbr>(double[]&nbsp;p0,
 double[]&nbsp;p1)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#determinant(double%5B%5D%5B%5D)" class="member-name-link">determinant</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">using cofactors and minors of the matrix, return the determinant.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#determinant(float%5B%5D%5B%5D)" class="member-name-link">determinant</a><wbr>(float[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">using cofactors and minors of the matrix, return the determinant.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#determinant(no.uib.cipr.matrix.Matrix)" class="member-name-link">determinant</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">using cofactors and minors of the matrix, return the determinant.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#determinantFromLU(double%5B%5D%5B%5D)" class="member-name-link">determinantFromLU</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the determinant of a using the diagonal of U from the
 LU decomposition.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#dot(double%5B%5D,double%5B%5D)" class="member-name-link">dot</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">dot product, summation_over_i(a[i]*b[i])</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#eigenvalues2X2(double%5B%5D%5B%5D)" class="member-name-link">eigenvalues2X2</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate for matrix A, the 2 eigenvalues.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#eigenvalues2X2(float%5B%5D%5B%5D)" class="member-name-link">eigenvalues2X2</a><wbr>(float[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate for matrix A, the 2 eigenvalues.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#equals(int%5B%5D%5B%5D,int%5B%5D%5B%5D)" class="member-name-link">equals</a><wbr>(int[][]&nbsp;a,
 int[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractColumn(double%5B%5D%5B%5D,int)" class="member-name-link">extractColumn</a><wbr>(double[][]&nbsp;a,
 int&nbsp;col)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractColumn(double%5B%5D%5B%5D,int,double%5B%5D)" class="member-name-link">extractColumn</a><wbr>(double[][]&nbsp;a,
 int&nbsp;col,
 double[]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractVectorFromSkewSymmetric(double%5B%5D%5B%5D)" class="member-name-link">extractVectorFromSkewSymmetric</a><wbr>(double[][]&nbsp;vHat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract the vector from a skew-symmetric matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fill(double%5B%5D%5B%5D,double)" class="member-name-link">fill</a><wbr>(double[][]&nbsp;a,
 double&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#flipLR(double%5B%5D%5B%5D)" class="member-name-link">flipLR</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform a left-right swap of the columns of a, flipping the matrix
 vertically.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#flipUD(double%5B%5D%5B%5D)" class="member-name-link">flipUD</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform an up-down swap of the rows of a, flipping the matrix
 horizontally.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#forwardSubstitution(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">forwardSubstitution</a><wbr>(double[][]&nbsp;lowerTriangular,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#forwardSubstitution(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">forwardSubstitution</a><wbr>(double[][]&nbsp;lowerTriangular,
 double[]&nbsp;b,
 double[]&nbsp;outX)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#forwardSubstitution(no.uib.cipr.matrix.LowerTriangDenseMatrix,double%5B%5D)" class="member-name-link">forwardSubstitution</a><wbr>(no.uib.cipr.matrix.LowerTriangDenseMatrix&nbsp;lowerTriangular,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#frobeniusNorm(double%5B%5D%5B%5D)" class="member-name-link">frobeniusNorm</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the Frobenius Norm of matrix a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#innerProduct(double%5B%5D,double%5B%5D)" class="member-name-link">innerProduct</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#innerProduct(int%5B%5D,double%5B%5D)" class="member-name-link">innerProduct</a><wbr>(int[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#innerProduct(gnu.trove.list.array.TDoubleArrayList,gnu.trove.list.array.TDoubleArrayList)" class="member-name-link">innerProduct</a><wbr>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 gnu.trove.list.array.TDoubleArrayList&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#inverse(double%5B%5D%5B%5D)" class="member-name-link">inverse</a><wbr>(double[][]&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">find the equation for which A * A^(-1) = the identity matrix using cramer's rule.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isAPermutationMatrix(int%5B%5D%5B%5D)" class="member-name-link">isAPermutationMatrix</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isInvertible(double%5B%5D%5B%5D)" class="member-name-link">isInvertible</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">from Strang "Introduction to Linear Algebra":</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isOrthogonal(int%5B%5D%5B%5D)" class="member-name-link">isOrthogonal</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isPositiveDefinite(double%5B%5D%5B%5D)" class="member-name-link">isPositiveDefinite</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A matrix is positive definite if it’s symmetric and all its eigenvalues are positive,
 which means its pivots are positive.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isPositiveSymmetric(double%5B%5D%5B%5D)" class="member-name-link">isPositiveSymmetric</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isSquare(double%5B%5D%5B%5D)" class="member-name-link">isSquare</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isSymmetric(double%5B%5D%5B%5D,double)" class="member-name-link">isSymmetric</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tol)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">checks for a_ij == a_ji.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#kroneckerProduct(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">kroneckerProduct</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given two matrices A € R^(mxn) and B € R^(kxl), their Kronecker product,
 denoted by A⨂B, is a new matrix € R^(mk x nl).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#kroneckerProduct(double%5B%5D,double%5B%5D)" class="member-name-link">kroneckerProduct</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given two vectors A € R^(m) and B € R^(k), their Kronecker product,
 denoted by A⨂B, is a new matrix € R^(mk).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#lp1Norm(int%5B%5D%5B%5D)" class="member-name-link">lp1Norm</a><wbr>(int[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">following the convention used by Matlab</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#lPSum(double%5B%5D,double)" class="member-name-link">lPSum</a><wbr>(double[]&nbsp;v,
 double&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">summation = the (1/p) power of sum of its (components)^p.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D%5B%5D,double)" class="member-name-link">multiply</a><wbr>(double[][]&nbsp;m,
 double&nbsp;factor)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(double[][]&nbsp;m,
 double[][]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(double[][]&nbsp;m,
 double[][]&nbsp;n,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D%5B%5D,int%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(double[][]&nbsp;m,
 int[][]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D%5B%5D,int%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(double[][]&nbsp;m,
 int[][]&nbsp;n,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(double%5B%5D,double)" class="member-name-link">multiply</a><wbr>(double[]&nbsp;a,
 double&nbsp;f)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(float%5B%5D%5B%5D,float)" class="member-name-link">multiply</a><wbr>(float[][]&nbsp;a,
 float&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by factor</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(int%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(int[][]&nbsp;m,
 double[][]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(int%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(int[][]&nbsp;m,
 double[][]&nbsp;n,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(int%5B%5D%5B%5D,int%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(int[][]&nbsp;m,
 int[][]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(int%5B%5D,int)" class="member-name-link">multiply</a><wbr>(int[]&nbsp;m,
 int&nbsp;factor)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply vector m by factor</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(int%5B%5D,int%5B%5D)" class="member-name-link">multiply</a><wbr>(int[]&nbsp;m,
 int[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(gnu.trove.list.array.TDoubleArrayList,double)" class="member-name-link">multiply</a><wbr>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 double&nbsp;f)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(java.lang.String%5B%5D%5B%5D,java.lang.String%5B%5D%5B%5D)" class="member-name-link">multiply</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by matrix n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(no.uib.cipr.matrix.Matrix,double)" class="member-name-link">multiply</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;a,
 double&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiply(no.uib.cipr.matrix.Matrix,no.uib.cipr.matrix.Matrix)" class="member-name-link">multiply</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;m,
 no.uib.cipr.matrix.Matrix&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrices and return matrix of size mrows X ncols</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyByDiagonal(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">multiplyByDiagonal</a><wbr>(double[][]&nbsp;m,
 double[]&nbsp;diag)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyByDiagonal(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiplyByDiagonal</a><wbr>(double[][]&nbsp;m,
 double[]&nbsp;diag,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyByDiagonal(no.uib.cipr.matrix.DenseMatrix,double%5B%5D)" class="member-name-link">multiplyByDiagonal</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 double[]&nbsp;diag)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyDiagonalByMatrix(double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiplyDiagonalByMatrix</a><wbr>(double[]&nbsp;diag,
 double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply the diagonal matrix of diag by the matrix m and return the results in the given output matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyDiagonalByMatrix(double%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiplyDiagonalByMatrix</a><wbr>(double[]&nbsp;diag,
 double[][]&nbsp;a,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply the diagonal matrix of diag by the matrix m and return the results in the given output matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(double[][]&nbsp;m,
 double[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by vector n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(double[][]&nbsp;m,
 double[]&nbsp;n,
 double[]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(double%5B%5D%5B%5D,int%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(double[][]&nbsp;m,
 int[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by vector n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(double%5B%5D%5B%5D,int%5B%5D,double%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(double[][]&nbsp;m,
 int[]&nbsp;n,
 double[]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(float%5B%5D%5B%5D,float%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(float[][]&nbsp;m,
 float[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply matrix m by vector n</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyMatrixByColumnVector(no.uib.cipr.matrix.Matrix,double%5B%5D)" class="member-name-link">multiplyMatrixByColumnVector</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multiplyRowVectorByMatrix(double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">multiplyRowVectorByMatrix</a><wbr>(double[]&nbsp;v,
 double[][]&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply the row vector v by matrix m.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multisetIntersection(int%5B%5D,int%5B%5D)" class="member-name-link">multisetIntersection</a><wbr>(int[]&nbsp;orderedA,
 int[]&nbsp;orderedB)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given 2 non-decreasing ordered sequences of numbers, find their intersection.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#multisetUnorderedIntersection(int%5B%5D,int%5B%5D)" class="member-name-link">multisetUnorderedIntersection</a><wbr>(int[]&nbsp;a,
 int[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given 2 sequences of numbers, find their intersection.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nearestPositiveSemidefiniteToA(double%5B%5D%5B%5D,double)" class="member-name-link">nearestPositiveSemidefiniteToA</a><wbr>(double[][]&nbsp;a,
 double&nbsp;eps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a matrix a that is not necessarily symmetric,
 and a nonnegative number eps, find the
 nearest symmetric positive definite matrices with eigenvalues at least eps.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nearestPositiveSemidefiniteToASymmetric(double%5B%5D%5B%5D,double)" class="member-name-link">nearestPositiveSemidefiniteToASymmetric</a><wbr>(double[][]&nbsp;a,
 double&nbsp;eps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a symmetric matrix and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nearestSymmetricToA(double%5B%5D%5B%5D)" class="member-name-link">nearestSymmetricToA</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a matrix A that is not necessarily symmetric, find the
 nearest symmetric matrix to A.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeColumnsL2(double%5B%5D%5B%5D)" class="member-name-link">normalizeColumnsL2</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">normalize each column of matrix a by the square root of the sum of
 its squared components.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeL2(double%5B%5D)" class="member-name-link">normalizeL2</a><wbr>(double[]&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">normalize vector v by euclidean, that is the square root of the sum of
 its squared components.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeLP(double%5B%5D,double)" class="member-name-link">normalizeLP</a><wbr>(double[]&nbsp;v,
 double&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">normalize vector v by power p, that is the (1/p) power of sum of
 its (components)^p.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeRowsL2(double%5B%5D%5B%5D)" class="member-name-link">normalizeRowsL2</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">normalize each row of matrix a by the square root of the sum of
 its squared components.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nullSpaceUsingQR(double%5B%5D%5B%5D,double)" class="member-name-link">nullSpaceUsingQR</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tol)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">return the nullspace of matrix A using QR decomposition.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nullSpaceUsingSVD(double%5B%5D%5B%5D,double)" class="member-name-link">nullSpaceUsingSVD</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tol)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">return the nullspace of matrix A using SVD.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#outerProduct(double%5B%5D,double%5B%5D)" class="member-name-link">outerProduct</a><wbr>(double[]&nbsp;v1,
 double[]&nbsp;v2)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">the outer product of vectors v1 and v2, which is v1 as a single row matrix
 and v2 as a single column matrix, so is v1 * v2^T.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.QH.html" title="class in algorithms.matrix">MatrixUtil.QH</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performPolarDecomposition(double%5B%5D%5B%5D)" class="member-name-link">performPolarDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform a polar decomposition on square matrix a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.QR</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performQRDecomposition(double%5B%5D%5B%5D)" class="member-name-link">performQRDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform QR decomposition (a.k.a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performSVD(double%5B%5D%5B%5D)" class="member-name-link">performSVD</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performSVD(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">performSVD</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performSVDATransposeA(double%5B%5D%5B%5D)" class="member-name-link">performSVDATransposeA</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix A^T*A then perform SVD on it.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#performSVDATransposeA(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">performSVDATransposeA</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;aTa)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseAdd(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseAdd</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise addition</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseAdd(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseAdd</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise addition</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseDivision(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseDivision</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">right divide is pointwise division</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseDivision(double%5B%5D,double%5B%5D)" class="member-name-link">pointwiseDivision</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">right divide is pointwise division, that is a[i]/b[i] for i = [0, a.length).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseMultiplication(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseMultiplication</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise multiplication (a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseMultiplication(double%5B%5D,double%5B%5D)" class="member-name-link">pointwiseMultiplication</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise multiplication (a.k.a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseMultiplication(int%5B%5D%5B%5D,int%5B%5D%5B%5D)" class="member-name-link">pointwiseMultiplication</a><wbr>(int[][]&nbsp;a,
 int[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise multiplication (a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseSubtract(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseSubtract</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise subtraction</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseSubtract(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pointwiseSubtract</a><wbr>(double[][]&nbsp;a,
 double[][]&nbsp;b,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise subtraction</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseSubtract(double%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">pointwiseSubtract</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b,
 double[]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pointwise subtraction</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pointwiseSubtract(int%5B%5D%5B%5D,int%5B%5D%5B%5D)" class="member-name-link">pointwiseSubtract</a><wbr>(int[][]&nbsp;a,
 int[][]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">point-wise subtraction</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerMethod(double%5B%5D%5B%5D,double)" class="member-name-link">powerMethod</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tolerance)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the largest eigenvalue using the power method.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerMethod(double%5B%5D%5B%5D,double,double%5B%5D)" class="member-name-link">powerMethod</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tolerance,
 double[]&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the largest eigenvalue using the power method.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerMethod(double%5B%5D%5B%5D,int)" class="member-name-link">powerMethod</a><wbr>(double[][]&nbsp;a,
 int&nbsp;nIterations)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the largest eigenvalue using the power method.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerMethodEigenPairs(double%5B%5D%5B%5D,double)" class="member-name-link">powerMethodEigenPairs</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tolerance)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the eigenvalue pairs using the power method.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerOf(double%5B%5D%5B%5D,int)" class="member-name-link">powerOf</a><wbr>(double[][]&nbsp;a,
 int&nbsp;power)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">this method is not as fast as powerOfUsingEig(), but is useful for a look at power of 2 steps
 in multiplication.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#powerOfUsingEig(double%5B%5D%5B%5D,int)" class="member-name-link">powerOfUsingEig</a><wbr>(double[][]&nbsp;a,
 int&nbsp;power)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate (matrix A)^power using its eigen decompostion:
 A^power = S * (Delta^power) * S^-1
 where S holds eigenvectors in its columns.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.ConditionedMatrix.html" title="class in algorithms.matrix">MatrixUtil.ConditionedMatrix</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#preconditionScaling(double%5B%5D%5B%5D)" class="member-name-link">preconditionScaling</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">apply Ruiz scaling as "equilibration" for matrix a as a linear system in order to
 pre-condition it before use.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#projection(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">projection</a><wbr>(double[][]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solve for the vector x which is the closest to a given vector b in the
 subspace defined by A which is n columns of linearly independent vectors
 of length m (they are in real space R^m).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pseudoinverseFullColumnRank(double%5B%5D%5B%5D)" class="member-name-link">pseudoinverseFullColumnRank</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 column rank matrix or overdetermined, 
 n .geq.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pseudoinverseFullRowRank(double%5B%5D%5B%5D)" class="member-name-link">pseudoinverseFullRowRank</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 row rank matrix, m .geq.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pseudoinverseRankDeficient(double%5B%5D%5B%5D)" class="member-name-link">pseudoinverseRankDeficient</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#pseudoinverseRankDeficient(double%5B%5D%5B%5D,boolean)" class="member-name-link">pseudoinverseRankDeficient</a><wbr>(double[][]&nbsp;a,
 boolean&nbsp;checkForFullRank)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(double%5B%5D%5B%5D)" class="member-name-link">rank</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(double%5B%5D%5B%5D,double)" class="member-name-link">rank</a><wbr>(double[][]&nbsp;a,
 double&nbsp;eps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the rank of martix A</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(algorithms.matrix.MatrixUtil.SVDProducts)" class="member-name-link">rank</a><wbr>(<a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;svd)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rank(no.uib.cipr.matrix.SVD)" class="member-name-link">rank</a><wbr>(no.uib.cipr.matrix.SVD&nbsp;svd)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reshapeToVector(double%5B%5D%5B%5D)" class="member-name-link">reshapeToVector</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">rewrite matrix a into a vector using the order of all rows of column 0,
 then all rows of column 1, etc.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rowMeans(double%5B%5D%5B%5D)" class="member-name-link">rowMeans</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a, return the mean of each row of a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#skewSymmetric(double%5B%5D)" class="member-name-link">skewSymmetric</a><wbr>(double[]&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#skewSymmetric(double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">skewSymmetric</a><wbr>(double[]&nbsp;v,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>,<wbr>no.uib.cipr.matrix.DenseVectorSub&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sparseEigen(no.uib.cipr.matrix.Matrix,int,no.uib.cipr.matrix.sparse.ArpackSym.Ritz)" class="member-name-link">sparseEigen</a><wbr>(no.uib.cipr.matrix.Matrix&nbsp;A,
 int&nbsp;nEigenValues,
 no.uib.cipr.matrix.sparse.ArpackSym.Ritz&nbsp;ritz)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">use the MTJ arpack to partially solve symmetric eigensystems for eigenvalues.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#spectralNorm(double%5B%5D%5B%5D)" class="member-name-link">spectralNorm</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the value of the largest singular value of matrix r.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#squareRoot(double%5B%5D%5B%5D)" class="member-name-link">squareRoot</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the square root of symmetric positive definite matrix A using SVD.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#stack(double%5B%5D%5B%5D)" class="member-name-link">stack</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract each column of a and append it to an output vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#standardDeviation(double%5B%5D%5B%5D)" class="member-name-link">standardDeviation</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(double%5B%5D,double)" class="member-name-link">subtract</a><wbr>(double[]&nbsp;m,
 double&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate m[i] - s for each i=[0, m.length).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(double%5B%5D,double%5B%5D)" class="member-name-link">subtract</a><wbr>(double[]&nbsp;m,
 double[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(double%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">subtract</a><wbr>(double[]&nbsp;m,
 double[]&nbsp;n,
 double[]&nbsp;output)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(double,double%5B%5D)" class="member-name-link">subtract</a><wbr>(double&nbsp;s,
 double[]&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate s - m[i] for each i=[0, m.length).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(float%5B%5D%5B%5D,float%5B%5D%5B%5D)" class="member-name-link">subtract</a><wbr>(float[][]&nbsp;m,
 float[][]&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(float%5B%5D,float%5B%5D)" class="member-name-link">subtract</a><wbr>(float[]&nbsp;m,
 float[]&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static gnu.trove.list.array.TDoubleArrayList</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(gnu.trove.list.array.TDoubleArrayList,gnu.trove.list.array.TDoubleArrayList)" class="member-name-link">subtract</a><wbr>(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 gnu.trove.list.array.TDoubleArrayList&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#subtract(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">subtract</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 no.uib.cipr.matrix.DenseMatrix&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#trace(double%5B%5D)" class="member-name-link">trace</a><wbr>(double[]&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the sum of the diagonal elements of v*I (i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#trace(double%5B%5D%5B%5D)" class="member-name-link">trace</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the sum of the diagonal elements of a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#trace(float%5B%5D%5B%5D)" class="member-name-link">trace</a><wbr>(float[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the sum of the diagonal elements of a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(double%5B%5D%5B%5D)" class="member-name-link">transpose</a><wbr>(double[][]&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">transpose</a><wbr>(double[][]&nbsp;m,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">transpose matrix m into out matrix which must be size m[0].length X m.length.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(float%5B%5D%5B%5D)" class="member-name-link">transpose</a><wbr>(float[][]&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(int%5B%5D%5B%5D)" class="member-name-link">transpose</a><wbr>(int[][]&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(algorithms.matrix.BlockMatrixIsometric)" class="member-name-link">transpose</a><wbr>(<a href="BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a>&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(java.lang.String%5B%5D%5B%5D)" class="member-name-link">transpose</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#transpose(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">transpose</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#tripleProduct(double%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">tripleProduct</a><wbr>(double[]&nbsp;a,
 double[]&nbsp;b,
 double[]&nbsp;c)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the triple product as a x (b X c).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#zeros(int,int)" class="member-name-link">zeros</a><wbr>(int&nbsp;nRows,
 int&nbsp;nCols)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create an array of zeros</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>MatrixUtil</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">MatrixUtil</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="multiplyRowVectorByMatrix(double[],double[][])">
<h3>multiplyRowVectorByMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">multiplyRowVectorByMatrix</span><wbr><span class="parameters">(double[]&nbsp;v,
 double[][]&nbsp;m)</span></div>
<div class="block">multiply the row vector v by matrix m.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector</dd>
<dd><code>m</code> - matrix</dd>
<dt>Returns:</dt>
<dd>result is size [1][m[0].length]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(double[][],double[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[]&nbsp;n)</span></div>
<div class="block">multiply matrix m by vector n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt>Returns:</dt>
<dd>vector of length m.length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(double[][],int[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(double[][]&nbsp;m,
 int[]&nbsp;n)</span></div>
<div class="block">multiply matrix m by vector n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt>Returns:</dt>
<dd>vector of length m.length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(double[][],double[],double[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[]&nbsp;n,
 double[]&nbsp;out)</span></div>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dd><code>out</code> - vector of length m.length to return results in</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(double[][],int[],double[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(double[][]&nbsp;m,
 int[]&nbsp;n,
 double[]&nbsp;out)</span></div>
<div class="block">multiply matrix m by vector n and return results in given vector out</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dd><code>out</code> - vector of length m.length to return results in</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(float[][],float[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(float[][]&nbsp;m,
 float[]&nbsp;n)</span></div>
<div class="block">multiply matrix m by vector n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - one dimensional array</dd>
<dt>Returns:</dt>
<dd>result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyMatrixByColumnVector(no.uib.cipr.matrix.Matrix,double[])">
<h3>multiplyMatrixByColumnVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">multiplyMatrixByColumnVector</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;a,
 double[]&nbsp;b)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(int[],int)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(int[]&nbsp;m,
 int&nbsp;factor)</span></div>
<div class="block">multiply vector m by factor</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - one dimensional array that is input and output for result</dd>
<dd><code>factor</code> - factor to multiply m by</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(float[][],float)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(float[][]&nbsp;a,
 float&nbsp;m)</span></div>
<div class="block">multiply matrix m by factor</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in that is input and output for result</dd>
<dd><code>m</code> - factor to multiply m by</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(int[],int[])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(int[]&nbsp;m,
 int[]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(double[][],double[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[][]&nbsp;n)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two-dimensional array in row major format</dd>
<dd><code>n</code> - two-dimensional array in row major format</dd>
<dt>Returns:</dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(double[][],int[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[][]&nbsp;m,
 int[][]&nbsp;n)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt>Returns:</dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(int[][],double[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(int[][]&nbsp;m,
 double[][]&nbsp;n)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt>Returns:</dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(java.lang.String[][],java.lang.String[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;n)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt>Returns:</dt>
<dd>multiplication of m by n.  resulting matrix is size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(java.lang.String[][])">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>[][]&nbsp;m)</span></div>
</section>
</li>
<li>
<section class="detail" id="multiply(double[][],double[][],double[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[][]&nbsp;n,
 double[][]&nbsp;out)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - two-dimensional array in row major format</dd>
<dd><code>n</code> - two-dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(double[][],int[][],double[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[][]&nbsp;m,
 int[][]&nbsp;n,
 double[][]&nbsp;out)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(int[][],double[][],double[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(int[][]&nbsp;m,
 double[][]&nbsp;n,
 double[][]&nbsp;out)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dd><code>out</code> - the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(int[][],int[][])">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(int[][]&nbsp;m,
 int[][]&nbsp;n)</span></div>
<div class="block">multiply matrix m by matrix n</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - tow dimensional array in row major format</dd>
<dd><code>n</code> - two dimensional array in row major format</dd>
<dt>Returns:</dt>
<dd>out the results of multiplication of m by n.  the matrix should be size mrows X ncols.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isOrthogonal(int[][])">
<h3>isOrthogonal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isOrthogonal</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="isAPermutationMatrix(int[][])">
<h3>isAPermutationMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isAPermutationMatrix</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createATransposedTimesA(double[][])">
<h3>createATransposedTimesA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createATransposedTimesA</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createATransposedTimesA(double[][],double[][])">
<h3>createATransposedTimesA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">createATransposedTimesA</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;out)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>out</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(double[],double)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[]&nbsp;a,
 double&nbsp;f)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>f</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(double[][],double)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double&nbsp;factor)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>factor</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(no.uib.cipr.matrix.Matrix,no.uib.cipr.matrix.Matrix)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;m,
 no.uib.cipr.matrix.Matrix&nbsp;n)</span></div>
<div class="block">multiply matrices and return matrix of size mrows X ncols</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - matrix</dd>
<dd><code>n</code> - matrix</dd>
<dt>Returns:</dt>
<dd>result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(gnu.trove.list.array.TDoubleArrayList,double)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 double&nbsp;f)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>f</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiply(no.uib.cipr.matrix.Matrix,double)">
<h3>multiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiply</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;a,
 double&nbsp;b)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyByDiagonal(double[][],double[])">
<h3>multiplyByDiagonal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">multiplyByDiagonal</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[]&nbsp;diag)</span></div>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - matrix</dd>
<dd><code>diag</code> - vector</dd>
<dt>Returns:</dt>
<dd>result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyDiagonalByMatrix(double[],double[][])">
<h3>multiplyDiagonalByMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">multiplyDiagonalByMatrix</span><wbr><span class="parameters">(double[]&nbsp;diag,
 double[][]&nbsp;a)</span></div>
<div class="block">multiply the diagonal matrix of diag by the matrix m and return the results in the given output matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>diag</code> - an array holding the diagonal elements of the diagonal matrix.  size is length a.length.</dd>
<dd><code>a</code> - an mxn matrix.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyDiagonalByMatrix(double[],double[][],double[][])">
<h3>multiplyDiagonalByMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiplyDiagonalByMatrix</span><wbr><span class="parameters">(double[]&nbsp;diag,
 double[][]&nbsp;a,
 double[][]&nbsp;out)</span></div>
<div class="block">multiply the diagonal matrix of diag by the matrix m and return the results in the given output matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>diag</code> - an array holding the diagonal elements of the diagonal matrix.  size is length a.length.</dd>
<dd><code>a</code> - an mxn matrix.</dd>
<dd><code>out</code> - output matrix of size a.length X a[0].length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyByDiagonal(double[][],double[],double[][])">
<h3>multiplyByDiagonal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiplyByDiagonal</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[]&nbsp;diag,
 double[][]&nbsp;out)</span></div>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - matrix</dd>
<dd><code>diag</code> - vector</dd>
<dd><code>out</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multiplyByDiagonal(no.uib.cipr.matrix.DenseMatrix,double[])">
<h3>multiplyByDiagonal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">multiplyByDiagonal</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 double[]&nbsp;diag)</span></div>
<div class="block">perform dot product of m and a diagonalized matrix of diag,
 and return matrix of size mrows X mcols</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - matrix</dd>
<dd><code>diag</code> - diagonal array to use in diagonal matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="innerProduct(gnu.trove.list.array.TDoubleArrayList,gnu.trove.list.array.TDoubleArrayList)">
<h3>innerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">innerProduct</span><wbr><span class="parameters">(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 gnu.trove.list.array.TDoubleArrayList&nbsp;b)</span></div>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.  it's also known as the
 scalar product or dot product.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - list</dd>
<dd><code>b</code> - list</dd>
<dt>Returns:</dt>
<dd>scale result of a^T * b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="innerProduct(double[],double[])">
<h3>innerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">innerProduct</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">calculates the inner product of a and b, which is a as a single row matrix
 and b as a single column matrix, so is a^T * b.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array</dd>
<dd><code>b</code> - array</dd>
<dt>Returns:</dt>
<dd>scalar result of a^T * b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="innerProduct(int[],double[])">
<h3>innerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">innerProduct</span><wbr><span class="parameters">(int[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(gnu.trove.list.array.TDoubleArrayList,gnu.trove.list.array.TDoubleArrayList)">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.list.array.TDoubleArrayList</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(gnu.trove.list.array.TDoubleArrayList&nbsp;a,
 gnu.trove.list.array.TDoubleArrayList&nbsp;b)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(double[],double[])">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(double[]&nbsp;m,
 double[]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(double[],double)">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(double[]&nbsp;m,
 double&nbsp;s)</span></div>
<div class="block">calculate m[i] - s for each i=[0, m.length).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - array</dd>
<dd><code>s</code> - scalar</dd>
<dt>Returns:</dt>
<dd>result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(double,double[])">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(double&nbsp;s,
 double[]&nbsp;m)</span></div>
<div class="block">calculate s - m[i] for each i=[0, m.length).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - array</dd>
<dd><code>s</code> - scalar</dd>
<dt>Returns:</dt>
<dd>result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(double,double[])">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(double&nbsp;s,
 double[]&nbsp;m)</span></div>
<div class="block">calculate s + m[i] for each i=[0, m.length).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - array</dd>
<dd><code>s</code> - scalar to add to m</dd>
<dt>Returns:</dt>
<dd>resulting array</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(double[],double[],double[])">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(double[]&nbsp;m,
 double[]&nbsp;n,
 double[]&nbsp;output)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dd><code>output</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(double[],double[])">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(double[]&nbsp;m,
 double[]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(float[],float[])">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(float[]&nbsp;m,
 float[]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(float[][],float[][])">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(float[][]&nbsp;m,
 float[][]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(float[][],float[][])">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(float[][]&nbsp;m,
 float[][]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(float[],float[])">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(float[]&nbsp;m,
 float[]&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="subtract(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)">
<h3>subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">subtract</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 no.uib.cipr.matrix.DenseMatrix&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(int[],int)">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(int[]&nbsp;m,
 int&nbsp;n)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dd><code>n</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(float[][])">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(float[][]&nbsp;m)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(no.uib.cipr.matrix.DenseMatrix)">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;m)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(double[][])">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(double[][]&nbsp;m)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(int[][])">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(int[][]&nbsp;m)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(double[][],double[][])">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(double[][]&nbsp;m,
 double[][]&nbsp;out)</span></div>
<div class="block">transpose matrix m into out matrix which must be size m[0].length X m.length.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - matrix to transpose</dd>
<dd><code>out</code> - output matrix to hold transposed m</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertToRowMajor(no.uib.cipr.matrix.Matrix)">
<h3>convertToRowMajor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">convertToRowMajor</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="pseudoinverseRankDeficient(double[][])">
<h3>pseudoinverseRankDeficient</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pseudoinverseRankDeficient</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                             throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.
 Note that the term rank can be deceptive for cases when the 
 original matrix a was rank deficient and then is perturbed to become
 a full rank matrix leading to possibility of larger errors when treated as full rank.
 the term rank deficient can be replaced by the ter numerically rank deficient.
 (see Bjork 1991 Section 2, "Algorithms for linear least squares problems"
 and Chap 6 of Golub and Van Loan).
 This method uses the SVD of a,
 specifically, V*R*U^T where R is 1/diagonal of S for cases where
 rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
 Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
 inverse of A.
 
 Following Gilbert Strang's "Introduction to Linear Algebra".
 
 TODO: read "ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX" by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length .geq. a[0].length, the full rank pseudo-inverse
 is calculated instead of the rank-deficient;</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt>Returns:</dt>
<dd>pseudo-inverse of matrix a. dimensions are those of a^T.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pseudoinverseRankDeficient(double[][],boolean)">
<h3>pseudoinverseRankDeficient</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pseudoinverseRankDeficient</span><wbr><span class="parameters">(double[][]&nbsp;a,
 boolean&nbsp;checkForFullRank)</span>
                                      throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the pseudo-inverse of matrix a for cases when the rank of a
 is less than the width of matrix a.
 Note that the term rank can be deceptive for cases when the 
 original matrix a was rank deficient and then is perturbed to become
 a full rank matrix leading to possibility of larger errors when treated as full rank.
 the term rank deficient can be replaced by the term numerically rank deficient.
 (see Bjork 1991 Section 2, "Algorithms for linear least squares problems"
 and Chap 6 of Golub and Van Loan).
 This method uses the SVD of a,
 specifically, V*R*U^T where R is 1/diagonal of S for cases where
 rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
 Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
 inverse of A.
 
 Following Gilbert Strang's "Introduction to Linear Algebra".
 
 TODO: read "ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX" by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length .geq. a[0].length, the full rank pseudo-inverse
 is calculated instead of the rank-deficient;</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - and m X n matrix</dd>
<dd><code>checkForFullRank</code> - if true, the method looks for a[0],length == rank
 and if it is full-rank, the method returns the results form pseudoinverseFullRank(a)
 instead.</dd>
<dt>Returns:</dt>
<dd>pseudo-inverse of matrix a. dimensions are those of a^T.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pseudoinverseFullColumnRank(double[][])">
<h3>pseudoinverseFullColumnRank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pseudoinverseFullColumnRank</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                              throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 column rank matrix or overdetermined, 
 n .geq. rank.
 A_pseudoinverse for A being full column rank = inverse(A^T*A) * A^T.
 This particular pseudoinverse constitutes a left inverse.
 pseudoinv(A)*A = I.
 
 If inverting A^T*A fails, the method returns results of pseudoinverseRankDeficient().
 
 NOTE that (A^T*A) (or (A * A^T)) has to be invertible, that is, 
 the reduced echelon form of A has linearly independent columns (rank==n).
 following pseudocode from Cormen, Leiserson, Rivest, and Stein Introduction to Algorithms.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in row major format with dimensions
 m x n.  a is a full-rank matrix.
 a is a non-singular matrix(i.e. has exactly one solution).</dd>
<dt>Returns:</dt>
<dd>matrix of size [a[0].length][a.length]</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pseudoinverseFullRowRank(double[][])">
<h3>pseudoinverseFullRowRank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pseudoinverseFullRowRank</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
 row rank matrix, m .geq. rank.
 A_pseudoinverse for A being full row rank = a^T*inverse(A*A^T).
 This particular pseudoinverse constitutes a right inverse.
 A*pseudoinv(A) = I.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in row major format with dimensions
 m x n.  a is a full-rank matrix.
 a is a non-singular matrix(i.e. has exactly one solution).</dd>
<dt>Returns:</dt>
<dd>matrix of size [a[0].length][a.length]</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isInvertible(double[][])">
<h3>isInvertible</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isInvertible</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">from Strang "Introduction to Linear Algebra":
      <pre>
       an inverse matrix may or may not exist.  
       (1) has to be a square matrix.
           A^-1 x A = I, where I is the identity matrix.
       (2) an inverse matrix has n pivots remaining after elimination,
                where pivot is the leftmost non-zero variable. i.e. the rank r
                is equal to the dimension of the square matrix which is n.
       (3) after elimination, next test is that the determinant is not zero

       if A is invertible, then A * x = b can be solved as x = A^-1 * b
       and (A * B)^-1 = B^-1 * A^-1
      </pre>
     NOTE: because this uses decomposition, each application using it should decide whether
 to perform the exterior operations at same time to avoid recomputing
 any matrices.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>true if is invertible</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rank(double[][],double)">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;eps)</span>
                throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">determine the rank of martix A
      <pre>
      If matrix A is a square matrix:
          uses LUP decomposition and counts the L diagonal 1's
      Else
          uses SVD and counts the non-zero diagonal singular values.
          
      NOTE: a positive tolerance level eps is used to find the number of singular values
      above eps instead of 0.
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>eps</code> - a positive number for the tolerance above zero of the pivots or
 singular values.</dd>
<dt>Returns:</dt>
<dd>the rank of A</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createReverseMap(gnu.trove.map.TIntObjectMap)">
<h3>createReverseMap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</span>&nbsp;<span class="element-name">createReverseMap</span><wbr><span class="parameters">(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;adj)</span></div>
<div class="block">given a map called adj having keys and values for each key, 
 create a map where the keys are adj.values and the
 values are the keys of adj.values.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>adj</code> - a map</dd>
<dt>Returns:</dt>
<dd>the reverse map, this is the relationships of key to value are reersed to value to key</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performSVD(double[][])">
<h3>performSVD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></span>&nbsp;<span class="element-name">performSVD</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                         throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.
 <pre>
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V

          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U

          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>result of SVD of a or aT*a with re-scaled diagonal</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performSVD(no.uib.cipr.matrix.DenseMatrix)">
<h3>performSVD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></span>&nbsp;<span class="element-name">performSVD</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;a)</span>
                                         throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">performs SVD on matrix a and if fails to converge, performs SVD on
 a*a^T and a^T*a separately to get the factorization components for a.
 <pre>
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V

          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U

          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>result of SVD of a or aT*a with re-scaled diagonal</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sparseEigen(no.uib.cipr.matrix.Matrix,int,no.uib.cipr.matrix.sparse.ArpackSym.Ritz)">
<h3>sparseEigen</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>,<wbr>no.uib.cipr.matrix.DenseVectorSub&gt;</span>&nbsp;<span class="element-name">sparseEigen</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;A,
 int&nbsp;nEigenValues,
 no.uib.cipr.matrix.sparse.ArpackSym.Ritz&nbsp;ritz)</span></div>
<div class="block">use the MTJ arpack to partially solve symmetric eigensystems for eigenvalues.
 You can get the eigenvectors using

     <pre>
     see https://github.com/fommil/matrix-toolkits-java/blob/master/src/test/java/no/uib/cipr/matrix/sparse/ArpackSymTest.java
     Internally, this method does this:
     For example, to calculate the smallest 2 eigenvectors of matrix A,
     (1) calculates A^T * A to get the symmetric matrix:
         LinkedSparseMatrix A = ...;
         LinkedSparseMatrix AtA = A.transAmult(A, new LinkedSparseMatrix(A.numColumns(), A.numColumns()));
     (2) Then uses the Arpack solver with the enum for smallest eigenvalues.
         ArpackSym solver = new ArpackSym(AtA);
         Map Double, DenseVectorSub  results = solver.solve(2, ArpackSym.Ritz.SA);
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>A</code> - </dd>
<dd><code>nEigenValues</code> - </dd>
<dd><code>ritz</code> - <pre>
        ArpackSym.Ritz types:
        BE : compute NEV eigenvalues, half from each end of the spectrum
        LA : compute the NEV largest (algebraic) eigenvalues.
        LM : compute the NEV largest (in magnitude) eigenvalues.
        SA : compute the NEV smallest (algebraic) eigenvalues.
        SM : compute the NEV smallest (in magnitude) eigenvalues.
        </pre></dd>
<dt>Returns:</dt>
<dd>nEigenValues eigenvalues solved for the given sparse matrix A and ritz enum.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performSVDATransposeA(double[][])">
<h3>performSVDATransposeA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></span>&nbsp;<span class="element-name">performSVDATransposeA</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                                    throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">create matrix A^T*A then perform SVD on it.  NOTE that the singular values
 returned in S will have the square of values of SVD(A).s.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - the matrix a (internally, a^T*a will be calculated and used)</dd>
<dt>Returns:</dt>
<dd>result of SVD of aT*a</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ if SVD did not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performSVDATransposeA(no.uib.cipr.matrix.DenseMatrix)">
<h3>performSVDATransposeA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a></span>&nbsp;<span class="element-name">performSVDATransposeA</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;aTa)</span>
                                                    throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>aTa</code> - </dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performQRDecomposition(double[][])">
<h3>performQRDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.QR</span>&nbsp;<span class="element-name">performQRDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">perform QR decomposition (a.k.a. Francis algorithm, a.k.a. Francis QR step)
 on matrix a using the MTJ library.
 It's a sophisticated version of the "power method".
 A = Q*R of an orthonormal matrix Q and an upper triangular matrix R.
 The columns of Q are the eigenvectors of A.
 A*Q = Q * diag(eigenvalues of A).

 <pre>
 To calculate the product of eigenvalue or singular values using
 QR, see section "Connection to a determinant or a product of eigenvalues"
 in wikipedia:
 https://en.wikipedia.org/wiki/QR_decomposition
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square or rectangular matrix with independent columns.</dd>
<dt>Returns:</dt>
<dd>resulting QR decomposition of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateNormalizationMatrix2X3(double[][])">
<h3>calculateNormalizationMatrix2X3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculateNormalizationMatrix2X3</span><wbr><span class="parameters">(double[][]&nbsp;xy)</span></div>
<div class="block">given data points xy, want to create a matrix usable to transform
 the data points by scaling and translation so that:
        a) points are translated so that their centroid is at the origin.
        b) points are scaled so that the average distance from the
           origin is sqrt(2).
       Can use the transformation matrix with dot operator: Misc.multiply(xy, tMatrix).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - points in format [n X 2]</dd>
<dt>Returns:</dt>
<dd>a matrix for use for canonical transformation of the points.
 the format of the result is
 <pre>
  t[0] = new double[]{scale,       0,     -centroidX*scale};
        t[1] = new double[]{0,           scale, -centroidY*scale};
       </pre></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(float[][])">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(float[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(int[][])">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
</section>
</li>
<li>
<section class="detail" id="equals(int[][],int[][])">
<h3>equals</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">equals</span><wbr><span class="parameters">(int[][]&nbsp;a,
 int[][]&nbsp;b)</span></div>
</section>
</li>
<li>
<section class="detail" id="copy(double[][])">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(double[])">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(double[]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="copyLongToFloat(long[])">
<h3>copyLongToFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">copyLongToFloat</span><wbr><span class="parameters">(long[]&nbsp;a)</span></div>
</section>
</li>
<li>
<section class="detail" id="copyLongToDouble(long[])">
<h3>copyLongToDouble</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">copyLongToDouble</span><wbr><span class="parameters">(long[]&nbsp;a)</span></div>
</section>
</li>
<li>
<section class="detail" id="copy(double[][],double[][])">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(double[][]&nbsp;source,
 double[][]&nbsp;destination)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - </dd>
<dd><code>destination</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copySubMatrix(double[][],int,int,int,int)">
<h3>copySubMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">copySubMatrix</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;row0,
 int&nbsp;row1,
 int&nbsp;col0,
 int&nbsp;col1)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>row0</code> - beginning index, inclusive</dd>
<dd><code>row1</code> - end index, inclusive</dd>
<dd><code>col0</code> - beginning index, inclusive</dd>
<dd><code>col1</code> - end index, inclusive</dd>
<dt>Returns:</dt>
<dd>sub matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copySubMatrix(double[][],int,int,int,int,double[][])">
<h3>copySubMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">copySubMatrix</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;row0,
 int&nbsp;row1,
 int&nbsp;col0,
 int&nbsp;col1,
 double[][]&nbsp;out)</span></div>
<div class="block">copy the section of matrix a from row0 to row1 (inclusive) and
 col0 to col1 (inclusive) into output matrix out which must
 be size (row1-row0+1) X (col1-col0+1)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>row0</code> - beginning index, inclusive</dd>
<dd><code>row1</code> - end index, inclusive</dd>
<dd><code>col0</code> - beginning index, inclusive</dd>
<dd><code>col1</code> - end index, inclusive</dd>
<dd><code>out</code> - output matrix to hold the copied section</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractColumn(double[][],int)">
<h3>extractColumn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractColumn</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;col)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>col</code> - index of column to extract</dd>
<dt>Returns:</dt>
<dd>one dimensional array holding the column col of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractColumn(double[][],int,double[])">
<h3>extractColumn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">extractColumn</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;col,
 double[]&nbsp;out)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>col</code> - index of column to extract</dd>
<dd><code>out</code> - one dimensional array holding the column col of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="determinant(no.uib.cipr.matrix.Matrix)">
<h3>determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">determinant</span><wbr><span class="parameters">(no.uib.cipr.matrix.Matrix&nbsp;a)</span></div>
<div class="block">using cofactors and minors of the matrix, return the determinant.
 in practice one can use any row as the primary set of cofactors or
 any column.  this method may be optimized in the future, but for now,
 uses the first column as the cofactors.

 e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11
        + 135 + 2 = 148
         | 2   1  5 |
 <pre>
 Note that det(a) = 0 shows that matrix a is a singular matrix and is not
 invertible.
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix</dd>
<dt>Returns:</dt>
<dd>the determinant of matrix a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="determinant(double[][])">
<h3>determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">determinant</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">using cofactors and minors of the matrix, return the determinant.
 in practice one can use any row as the primary set of cofactors or
 any column.  this method may be optimized in the future, but for now,
 uses the first column as the cofactors.

 e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11 + 135 + 2 = 148
         | 2   1  5 |
 <pre>
 Note that det(a) = 0 shows that matrix a is a singular matrix and is not
 invertible.
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix</dd>
<dt>Returns:</dt>
<dd>determinant of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="determinant(float[][])">
<h3>determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">determinant</span><wbr><span class="parameters">(float[][]&nbsp;a)</span></div>
<div class="block">using cofactors and minors of the matrix, return the determinant.
 in practice one can use any row as the primary set of cofactors or
 any column.  this method may be optimized in the future, but for now,
 uses the first column as the cofactors.

 e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11 + 135 + 2 = 148
         | 2   1  5 |
 <pre>
 Note that det(a) = 0 shows that matrix a is a singular matrix and is not
 invertible.
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix</dd>
<dt>Returns:</dt>
<dd>determinant of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="determinantFromLU(double[][])">
<h3>determinantFromLU</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">determinantFromLU</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate the determinant of a using the diagonal of U from the
 LU decomposition.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix</dd>
<dt>Returns:</dt>
<dd>determinant of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="skewSymmetric(double[])">
<h3>skewSymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">skewSymmetric</span><wbr><span class="parameters">(double[]&nbsp;v)</span></div>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.
 the operator is also called "hat operator".
 v cross product with w is v X w = [v]_x * w.
 It’s individual terms are a_j_i = -a_i_j.
       <pre>
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |

       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector</dd>
<dt>Returns:</dt>
<dd>skew-symmetric matrix of vector v</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="skewSymmetric(double[],double[][])">
<h3>skewSymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">skewSymmetric</span><wbr><span class="parameters">(double[]&nbsp;v,
 double[][]&nbsp;out)</span></div>
<div class="block">constructs the 3x3 skew-symmetric matrices for use in cross products,
 notation is [v]_x.
 v cross product with w is v X w = [v]_x * w.
 It’s individual terms are a_j_i = -a_i_j.
       <pre>
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |

       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       </pre>
 the operator is also called "hat operator".
     Its opposite is the anti-symmetric matrix and is equal to -1 * skewSymmetric.
     <pre>
     some of its properties:
        let [u]_x be the skew symmetric of u and [v]_x be the skew-symmetric of v.
     where u and v are column vectors.

     -[u]_x * v = [v]_x * u

     -[u]_x * u = 0

     [u]_x = [ -[u]_x ]^T

     -[u]_x * -[v]_x = (u dot v) * I + v * u^T where '*' is matrix multiplication as usual.
     [u]_x * [v]_x = (u dot v) * I + v * u^T

     [u]_x * [v]_x - [v]_x * [u]_x = v * u^T - u*v^T = [u cross v]]_x

     u * v^T * -[w]_x + -[w]_x * v * u^T = -[u cross (v cross w)]_x
           where the later, triple cross product is used in making the Fundamental Matrix
           of photogrammetry, for example.

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - direction vector</dd>
<dd><code>out</code> - output skew-symmetric matrix for v</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractVectorFromSkewSymmetric(double[][])">
<h3>extractVectorFromSkewSymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractVectorFromSkewSymmetric</span><wbr><span class="parameters">(double[][]&nbsp;vHat)</span></div>
<div class="block">extract the vector from a skew-symmetric matrix.  the operation is called vee operator.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vHat</code> - skew-symmetric matrix</dd>
<dt>Returns:</dt>
<dd>extracted vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="crossProduct(double[],double[])">
<h3>crossProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">crossProduct</span><wbr><span class="parameters">(double[]&nbsp;p0,
 double[]&nbsp;p1)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p0</code> - </dd>
<dd><code>p1</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="areColinear(double[],double[],double)">
<h3>areColinear</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">areColinear</span><wbr><span class="parameters">(double[]&nbsp;p0,
 double[]&nbsp;p1,
 double&nbsp;eps)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p0</code> - </dd>
<dd><code>p1</code> - </dd>
<dd><code>eps</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="areColinear(double[],double[],double[],double)">
<h3>areColinear</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">areColinear</span><wbr><span class="parameters">(double[]&nbsp;p0,
 double[]&nbsp;p1,
 double[]&nbsp;p2,
 double&nbsp;eps)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p0</code> - </dd>
<dd><code>p1</code> - </dd>
<dd><code>p2</code> - </dd>
<dd><code>eps</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeL2(double[])">
<h3>normalizeL2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">normalizeL2</span><wbr><span class="parameters">(double[]&nbsp;v)</span></div>
<div class="block">normalize vector v by euclidean, that is the square root of the sum of
 its squared components.  notation is sometimes ||v||_2.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - array</dd>
<dt>Returns:</dt>
<dd>array v divided by the LP2 norm of v.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeColumnsL2(double[][])">
<h3>normalizeColumnsL2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">normalizeColumnsL2</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">normalize each column of matrix a by the square root of the sum of
 its squared components. ||v||_2 for each column...</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeRowsL2(double[][])">
<h3>normalizeRowsL2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">normalizeRowsL2</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">normalize each row of matrix a by the square root of the sum of
 its squared components. ||v||_2 for each row...</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="conditionNumber(double[][])">
<h3>conditionNumber</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">conditionNumber</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                              throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the condition number as the largest singular value divided
 by the singular value for i==(rank-1) of A where the singular values are
 found using the SVD.
     <pre>
     from https://blogs.mathworks.com/cleve/2017/07/17/what-is-the-condition-number-of-a-matrix/
     A condition number for a matrix and computational task measures how
     sensitive the answer is to perturbations in the input data and to roundoff
     errors made during the solution process....If a matrix is singular,
     then its condition number is infinite.
     ...(A large condition number means that the matrix is close to being singular).

     also see Section 9.2 of Strang's "Introduction to Linear Algebra".
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>condition number</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="preconditionScaling(double[][])">
<h3>preconditionScaling</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.ConditionedMatrix.html" title="class in algorithms.matrix">MatrixUtil.ConditionedMatrix</a></span>&nbsp;<span class="element-name">preconditionScaling</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">apply Ruiz scaling as "equilibration" for matrix a as a linear system in order to
 pre-condition it before use.
 Note: before using this method, you may want to apply permutations following
 Duff And Koster 1999 and HSL 2000 routine MC64.
     <pre>
     References:
     Ruiz 2001 "A Scaling Algorithm to Equilibrate Both Rows and Columns Norms in Matrices"
     iterative algorithm that has fast linear convergence and assymptotic rate of 1/2.

     Liu, Paul. "An exploration of matrix equilibration." (2015).
     "equilibration" of a linear system applies scaling and permutations
     to an ill-conditioned matrix as a pre-processing step to improve
     the conditioning.
     The Ruiz algorithm and the Liu algorithm both attempt to minimize the condition number of a
     matrix by scaling it by the infinity-norm of each row and column of a matrix to value 1.
     </pre>
     <pre>
     A_hat = the scaled matrix = D_1 * A * D_2

     rewrite:  A_hat =  D_1 * A * D_2
          as:  A_hat * (D_2)^-1 = D_1 * A

     For use in the example solving for x in A * x = b:
        A_hat * x_hat = b_hat
        For pre-multiplication:
            A_hat =  D_1 * A * D_2
            b_hat = D_1 * b
            x_hat = (D_2)^-1 * x  (this isn't done when solving for x in A*x=b)
        For post-multiplication:
            x = x_hat * D_2

     </pre>
     TODO: see LAPack xGEBAL
        can access it in MTJ using LAPack.getInstance()
        see more in com.github.fommil.netlib.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - an m X n matrix.</dd>
<dt>Returns:</dt>
<dd>the scaled matrix a_hat and the 2 matrices used to scale the matrix.  the
       matrices can be used to pre-multiply and post-multiply other data structures in a problem.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateInfNormForColumns(double[][],double[])">
<h3>calculateInfNormForColumns</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">calculateInfNormForColumns</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[]&nbsp;output)</span></div>
<div class="block">calculate the infinity norm for each column of matrix a where the infinity norm
 for each col as a set is the maximum absolute value for that col.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - an m x n matrix</dd>
<dd><code>output</code> - array of size a.length to be populated with the infinity norms for each column of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateInfNormForRows(double[][],double[])">
<h3>calculateInfNormForRows</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">calculateInfNormForRows</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[]&nbsp;output)</span></div>
<div class="block">calculate the infinity norm for each row of matrix a where the infinity norm
 for each row as a set is the maximum absolute value for that row.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - an m x n matrix</dd>
<dd><code>output</code> - array of size a.length to be populated with the infinity norms for each row of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lPSum(double[],double)">
<h3>lPSum</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">lPSum</span><wbr><span class="parameters">(double[]&nbsp;v,
 double&nbsp;p)</span></div>
<div class="block">summation = the (1/p) power of sum of its (components)^p.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - array v</dd>
<dd><code>p</code> - the power of the polynomial of v in the sum</dd>
<dt>Returns:</dt>
<dd>he (1/p) power of sum of its (components)^p</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lp1Norm(int[][])">
<h3>lp1Norm</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">lp1Norm</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
<div class="block">following the convention used by Matlab
    <pre>
    https://www.mathworks.com/help/matlab/ref/norm.html#bvhji30-3

    For p-norm = 1, the L1-norm is the maximum absolute column sum of the matrix.
    ||X||_1 = max sum for an arg j where (0.lte.j.lte.n-1) sum_(i=0 to n-1) ( |a[i][j] )
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>the maximum absolute column sum of the matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="frobeniusNorm(double[][])">
<h3>frobeniusNorm</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">frobeniusNorm</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate the Frobenius Norm of matrix a.
 It's the square root of the sum of squares of each element.
 It can also be calculated as the square root of the
 trace of a_conjugate*a, or as
 the square root of the sums of the squares of the singular
 values of a.
 (The later can be compared to the spectral norm which is the largest singular value of a.)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>the sum of each element of a squared</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="spectralNorm(double[][])">
<h3>spectralNorm</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">spectralNorm</span><wbr><span class="parameters">(double[][]&nbsp;r)</span>
                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the value of the largest singular value of matrix r.  this is the induced norm
 which measures what is the maximum of ‖𝐴𝑥‖‖𝑥‖ for any 𝑥≠0 (or, equivalently, the maximum of ‖𝐴𝑥‖ for ‖𝑥‖=1).
 Note that the frobenius norm can be defined as the square root of the sums of the squares of the singular
 values of and therefore can be different than the spectral norm.
 <pre>
     reference for documentation:
     https://math.stackexchange.com/questions/33083/what-is-the-difference-between-the-frobenius-norm-and-the-2-norm-of-a-matrix
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - matrix</dd>
<dt>Returns:</dt>
<dd>the spectral norm of r, which is the largest singular value of r</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nearestPositiveSemidefiniteToASymmetric(double[][],double)">
<h3>nearestPositiveSemidefiniteToASymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">nearestPositiveSemidefiniteToASymmetric</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;eps)</span>
                                                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">Given a symmetric matrix and a nonnegative number eps, find the
 nearest symmetric positive semidefinite matrices with eigenvalues at least eps.
       a pos def matrix is symmetric and its eigenvalues are all positive, 
       so, there's a unique minimum for quadratic equations, but the nearest
       will be a function of eps.
 <pre>
 References:
 https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
 Cheng and Higham, 1998

 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a symmetric matrix</dd>
<dd><code>eps</code> - a tolerance or error above 0 such as machine precision.  must
 be greater than or equal to 0.  If it is above 0, this method attempts
 to return a symmetric positive definite matrix.</dd>
<dt>Returns:</dt>
<dd>a matrix which is the nearest positive semidefinite matrix to a</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nearestSymmetricToA(double[][])">
<h3>nearestSymmetricToA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">nearestSymmetricToA</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">Given a matrix A that is not necessarily symmetric, find the
 nearest symmetric matrix to A.
 <pre>
 References:
 https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/

 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix which can be non-symmetric.</dd>
<dt>Returns:</dt>
<dd>a matrix which is the nearest symmetric to a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nearestPositiveSemidefiniteToA(double[][],double)">
<h3>nearestPositiveSemidefiniteToA</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">nearestPositiveSemidefiniteToA</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;eps)</span>
                                                 throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">Given a matrix a that is not necessarily symmetric,
 and a nonnegative number eps, find the
 nearest symmetric positive definite matrices with eigenvalues at least eps.
 Note that this method attempts to make it symmetric positive definite by
 adding a small perturbation of size smallest eigenvalue to the diagonal
 of the resulting matrix.  The result satisfies the broader, non-negative
 definition of positive semi-definite matrix.
 <pre>
 References:
 https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/

 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix which can be non-symmetric.</dd>
<dd><code>eps</code> - a tolerance or error above 0 such as machine precision.  must
 be greater than or equal to 0.  If it is above 0, this method attempts
 to return a symmetric positive definite matrix.</dd>
<dt>Returns:</dt>
<dd>matrix which is the nearest positive semidefinite to a</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeLP(double[],double)">
<h3>normalizeLP</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">normalizeLP</span><wbr><span class="parameters">(double[]&nbsp;v,
 double&nbsp;p)</span></div>
<div class="block">normalize vector v by power p, that is the (1/p) power of sum of
 its (components)^p.  notation is sometimes ||v||_p.
     <pre>
     when p = 0, this is the manhattan normalization or taxi-cab normalization,
     when p = 2, this is the euclidean normalization,
     when p = Double.POSITIVE_INFINITY, this is the max.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - array</dd>
<dd><code>p</code> - </dd>
<dt>Returns:</dt>
<dd>array v normalized by its lp_p sum.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="outerProduct(double[],double[])">
<h3>outerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">outerProduct</span><wbr><span class="parameters">(double[]&nbsp;v1,
 double[]&nbsp;v2)</span></div>
<div class="block">the outer product of vectors v1 and v2, which is v1 as a single row matrix
 and v2 as a single column matrix, so is v1 * v2^T.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v1</code> - array 1</dd>
<dd><code>v2</code> - array 2</dd>
<dt>Returns:</dt>
<dd>the outer product of v1 and v2 as double array of
 size v1.length X v2.length.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerMethod(double[][],int)">
<h3>powerMethod</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">powerMethod</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;nIterations)</span></div>
<div class="block">determine the largest eigenvalue using the power method.  note that
 matrix A must be diagonalize-able, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix A first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan
 "Matrix Computations".

 Note that this method normalizes the rows of matrix a during operation.
 If one is using a matrix that expects normalized columns, such as the transition
 matrix of page rank in MMDS chap 5, then you'll want to transpose the
 matrix before using this method).

 calculates lambda in lambda * v = M * v for some constant eigenvalue lambda.

 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).
 TODO: write a version for sparse graphs.
 TODO:consider implementing the inverse power method also to determine the
 smallest eigenvalue and its eigenvector</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a positive definite matrix.  if you have a transition matrix of normalized columns,
     you'll want to transpose the matrix before using this method.</dd>
<dd><code>nIterations</code> - number of iterations to use</dd>
<dt>Returns:</dt>
<dd>the largest eigenvalue of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerMethod(double[][],double,double[])">
<h3>powerMethod</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">powerMethod</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tolerance,
 double[]&nbsp;x)</span></div>
<div class="block">determine the largest eigenvalue using the power method.  note that
 matrix A must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix A first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan
 "Matrix Computations".
 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).
 The eigenvalue is returned and the eigenvector is returned by setting it into the elements of x.
 A * x = lamba * x where lambda is the eigenvalue corresponding to eigenvector x and x is the
 largest eigenvalue of matrix A, that is, the principal eigenvector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dd><code>x</code> - an initialized vector of size a.length that will be filled by
 this method to hold the vector used to calculate eig = x^T * a * x</dd>
<dt>Returns:</dt>
<dd>the largest eigenvalue of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerMethod(double[][],double)">
<h3>powerMethod</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">powerMethod</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tolerance)</span></div>
<div class="block">determine the largest eigenvalue using the power method.  note that
 array a must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix a first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method is implemented from pseudocode in Golub and van Loan
 "Matrix Computations".
 NOTE that the number of necessary iterations is dependent upon
 how close the largest and second largest eigenvalues are and that ratio
 tends to be near "1" for large matrices and in that case, the power
 method isn't the right method (consider QR or SVD).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dt>Returns:</dt>
<dd>the largest eigenvalue of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerMethodEigenPairs(double[][],double)">
<h3>powerMethodEigenPairs</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">powerMethodEigenPairs</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tolerance)</span></div>
<div class="block">determine the eigenvalue pairs using the power method.  note that
 array a must be diagonalizable, that is, a positive definite matrix.
 for best results, perform standard normalization on matrix a first
 because the first initial guess of an eigenvector of a is composed
 of random values between [0 and 1).
 The method follows "Mining of Massive Datasets" by Leskovec, Rajaraman,
 and Ullman.  http://www.mmds.org/</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a positive definite matrix</dd>
<dd><code>tolerance</code> - iterations are stopped when the current multiplication vector
 difference from previous is smaller than tolerance for each item.</dd>
<dt>Returns:</dt>
<dd>an array of a.length eigenvectors</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerOfUsingEig(double[][],int)">
<h3>powerOfUsingEig</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">powerOfUsingEig</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;power)</span>
                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate (matrix A)^power using its eigen decompostion:
 A^power = S * (Delta^power) * S^-1
 where S holds eigenvectors in its columns.  Delta is a diagonal matrix
 holding the eigenvalues.
 The r.t.c. is O(n^3), but the accuracy is not as good as the powerOf() method.
 Note that using the eigenvalues and eignevectors to calc the power matrix in this algorithm
 is accurate when using python3 numpy with similar steps.  Numpy linear algebra uses
 complex numbers for the calculations.  Here in java, the MTJ MatrixToolkit is using real
 numbers instead of complex numbers.
 TODO: find a light weight effiicent high accuracy linear algebra library that uses complex
 numbers and refactor for using it.
     <emp>NOTE: prefer to use powerOf(...) instead while this comment is here.</emp></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix</dd>
<dd><code>power</code> - integer power to apply to matrix a</dd>
<dt>Returns:</dt>
<dd>(matrix A)^power</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="powerOf(double[][],int)">
<h3>powerOf</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">powerOf</span><wbr><span class="parameters">(double[][]&nbsp;a,
 int&nbsp;power)</span>
                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">this method is not as fast as powerOfUsingEig(), but is useful for a look at power of 2 steps
 in multiplication.
 A brute force multiplication of matrix 'a' to the power 'power' has a r.t.c. of
 O(n^3) * the 'power' where n is the number of rows, which is also the number of columns in
 matrix 'a'.
 The r.t.c. of powerOfUsingEig() method is O(n^3), but the matrix has to be decomposable
 into a form E * D * E^-1 where E are eigenvectors and D is a diagonal of eigenvalues.
 The r.t.c. of this method powerOf(...) is O(n^3 * log(power)).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>power</code> - </dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="squareRoot(double[][])">
<h3>squareRoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">squareRoot</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                             throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the square root of symmetric positive definite matrix A using SVD.

 <pre>
    [U, S, V] = svd(A)
    J = V * S^(1/2) * V^T is a symmetric n×n matrix, such that square root of A = JJ.
    J is non-negative definite.
 </pre>
 from Allan Jepson's lecture on Gilbert Strang's SVD in machine learning
 http://www.cs.toronto.edu/~jepson/csc420/notes/introSVD.pdf
 Also see Chap 7.4 of "Introduction to LinearAlgebra" by Strang, the section
 on Polar Decomposition.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square symmetric positive definite matrix.  If the matrix is not
          positive definite matrix, use nearestPositiveSemidefiniteToA() first.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown by MTJ when SVD could not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isSquare(double[][])">
<h3>isSquare</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isSquare</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="isSymmetric(double[][],double)">
<h3>isSymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isSymmetric</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tol)</span></div>
<div class="block">checks for a_ij == a_ji.  no normalization for row factors is made.
  that is, there may be a factor which makes the matrix symmetric.
        e.g. [33, 24]
             [48, 57] here, divide by 2 and the matrix is symmetric</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>tol</code> - </dd>
<dt>Returns:</dt>
<dd>true if a is symmetric</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isPositiveSymmetric(double[][])">
<h3>isPositiveSymmetric</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isPositiveSymmetric</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="projection(double[][],double[])">
<h3>projection</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.ProjectionResults.html" title="class in algorithms.matrix">MatrixUtil.ProjectionResults</a></span>&nbsp;<span class="element-name">projection</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[]&nbsp;b)</span>
                                               throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">solve for the vector x which is the closest to a given vector b in the
 subspace defined by A which is n columns of linearly independent vectors
 of length m (they are in real space R^m).
 x is an approximation so is noted as x^{hat}.
 the projection p = A*x^{hat}.
 The matrix projection P = p*b.
     <pre>
     Chap 4 of the book "Introduction to Linear Algebra" by W Gilbert Strang
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - subspace defined by A which is n columns of linearly
 independent vectors of length m (they are in real space R^m).</dd>
<dd><code>b</code> - array b</dd>
<dt>Returns:</dt>
<dd>matrix projection P = p*b where p = A*x^{hat}</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allEigenValuesGEQ(double[][],double)">
<h3>allEigenValuesGEQ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">allEigenValuesGEQ</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tol)</span>
                                 throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">check whether all eigenvalues are >=  tol</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>tol</code> - </dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isPositiveDefinite(double[][])">
<h3>isPositiveDefinite</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isPositiveDefinite</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">A matrix is positive definite if it’s symmetric and all its eigenvalues are positive,
 which means its pivots are positive.
 a quick test is that x^T * A * x is strictly positive for every non-zero
 column vector x of n real numbers where A is n x n.
 Every positive definite matrix can be factored into L*D*L^T with positive pivots.
 Also note that if a has n independent columns (r==n), A^T*A is positive definite.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dt>Returns:</dt>
<dd>true if a is positive definite</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createCofactor(double[][])">
<h3>createCofactor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createCofactor</span><wbr><span class="parameters">(double[][]&nbsp;m)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="inverse(double[][])">
<h3>inverse</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">inverse</span><wbr><span class="parameters">(double[][]&nbsp;m)</span></div>
<div class="block">find the equation for which A * A^(-1) = the identity matrix using cramer's rule.

 note that for a to be invertible, none of its eigenvalues can be 0.
 also note that if the number of linearly independent vectors os matrix
 A is equal to the number of columns of A, one can use the spectral
 decomposition: A^-1 = Q * (delta)^-1 * Q^-1
 where Q is a matrix whose columns hold eigenvectors and delta is a diagonal
 matrix holding the eigenvalues.

             1
 A^(-1) =  ------ C^(T)  where C_ij = cofactor of a_ij
            det A</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - a square invertible matrix.</dd>
<dt>Returns:</dt>
<dd>inverse of matrix m</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="columnMeans(double[][])">
<h3>columnMeans</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">columnMeans</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.
 note that the format must be a[nSamples][nVariables],
 e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
 and nVariables = 3;</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>mean of each column as an array of size a[0].length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rowMeans(double[][])">
<h3>rowMeans</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">rowMeans</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">given a, return the mean of each row of a.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dt>Returns:</dt>
<dd>mean of each row as an array of size a.length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="standardDeviation(double[][])">
<h3>standardDeviation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">standardDeviation</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">given a as vectors of data of nSamples of nVariables, return the
 mean of each of the variables.
 note that the format must be a[nSamples][nVariables],
 e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
 and nVariables = 3;</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - vectors of data of nSamples of nVariables in format [nSamples X nVariables]</dd>
<dt>Returns:</dt>
<dd>standard deviation of the variables.  length is a[0].length</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aMinusVectorTimesIdentity(double[][],double[])">
<h3>aMinusVectorTimesIdentity</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">aMinusVectorTimesIdentity</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[]&nbsp;v)</span></div>
<div class="block">calculate a - v*I where A is square matrix and v is a vector.  I is the identity
 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix.</dd>
<dd><code>v</code> - a vector of length of a.length.</dd>
<dt>Returns:</dt>
<dd>the matrix a - v*I.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="trace(double[][])">
<h3>trace</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">trace</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate the sum of the diagonal elements of a.
 Note that the trace of matrix A equals the sum of its eigenvalues.
 Note: the trace of A is equal to the sum of its eigenvalues.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix.</dd>
<dt>Returns:</dt>
<dd>the sum of the diagonal elements of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="trace(float[][])">
<h3>trace</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">trace</span><wbr><span class="parameters">(float[][]&nbsp;a)</span></div>
<div class="block">calculate the sum of the diagonal elements of a.
 Note that the trace of matrix A equals the sum of its eigenvalues.
 Note: the trace of A is equal to the sum of its eigenvalues.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a square matrix.</dd>
<dt>Returns:</dt>
<dd>the sum of the diagonal elements of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="trace(double[])">
<h3>trace</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">trace</span><wbr><span class="parameters">(double[]&nbsp;v)</span></div>
<div class="block">calculate the sum of the diagonal elements of v*I (i.e. sum of all elements of v)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a vector to be treated as diagonal elements of an identity matrix.</dd>
<dt>Returns:</dt>
<dd>the sum of the elements of v</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseMultiplication(double[][],double[][])">
<h3>pointwiseMultiplication</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pointwiseMultiplication</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b)</span></div>
<div class="block">pointwise multiplication (a.k.a. Hadamard product, entrywise product, and Schur product)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>element-wise multiplication of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseMultiplication(int[][],int[][])">
<h3>pointwiseMultiplication</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">pointwiseMultiplication</span><wbr><span class="parameters">(int[][]&nbsp;a,
 int[][]&nbsp;b)</span></div>
<div class="block">pointwise multiplication (a.k.a. Hadamard product, entrywise product, and Schur product)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>element-wise multiplication of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseAdd(double[][],double[][])">
<h3>pointwiseAdd</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pointwiseAdd</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b)</span></div>
<div class="block">pointwise addition</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>element-wise addition of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseAdd(double[][],double[][],double[][])">
<h3>pointwiseAdd</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">pointwiseAdd</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b,
 double[][]&nbsp;out)</span></div>
<div class="block">pointwise addition</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dd><code>out</code> - the results of element wise add of a + b. Note that it
 is safe to provide out as the same object as input argument a or b.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseSubtract(double[][],double[][])">
<h3>pointwiseSubtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pointwiseSubtract</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b)</span></div>
<div class="block">pointwise subtraction</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>element-wise subtraction of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseSubtract(double[][],double[][],double[][])">
<h3>pointwiseSubtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">pointwiseSubtract</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b,
 double[][]&nbsp;out)</span></div>
<div class="block">pointwise subtraction</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>b</code> - matrix</dd>
<dd><code>out</code> - the results of element wise subtraction, a - b. Note that it</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseSubtract(int[][],int[][])">
<h3>pointwiseSubtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">pointwiseSubtract</span><wbr><span class="parameters">(int[][]&nbsp;a,
 int[][]&nbsp;b)</span></div>
<div class="block">point-wise subtraction</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>the results of point-wise subtraction, a - b.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseSubtract(double[],double[],double[])">
<h3>pointwiseSubtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">pointwiseSubtract</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b,
 double[]&nbsp;out)</span></div>
<div class="block">pointwise subtraction</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array</dd>
<dd><code>b</code> - array</dd>
<dd><code>out</code> - the results of element wise subtraction, a - b. Note that it
 is safe to provide out as the same object as input argument a or b.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseMultiplication(double[],double[])">
<h3>pointwiseMultiplication</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">pointwiseMultiplication</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">pointwise multiplication (a.k.a. Hadamard product, entrywise product, and Schur product)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>b</code> - matrix</dd>
<dt>Returns:</dt>
<dd>element-wise multiplication of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dot(double[],double[])">
<h3>dot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">dot</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">dot product, summation_over_i(a[i]*b[i])</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array</dd>
<dd><code>b</code> - array</dd>
<dt>Returns:</dt>
<dd>dot product of a and b which is a.k.a.inner product</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="zeros(int,int)">
<h3>zeros</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">zeros</span><wbr><span class="parameters">(int&nbsp;nRows,
 int&nbsp;nCols)</span></div>
<div class="block">create an array of zeros</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nRows</code> - number of rows for new matrix</dd>
<dd><code>nCols</code> - number of columns for new matrix</dd>
<dt>Returns:</dt>
<dd>a new empty double array of size [nRows X nCols] in row major notation.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createIdentityMatrix(int)">
<h3>createIdentityMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createIdentityMatrix</span><wbr><span class="parameters">(int&nbsp;nRows)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nRows</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseDivision(double[][],double[][])">
<h3>pointwiseDivision</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">pointwiseDivision</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b)</span></div>
<div class="block">right divide is pointwise division</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dd><code>b</code> - matrix b</dd>
<dt>Returns:</dt>
<dd>element-wise division of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pointwiseDivision(double[],double[])">
<h3>pointwiseDivision</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">pointwiseDivision</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">right divide is pointwise division, that is a[i]/b[i] for i = [0, a.length).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array a</dd>
<dd><code>b</code> - array b</dd>
<dt>Returns:</dt>
<dd>element-wise division of elements in a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flipLR(double[][])">
<h3>flipLR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">flipLR</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">perform a left-right swap of the columns of a, flipping the matrix
 vertically.  the method mimics matlab's flipur.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flipUD(double[][])">
<h3>flipUD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">flipUD</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">perform an up-down swap of the rows of a, flipping the matrix
 horizontally.  the method mimics matlab's flipud.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="forwardSubstitution(double[][],double[])">
<h3>forwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">forwardSubstitution</span><wbr><span class="parameters">(double[][]&nbsp;lowerTriangular,
 double[]&nbsp;b)</span></div>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dt>Returns:</dt>
<dd>x in equation L*x = b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="forwardSubstitution(double[][],double[],double[])">
<h3>forwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">forwardSubstitution</span><wbr><span class="parameters">(double[][]&nbsp;lowerTriangular,
 double[]&nbsp;b,
 double[]&nbsp;outX)</span></div>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.
 method follows Golub and Van Loan algorithm 4.1-1.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dd><code>outX</code> - output variable x in equation L*x = b.  length is b.length.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="forwardSubstitution(no.uib.cipr.matrix.LowerTriangDenseMatrix,double[])">
<h3>forwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">forwardSubstitution</span><wbr><span class="parameters">(no.uib.cipr.matrix.LowerTriangDenseMatrix&nbsp;lowerTriangular,
 double[]&nbsp;b)</span></div>
<div class="block">solves for vector x in the equation L*x=b where L is the lower triangular
 matrix and b is a vector.
 runtime complexity is approx (b.length)^2.
 method follows Golub and Van Loan algorithm 4.1-1.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>lowerTriangular</code> - the lower triangular matrix</dd>
<dd><code>b</code> - vector on the righthand side of the equation L*x=b</dd>
<dt>Returns:</dt>
<dd>x in equation L*x = b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="backwardSubstitution(double[][],double[])">
<h3>backwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">backwardSubstitution</span><wbr><span class="parameters">(double[][]&nbsp;upperTriangular,
 double[]&nbsp;y)</span></div>
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.
 method follows Golub and Van Loan algorithm 4.1-2.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>upperTriangular</code> - the upper triangular matrix
 (a_i_j=0 where i .gt. j)
 <pre>
     0  1  2
        2  *  *  *
        1  *  *
        0  *
           0  1  2
 </pre></dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dt>Returns:</dt>
<dd>x in equation U*x = y</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="backwardSubstitution(double[][],double[],double[])">
<h3>backwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">backwardSubstitution</span><wbr><span class="parameters">(double[][]&nbsp;upperTriangular,
 double[]&nbsp;y,
 double[]&nbsp;outX)</span></div>
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>upperTriangular</code> - the upper triangular matrix
 (a_i_j=0 where i .gt. j)
 <pre>
     0  1  2
        2  *  *  *
        1  *  *
        0  *
           0  1  2
 </pre></dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dd><code>outX</code> - output variable x in equation U*x = y.  must be length y.length.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="backwardSubstitution(no.uib.cipr.matrix.UpperTriangDenseMatrix,double[])">
<h3>backwardSubstitution</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">backwardSubstitution</span><wbr><span class="parameters">(no.uib.cipr.matrix.UpperTriangDenseMatrix&nbsp;upperTriangular,
 double[]&nbsp;y)</span></div>
<div class="block">solves for vector x in the equation U*x = y where
 U is an upper triangular matrix and y is a vector.
 runtime complexity is approx (y.length)^2.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>upperTriangular</code> - the upper triangular matrix</dd>
<dd><code>y</code> - vector on righthand side of equation</dd>
<dt>Returns:</dt>
<dd>x in equation U*x = y</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fill(double[][],double)">
<h3>fill</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">fill</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;value)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dd><code>value</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transpose(algorithms.matrix.BlockMatrixIsometric)">
<h3>transpose</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a></span>&nbsp;<span class="element-name">transpose</span><wbr><span class="parameters">(<a href="BlockMatrixIsometric.html" title="class in algorithms.matrix">BlockMatrixIsometric</a>&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="reshapeToVector(double[][])">
<h3>reshapeToVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">reshapeToVector</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">rewrite matrix a into a vector using the order of all rows of column 0,
 then all rows of column 1, etc.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dt>Returns:</dt>
<dd>matrix a reshaped into an array</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculatePreconditionerFromLUP(double[][])">
<h3>calculatePreconditionerFromLUP</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculatePreconditionerFromLUP</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate a pre-conditoner matrix based upon the matrix U in
 the decompositon P*A = L*U where P is a permutation matrix,
 L is a lower triangular matrix, U is an upper triangular matrix.
 
 see Bjork 1991 Section 4.3, "Algorithms for linear least squares problems",
 especially the end of the section.
 
 from wikipedia:
 LU factorization with partial pivoting: It turns out that a proper 
 permutation in rows (or columns) is sufficient for LU factorization. 
 LU factorization with partial pivoting (LUP) refers often to LU 
 factorization with row permutations only.
 
 The choice of a good preconditioner may improve the speed of an iterative
 method.
 
 Note that if matrix a has full rank, the ideal choice of a preconditioner
 is instead of this method's results, is to use the Cholesky factor of 
 A^T*A. 
 Note that another preconditioner uses the columns of a to form a diagonal
 matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
   d_j = (||a_j||_2)^2  where a_j is column j of a.
 <pre>
 using a preconditioner involves reforming A*x = b into
 A * (M^-1) * y = b, solve for y
 and M * x = y, solve for x.
 
 Or the left precondition:
   (M^-1) * (A*x - b) = 0
 
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt>Returns:</dt>
<dd>matrix with dimensions of a^T</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculatePreconditionerFromColumns(double[][])">
<h3>calculatePreconditionerFromColumns</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculatePreconditionerFromColumns</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate a pre-conditoner matrix based upon the columns of matrix a to 
 form a diagonal matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
   d_j = (||a_j||_2)^2  where a_j is column j of a.
 
 see Bjork 1991 Section 4.3, "Algorithms for linear least squares problems",
 especially the end of the section.
 
 from wikipedia:
 LU factorization with partial pivoting: It turns out that a proper 
 permutation in rows (or columns) is sufficient for LU factorization. 
 LU factorization with partial pivoting (LUP) refers often to LU 
 factorization with row permutations only.
 
 The choice of a good preconditioner may improve the speed of an iterative
 method.
 
 Note that if matrix a has full rank, the ideal choice of a preconditioner
 is instead of this method's results, is to use the Cholesky factor of 
 A^T*A. 
 
 <pre>
 using a preconditioner involves reforming A*x = b into
 A * (M^-1) * y = b, solve for y
 and M * x = y, solve for x.
 
 Or the left precondition:
   (M^-1) * (A*x - b) = 0
 
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - and m X n matrix</dd>
<dt>Returns:</dt>
<dd>matrix with dimensions of a^T</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="performPolarDecomposition(double[][])">
<h3>performPolarDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="MatrixUtil.QH.html" title="class in algorithms.matrix">MatrixUtil.QH</a></span>&nbsp;<span class="element-name">performPolarDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                                               throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">perform a polar decomposition on square matrix a.
 A = Q*H where Q is orthogonal and H is a symmetric positive semidefinite matrix.  
     If A is invertible, then H is symmetric positive definite.
     The method follows Strang "Introduction to Linear Algebra" Chapter 7 section G.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - square matrix</dd>
<dt>Returns:</dt>
<dd>polar decomposition of a</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multisetIntersection(int[],int[])">
<h3>multisetIntersection</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[]</span>&nbsp;<span class="element-name">multisetIntersection</span><wbr><span class="parameters">(int[]&nbsp;orderedA,
 int[]&nbsp;orderedB)</span></div>
<div class="block">given 2 non-decreasing ordered sequences of numbers, find their intersection.
 The method is called multiset because the sequences may contain more than
 one element having the same value... the method is used for multisets as multi-sequences.
 The runtime complexity is O(max(a.length, b.length)).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>orderedA</code> - an increasing sequence of numbers (i.e. ascending sorted).</dd>
<dd><code>orderedB</code> - an increasing sequence of numbers (i.e. sorted by non-decreasing order)</dd>
<dt>Returns:</dt>
<dd>the intersection of orderedA and orderedB</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="multisetUnorderedIntersection(int[],int[])">
<h3>multisetUnorderedIntersection</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[]</span>&nbsp;<span class="element-name">multisetUnorderedIntersection</span><wbr><span class="parameters">(int[]&nbsp;a,
 int[]&nbsp;b)</span></div>
<div class="block">given 2 sequences of numbers, find their intersection.
 The method is called multiset because the sequences may contain more than
 one element having the same value... the method is used for multisets as multi-sequences.
 The runtime complexity is O(N*log_2(N)) where N is max(a.length, b.length).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a sequence of numbers</dd>
<dd><code>b</code> - a sequence of numbers</dd>
<dt>Returns:</dt>
<dd>intersection of a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(gnu.trove.map.TIntObjectMap)">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(gnu.trove.map.TObjectDoubleMap)">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.map.TObjectDoubleMap&lt;<a href="../util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(gnu.trove.map.TObjectDoubleMap&lt;<a href="../util/PairInt.html" title="class in algorithms.util">PairInt</a>&gt;&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="copyToSymmetricMap(gnu.trove.map.TIntObjectMap)">
<h3>copyToSymmetricMap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;</span>&nbsp;<span class="element-name">copyToSymmetricMap</span><wbr><span class="parameters">(gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;a)</span></div>
<div class="block">create a symmetric adjacency map from a</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - an adjacency map</dd>
<dt>Returns:</dt>
<dd>a sthe ymmetric adjacency map of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copy(gnu.trove.map.TIntIntMap)">
<h3>copy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">gnu.trove.map.TIntIntMap</span>&nbsp;<span class="element-name">copy</span><wbr><span class="parameters">(gnu.trove.map.TIntIntMap&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertToFloat(double[][])">
<h3>convertToFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">convertToFloat</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertToFloat(double[])">
<h3>convertToFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">convertToFloat</span><wbr><span class="parameters">(double[]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertIntToDouble(int[][])">
<h3>convertIntToDouble</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">convertIntToDouble</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertToDouble(float[][])">
<h3>convertToDouble</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">convertToDouble</span><wbr><span class="parameters">(float[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertToFloat(int[][])">
<h3>convertToFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">convertToFloat</span><wbr><span class="parameters">(int[][]&nbsp;a)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createPermutationMatrix(int[])">
<h3>createPermutationMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="element-name">createPermutationMatrix</span><wbr><span class="parameters">(int[]&nbsp;assignments)</span></div>
<div class="block">create a permutation matrix given the vector of permuted element indexes.
 Usage: pre-multiplying, P*A, results in permuting the rows of A.
 post-multiplying, A*P, results in permuting the columns of A.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>assignments</code> - the permutation vector.</dd>
<dt>Returns:</dt>
<dd>permutation matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stack(double[][])">
<h3>stack</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">stack</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">extract each column of a and append it to an output vector.
 if a is [mxn], the output vector length will be m*n.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix a</dd>
<dt>Returns:</dt>
<dd>the output vector of stacked columns of a</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="kroneckerProduct(double[][],double[][])">
<h3>kroneckerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">kroneckerProduct</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[][]&nbsp;b)</span></div>
<div class="block">Given two matrices A € R^(mxn) and B € R^(kxl), their Kronecker product,
 denoted by A⨂B, is a new matrix € R^(mk x nl).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>b</code> - matrix</dd>
<dt>Returns:</dt>
<dd>kronecker product of a and b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="kroneckerProduct(double[],double[])">
<h3>kroneckerProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">kroneckerProduct</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">Given two vectors A € R^(m) and B € R^(k), their Kronecker product,
 denoted by A⨂B, is a new matrix € R^(mk).  It is the outer product of the
 vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array a</dd>
<dd><code>b</code> - array b</dd>
<dt>Returns:</dt>
<dd>the outer product</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nullSpaceUsingSVD(double[][],double)">
<h3>nullSpaceUsingSVD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">nullSpaceUsingSVD</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tol)</span>
                                    throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">return the nullspace of matrix A using SVD.  This method is more accurate, but slower than
 using QR decomposition.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix of dimensions [mXn]</dd>
<dd><code>tol</code> - tolerance as the equivalent to 0 which is approximately machine precision.</dd>
<dt>Returns:</dt>
<dd>nullspace of matrix A, transposed to row vectors for easier use.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nullSpaceUsingQR(double[][],double)">
<h3>nullSpaceUsingQR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">nullSpaceUsingQR</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tol)</span>
                                   throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">return the nullspace of matrix A using QR decomposition.
 This method is less accurate, but faster than using SVD decomposition.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix of dimensions [mXn] where m must be .leq. n.</dd>
<dd><code>tol</code> - tolerance as the equivalent to 0 which is approximately machine precision.</dd>
<dt>Returns:</dt>
<dd>nullspace of matrix A transposed to row vectors for easier use.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="tripleProduct(double[],double[],double[])">
<h3>tripleProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">tripleProduct</span><wbr><span class="parameters">(double[]&nbsp;a,
 double[]&nbsp;b,
 double[]&nbsp;c)</span></div>
<div class="block">calculate the triple product as a x (b X c).
     <pre>
     from Boas "Mathematical Methods in the Physical Sciences", eqn 3.8
     a X (b X c) = (a dot c)*B - (a dot b) * c.

     also adapted from MASKS example code triple_product.m.
     "An introduction to 3-D Vision"
     by Y. Ma, S. Soatto, J. Kosecka, S. Sastry (MASKS)
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - array of length 3</dd>
<dd><code>b</code> - array of length 3</dd>
<dd><code>c</code> - array of length 3</dd>
<dt>Returns:</dt>
<dd>triple product of a, b, c.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rank(no.uib.cipr.matrix.SVD)">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(no.uib.cipr.matrix.SVD&nbsp;svd)</span></div>
</section>
</li>
<li>
<section class="detail" id="rank(algorithms.matrix.MatrixUtil.SVDProducts)">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(<a href="MatrixUtil.SVDProducts.html" title="class in algorithms.matrix">MatrixUtil.SVDProducts</a>&nbsp;svd)</span></div>
</section>
</li>
<li>
<section class="detail" id="rank(double[][])">
<h3>rank</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">rank</span><wbr><span class="parameters">(double[][]&nbsp;a)</span>
                throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="eigenvalues2X2(double[][])">
<h3>eigenvalues2X2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">eigenvalues2X2</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">calculate for matrix A, the 2 eigenvalues.
 The method uses the determinant, trace and quadratic formula.
     <pre>
     https://en.wikipedia.org/wiki/Eigenvalue_algorithm
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="eigenvalues2X2(float[][])">
<h3>eigenvalues2X2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[]</span>&nbsp;<span class="element-name">eigenvalues2X2</span><wbr><span class="parameters">(float[][]&nbsp;a)</span></div>
<div class="block">calculate for matrix A, the 2 eigenvalues.
 The method uses the determinant, trace and quadratic formula.
     <pre>
     https://en.wikipedia.org/wiki/Eigenvalue_algorithm
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
