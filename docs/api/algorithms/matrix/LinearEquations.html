<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Tue Sep 17 11:54:51 PDT 2024 -->
<title>LinearEquations</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-09-17">
<meta name="description" content="declaration: package: algorithms.matrix, class: LinearEquations">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.matrix</a></div>
<h1 title="Class LinearEquations" class="title">Class LinearEquations</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.matrix.LinearEquations</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">LinearEquations</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">a class of utility methods for linear algebra.
 <pre>
 note, for solving linear least squares problems, a good resource aside
 from Strang, Golub and van Loan, and Cormen, Leiserson, Rivest, and Stein is:
 “Algorithms for Linear Least Squares Problems”, 
 Bj̈orck 1991, published in Computer Algorithms for Solving Linear Algebraic Equations;
 The State of the Art., Vol. 77 of NATO-ASI Series F: Computer and Systems Sciences, pages 57–92.

   LUPSolve, __, and __ follow
   pseudocode from Cormen, Leiserson, Rivest, and Stein, "Introduction to
   Computer Algorithms".
 </pre>
 Note that any rectangular matrix can be made into a square matrix by adding zero rows or columns,
 without changing the nonzero singular values.
 Bjorck 1991, "Algorithms for Linear Least Squares Problems"</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="LinearEquations.LDL.html" class="type-name-link" title="class in algorithms.matrix">LinearEquations.LDL</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="LinearEquations.LDM.html" class="type-name-link" title="class in algorithms.matrix">LinearEquations.LDM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">lower triangular portion of A = L * D * M^T</div>
</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="LinearEquations.LU.html" class="type-name-link" title="class in algorithms.matrix">LinearEquations.LU</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="LinearEquations.LUP.html" class="type-name-link" title="class in algorithms.matrix">LinearEquations.LUP</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">LinearEquations</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_leastSquaresPolynomial(double%5B%5D%5B%5D,int,boolean)" class="member-name-link">_leastSquaresPolynomial</a><wbr>(double[][]&nbsp;xy,
 int&nbsp;polyOrder,
 boolean&nbsp;solveFullRank)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#choleskyDecompositionViaLDL(double%5B%5D%5B%5D,double)" class="member-name-link">choleskyDecompositionViaLDL</a><wbr>(double[][]&nbsp;a,
 double&nbsp;eps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#choleskyDecompositionViaMTJ(double%5B%5D%5B%5D)" class="member-name-link">choleskyDecompositionViaMTJ</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#gaussianEliminationViaLU(double%5B%5D%5B%5D,double)" class="member-name-link">gaussianEliminationViaLU</a><wbr>(double[][]&nbsp;a,
 double&nbsp;tol)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create the reduced row echelon form of matrix a as the Upper right matrix from the LU decomposition,
 further normalized and reduced.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LDLDecomposition(double%5B%5D%5B%5D)" class="member-name-link">LDLDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LDLDecomposition(double%5B%5D%5B%5D,double)" class="member-name-link">LDLDecomposition</a><wbr>(double[][]&nbsp;a,
 double&nbsp;eps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform an L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LDMDecomposition(double%5B%5D%5B%5D)" class="member-name-link">LDMDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#leastSquaresPolynomial(double%5B%5D%5B%5D,int)" class="member-name-link">leastSquaresPolynomial</a><wbr>(double[][]&nbsp;xy,
 int&nbsp;polyOrder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#leastSquaresPolynomial(double%5B%5D%5B%5D,int,boolean)" class="member-name-link">leastSquaresPolynomial</a><wbr>(double[][]&nbsp;xy,
 int&nbsp;polyOrder,
 boolean&nbsp;solveForFullRank)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LUDecomposition(double%5B%5D%5B%5D)" class="member-name-link">LUDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LUPDecomposition(double%5B%5D%5B%5D)" class="member-name-link">LUPDecomposition</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#LUPSolve(double%5B%5D%5B%5D,double%5B%5D%5B%5D,int%5B%5D,double%5B%5D)" class="member-name-link">LUPSolve</a><wbr>(double[][]&nbsp;ell,
 double[][]&nbsp;u,
 int[]&nbsp;p,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ...</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#makePivots1(double%5B%5D%5B%5D,double)" class="member-name-link">makePivots1</a><wbr>(double[][]&nbsp;u,
 double&nbsp;tol)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveXFromLUDecomposition(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">solveXFromLUDecomposition</a><wbr>(double[][]&nbsp;a,
 double[]&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solve for x in A*x=b by LU decomposition</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>LinearEquations</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">LinearEquations</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="LUPSolve(double[][],double[][],int[],double[])">
<h3>LUPSolve</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">LUPSolve</span><wbr><span class="parameters">(double[][]&nbsp;ell,
 double[][]&nbsp;u,
 int[]&nbsp;p,
 double[]&nbsp;b)</span></div>
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ... a_0_n*x_n     = b_0
       a_1_0*x_0   +  a_1_1*x_1   + ... a_1_n*x_n     = b_1
          ...
       a_n-1_0*x_0 +  a_n-1_1*x_1 + ... a_{n-1}_n*x_{n-1} = b_{n-1}
     where a is a square matrix, that is, there are n equations and n
     unknowns.
     LUP decomposition is more numerically stable than x = A^-1*b.
         can find L, U, and P such that P*A=L*U
     where L is a lower triangular matrix, U is an upper triangular matrix,
     and P is a permutation matrix.
     (a permutation matrix is all 0's excepting a single 1 in each column, uniquely.
     multiplying a vector by a permutation rearranges the members of the vector.)
     Uses forward substitution then back substitution.
       L*U*x=P*b.
         let y=U*x.
       L*y=P*b  (uses forward substitution with these results).
       U*x=y    (uses back substitution with these results).
       A*x=b    (then solves x_i=(y_i - summation_j=i_to_{n-1}(u_i_j*x_j))/u_i_i).
     runtime complexity is O(n^2) for backward and forward substitutions.
 The method follows Cormen et al. Chap 28.3.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>ell</code> - is an nxn lower triangular matrix using row major format.</dd>
<dd><code>u</code> - is an nxn upper triangular matrix using row major format.</dd>
<dd><code>p</code> - is an array of length n holding permutation vector columns. 
            e.g. p_0=0 states that column 0 contains a 1 for row=0.
            e.g. p_1=2 states that column 2 contains a 1 for row=1.
            full_permutation_matrix = zeros everywhere except the row, col pairs in p</dd>
<dd><code>b</code> - is an array of length n.</dd>
<dt>Returns:</dt>
<dd>array of x</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveXFromLUDecomposition(double[][],double[])">
<h3>solveXFromLUDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">solveXFromLUDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double[]&nbsp;b)</span></div>
<div class="block">solve for x in A*x=b by LU decomposition</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - matrix</dd>
<dd><code>b</code> - vector</dd>
<dt>Returns:</dt>
<dd>the solution x to a * x = b</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LUDecomposition(double[][])">
<h3>LUDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></span>&nbsp;<span class="element-name">LUDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.   uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix(i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt>Returns:</dt>
<dd>LU a wrapper holding the 2 two-dimensional row major output arrays.
 L and U.  they are both size nXn where n=a.length.
 L is a unit lower triangular matrix (has 1's on the diagonal) and U
 is an upper triangular matrix whose diagonals are the matrix pivots.
 Note that the determinant of A is the product of the U diagonals,
 that is det(A) = u[0][0] * u[1][1]...*u[n-1][n-1].</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="gaussianEliminationViaLU(double[][],double)">
<h3>gaussianEliminationViaLU</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">gaussianEliminationViaLU</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;tol)</span>
                                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">create the reduced row echelon form of matrix a as the Upper right matrix from the LU decomposition,
 further normalized and reduced.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - a rectangular matrix</dd>
<dd><code>tol</code> - tolerance for comparing to zero.  e.g. the machine precision.</dd>
<dt>Returns:</dt>
<dd>the reduced echelon matrix of a</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="makePivots1(double[][],double)">
<h3>makePivots1</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">makePivots1</span><wbr><span class="parameters">(double[][]&nbsp;u,
 double&nbsp;tol)</span></div>
</section>
</li>
<li>
<section class="detail" id="LDMDecomposition(double[][])">
<h3>LDMDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></span>&nbsp;<span class="element-name">LDMDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.  If all leading principal sub-matrices of 
 A are non-singular then there exist lower unit triangular matrices
 L and M and a diagonal matrix D = diag(d1, d2, ...d_n) where d_i = u_i_i.
 A = L*D*M^T.
 Note that D is non-singular and that M^T = D^-1*U is unit upper triangular.
 (A=L*U = L*D*(D^-1*U = L*D*M^T).
 <pre>
 Once A = L*D*M^T is decomposed, one can solve A*x = b:
 L*y = b   (in (n^2)/2 flops
 D*z= y    (in n flops)
 M^T*x = z (in (n^2)/2 flops)
 
 References:
 Golub and va Loan, "Matrix Computations", Section 5.1
 </pre>
 2n^3/3 flops.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt>Returns:</dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="choleskyDecompositionViaMTJ(double[][])">
<h3>choleskyDecompositionViaMTJ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">choleskyDecompositionViaMTJ</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - symmetric positive definite matrix.  
     a pos def matrix is symmetric and its eigenvalues are all positive.</dd>
<dt>Returns:</dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="choleskyDecompositionViaLDL(double[][],double)">
<h3>choleskyDecompositionViaLDL</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">choleskyDecompositionViaLDL</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;eps)</span></div>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.
 reference:
 golub and van loan "matrix computations, theorem 5.2-3.
 This method uses LDL decomposition to compute G in 
 a = G*G^T where G is a lower triangular matrix with positive
 diagonal entries.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - symmetric positive definite matrix.
     a pos def matrix is symmetric and its eigenvalues are all positive.</dd>
<dd><code>eps</code> - value for an error tolerance around zero used in the LDL decomposition.</dd>
<dt>Returns:</dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LDLDecomposition(double[][])">
<h3>LDLDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></span>&nbsp;<span class="element-name">LDLDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt>Returns:</dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LDLDecomposition(double[][],double)">
<h3>LDLDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></span>&nbsp;<span class="element-name">LDLDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a,
 double&nbsp;eps)</span></div>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform an L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dd><code>eps</code> - value for a tolerance of an error around 0.</dd>
<dt>Returns:</dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.
 Note that the method will return null when an intermediary calculation 
 is smaller than eps.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LUPDecomposition(double[][])">
<h3>LUPDecomposition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></span>&nbsp;<span class="element-name">LUPDecomposition</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.  
 creates a permutation matrix to pivot rows so that the row reduction
 divisions are by the largest numbers.
 uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix (i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt>Returns:</dt>
<dd>LUP a wrapper holding the 2 two-dimensional row major output arrays.
 L and U and the condensed permutation array p, where P*A=L*U.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leastSquaresPolynomial(double[][],int,boolean)">
<h3>leastSquaresPolynomial</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">leastSquaresPolynomial</span><wbr><span class="parameters">(double[][]&nbsp;xy,
 int&nbsp;polyOrder,
 boolean&nbsp;solveForFullRank)</span>
                                       throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveForFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt>Returns:</dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code> - thrown if MTJ SVD operation did not converge</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leastSquaresPolynomial(double[][],int)">
<h3>leastSquaresPolynomial</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">leastSquaresPolynomial</span><wbr><span class="parameters">(double[][]&nbsp;xy,
 int&nbsp;polyOrder)</span>
                                       throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dt>Returns:</dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_leastSquaresPolynomial(double[][],int,boolean)">
<h3>_leastSquaresPolynomial</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">_leastSquaresPolynomial</span><wbr><span class="parameters">(double[][]&nbsp;xy,
 int&nbsp;polyOrder,
 boolean&nbsp;solveFullRank)</span>
                                        throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt>Returns:</dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
