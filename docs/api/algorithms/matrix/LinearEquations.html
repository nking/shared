<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_131) on Thu Sep 02 09:58:21 PDT 2021 -->
<title>LinearEquations</title>
<meta name="date" content="2021-09-02">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LinearEquations";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/matrix/LinearEquations.html" target="_top">Frames</a></li>
<li><a href="LinearEquations.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">algorithms.matrix</div>
<h2 title="Class LinearEquations" class="title">Class LinearEquations</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.matrix.LinearEquations</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">LinearEquations</span>
extends java.lang.Object</pre>
<div class="block">a class of utility methods for linear algebra.
 <pre>
 note, for solving linear least squares problems, a good resource aside
 from Strang, Golub & van Loan, and Cormen et al. is:
 “Algorithms for Linear Least Squares Problems”, 
 Bj̈orck 1991, published in Computer Algorithms for Solving Linear Algebraic Equations;
 The State of the Art., Vol. 77 of NATO-ASI Series F: Computer and Systems Sciences, pages 57–92.
 </pre>
   LUPSolve, __, and __ follow
   pseudocode from Cormen, Leiserson, Rivest, and Stein, "Introduction to
   Computer Algorithms".</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></span></code>
<div class="block">lower triangular portion of A = L * D * M^T</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LinearEquations--">LinearEquations</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#Z:Z_leastSquaresPolynomial-double:A:A-int-boolean-">_leastSquaresPolynomial</a></span>(double[][]&nbsp;xy,
                       int&nbsp;polyOrder,
                       boolean&nbsp;solveFullRank)</code>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#choleskyDecompositionViaLDL-double:A:A-double-">choleskyDecompositionViaLDL</a></span>(double[][]&nbsp;a,
                           double&nbsp;eps)</code>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#choleskyDecompositionViaMTJ-double:A:A-">choleskyDecompositionViaMTJ</a></span>(double[][]&nbsp;a)</code>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LDLDecomposition-double:A:A-">LDLDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LDLDecomposition-double:A:A-double-">LDLDecomposition</a></span>(double[][]&nbsp;a,
                double&nbsp;eps)</code>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LDMDecomposition-double:A:A-">LDMDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#leastSquaresPolynomial-double:A:A-int-">leastSquaresPolynomial</a></span>(double[][]&nbsp;xy,
                      int&nbsp;polyOrder)</code>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#leastSquaresPolynomial-double:A:A-int-boolean-">leastSquaresPolynomial</a></span>(double[][]&nbsp;xy,
                      int&nbsp;polyOrder,
                      boolean&nbsp;solveForFullRank)</code>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LUDecomposition-double:A:A-">LUDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static <a href="../../algorithms/matrix/LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LUPDecomposition-double:A:A-">LUPDecomposition</a></span>(double[][]&nbsp;a)</code>
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#LUPSolve-double:A:A-double:A:A-int:A-double:A-">LUPSolve</a></span>(double[][]&nbsp;ell,
        double[][]&nbsp;u,
        int[]&nbsp;p,
        double[]&nbsp;b)</code>
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ...</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../algorithms/matrix/LinearEquations.html#solveXFromLUDecomposition-double:A:A-double:A-">solveXFromLUDecomposition</a></span>(double[][]&nbsp;a,
                         double[]&nbsp;b)</code>
<div class="block">solve for x in A*x=b by LU decomposition</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="LinearEquations--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LinearEquations</h4>
<pre>public&nbsp;LinearEquations()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="LUPSolve-double:A:A-double:A:A-int:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUPSolve</h4>
<pre>public static&nbsp;double[]&nbsp;LUPSolve(double[][]&nbsp;ell,
                                double[][]&nbsp;u,
                                int[]&nbsp;p,
                                double[]&nbsp;b)</pre>
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ... a_0_n*x_n     = b_0
       a_1_0*x_0   +  a_1_1*x_1   + ... a_1_n*x_n     = b_1
          ...
       a_n-1_0*x_0 +  a_n-1_1*x_1 + ... a_{n-1}_n*x_{n-1} = b_{n-1}
     where a is a square matrix, that is, there are n equations and n
     unknowns.
     LUP decomposition is more numerically stable than x = A^-1*b.
         can find L, U, and P such that P*A=L*U
     where L is a lower triangular matrix, U is an upper triangular matrix,
     and P is a permutation matrix.
     (a permutation matrix is all 0's excepting a single 1 in each column, uniquely.
     multiplying a vector by a permutation rearranges the members of the vector.)
     Uses forward substitution then back substitution.
       L*U*x=P*b.
         let y=U*x.
       L*y=P*b  (uses forward substitution with these results).
       U*x=y    (uses back substitution with these results).
       A*x=b    (then solves x_i=(y_i - summation_j=i_to_{n-1}(u_i_j*x_j))/u_i_i).
     runtime complexity is O(n^2) for backward and forward substitutions.
 The method follows Cormet et al. Chap 28.3.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ell</code> - is an nxn lower triangular matrix using row major format.</dd>
<dd><code>u</code> - is an nxn upper triangular matrix using row major format.</dd>
<dd><code>p</code> - is an array of length n holding permutation vector columns. 
            e.g. p_0=0 states that column 0 contains a 1 for row=0.
            e.g. p_1=2 states that column 2 contains a 1 for row=1.
            full_permutation_matrix = zeros everywhere except the row, col pairs in p</dd>
<dd><code>b</code> - is an array of length n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of x</dd>
</dl>
</li>
</ul>
<a name="solveXFromLUDecomposition-double:A:A-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveXFromLUDecomposition</h4>
<pre>public static&nbsp;double[]&nbsp;solveXFromLUDecomposition(double[][]&nbsp;a,
                                                 double[]&nbsp;b)</pre>
<div class="block">solve for x in A*x=b by LU decomposition</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="LUDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a>&nbsp;LUDecomposition(double[][]&nbsp;a)</pre>
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.   uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix(i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LU a wrapper holding the 2 two-dimensional row major output arrays.
 L and U.  they are both size nXn where n=a.length.
 L is a unit lower triangular matrix (has 1's on the diagonal) and U
 is an upper triangular matrix whose diagonals are the matrix pivots.
 Note that the determinant of A is the product of the U diagonals,
 that is det(A) = u[0][0] * u[1][1]...*u[n-1][n-1].</dd>
</dl>
</li>
</ul>
<a name="LDMDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDMDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a>&nbsp;LDMDecomposition(double[][]&nbsp;a)</pre>
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.  If all leading principal sub-matrices of 
 A are non-singular then there exist lower unit triangular matrices
 L and M and a diagonal matrix D = diag(d1, d2, ...d_n) where d_i = u_i_i.
 A = L*D*M^T.
 Note that D is non-singular and that M^T = D^-1*U is unit upper triangular.
 (A=L*U = L*D*(D^-1*U = L*D*M^T).
 <pre>
 Once A = L*D*M^T is decomposed, one can solve A*x = b:
 L*y = b   (in (n^2)/2 flops
 D*z= y    (in n flops)
 M^T*x = z (in (n^2)/2 flops)
 
 References:
 Golub and va Loan, "MAtrix Computations", Section 5.1
 </pre>
 2n^3/3 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</li>
</ul>
<a name="choleskyDecompositionViaMTJ-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>choleskyDecompositionViaMTJ</h4>
<pre>public static&nbsp;double[][]&nbsp;choleskyDecompositionViaMTJ(double[][]&nbsp;a)</pre>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - symmetric positive definite matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</li>
</ul>
<a name="choleskyDecompositionViaLDL-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>choleskyDecompositionViaLDL</h4>
<pre>public static&nbsp;double[][]&nbsp;choleskyDecompositionViaLDL(double[][]&nbsp;a,
                                                     double&nbsp;eps)</pre>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.
 reference:
 golub & van loan "matrix computations, theorem 5.2-3.
 This method uses LDL decomposition to compute G in 
 a = G*G^T where G is a lower triangular matrix with positive
 diagonal entries.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - symmetric positive definite matrix</dd>
<dd><code>eps</code> - value for an error tolerance around zero used in the LDL decomposition.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</li>
</ul>
<a name="LDLDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDLDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a>&nbsp;LDLDecomposition(double[][]&nbsp;a)</pre>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</li>
</ul>
<a name="LDLDecomposition-double:A:A-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDLDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a>&nbsp;LDLDecomposition(double[][]&nbsp;a,
                                                   double&nbsp;eps)</pre>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dd><code>eps</code> - value for a tolerance of an error around 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.
 Note that the method will return null when an intermediary calculation 
 is smaller than eps.</dd>
</dl>
</li>
</ul>
<a name="LUPDecomposition-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUPDecomposition</h4>
<pre>public static&nbsp;<a href="../../algorithms/matrix/LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a>&nbsp;LUPDecomposition(double[][]&nbsp;a)</pre>
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.  
 creates a permutation matrix to pivot rows so that the row reduction
 divisions are by the largest numbers.
 uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix (i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LUP a wrapper holding the 2 two-dimensional row major output arrays.
 L and U and the condensed permutation array p, where P*A=L*U.</dd>
</dl>
</li>
</ul>
<a name="leastSquaresPolynomial-double:A:A-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leastSquaresPolynomial</h4>
<pre>public static&nbsp;double[]&nbsp;leastSquaresPolynomial(double[][]&nbsp;xy,
                                              int&nbsp;polyOrder,
                                              boolean&nbsp;solveForFullRank)
                                       throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen et al. Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveForFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="leastSquaresPolynomial-double:A:A-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leastSquaresPolynomial</h4>
<pre>public static&nbsp;double[]&nbsp;leastSquaresPolynomial(double[][]&nbsp;xy,
                                              int&nbsp;polyOrder)
                                       throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen et al. Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a name="Z:Z_leastSquaresPolynomial-double:A:A-int-boolean-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_leastSquaresPolynomial</h4>
<pre>public static&nbsp;double[]&nbsp;_leastSquaresPolynomial(double[][]&nbsp;xy,
                                               int&nbsp;polyOrder,
                                               boolean&nbsp;solveFullRank)
                                        throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen et al. Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/matrix/BlockMatrixIsometric.html" title="class in algorithms.matrix"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../algorithms/matrix/LinearEquations.LDL.html" title="class in algorithms.matrix"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/matrix/LinearEquations.html" target="_top">Frames</a></li>
<li><a href="LinearEquations.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
