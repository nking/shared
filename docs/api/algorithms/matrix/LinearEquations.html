<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Wed Oct 26 11:58:06 PDT 2022 -->
<title>LinearEquations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-10-26">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LinearEquations";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.matrix</a></div>
<h2 title="Class LinearEquations" class="title">Class LinearEquations</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.matrix.LinearEquations</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">LinearEquations</span>
extends java.lang.Object</pre>
<div class="block">a class of utility methods for linear algebra.
 <pre>
 note, for solving linear least squares problems, a good resource aside
 from Strang, Golub & van Loan, and Cormen, Leiserson, Rivest, and Stein is:
 “Algorithms for Linear Least Squares Problems”, 
 Bj̈orck 1991, published in Computer Algorithms for Solving Linear Algebraic Equations;
 The State of the Art., Vol. 77 of NATO-ASI Series F: Computer and Systems Sciences, pages 57–92.

   LUPSolve, __, and __ follow
   pseudocode from Cormen, Leiserson, Rivest, and Stein, "Introduction to
   Computer Algorithms".
 </pre>
 Note that any rectangular matrix can be made into a square matrix by adding zero rows or columns,
 without changing the nonzero singular values.
 Bjorck 1991, "Algorithms for Linear Least Squares Problems"</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></span></code></th>
<td class="colLast">
<div class="block">lower triangular portion of A = L * D * M^T</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">LinearEquations</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_leastSquaresPolynomial(double%5B%5D%5B%5D,int,boolean)">_leastSquaresPolynomial</a></span>&#8203;(double[][]&nbsp;xy,
                       int&nbsp;polyOrder,
                       boolean&nbsp;solveFullRank)</code></th>
<td class="colLast">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#choleskyDecompositionViaLDL(double%5B%5D%5B%5D,double)">choleskyDecompositionViaLDL</a></span>&#8203;(double[][]&nbsp;a,
                           double&nbsp;eps)</code></th>
<td class="colLast">
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#choleskyDecompositionViaMTJ(double%5B%5D%5B%5D)">choleskyDecompositionViaMTJ</a></span>&#8203;(double[][]&nbsp;a)</code></th>
<td class="colLast">
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gaussianEliminationViaLU(double%5B%5D%5B%5D,double)">gaussianEliminationViaLU</a></span>&#8203;(double[][]&nbsp;a,
                        double&nbsp;tol)</code></th>
<td class="colLast">
<div class="block">create the reduced row echelon form of matrix a as the Upper right matrix from the LU decomposition,
 further normalized and reduced.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static <a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LDLDecomposition(double%5B%5D%5B%5D)">LDLDecomposition</a></span>&#8203;(double[][]&nbsp;a)</code></th>
<td class="colLast">
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static <a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LDLDecomposition(double%5B%5D%5B%5D,double)">LDLDecomposition</a></span>&#8203;(double[][]&nbsp;a,
                double&nbsp;eps)</code></th>
<td class="colLast">
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static <a href="LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LDMDecomposition(double%5B%5D%5B%5D)">LDMDecomposition</a></span>&#8203;(double[][]&nbsp;a)</code></th>
<td class="colLast">
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#leastSquaresPolynomial(double%5B%5D%5B%5D,int)">leastSquaresPolynomial</a></span>&#8203;(double[][]&nbsp;xy,
                      int&nbsp;polyOrder)</code></th>
<td class="colLast">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#leastSquaresPolynomial(double%5B%5D%5B%5D,int,boolean)">leastSquaresPolynomial</a></span>&#8203;(double[][]&nbsp;xy,
                      int&nbsp;polyOrder,
                      boolean&nbsp;solveForFullRank)</code></th>
<td class="colLast">
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static <a href="LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LUDecomposition(double%5B%5D%5B%5D)">LUDecomposition</a></span>&#8203;(double[][]&nbsp;a)</code></th>
<td class="colLast">
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LUPDecomposition(double%5B%5D%5B%5D)">LUPDecomposition</a></span>&#8203;(double[][]&nbsp;a)</code></th>
<td class="colLast">
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LUPSolve(double%5B%5D%5B%5D,double%5B%5D%5B%5D,int%5B%5D,double%5B%5D)">LUPSolve</a></span>&#8203;(double[][]&nbsp;ell,
        double[][]&nbsp;u,
        int[]&nbsp;p,
        double[]&nbsp;b)</code></th>
<td class="colLast">
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ...</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>(package private) static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makePivots1(double%5B%5D%5B%5D,double)">makePivots1</a></span>&#8203;(double[][]&nbsp;u,
           double&nbsp;tol)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solveXFromLUDecomposition(double%5B%5D%5B%5D,double%5B%5D)">solveXFromLUDecomposition</a></span>&#8203;(double[][]&nbsp;a,
                         double[]&nbsp;b)</code></th>
<td class="colLast">
<div class="block">solve for x in A*x=b by LU decomposition</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LinearEquations</h4>
<pre>public&nbsp;LinearEquations()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="LUPSolve(double[][],double[][],int[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUPSolve</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;LUPSolve&#8203;(double[][]&nbsp;ell,
                                double[][]&nbsp;u,
                                int[]&nbsp;p,
                                double[]&nbsp;b)</pre>
<div class="block">solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ... a_0_n*x_n     = b_0
       a_1_0*x_0   +  a_1_1*x_1   + ... a_1_n*x_n     = b_1
          ...
       a_n-1_0*x_0 +  a_n-1_1*x_1 + ... a_{n-1}_n*x_{n-1} = b_{n-1}
     where a is a square matrix, that is, there are n equations and n
     unknowns.
     LUP decomposition is more numerically stable than x = A^-1*b.
         can find L, U, and P such that P*A=L*U
     where L is a lower triangular matrix, U is an upper triangular matrix,
     and P is a permutation matrix.
     (a permutation matrix is all 0's excepting a single 1 in each column, uniquely.
     multiplying a vector by a permutation rearranges the members of the vector.)
     Uses forward substitution then back substitution.
       L*U*x=P*b.
         let y=U*x.
       L*y=P*b  (uses forward substitution with these results).
       U*x=y    (uses back substitution with these results).
       A*x=b    (then solves x_i=(y_i - summation_j=i_to_{n-1}(u_i_j*x_j))/u_i_i).
     runtime complexity is O(n^2) for backward and forward substitutions.
 The method follows Cormet et al. Chap 28.3.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ell</code> - is an nxn lower triangular matrix using row major format.</dd>
<dd><code>u</code> - is an nxn upper triangular matrix using row major format.</dd>
<dd><code>p</code> - is an array of length n holding permutation vector columns. 
            e.g. p_0=0 states that column 0 contains a 1 for row=0.
            e.g. p_1=2 states that column 2 contains a 1 for row=1.
            full_permutation_matrix = zeros everywhere except the row, col pairs in p</dd>
<dd><code>b</code> - is an array of length n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of x</dd>
</dl>
</li>
</ul>
<a id="solveXFromLUDecomposition(double[][],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveXFromLUDecomposition</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;solveXFromLUDecomposition&#8203;(double[][]&nbsp;a,
                                                 double[]&nbsp;b)</pre>
<div class="block">solve for x in A*x=b by LU decomposition</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - </dd>
<dd><code>b</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="LUDecomposition(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUDecomposition</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearEquations.LU.html" title="class in algorithms.matrix">LinearEquations.LU</a>&nbsp;LUDecomposition&#8203;(double[][]&nbsp;a)</pre>
<div class="block">an efficient LUP decomposition for a being a square non-singular matrix and
 P is the Identity matrix.   uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix(i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LU a wrapper holding the 2 two-dimensional row major output arrays.
 L and U.  they are both size nXn where n=a.length.
 L is a unit lower triangular matrix (has 1's on the diagonal) and U
 is an upper triangular matrix whose diagonals are the matrix pivots.
 Note that the determinant of A is the product of the U diagonals,
 that is det(A) = u[0][0] * u[1][1]...*u[n-1][n-1].</dd>
</dl>
</li>
</ul>
<a id="gaussianEliminationViaLU(double[][],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gaussianEliminationViaLU</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;gaussianEliminationViaLU&#8203;(double[][]&nbsp;a,
                                                  double&nbsp;tol)
                                           throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">create the reduced row echelon form of matrix a as the Upper right matrix from the LU decomposition,
 further normalized and reduced.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - a rectangular matrix</dd>
<dd><code>tol</code> - tolerance for comparing to zero.  e.g. the machine precision.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="makePivots1(double[][],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makePivots1</h4>
<pre class="methodSignature">static&nbsp;void&nbsp;makePivots1&#8203;(double[][]&nbsp;u,
                        double&nbsp;tol)</pre>
</li>
</ul>
<a id="LDMDecomposition(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDMDecomposition</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearEquations.LDM.html" title="class in algorithms.matrix">LinearEquations.LDM</a>&nbsp;LDMDecomposition&#8203;(double[][]&nbsp;a)</pre>
<div class="block">for a symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-M decomposition which is a 
 variation of L-U decomposition.  If all leading principal sub-matrices of 
 A are non-singular then there exist lower unit triangular matrices
 L and M and a diagonal matrix D = diag(d1, d2, ...d_n) where d_i = u_i_i.
 A = L*D*M^T.
 Note that D is non-singular and that M^T = D^-1*U is unit upper triangular.
 (A=L*U = L*D*(D^-1*U = L*D*M^T).
 <pre>
 Once A = L*D*M^T is decomposed, one can solve A*x = b:
 L*y = b   (in (n^2)/2 flops
 D*z= y    (in n flops)
 M^T*x = z (in (n^2)/2 flops)
 
 References:
 Golub and va Loan, "Matrix Computations", Section 5.1
 </pre>
 2n^3/3 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</li>
</ul>
<a id="choleskyDecompositionViaMTJ(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>choleskyDecompositionViaMTJ</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;choleskyDecompositionViaMTJ&#8203;(double[][]&nbsp;a)</pre>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a using the MTJ library.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - symmetric positive definite matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</li>
</ul>
<a id="choleskyDecompositionViaLDL(double[][],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>choleskyDecompositionViaLDL</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;choleskyDecompositionViaLDL&#8203;(double[][]&nbsp;a,
                                                     double&nbsp;eps)</pre>
<div class="block">compute the cholesky decomposition for symmetric positive definite matrix
 a.
 reference:
 golub & van loan "matrix computations, theorem 5.2-3.
 This method uses LDL decomposition to compute G in 
 a = G*G^T where G is a lower triangular matrix with positive
 diagonal entries.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - symmetric positive definite matrix</dd>
<dd><code>eps</code> - value for an error tolerance around zero used in the LDL decomposition.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lower triangular matrix G  which G is a lower triangular matrix with positive
 diagonal entries.  a = G*G^T.</dd>
</dl>
</li>
</ul>
<a id="LDLDecomposition(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDLDecomposition</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a>&nbsp;LDLDecomposition&#8203;(double[][]&nbsp;a)</pre>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.</dd>
</dl>
</li>
</ul>
<a id="LDLDecomposition(double[][],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LDLDecomposition</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearEquations.LDL.html" title="class in algorithms.matrix">LinearEquations.LDL</a>&nbsp;LDLDecomposition&#8203;(double[][]&nbsp;a,
                                                   double&nbsp;eps)</pre>
<div class="block">for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
 perform and L-D-L decomposition which is a 
 variation of L-U decomposition.  Computes a unit lower triangular matrix
 L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
 A = L*D*L^T.
 <pre>
 
 References:
 Golub and van Loan, "Matrix Computations", Algorithm 5.1.2
 </pre>
 n^3/6 flops.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - two dimensional array in row major format.  
 a is a symmetric matrix with dimensions n x n.</dd>
<dd><code>eps</code> - value for a tolerance of an error around 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LDM a wrapper holding the 2 two-dimensional row major output arrays.
 L and M and the diagonal matrix D as a an array of the diagonal.
 Note that the method will return null when an intermediary calculation 
 is smaller than eps.</dd>
</dl>
</li>
</ul>
<a id="LUPDecomposition(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUPDecomposition</h4>
<pre class="methodSignature">public static&nbsp;<a href="LinearEquations.LUP.html" title="class in algorithms.matrix">LinearEquations.LUP</a>&nbsp;LUPDecomposition&#8203;(double[][]&nbsp;a)</pre>
<div class="block">an LUP decomposition for a being a square non-singular matrix that tries 
 to reduce errors due to division by small numbers.  
 creates a permutation matrix to pivot rows so that the row reduction
 divisions are by the largest numbers.
 uses Gaussian elimination and the Schur
 complement while making recursive subdivision subdivisions.
 The runtime is O(n^3).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - square two dimensional array in row major format.  
 a is a non-singular matrix (i.e. has exactly one solution).  the rank of
 a is n (it's dimensions are m x n).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>LUP a wrapper holding the 2 two-dimensional row major output arrays.
 L and U and the condensed permutation array p, where P*A=L*U.</dd>
</dl>
</li>
</ul>
<a id="leastSquaresPolynomial(double[][],int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leastSquaresPolynomial</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;leastSquaresPolynomial&#8203;(double[][]&nbsp;xy,
                                              int&nbsp;polyOrder,
                                              boolean&nbsp;solveForFullRank)
                                       throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveForFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="leastSquaresPolynomial(double[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leastSquaresPolynomial</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;leastSquaresPolynomial&#8203;(double[][]&nbsp;xy,
                                              int&nbsp;polyOrder)
                                       throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="_leastSquaresPolynomial(double[][],int,boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_leastSquaresPolynomial</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;_leastSquaresPolynomial&#8203;(double[][]&nbsp;xy,
                                               int&nbsp;polyOrder,
                                               boolean&nbsp;solveFullRank)
                                        throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">given data points xy and the assumption that measurement errors are small,
 fit a polynomial of order polyOrder to the data points, minimizing the
 error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
 calculated by c = pseudo-inverse of A * y where A is the components of
 x as polynomial factors.
 NOTE that a regularized linear least squares algorithm called Elastic-Net
 is implemented as thirdparty.scipy.optimization.ElastticNet.
 This method follows pseudocode in chapter 28 of Cormen, Leiserson, Rivest, and Stein Introduction
 To Algorithms.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xy</code> - two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.</dd>
<dd><code>polyOrder</code> - the order of a polynomial to fit.  should be .lte. the
 number of rows.</dd>
<dd><code>solveFullRank</code> - when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
 and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
 (see Chap 4.3 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang and Chap 28 from the book "Introductionvto 
 Algorithms" by Cormen, Leiserson, Rivest, and Stein.)
 when solveForFullRank is set to 'False' this method uses the SVD to
 create a pseudoinverse (see Chap 7 from the book "Introduction to Linear
 Algebra" by W Gilbert Strang.)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>coefficients c where y_i = summation(c_i*x^i) + error</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
