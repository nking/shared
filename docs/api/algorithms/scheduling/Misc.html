<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Mon Jul 18 13:14:45 PDT 2022 -->
<title>Misc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-07-18">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Misc";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.scheduling</a></div>
<h2 title="Class Misc" class="title">Class Misc</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.scheduling.Misc</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Misc</span>
extends java.lang.Object</pre>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Misc</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intervalPartitionGreedy(double%5B%5D,double%5B%5D)">intervalPartitionGreedy</a></span>&#8203;(double[]&nbsp;s,
                       double[]&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Interval Partitioning:
    Given an infinite number of possible exclusive resources to use, 
    schedule all the activities using the smallest number of resources.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unweightedIntervalMinimizeLateGreedy(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">unweightedIntervalMinimizeLateGreedy</a></span>&#8203;(double[]&nbsp;duration,
                                    double[]&nbsp;deadline,
                                    double[]&nbsp;outputStart,
                                    double[]&nbsp;outputLate)</code></th>
<td class="colLast">
<div class="block">schedule a set of n tasks where each task is associated with a execution time 
 t_i and a deadline d_i.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unweightedIntervalNoConflicts(double%5B%5D,double%5B%5D)">unweightedIntervalNoConflicts</a></span>&#8203;(double[]&nbsp;s,
                             double[]&nbsp;f)</code></th>
<td class="colLast">
<div class="block">schedule a set of n tasks where each task is associated with a execution time 
 t_i and a deadline d_i.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weightedGreedy(int%5B%5D,int%5B%5D)">weightedGreedy</a></span>&#8203;(int[]&nbsp;deadlines,
              int[]&nbsp;penalties)</code></th>
<td class="colLast">
<div class="block">sect 16.5 of Cormen et al.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weightedIntervalBottomUp(double%5B%5D,double%5B%5D,double%5B%5D)">weightedIntervalBottomUp</a></span>&#8203;(double[]&nbsp;s,
                        double[]&nbsp;f,
                        double[]&nbsp;v)</code></th>
<td class="colLast">
<div class="block">The objective is to compute any maximum sized subset of non-overlapping intervals.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weightedIntervalBottomUp2(double%5B%5D,double%5B%5D,double%5B%5D)">weightedIntervalBottomUp2</a></span>&#8203;(double[]&nbsp;s,
                         double[]&nbsp;f,
                         double[]&nbsp;v)</code></th>
<td class="colLast">
<div class="block">The objective is to compute any maximum sized subset of non-overlapping intervals.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Misc</h4>
<pre>public&nbsp;Misc()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="unweightedIntervalMinimizeLateGreedy(double[],double[],double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unweightedIntervalMinimizeLateGreedy</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;unweightedIntervalMinimizeLateGreedy&#8203;(double[]&nbsp;duration,
                                                  double[]&nbsp;deadline,
                                                  double[]&nbsp;outputStart,
                                                  double[]&nbsp;outputLate)</pre>
<div class="block">schedule a set of n tasks where each task is associated with a execution time 
 t_i and a deadline d_i. 
 The objective is to schedule the tasks, no two overlapping in time, 
 such that they are all completed before their deadline. 
 If this is not possible, define the lateness of the ith task to be amount 
 by which its finish time exceeds its deadline. 
 The objective is to minimize the maximum lateness over all the tasks.
 
 References:
 <pre>
 lecture 7 notes of David Mount for CMSC 451 
 Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
 https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
 </pre>
 
 runtime complexity O(N * log_2(N)).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - duration of task</dd>
<dd><code>deadline</code> - deadline for task</dd>
<dd><code>outputStart</code> - output array to hold start times for the resulting scheduled index order</dd>
<dd><code>outputLate</code> - output array to hold lateness for the resulting scheduled index order.
 if is on time, element will be 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>indexes for scheduling order</dd>
</dl>
</li>
</ul>
<a id="unweightedIntervalNoConflicts(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unweightedIntervalNoConflicts</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;unweightedIntervalNoConflicts&#8203;(double[]&nbsp;s,
                                           double[]&nbsp;f)</pre>
<div class="block">schedule a set of n tasks where each task is associated with a execution time 
 t_i and a deadline d_i. 
 The objective is to schedule the tasks, no two overlapping in time, 
 such that they are all completed before their deadline. 
 If this is not possible, define the lateness of the ith task to be amount 
 by which its finish time exceeds its deadline. 
 The objective is to minimize the maximum lateness over all the tasks.
 
 The algorithm is aka Earliest Finish First (EFF) and Earliest Deadline First (EDF)
    (1) sort tasks by finish time
    (2) iterate over tasks, scheduling each that starts after the previous ended
 
 References:
 <pre>
 lecture 7 notes of David Mount for CMSC 451 
 Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
 https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
 </pre>
 
 runtime complexity is O(N * log_2(N)).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s</code> - start times for tasks</dd>
<dd><code>f</code> - finish times for tasks</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>indexes for scheduled non-conflicting tasks</dd>
</dl>
</li>
</ul>
<a id="weightedIntervalBottomUp(double[],double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedIntervalBottomUp</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;weightedIntervalBottomUp&#8203;(double[]&nbsp;s,
                                      double[]&nbsp;f,
                                      double[]&nbsp;v)</pre>
<div class="block">The objective is to compute any maximum sized subset of non-overlapping intervals.
 Weighted Interval Scheduling: 
 given a set S = {1, . . . , n} of n activity requests, 
 where each activity is expressed as an interval [s_i, f_i] from a given 
 start time si to a given finish time f_i
 and each request is associated with a numeric weight or value v_i.
 
 The objective is to find a set of non-overlapping requests such that sum 
 of values of the scheduled requests is maximum.
 
 This code uses dynamic programming and has runtime complexity O(n^2).
 
 The code follows the lecture notes of David Mount for CMSC 451 
 Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
 https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s</code> - interval start times</dd>
<dd><code>f</code> - interval finish times</dd>
<dd><code>v</code> - interval weights</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>indexes of scheduled intervals.</dd>
</dl>
</li>
</ul>
<a id="weightedIntervalBottomUp2(double[],double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedIntervalBottomUp2</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;weightedIntervalBottomUp2&#8203;(double[]&nbsp;s,
                                       double[]&nbsp;f,
                                       double[]&nbsp;v)</pre>
<div class="block">The objective is to compute any maximum sized subset of non-overlapping intervals.
 Weighted Interval Scheduling: 
 given a set S = {1, . . . , n} of n activity requests, 
 where each activity is expressed as an interval [s_i, f_i] from a given 
 start time si to a given finish time f_i
 and each request is associated with a numeric weight or value v_i.
 
 The objective is to find a set of non-overlapping requests such that sum 
 of values of the scheduled requests is maximum.
 
 This code uses dynamic programming and has runtime complexity O(n^2).
 
 The problem is from the lecture notes of David Mount for CMSC 451 
 Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
 https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf
 
 His pseudocode is present in the version of this method called 
 weightedIntervalBottomUp().
 
 runtime complexity is O(n^2)
 
 The version here is a simpler dynamic programming solution:
 
       <pre>
         Roughly:
         
           Thru these 2 short examples, one can see that a dynamic solution 
           also avoiding exponential comparisons of every permutation by re-using
           the answers from subproblems, should be possible.
           
          First, sort tasks by finish time.

          example:
            0 ---------|
            1    ------------|*
            2             -----|
            3          ------------|
            0+2 is possible. store total weight.
            0+3 is possible and has larger weight than 0+2. store total weight.

          Mount's example:
              0  1  2  3  4  5  6  7  8  9
           0  ---------|
           1     ------------|*
           2           --------|
           3        ---------------|
           4                   ------|*
           5                       -----|
             indexes that can be appended after 0: 2,4,5
             indexes that can be appended after 1: 4,5
             indexes that can be appended after 2: 4,5
             indexes that can be appended after 3: 5
             indexes that can be appended after 4:

             start from i=5.  best combination = [5], weight=w[5]
                        i=4.  best combination = [4], weight=w[4]
                        i=3.  best combination = [3,5], weight=w[3]+memo[5]
                        i=2.  combinations max([2,4], [2,5]) = max(w[2]+memo[4], w[2]+memo[5])
                        i=1.  combinations max([1,4], [1,5]) = max(w[1]+memo[4], w[1]+memo[5])
                        i=0.  combinations max([0,2], [0,4], [0,5]) = max(w[0]+memo[2], w[0]+memo[4], w[0]+memo[5])

             so memo can be a 1-dimensional array
             can also store the indexes in a map with key=integer and value=integer hashset

        sort tasks by finish time.

        for i=[n-1,0]
          max = int.min
          jmax = -1
          for j=[i+1, n) { // memo[j] will already exist and hold best max sum for its part of the schedule to end
            if (s[j] >= f[i]) { // task j can be appended after task i
              if (memo[j] > max) {
                jmax = j;
                max = memo[j];
              }
            }
          }
          set = new hashset int();
          map.put(i, set);
          set.add(i);
          if (jmax==-1) {
            memo[i] = w[i];
          } else {
            memo[i] = w[i] + max;
            set.add(jmax);
          }
        }
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s</code> - interval start times</dd>
<dd><code>f</code> - interval finish times</dd>
<dd><code>v</code> - interval weights</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>indexes of scheduled intervals.</dd>
</dl>
</li>
</ul>
<a id="weightedGreedy(int[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedGreedy</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;weightedGreedy&#8203;(int[]&nbsp;deadlines,
                            int[]&nbsp;penalties)</pre>
<div class="block">sect 16.5 of Cormen et al.
 
 there are numTasks number of tasks, each of which takes 1 unit of time
 and has its own deadline and penalty for missing the deadline.
 
 minimize the total penalty incurred for missed deadlines.
 
 early tasks: finishes before or at deadline.
 
 late tasks: finish after their deadlines.
 
 early-first form:  early tasks precede late tasks.
 
 canonical form: 
     early tasks precede late tasks
     and early tasks are in monotonically increasing order of deadlines.
     (1) put schedule in early first form
     (2) swap sequential pairs in the early list when d_{k} > d_{k+1}
     (3) list the early tasks
     (4) list the late tasks in any order
 
 if no tasks are late, the set is independent.
 
 the early set by themselves is an independent set.
 
 let L = set of all sets on independent tasks.
 
 N_t(A) = number of tasks t=0,1,2...n in set A whose deadline is t or earlier.
 
 if N_t(A) > t then there is no way to schedule all tasks within deadline.
 
 the problem of maximizing the sum of penalties for the early tasks
  is the same as minimizing the sum of penalties for the late tasks.
 
 algorithm with r.t. O(N * log_2(N)):
 
 (1) Use the Greedy algorithm to find a maximum weight independent set of
     tasks A.
 (2) create an optimal schedule having the tasks in A as its early tasks.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>deadlines</code> - values must be between 1 and numTasks, inclusive</dd>
<dd><code>penalties</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="intervalPartitionGreedy(double[],double[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>intervalPartitionGreedy</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;intervalPartitionGreedy&#8203;(double[]&nbsp;s,
                                     double[]&nbsp;f)</pre>
<div class="block">Interval Partitioning:
    Given an infinite number of possible exclusive resources to use, 
    schedule all the activities using the smallest number of resources.
    The activity requests each have a start and finish time.
    Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
    such that events of R_j are mutually non-conflicting, for each j: 0 ≤ j ≤ (d-1).

    References:
    <pre>
    lecture 7 notes of David Mount for CMSC 451       
    Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
    https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
    </pre>

     runtime complexity is O(n^2)
 
 Note: can compare this algorithm to the left-edge algorithms which
 sorts by increasing finish times, then loops over each request
 to add all sequential non-conflicting requests to a resource, then
 start a new resource for a conflict.
 Then one attempts to merge resources, by visiting them in reverse order.
 After all requests have been placed in a resource, one attempts to
 merge the non-conflicting resources by visiting them in reverse order
 and comparing to the previous resource (that is, starting with the last resource
 created, and then the one before it, etc until the first is visited).
 The left-edge algorithm runtime is similar to this interval partitioning greedy algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s</code> - start times</dd>
<dd><code>f</code> - finish times</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>indexes of resources to schedule the requests on.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
