see shared/src/main/algorithms/optimization/Knapsack*

===========================================================
max value for exact target:
    Given a set of n items, each with a mass and a value,
    determine the number of each item to include in a collection
    so that the total weight W is exactly equal to a given target
    and the total value is as large as possible.
  
basic outline for all exact target methods:

    int[] tab = new int[target + 1];
    int sentinel = Integer.MIN_VALUE;
    Arrays.fill(tab, sentinel);
    tab[0] = 0;
    int i, wc, c, wc2;
    for (i = 0; i < n; i++) {
    ... specialized weight logic for each knapsack type ...
    }
    return tab[target];

0-1:
        // since tab holds current and prev i results,
        // need to traverse weights from high to low
        // to avoid including an updated low wc2 in current wc
        for (wc = target; wc >= weights[i]; --wc) {
            wc2 = wc-weights[i];
            if (wc2 == 0) {
                tab[wc] = Math.max(tab[wc],  values[i]);
            } else if (wc2 > 0)  {
                int s = (tab[wc2] == sentinel) ? sentinel : tab[wc2] + values[i];
                tab[wc] = Math.max(tab[wc], s);
            }
        }

Bounded:
        // since tab holds current and prev i results,
        // need to traverse weights from high to low
        // to avoid including an updated low wc2 in current wc
        for (wc = target; wc >= weights[i]; --wc) {
            for (q = 1; q <= quantities[i]; ++q) {
                wc2 = wc - q * weights[i];
                if (wc2 == 0) {
                    tab[wc] = Math.max(tab[wc], q * values[i]);
                } else if (wc2 > 0)  {
                    int s = (tab[wc2]==sentinel) ? sentinel : tab[wc2] + q * values[i];
                    tab[wc] = Math.max(tab[wc], s);
                }
            }
        }

Unbounded:
        if (weights[i] > target) continue;
        // traverse wc from 1 to target to be able to 
        // add current wc2 counts to current count sum
        for (wc = 1; wc <= target; wc++) {
            wc2 = wc - weights[i];
            if (wc2 == 0) {
                tab[wc] = Math.max(tab[wc], values[i]);
            } else if (wc2 > 0)  {
                int s = (tab[wc2] == sentinel) ? sentinel : tab[wc2] +  values[i];
                tab[wc] = Math.max(tab[wc], s);
            }
        }

