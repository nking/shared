<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedBlackBSTLongInt2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.edu.princeton.cs.algs4</a> &gt; <span class="el_source">RedBlackBSTLongInt2.java</span></div><h1>RedBlackBSTLongInt2.java</h1><pre class="source lang-java linenums">package thirdparty.edu.princeton.cs.algs4;

/******************************************************************************
   adapted from RedBlackBST.java 
   from the 
   book &quot;Algorithms&quot; by Sedgewick and Wayne
   http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java
   copyright for authors Robert Sedgewick and Kevin Wayne
   is GPLV3, http://algs4.cs.princeton.edu/faq/

This version uses smaller amount of memory by replacing linked nodes with
associative arrays.

*     x.left.key .lte. x.key
*     x.right.key .gte. x.key
* 
 *  Compilation:  javac RedBlackBST.java
 *  Execution:    java RedBlackBST left-pipe input.txt
 *  Dependencies: StdIn.java StdOut.java  
 *  Data files:   http://algs4.cs.princeton.edu/33balanced/tinyST.txt  
 *    
 *  A symbol table implemented using a left-leaning red-black BST.
 *  This is the 2-3 version.
 *
 *  Note: commented out assertions because DrJava now enables assertions
 *        by default.
 *
 *  % more tinyST.txt
 *  S E A R C H E X A M P L E
 *  
 *  % java RedBlackBST left-pipe tinyST.txt
 *  A 8
 *  C 4
 *  E 12
 *  H 5
 *  L 11
 *  M 9
 *  P 10
 *  R 3
 *  S 0
 *  X 7
 *
 ******************************************************************************/

import algorithms.util.ObjectSpaceEstimator;
import algorithms.util.NodeMap;
import gnu.trove.list.TLongList;
import gnu.trove.list.array.TLongArrayList;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Stack;

/**
 * NOTE: this implementation of the long-int Red Black tree uses the least
 * amount of memory of all versions by replacing the tree structure of linked
 * lists of nodes as objects with associative arrays that use primitive 
 * arrays internally.  Reducing the Red Black tree space used was necessary for building the
 * YFastTrie.
 * 
 * 
 *  The {@code BST} class represents an ordered symbol table of generic
 *  key-value pairs.
 *  It supports the usual &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;get&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;,
 *  &lt;em&gt;delete&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; methods.
 *  It also provides ordered methods for finding the &lt;em&gt;minimum&lt;/em&gt;,
 *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;floor&lt;/em&gt;, and &lt;em&gt;ceiling&lt;/em&gt;.
 *  It also provides a &lt;em&gt;keys&lt;/em&gt; method for iterating over all of the keys.
 *  A symbol table implements the &lt;em&gt;associative array&lt;/em&gt; abstraction:
 *  when associating a value with a key that is already in the symbol table,
 *  the convention is to replace the old value with the new value.
 *  Unlike {@link java.util.Map}, this class uses the convention that
 *  values cannot be {@code null}â€”setting the
 *  value associated with a key to {@code null} is equivalent to deleting the key
 *  from the symbol table.
 *  &lt;p&gt;
 *  This implementation uses a left-leaning red-black BST. It requires that
 *  the key type implements the {@code Comparable} interface and calls the
 *  {@code compareTo()} and method to compare two keys. It does not call either
 *  {@code equals()} or {@code hashCode()}.
 *  The &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;, &lt;em&gt;remove&lt;/em&gt;, &lt;em&gt;minimum&lt;/em&gt;,
 *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;ceiling&lt;/em&gt;, and &lt;em&gt;floor&lt;/em&gt; operations each take
 *  logarithmic time in the worst case, if the tree becomes unbalanced.
 *  The &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; operations take constant time.
 *  Construction takes constant time.
 *  &lt;p&gt;
 *  For additional documentation, see 
 * &lt;a href=&quot;http://algs4.cs.princeton.edu/33balanced&quot;&gt;Section 3.3&lt;/a&gt; of
 *  &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.
 *  For other implementations of the same API, see {@link ST}, {@link BinarySearchST},
 *  {@link SequentialSearchST}, {@link BST},
 *  {@link SeparateChainingHashST}, {@link LinearProbingHashST}, and {@link AVLTreeST}.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 
 * edits made to their original code include replacing the linked object Nodes
 * with an associative array holding multiple values.
 */
<span class="fc" id="L100">public class RedBlackBSTLongInt2 {</span>
    
    private static final int RED   = 1;
    private static final int BLACK = 0;

<span class="pc" id="L105">    protected long root = -1;</span>
<span class="pc" id="L106">    protected boolean rootIsSet = false;</span>

    //TODO: as soon as this is debugged,
    //   make a class that extends TLongLongMap for
    //   key long, and values long, int, long, long, int, int
    //   reducing the number of long keys from 6 to 1
    protected final NodeMap nodeMap;
    
    /**
     * Initializes an empty symbol table.
     */
<span class="fc" id="L117">    public RedBlackBSTLongInt2() {</span>
<span class="fc" id="L118">        nodeMap = new NodeMap();</span>
<span class="fc" id="L119">    }</span>
    
    /**
     * Initializes an empty symbol table.
     */
<span class="nc" id="L124">    public RedBlackBSTLongInt2(int capacity) {</span>
<span class="nc" id="L125">        nodeMap = new NodeMap(capacity);</span>
<span class="nc" id="L126">    }</span>

    private long addNewNode(long key, int val, int color, int size) {
<span class="fc" id="L129">        nodeMap.put(key, val, color, size);</span>
<span class="fc" id="L130">        return key;</span>
    }
    
   /***************************************************************************
    *  Node helper methods.
    ***************************************************************************/
    // is node x red; false if x is null ?
    private boolean isRed(long x) {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return false;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        return nodeMap.getNodeColor(x) == RED;</span>
    }
    private boolean isLeftRed(long x) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L143">            return false;</span>
        }
<span class="fc" id="L145">        return isRed(nodeMap.getLeft(x));</span>
    }
    private boolean isRightRed(long x) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L149">            return false;</span>
        }
<span class="fc" id="L151">        return isRed(nodeMap.getRight(x));</span>
    }
    private boolean isLeftLeftRed(long x) {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="nc" id="L155">            return false;</span>
        }
<span class="fc" id="L157">        long left = nodeMap.getLeft(x);</span>
<span class="fc" id="L158">        return isLeftRed(left);</span>
    }
    private boolean isRightLeftRed(long x) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="nc" id="L162">            return false;</span>
        }
<span class="fc" id="L164">        long right = nodeMap.getRight(x);</span>
<span class="fc" id="L165">        return isLeftRed(right);</span>
    }

    // number of node in subtree rooted at x; 0 if x is null
    private int size(long x) {
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc" id="L171">        return nodeMap.getNodeSize(x);</span>
    }
    private int sizeLeft(long x) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return 0;</span>
<span class="fc" id="L176">        return nodeMap.getNodeSize(nodeMap.getLeft(x));</span>
    }
    private int sizeRight(long x) {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return 0;</span>
<span class="fc" id="L181">        return nodeMap.getNodeSize(nodeMap.getRight(x));</span>
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
<span class="fc" id="L189">        return size(root);</span>
    }

   /**
     * Is this symbol table empty?
     * @return {@code true} if this symbol table is empty and {@code false} otherwise
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        return !rootIsSet;</span>
    }

   /***************************************************************************
    *  Standard BST search.
    ***************************************************************************/

    /**
     * Returns the value associated with the given key.
     * @param key the key
     * @param output if output[0] == -1, then key was not present, else the
     *    returned value is found in output[1]
     */
    public void get(long key, int[] output) {
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L212">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="fc" id="L214">        output[0] = 0;</span>
<span class="fc" id="L215">        get(root, key, output);</span>
<span class="fc" id="L216">    }</span>

    // value associated with the given key in subtree rooted at x; null if no such key
    private void get(long x, long key, int[] output) {
        //while (x != null) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L222" title="All 4 branches covered.">            int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L225">                    x = nodeMap.getLeft(x);</span>
                } else {
                    break;
                }
<span class="fc bfc" id="L229" title="All 2 branches covered.">            } else if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L231">                    x = nodeMap.getRight(x);</span>
                } else {
                    break;
                }
            } else {
<span class="fc" id="L236">                output[1] = nodeMap.getNodeValue(x);</span>
<span class="fc" id="L237">                return;</span>
            }
<span class="fc" id="L239">        }</span>
<span class="fc" id="L240">        output[0] = -1;</span>
<span class="fc" id="L241">    }</span>

    /**
     * Does this symbol table contain the given key?
     * @param key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *     {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(long key) {
<span class="fc" id="L251">        get(key, cache0);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        return (cache0[0] != -1);</span>
    }
<span class="pc" id="L254">    private int[] cache0 = new int[2];</span>

   /***************************************************************************
    *  Red-black tree insertion.
    ***************************************************************************/

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     *
     * @param key the key
     * @param val the value
     */
    public void put(long key, int val) {
        
        //System.out.println(&quot;put &quot; + key + &quot;:&quot;);
        
        //System.out.println(&quot;before put &quot; + key);
        //printPreOrderTraversal();
        
<span class="fc" id="L274">        root = put(root, key, val);</span>
<span class="fc" id="L275">        rootIsSet = true;</span>
<span class="fc" id="L276">        nodeMap.updateNodeColor(root, BLACK);</span>
        
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (nodeMap.parentIsSet(root)) {</span>
<span class="nc" id="L279">            nodeMap.unsetParent(root);</span>
        }
        
        //printPreOrderTraversal();
        //System.out.println(&quot;after put &quot; + key + &quot; root=&quot; + root);
        
<span class="pc bnc" id="L285" title="All 2 branches missed.">        assert(check());</span>
<span class="fc" id="L286">    }</span>

    // insert the key-value pair in the subtree rooted at h
    //private Node put(Node h, long key, int val) {
    private long put(long h, long key, int val) {
        
        //System.out.println(&quot;put h=&quot; + h + &quot; key=&quot; + key);
        
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">        if (!rootIsSet || !nodeMap.containsKey(h)) {</span>
<span class="fc" id="L295">            return addNewNode(key, val, RED, 1);</span>
        }
       
<span class="pc bpc" id="L298" title="1 of 4 branches missed.">        int cmp = (key &lt; h) ? -1 : (key &gt; h) ? 1 : 0;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (cmp &lt; 0) {</span>
            //h.left  = put(h.left,  key, val);
            long putKey;
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (nodeMap.leftIsSet(h)) {</span>
                //h.left = putKey
                //putKey.parent = h
<span class="fc" id="L305">                long hLeft = nodeMap.getLeft(h);</span>
<span class="fc" id="L306">                putKey = put(hLeft,  key, val);</span>
<span class="fc" id="L307">            } else {</span>
<span class="fc" id="L308">                putKey = addNewNode(key, val, RED, 1);</span>
            }
<span class="fc" id="L310">            nodeMap.updateLeft(h, putKey);</span>
<span class="fc" id="L311">            nodeMap.updateParent(putKey, h);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        } else if (cmp &gt; 0) {</span>
            //h.right = put(h.right, key, val);
            long putKey;
<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (nodeMap.rightIsSet(h)) {</span>
<span class="fc" id="L316">                long hRight = nodeMap.getRight(h);</span>
<span class="fc" id="L317">                putKey = put(nodeMap.getRight(h),  key, val);</span>
<span class="fc" id="L318">            } else {</span>
<span class="fc" id="L319">                putKey = addNewNode(key, val, RED, 1);</span>
            }
<span class="fc" id="L321">            nodeMap.updateRight(h, putKey);</span>
<span class="fc" id="L322">            nodeMap.updateParent(putKey, h);</span>
<span class="fc" id="L323">        } else {</span>
            //h.val   = val;
<span class="nc bnc" id="L325" title="All 2 branches missed.">            assert(nodeMap.containsKey(h));</span>
<span class="nc" id="L326">            nodeMap.updateNodeValue(h, val);</span>
        }
        
        // fix-up any right-leaning links
<span class="fc bfc" id="L330" title="All 4 branches covered.">        if (isRightRed(h) &amp;&amp; !isLeftRed(h)) {</span>
<span class="fc" id="L331">            h = rotateLeft(h);</span>
        }
<span class="fc bfc" id="L333" title="All 4 branches covered.">        if (isLeftRed(h)  &amp;&amp;  isLeftLeftRed(h)) {</span>
<span class="fc" id="L334">            h = rotateRight(h);</span>
        }
<span class="fc bfc" id="L336" title="All 4 branches covered.">        if (isLeftRed(h)  &amp;&amp;  isRightRed(h))  {</span>
<span class="fc" id="L337">            flipColors(h);</span>
        }
<span class="fc" id="L339">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L340">        nodeMap.updateNodeSize(h, size);</span>
       
<span class="fc" id="L342">        return h;</span>
    }

   /***************************************************************************
    *  Red-black tree deletion.
    ***************************************************************************/

    private void setRootToRedIfChildrenAreBlack() {
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">        if (!isLeftRed(root) &amp;&amp; !isRightRed(root)) {</span>
<span class="fc" id="L351">            nodeMap.updateNodeColor(root, RED);</span>
        }
<span class="fc" id="L353">    }</span>
    
    /**
     * Removes the smallest key and associated value from the symbol table.
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMin() {
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);</span>

        //System.out.println(&quot;deleteMin.  root=&quot; +root);
        //printPreOrderTraversal();
        
<span class="fc" id="L365">        int sz0 = size();</span>
        
<span class="pc bnc" id="L367" title="All 2 branches missed.">        assert(nodeMap.containsKey(root));</span>
        
        // if both children of root are black, set root to red
<span class="fc" id="L370">        setRootToRedIfChildrenAreBlack();</span>
        
        //root = deleteMin(root);
<span class="fc" id="L373">        long[] output = new long[2];</span>
<span class="fc" id="L374">        deleteMin(root, output);</span>
        
        //System.out.println(&quot;deleteMin=&quot; + Arrays.toString(output));
        
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L379">            rootIsSet = false;</span>
<span class="nc" id="L380">            nodeMap.remove(root);</span>
<span class="nc" id="L381">            root = -1;</span>
        } else {
            //System.out.println(&quot;in deleteMin: assigning root=&quot; + output[1]);
<span class="fc" id="L384">            root = output[1];</span>
<span class="fc" id="L385">            nodeMap.unsetParent(root);</span>
        }
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
            //root.color = BLACK;
<span class="fc" id="L389">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //System.out.format(&quot;AFTER deleteMin()\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="pc bnc" id="L395" title="All 2 branches missed.">        assert(check());</span>
        
<span class="pc bnc" id="L397" title="All 2 branches missed.">        assert(sz0 == (size() + 1));</span>
<span class="fc" id="L398">    }</span>

    // delete the key-value pair with the minimum key rooted at h.
    // output is length==2, output[0] holds the error code
    // and is -1 when there is an error.  output[1] holds the top node
    // from which the min was deleted (note that the top node may have
    // been rotated, so might not equal h).
    // if output.length == 3, the third item is set to be the
    // minimum node which was deleted.
    private void deleteMin(long h, long[] output) { 
        
        //System.out.println(&quot;deleteMin &quot; + nodeToString(h));
        
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(h)) {</span>
<span class="nc" id="L412">            output[0] = -1;</span>
<span class="nc" id="L413">            return;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        } else if (!nodeMap.leftIsSet(h)) {</span>
<span class="fc" id="L415">            output[0] = -1;</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (output.length == 3) {</span>
<span class="fc" id="L417">                output[2] = h;</span>
            }
<span class="fc" id="L419">            return;</span>
        }

        //System.out.format(&quot;BEFORE deleteMin(%d)\n&quot;, h);
        //printPreOrderTraversal(1);
        
        
<span class="fc bfc" id="L426" title="All 4 branches covered.">        if (!isLeftRed(h) &amp;&amp; !isLeftLeftRed(h)) {</span>
<span class="fc" id="L427">            h = moveRedLeft(h);</span>
        }
        
        //h.left = deleteMin(h.left);
        
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (!nodeMap.leftIsSet(h)) {</span>
<span class="nc" id="L433">            output[0] = -1;</span>
<span class="nc" id="L434">            return;</span>
        }
<span class="fc" id="L436">        long left = nodeMap.getLeft(h);</span>
        //assert(parent == h);
        
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (output.length == 3) {</span>
<span class="fc" id="L440">            output[2] = left;</span>
        }
        
<span class="fc" id="L443">        deleteMin(left, output);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (output[0] == -1) {</span>
            //h.left = null
<span class="fc" id="L446">            nodeMap.unsetLeft(h);</span>
<span class="fc" id="L447">            output[0] = 0;</span>
        } else {
            //System.out.println(&quot; deleteMin return is &quot; + output[1] 
            //   + &quot; h.left gets assigned it&quot;);
<span class="fc" id="L451">            nodeMap.updateParent(output[1], h);</span>
<span class="fc" id="L452">            nodeMap.updateLeft(h, output[1]);</span>
        }
<span class="fc" id="L454">        output[1] = balance(h);</span>
        
        //printPreOrderTraversal(1);
        //System.out.format(&quot;AFTER deleteMin(h)\n&quot;);
<span class="fc" id="L458">    }</span>

    /**
     * Removes the largest key and associated value from the symbol table.
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMax() {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);</span>

        //System.out.println(&quot;deleteMax.  root=&quot; +root);
        //printPreOrderTraversal();
        
        // if both children of root are black, set root to red
<span class="fc" id="L471">        setRootToRedIfChildrenAreBlack();</span>

        //root = deleteMax(root);
        
<span class="fc" id="L475">        long[] output = new long[2];</span>
<span class="fc" id="L476">        deleteMax(root, output);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L478">            nodeMap.remove(root);</span>
<span class="nc" id="L479">            rootIsSet = false;</span>
<span class="nc" id="L480">            root = -1;</span>
<span class="nc" id="L481">            return;</span>
        }
<span class="fc" id="L483">        root = output[1];</span>
<span class="fc" id="L484">        nodeMap.unsetParent(root);</span>
        
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
            //root.color = BLACK;
<span class="fc" id="L488">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //System.out.format(&quot;AFTER deleteMax()\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="pc bnc" id="L494" title="All 2 branches missed.">        assert(check());</span>
<span class="fc" id="L495">    }</span>

    // delete the key-value pair with the maximum key rooted at h
    private void deleteMax(long h, long[] output) { 
    
        //System.out.format(&quot;BEFORE deleteMax(%d)\n&quot;, h);
        //printPreOrderTraversal(1);
        
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (isLeftRed(h)) {</span>
<span class="fc" id="L504">            h = rotateRight(h);</span>
        }
      
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(h)) {</span>
            // h is max key
<span class="fc" id="L509">            output[0] = -1;</span>
<span class="fc" id="L510">            return;</span>
        }

<span class="fc bfc" id="L513" title="All 4 branches covered.">        if (!isRightRed(h) &amp;&amp; !isRightLeftRed(h)) {</span>
            //move red node down the right spine of the tree
<span class="fc" id="L515">            h = moveRedRight(h);</span>
        }
        
        //h.right = deleteMax(h.right);
        
<span class="pc bnc" id="L520" title="All 2 branches missed.">        assert(nodeMap.rightIsSet(h));</span>
        
<span class="fc" id="L522">        deleteMax(nodeMap.getRight(h), output);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L524">            nodeMap.unsetRight(h);</span>
        } else {
<span class="fc" id="L526">            nodeMap.updateParent(output[1], h);</span>
<span class="fc" id="L527">            nodeMap.updateRight(h, output[1]);</span>
        }

<span class="fc" id="L530">        output[0] = 0;</span>
<span class="fc" id="L531">        output[1] = balance(h);</span>
        
        
        //System.out.format(&quot;AFTER deleteMax(h)\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="fc" id="L537">    }</span>

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     */
    public void delete(long key) { 
        
<span class="fc" id="L547">        int sz0 = size();</span>
        
        //System.out.println(&quot;\nbefore delete &quot; + key + &quot; root=&quot; + root);
        //printPreOrderTraversal();
        
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (!contains(key)) return;</span>

        // if both children of root are black, set root to red
<span class="fc" id="L555">        setRootToRedIfChildrenAreBlack();</span>
        
        ////root = delete(root, key);
        
<span class="fc" id="L559">        long[] output = new long[2];</span>
<span class="fc" id="L560">        delete(root, key, output);</span>
        
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L563">            rootIsSet = false;</span>
<span class="fc" id="L564">            nodeMap.remove(root);</span>
<span class="fc" id="L565">            root = -1;</span>
<span class="fc" id="L566">            return;</span>
        }
<span class="fc" id="L568">        root = output[1];</span>
<span class="fc" id="L569">        nodeMap.unsetParent(root);</span>
        
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
<span class="fc" id="L572">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //printPreOrderTraversal();
        //System.out.println(&quot;after delete &quot; + key + &quot; root=&quot; + root);
        
<span class="pc bnc" id="L578" title="All 2 branches missed.">        assert(check());</span>
        
<span class="pc bnc" id="L580" title="All 2 branches missed.">        assert(sz0 == (size() + 1));</span>
<span class="fc" id="L581">    }</span>

    // delete the key-value pair with the given key rooted at h
    private void delete(long h, long key, long[] output) { 
        
        //System.out.format(&quot;delete(%d, %d)\n&quot;, h, key);
        
<span class="pc bnc" id="L588" title="All 2 branches missed.">        assert(nodeMap.containsKey(key));</span>
<span class="pc bnc" id="L589" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
        
        // assert get(h, key) != null;
        {//DEBUG
<span class="fc" id="L593">            int[] vOutput = new int[2];</span>
<span class="fc" id="L594">            get(h, key, vOutput);</span>
<span class="pc bnc" id="L595" title="All 2 branches missed.">            assert(vOutput[0] != -1);</span>
        }
        
<span class="fc" id="L598">        output[0] = 0;</span>
        
        //NOTE: this method and the methods it uses do not always
        //check for nulls and handle them
                    
<span class="fc bfc" id="L603" title="All 2 branches covered.">        if (key &lt; h)  {</span>
<span class="fc bfc" id="L604" title="All 4 branches covered.">            if (!isLeftRed(h) &amp;&amp; !isLeftLeftRed(h)) {</span>
<span class="fc" id="L605">                h = moveRedLeft(h);</span>
            }
<span class="pc bnc" id="L607" title="All 2 branches missed.">            assert(nodeMap.leftIsSet(h));</span>
            //h.left = delete(h.left, key);
<span class="fc" id="L609">            deleteFromLeftAssignLeft(h, h, key, output);</span>
<span class="fc" id="L610">            output[0] = 0;</span>
        } else {
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (isLeftRed(h)) {</span>
<span class="fc" id="L613">                h = rotateRight(h);</span>
            }
<span class="fc bfc" id="L615" title="All 4 branches covered.">            if (key == h &amp;&amp; !nodeMap.rightIsSet(h)) {</span>
<span class="fc" id="L616">                output[0] = -1;</span>
<span class="fc" id="L617">                return;</span>
            }
<span class="fc bfc" id="L619" title="All 4 branches covered.">            if (!isRightRed(h) &amp;&amp; !isRightLeftRed(h)) {</span>
<span class="fc" id="L620">                h = moveRedRight(h);</span>
            }
<span class="fc bfc" id="L622" title="All 2 branches covered.">            if (key == h) {</span>
               
                //NLK: TODO: revisit this code. it or similar had a bug I fixed,
                //    but forgot to communicate the fix back to the authors or
                //    follow up on whether they fixed it.
                
                /*
                useful in visualizing this case is
                https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf
                pg 66, &quot;Deleting an arbitrary node&quot;
                
                To delete 'D':
                
                               H
                        D             L
                    B      F       J     N
                   A C    E G     I K   M
                
                  D.key = min(D.right)
                  D.value = get(D.right, D.key)
                  D.right = deleteMin(D.right)
                  then delete the min node
                  then fix right-leaning red link of F, the parent
                    of the just deleted E node
                              H
                        E             L
                    B      F       J     N
                   A C      G     I K   M   
                
                
                              H
                        E             L
                    B      F       J     N
                   A C    G       I K   M   
                */
                
                //Node x = min(h.right);
                // Note: need to use deleteMin all in one because there
                //   are rotations in it that may change the branch
                //   traversed and hence the minimum of that branch
                //   might not be the same as x.
<span class="fc" id="L663">                long[] output3 = new long[3];</span>
<span class="fc" id="L664">                deleteMin(nodeMap.getRight(h), output3);</span>
                        
                //System.out.println(&quot;deleteMin=&quot; + Arrays.toString(output3));
        
<span class="fc" id="L668">                int hClr = nodeMap.getNodeColor(h);</span>
<span class="fc" id="L669">                boolean hLeftExists = nodeMap.leftIsSet(h);</span>
<span class="fc" id="L670">                boolean hRightExists = nodeMap.rightIsSet(h);</span>
<span class="fc" id="L671">                boolean hParentExists = nodeMap.parentIsSet(h);</span>
<span class="fc" id="L672">                long hLeft = nodeMap.getLeft(h);</span>
<span class="fc" id="L673">                long hRight = nodeMap.getRight(h);</span>
<span class="fc" id="L674">                long hParent = nodeMap.getParent(h);</span>
<span class="fc" id="L675">                int hSize = nodeMap.getNodeSize(h);</span>
               
<span class="fc" id="L677">                String hDBG = nodeToString(h);</span>
                
<span class="fc" id="L679">                long x = output3[2];</span>
               
                //System.out.println(
                //    &quot;   x to get h fields except val. &quot; + 
                //    &quot;\n   x=&quot; + nodeToString(x)
                //    + &quot;\n   h=&quot; + hDBG
                //);
               
<span class="pc bnc" id="L687" title="All 2 branches missed.">                assert(x != h);</span>
                
                //int xClr = nodeMap.getNodeColor(x);
                //boolean xLeftExists = nodeMap.leftIsSet(x);
                //boolean xRightExists = nodeMap.rightIsSet(x);
<span class="fc" id="L692">                boolean xParentExists = nodeMap.parentIsSet(x);</span>
                //long xLeft = nodeMap.getLeft(x);
                //long xRight = nodeMap.getRight(x);
<span class="fc" id="L695">                long xParent = nodeMap.getParent(x);</span>
<span class="fc" id="L696">                int xVal = nodeMap.getNodeValue(x);</span>
                
                // finish deleting x if not already
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">                if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L700">                    long minParent = nodeMap.getParent(x);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">                    if (nodeMap.leftIsSet(minParent)</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">                        &amp;&amp; nodeMap.getLeft(minParent) == x) {</span>
<span class="nc" id="L703">                        nodeMap.unsetLeft(minParent);</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                    } else if (nodeMap.rightIsSet(minParent)</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                            &amp;&amp; nodeMap.getRight(minParent) == x) {</span>
<span class="fc" id="L706">                        nodeMap.unsetRight(minParent);</span>
                    }
<span class="fc" id="L708">                    nodeMap.unsetParent(x);</span>
                }
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">                if (nodeMap.containsKey(x)) {</span>
<span class="fc" id="L711">                    nodeMap.remove(x);</span>
                }
                
<span class="pc bpc" id="L714" title="1 of 4 branches missed.">                if (hRightExists &amp;&amp; hRight == x) {</span>
<span class="fc" id="L715">                    hRightExists = false;</span>
                }
                
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">                if (xParentExists) {</span>
<span class="pc bnc" id="L719" title="All 2 branches missed.">                    assert(!nodeMap.parentIsSet(x));</span>
                }
                
<span class="fc" id="L722">                setHFromX(x, h, xVal, hClr, </span>
                    hLeftExists, hLeft, 
                    hRightExists, hRight, hParentExists, hParent, hSize - 1);
                    
<span class="fc" id="L726">                h = x;</span>
                
                //System.out.println(&quot;  merged=&quot; + nodeToString(h));
                
<span class="fc" id="L730">                output[0] = 0;</span>
                 
<span class="fc" id="L732">            } else {</span>
                //h.right = delete(h.right, key);
<span class="fc" id="L734">                deleteFromRightAssignRight(h, h, key, output);</span>
<span class="fc" id="L735">                output[0] = 0;</span>
            }
        }
                
<span class="fc" id="L739">        output[0] = 0;</span>
<span class="fc" id="L740">        output[1] = balance(h);  </span>
<span class="fc" id="L741">    }</span>
    
   /***************************************************************************
    *  Red-black tree helper functions.
    ***************************************************************************/

    /**
     * make a left-leaning link lean to the right.
     Note that the parent link logic is from Cormen, Leiserson, Rivest, and Stein &quot;Introduction to
     Algorithms&quot;.
     */
    protected long rotateRight(long h) {
        
        //System.out.println(&quot;  *RR &quot; + h);
        
        // assert (h != null) &amp;&amp; isRed(h.left);
<span class="pc bnc" id="L757" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L758" title="All 2 branches missed.">        assert(isLeftRed(h));</span>
        
        /*
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = x.right.color;
        x.right.color = RED;
        x.size = h.size;
        h.size = size(h.left) + size(h.right) + 1;
        */
        
<span class="fc" id="L770">        long x = nodeMap.getLeft(h);</span>

        //System.out.println(&quot;  before RR h=&quot; + nodeToString(h));
        //System.out.println(&quot;  before RR x=&quot; + nodeToString(x));
        
<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
            //System.out.println(&quot;--0&quot;);
            //h.left = x.right;
<span class="fc" id="L778">            long xRight = nodeMap.getRight(x);</span>
            
<span class="fc" id="L780">            nodeMap.updateLeft(h, xRight);</span>
<span class="fc" id="L781">            nodeMap.updateParent(xRight, h);</span>
<span class="fc" id="L782">        } else {</span>
            //System.out.println(&quot;--1&quot;);
<span class="fc" id="L784">            nodeMap.unsetLeft(h);</span>
        }
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (nodeMap.parentIsSet(h)) {</span>
            //System.out.println(&quot;--2&quot;);
<span class="fc" id="L788">            long hParent = nodeMap.getParent(h);</span>
            // assign x as child of its new parent
            
<span class="fc" id="L791">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L792" title="1 of 4 branches missed.">            if (nodeMap.leftIsSet(hParent) &amp;&amp; nodeMap.getLeft(hParent) ==</span>
                h) {
                //System.out.println(&quot;--3&quot;);
<span class="fc" id="L795">                nodeMap.updateLeft(hParent, x);</span>
            } else {
                //System.out.println(&quot;--4&quot;);
<span class="fc" id="L798">                nodeMap.updateRight(hParent, x);</span>
            }
<span class="fc" id="L800">        } else {</span>
            //System.out.println(&quot;--5&quot;);
<span class="fc" id="L802">            nodeMap.unsetParent(x);</span>
            //root = x;
        }
        
        //System.out.println(&quot;  in RR after h.left h=&quot; + nodeToString(h));
        
        //x.right = h;
<span class="fc" id="L809">        nodeMap.updateRight(x, h);</span>
<span class="fc" id="L810">        nodeMap.updateParent(h, x);</span>
        
        //System.out.println(&quot;  in RR after x.right h=&quot; + nodeToString(h));
        //System.out.println(&quot;  in RR after x.right x=&quot; + nodeToString(x));
        
        //x.color = x.right.color;
        //x.right.color = RED;
        //x.size = h.size;
<span class="fc" id="L818">        nodeMap.updateNodeColor(x, nodeMap.getNodeColor(nodeMap.getRight(x)));</span>
<span class="fc" id="L819">        nodeMap.updateNodeColor(nodeMap.getRight(x), RED);</span>
        
<span class="fc" id="L821">        nodeMap.updateNodeSize(x, nodeMap.getNodeSize(h));</span>
        
        //h.size = size(h.left) + size(h.right) + 1;
<span class="fc" id="L824">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L825">        nodeMap.updateNodeSize(h, size);</span>
        
        //System.out.println(&quot;  after RR: h=&quot; + nodeToString(h));
        
        //System.out.println(&quot;after rotateRight:&quot;);
        //printPreOrderTraversal();
        
<span class="fc" id="L832">        return x;</span>
    }

    /**
     make a right-leaning link lean to the left.
     Note that the parent link logic is from Cormen, Leiserson, Rivest, and Stein &quot;Introduction to
     Algorithms&quot;.
     */
    protected long rotateLeft(long h) {
        
        //System.out.println(&quot;  *RL h=&quot; + h);
        
        // assert (h != null) &amp;&amp; isRed(h.right);
<span class="pc bnc" id="L845" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L846" title="All 2 branches missed.">        assert(isRightRed(h));</span>
        
        //Node x = h.right;
<span class="fc" id="L849">        long x = nodeMap.getRight(h);</span>
        
        //System.out.println(&quot;  before RL h=&quot; + nodeToString(h));
        //System.out.println(&quot;  before RL x=&quot; + nodeToString(x));

        //h.right = x.left;
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
            //System.out.println(&quot;---0&quot;);
<span class="fc" id="L857">            long left = nodeMap.getLeft(x);</span>
            
<span class="fc" id="L859">            nodeMap.updateRight(h, left);</span>
<span class="fc" id="L860">            nodeMap.updateParent(left, h);</span>
            
<span class="fc" id="L862">        } else {</span>
            //System.out.println(&quot;---1&quot;);
<span class="fc" id="L864">            nodeMap.unsetRight(h);</span>
        }
       
        //System.out.println(&quot;  in RL after h.right h=&quot; + nodeToString(h));
        
<span class="fc bfc" id="L869" title="All 2 branches covered.">        if (nodeMap.parentIsSet(h)) {</span>
            //System.out.println(&quot;---2&quot;);
<span class="fc" id="L871">            long hParent = nodeMap.getParent(h);</span>
<span class="fc" id="L872">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L873" title="1 of 4 branches missed.">            if (nodeMap.leftIsSet(hParent) &amp;&amp; nodeMap.getLeft(hParent) ==</span>
                h) {
                //System.out.println(&quot;---3&quot;);
<span class="fc" id="L876">                nodeMap.updateLeft(hParent, x);</span>
            } else {
                //System.out.println(&quot;---4&quot;);
<span class="fc" id="L879">                nodeMap.updateRight(hParent, x);</span>
            }
<span class="fc" id="L881">        } else {</span>
            //System.out.println(&quot;---5&quot;);
<span class="fc" id="L883">            nodeMap.unsetParent(x);</span>
        }
                
        //x.left = h;
<span class="fc" id="L887">        nodeMap.updateLeft(x, h);</span>
<span class="fc" id="L888">        nodeMap.updateParent(h, x);</span>
        
        //System.out.println(&quot;  in RL after x.left h=&quot; + nodeToString(h));
        //System.out.println(&quot;  in RL after x.left x=&quot; + nodeToString(x));

        //x.color = x.left.color;
<span class="fc" id="L894">        nodeMap.updateNodeColor(x, nodeMap.getNodeColor(h));</span>
        //x.left.color = RED;
<span class="fc" id="L896">        nodeMap.updateNodeColor(h, RED);</span>
        
<span class="fc" id="L898">        nodeMap.updateNodeSize(x, nodeMap.getNodeSize(h));</span>
        
<span class="fc" id="L900">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L901">        nodeMap.updateNodeSize(h, size);</span>
               
        //System.out.println(&quot;  after RL: h=&quot; + nodeToString(h));
        
<span class="fc" id="L905">        return x;</span>
    }

    // flip the colors of a node and its two children
    protected void flipColors(long h) {
        // h must have opposite color of its two children
<span class="pc bnc" id="L911" title="All 4 branches missed.">        assert(nodeMap.containsKey(h) &amp;&amp; nodeMap.leftIsSet(h) </span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            &amp;&amp; nodeMap.rightIsSet(h));</span>
<span class="pc bnc" id="L913" title="All 6 branches missed.">        assert(!isRed(h) &amp;&amp;  isLeftRed(h) &amp;&amp;  isRightRed(h))</span>
<span class="nc bnc" id="L914" title="All 6 branches missed.">        || (isRed(h)  &amp;&amp; !isLeftRed(h) &amp;&amp; !isRightRed(h));</span>
        
        /*
        h.color = !h.color;
        h.left.color = !h.left.color;
        h.right.color = !h.right.color;
        */
<span class="fc" id="L921">        int clr = nodeMap.getNodeColor(h);</span>
<span class="fc" id="L922">        clr ^= 1;</span>
<span class="fc" id="L923">        nodeMap.updateNodeColor(h, clr);</span>
        
<span class="fc" id="L925">        clr = nodeMap.getNodeColor(nodeMap.getLeft(h));</span>
<span class="fc" id="L926">        clr ^= 1;</span>
<span class="fc" id="L927">        nodeMap.updateNodeColor(nodeMap.getLeft(h), clr);</span>
        
<span class="fc" id="L929">        clr = nodeMap.getNodeColor(nodeMap.getRight(h));</span>
<span class="fc" id="L930">        clr ^= 1;</span>
<span class="fc" id="L931">        nodeMap.updateNodeColor(nodeMap.getRight(h), clr);</span>
<span class="fc" id="L932">    }</span>

    // Assuming that h is red and both h.left and h.left.left
    // are black, make h.left or one of its children red.
    protected long moveRedLeft(long h) {
<span class="pc bnc" id="L937" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L938" title="All 6 branches missed.">        assert(isRed(h) &amp;&amp; !isLeftRed(h) &amp;&amp; !isLeftLeftRed(h));</span>

        //System.out.println(&quot;moveRedLeft &quot; + nodeToString(h));
        
<span class="fc" id="L942">        flipColors(h);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (isRightLeftRed(h)) {</span>
            //h.right = rotateRight(h.right);
<span class="fc" id="L945">            long rKey = rotateRight(nodeMap.getRight(h));</span>
<span class="fc" id="L946">            nodeMap.updateRight(h, rKey);</span>
<span class="fc" id="L947">            nodeMap.updateParent(rKey, h);</span>
<span class="fc" id="L948">            h = rotateLeft(h);</span>
<span class="fc" id="L949">            flipColors(h);</span>
        }
<span class="fc" id="L951">        return h;</span>
    }

    //move red node down the right spine of the tree
    // Assuming that h is red and both h.right and h.right.left
    // are black, make h.right or one of its children red.
    private long moveRedRight(long h) {
<span class="pc bnc" id="L958" title="All 2 branches missed.">        assert (nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L959" title="All 6 branches missed.">        assert(isRed(h) &amp;&amp; !isRightRed(h) &amp;&amp; !isRightLeftRed(h));</span>
        
<span class="fc" id="L961">        flipColors(h);</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">        if (isLeftLeftRed(h)) { </span>
<span class="fc" id="L963">            h = rotateRight(h);</span>
<span class="fc" id="L964">            flipColors(h);</span>
        }
        
        //System.out.println(&quot;after moveRedRight h=&quot; + nodeToString(h));
        //printPreOrderTraversal();
        
<span class="fc" id="L970">        return h;</span>
    }

    // restore red-black tree invariant
    private long balance(long h) {
        
        //System.out.println(&quot;balance &quot; + nodeToString(h));
        
<span class="pc bnc" id="L978" title="All 2 branches missed.">        assert (nodeMap.containsKey(h));</span>

<span class="fc bfc" id="L980" title="All 2 branches covered.">        if (isRightRed(h))   {</span>
<span class="fc" id="L981">            h = rotateLeft(h);</span>
        }
<span class="fc bfc" id="L983" title="All 4 branches covered.">        if (isLeftRed(h) &amp;&amp; isLeftLeftRed(h)) {</span>
<span class="fc" id="L984">            h = rotateRight(h);</span>
        }
<span class="fc bfc" id="L986" title="All 4 branches covered.">        if (isLeftRed(h) &amp;&amp; isRightRed(h))  {</span>
<span class="fc" id="L987">            flipColors(h);</span>
        }

<span class="fc" id="L990">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L991">        nodeMap.updateNodeSize(h, size);</span>
        
<span class="fc" id="L993">        return h;</span>
    }


   /***************************************************************************
    *  Utility functions.
    ***************************************************************************/

    /**
     * Returns the height of the BST (for debugging).
     * @return the height of the BST (a 1-node tree has height 0)
     */
    public int height() {
<span class="nc" id="L1006">        return height(root);</span>
    }
    private int height(long x) {
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (!nodeMap.containsKey(x)) return -1;</span>
<span class="nc" id="L1010">        return 1 + Math.max(heightLeft(x), heightRight(x));</span>
    }
    private int heightLeft(long x) {
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (!nodeMap.leftIsSet(x)) return -1;</span>
<span class="nc" id="L1014">        return height(nodeMap.getLeft(x));</span>
    }
    private int heightRight(long x) {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (!nodeMap.rightIsSet(x)) return -1;</span>
<span class="nc" id="L1018">        return height(nodeMap.getRight(x));</span>
    }

   /***************************************************************************
    *  Ordered symbol table methods.
    ***************************************************************************/

    /**
     * Returns the smallest key in the symbol table.
     * @param output if output[0] == -1 no minimum was present,
     * else output[1] holds the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void min(long[] output) {
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;called min() with empty symbol table&quot;);</span>
<span class="fc" id="L1033">        output[0] = 0;</span>
<span class="fc" id="L1034">        min(root, output);</span>
<span class="fc" id="L1035">    }</span>

    // the smallest key in subtree rooted at x; null if no such key
    private void min(long x, long[] output) { 
        //assert(nodeMap.containsKey(x));
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1041">            output[0] = -1;</span>
<span class="nc" id="L1042">            return;</span>
        }
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        while (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1045">            x = nodeMap.getLeft(x);</span>
        }
<span class="fc" id="L1047">        output[1] = x;</span>
<span class="fc" id="L1048">    }</span>

    /**
     * Returns the largest key in the symbol table.
     * @param output if output[0] == -1 no minimum was present,
     * else output[1] holds the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void max(long[] output) {
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;called max() with empty symbol table&quot;);</span>
<span class="fc" id="L1058">        output[0] = 0;</span>
<span class="fc" id="L1059">        max(root, output);</span>
<span class="fc" id="L1060">    } </span>

    // the largest key in the subtree rooted at x; null if no such key
    private void max(long x, long[] output) { 
        //assert(nodeMap.containsKey(x));
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1066">            output[0] = -1;</span>
<span class="nc" id="L1067">            return;</span>
        }
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        while (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1070">            x = nodeMap.getRight(x);</span>
        }
<span class="fc" id="L1072">        output[1] = x;</span>
<span class="fc" id="L1073">    }</span>

    /**
     * Returns the largest key in the symbol table less than or equal to {@code key}.
     * @param key the key
     * @param output if output[0] == -1, the key was not present, 
     * else output[1] holds the largest key in the symbol table less than or equal to {@code key}
     @throws NoSuchElementException if the tree is empty
     */
    public void floor(long key, long[] output) {
<span class="pc bpc" id="L1083" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1084">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1087">            output[0] = -1;</span>
<span class="nc" id="L1088">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1090">        floor(root, key, output);</span>
<span class="fc" id="L1091">    }    </span>

    /**
     * Returns the largest key in the symbol table less than {@code key}.
     * @param key the key
     * @param output if output[0] == -1, the key was not present, 
     * else output[1] holds the largest key in the symbol table less than or equal to {@code key}
     @throws NoSuchElementException if the tree is empty
     */
    public void lower(long key, long[] output) {
<span class="pc bpc" id="L1101" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1102">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1105">            output[0] = -1;</span>
<span class="nc" id="L1106">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1108">        TLongList stack = new TLongArrayList();</span>
<span class="fc" id="L1109">        output[0] = 0;</span>
<span class="fc" id="L1110">        lower(root, key, stack, output);</span>
<span class="fc" id="L1111">    }    </span>
    
    // the largest key in the subtree rooted at x less than or equal to the given key
    private void floor(long x, long key, long[] output) {
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1116">            output[0] = -1;</span>
<span class="nc" id="L1117">            return;</span>
        }
<span class="fc" id="L1119">        output[0] = 0;</span>
<span class="pc bpc" id="L1120" title="1 of 4 branches missed.">        int cmp = (key &lt; x) ? -1 : (key &gt; x) ? 1 : 0;</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        if (cmp == 0) {</span>
<span class="nc" id="L1122">            output[1] = x;</span>
<span class="nc" id="L1123">            return;</span>
        }
<span class="fc bfc" id="L1125" title="All 2 branches covered.">        if (cmp &lt; 0)  {</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1127">                floor(nodeMap.getLeft(x), key, output);</span>
<span class="fc" id="L1128">                return;</span>
            }
<span class="fc" id="L1130">            output[0] = -1;</span>
<span class="fc" id="L1131">            return;</span>
        }
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1134">            floor(nodeMap.getRight(x), key, output);</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">            if (output[0] == -1) {</span>
<span class="fc" id="L1136">                output[0] = 0;</span>
<span class="fc" id="L1137">                output[1] = x;</span>
            }
<span class="fc" id="L1139">            return;</span>
        }
<span class="fc" id="L1141">        output[0] = 0;</span>
<span class="fc" id="L1142">        output[1] = x;</span>
<span class="fc" id="L1143">    }</span>
    
    /** the largest key in the subtree rooted at x less than the given key
     * 
     * The method is symmetric t the successor method called 
     * higher, as suggested by Cormen, Leiserson, Rivest, and Stein in
     * the book &quot;Introduction to Algorithms&quot;.
     * 
     * @param x
     * @param key
     * @param stack
     * @return 
     */
    private void lower(long x, long key, TLongList stack, long[] output) { 
       
        //binary search until overshoot
<span class="fc" id="L1159">        long maxLower = Long.MAX_VALUE;</span>
<span class="pc bpc" id="L1160" title="1 of 4 branches missed.">        while (nodeMap.containsKey(x) &amp;&amp; key != x) {</span>
<span class="fc" id="L1161">            stack.add(x);</span>
            //System.out.println(&quot;lower: x=&quot; + x + &quot; q=&quot; + key);
<span class="fc bfc" id="L1163" title="All 2 branches covered.">            if (x &lt; key) {</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">                if (maxLower == Long.MAX_VALUE) {</span>
<span class="fc" id="L1165">                    maxLower = x;</span>
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">                } else if (x &gt; maxLower) {</span>
<span class="fc" id="L1167">                    maxLower = x;</span>
                }
            }
<span class="fc bfc" id="L1170" title="All 2 branches covered.">            if (key &lt; x) {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1172">                    break;</span>
                }
<span class="fc" id="L1174">                x = nodeMap.getLeft(x);</span>
            } else {
                //System.out.println(&quot;   x=&quot; + x.key);
<span class="fc bfc" id="L1177" title="All 2 branches covered.">                if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1178">                    break;</span>
                }
<span class="fc" id="L1180">                x = nodeMap.getRight(x);</span>
            }
        }
        
<span class="fc" id="L1184">        long y = -1;</span>
<span class="fc" id="L1185">        int yIdx = -1;</span>
<span class="fc" id="L1186">        boolean yIsSet = false;</span>
        
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (stack.size() &gt; 1) {</span>
<span class="nc" id="L1190">                x = stack.get(stack.size() - 1);</span>
<span class="nc" id="L1191">                yIdx = stack.size() - 2;</span>
<span class="nc" id="L1192">                y = stack.get(yIdx);</span>
<span class="nc" id="L1193">                yIsSet = true;</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            } else if (stack.size() == 1) {</span>
<span class="nc" id="L1195">                x = stack.get(stack.size() - 1);</span>
            }
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        } else if (!stack.isEmpty()) {</span>
<span class="fc" id="L1198">            yIdx = stack.size() - 1;</span>
<span class="fc" id="L1199">            y = stack.get(yIdx);</span>
<span class="fc" id="L1200">            yIsSet = true;</span>
        }
        
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1204">            max(nodeMap.getLeft(x), output);</span>
<span class="fc" id="L1205">            return;</span>
        }
      
        //while (y != null &amp;&amp; x == y.left) {
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        while (yIsSet &amp;&amp; </span>
            (
<span class="pc bpc" id="L1211" title="1 of 4 branches missed.">            (nodeMap.leftIsSet(y) &amp;&amp; nodeMap.containsKey(x) &amp;&amp;</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">            nodeMap.getLeft(y) == nodeMap.getNodeValue(x)) </span>
            || 
<span class="pc bpc" id="L1214" title="1 of 4 branches missed.">            (!nodeMap.leftIsSet(y) &amp;&amp; !nodeMap.containsKey(x))</span>
            )
            ) {
            
            //System.out.println(&quot;lower: y=&quot; + y.key + &quot; q=&quot; + key);
<span class="fc" id="L1219">            x = y;</span>
<span class="fc" id="L1220">            yIdx--;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            if (yIdx &lt; 0) break;</span>
<span class="fc" id="L1222">            y = stack.get(yIdx);</span>
<span class="fc" id="L1223">            yIsSet = true;</span>
        }
        
        //System.out.println(&quot;    y=&quot; + y.key + &quot; q=&quot; + key);
<span class="pc bpc" id="L1227" title="1 of 4 branches missed.">        if (yIsSet &amp;&amp; y &gt;= key) {</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">            if (maxLower &lt; Long.MAX_VALUE) {</span>
<span class="fc" id="L1229">                output[1] = maxLower;</span>
<span class="fc" id="L1230">                return;</span>
            }
<span class="fc" id="L1232">            output[0] = -1;</span>
<span class="fc" id="L1233">            return;</span>
        }
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">        if (yIsSet) {</span>
<span class="fc" id="L1236">            output[0] = 0;</span>
<span class="fc" id="L1237">            output[1] = y;</span>
        } else {
<span class="nc" id="L1239">            output[0] = -1;</span>
        }
<span class="fc" id="L1241">    }</span>

    /**
     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
     * @param key the key
     * @param output if output[0] == -1, the key was not present, 
     * else output[1] holds
     * the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if the tree is empty
     */
    public void ceiling(long key, long[] output) {
<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1253">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1256">            output[0] = -1;</span>
<span class="nc" id="L1257">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1259">        output[0] = 0;</span>
<span class="fc" id="L1260">        ceiling(root, key, output);</span>
<span class="fc" id="L1261">    }</span>

    /**
     * Returns the smallest key in the symbol table greater than {@code key}.
     * @param key the key
     * @param output if output[0] == -1, the key was not present, 
     * else output[1] holds
     * the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if the tree is empty
     */
    public void higher(long key, final long[] output) {
<span class="pc bpc" id="L1272" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1273">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1276">            output[0] = -1;</span>
<span class="nc" id="L1277">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1279">        higher(root, key, output);</span>
<span class="fc" id="L1280">    }</span>
    
    // the smallest key in the subtree rooted at x greater than or equal to the given key
    private void ceiling(long x, long key, long[] output) {
        
        //TODO: make this iterative
        
<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1288">            output[0] = -1;</span>
<span class="nc" id="L1289">            return;</span>
        }
<span class="fc" id="L1291">        output[0] = 0;</span>
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">        int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">        if (cmp == 0) {</span>
<span class="nc" id="L1294">            output[1] = x;</span>
<span class="nc" id="L1295">            return;</span>
        }
<span class="fc bfc" id="L1297" title="All 2 branches covered.">        if (cmp &gt; 0)  {</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1299">                ceiling(nodeMap.getRight(x), key, output);</span>
            } else {
<span class="fc" id="L1301">                output[0] = -1;</span>
            }
<span class="fc" id="L1303">            return;</span>
        }
        /*
        Node t = ceiling(x.left, key);
        if (t != null) {
            return t;
        } else {
            return x;
        }*/
<span class="fc bfc" id="L1312" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1313">            ceiling(nodeMap.getLeft(x), key, output);</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">            if (output[0] == -1) {</span>
<span class="fc" id="L1315">                output[0] = 0;</span>
<span class="fc" id="L1316">                output[1] = x;</span>
            }
        } else {
<span class="fc" id="L1319">            output[0] = 0;</span>
<span class="fc" id="L1320">            output[1] = x;</span>
        }
<span class="fc" id="L1322">    }</span>
    
    /** the smallest key in the subtree rooted at x greater than the given key.
     * 
     * NOTE: the method uses in part, a pattern adapted from the Cormen, Leiserson, Rivest, and Stein
     * book &quot;Introduction to Algorithms&quot; for their Red Black Tree.
     * 
     * @param x
     * @param key
     * @return 
     */
    private void higher(long x, long key, final long[] output) {  
        
        //System.out.println(&quot;higher: x=&quot; + x + &quot; key=&quot; + key);
        
        /*
                    X
        left .lte.     right .gte.
        */
        
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L1343" title="All 4 branches covered.">            int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
            //System.out.println(&quot;higher: x=&quot; + x + &quot; cmp=&quot; + cmp);
<span class="fc bfc" id="L1345" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">                if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1347">                    x = nodeMap.getLeft(x);</span>
                } else {
                    break;
                }
<span class="fc bfc" id="L1351" title="All 2 branches covered.">            } else if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">                if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1353">                    x = nodeMap.getRight(x);</span>
                } else {
                    break;
                }
            } else {
                break;
            }
<span class="fc" id="L1360">        }</span>
                
        // right node has larger key
<span class="fc bfc" id="L1363" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1364">            output[0] = 0;</span>
<span class="fc" id="L1365">            min(nodeMap.getRight(x), output);</span>
            //System.out.println(&quot;min=&quot; + Arrays.toString(output));
<span class="fc" id="L1367">            return;</span>
        }
<span class="fc" id="L1369">        boolean yIsSet = false;</span>
<span class="fc" id="L1370">        long y = -1;</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">        if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L1372">            y = nodeMap.getParent(x);</span>
<span class="fc" id="L1373">            yIsSet = true;</span>
            //System.out.println(&quot;y=&quot; + y);
        }
<span class="fc bfc" id="L1376" title="All 4 branches covered.">        while (yIsSet &amp;&amp; nodeMap.rightIsSet(y) &amp;&amp;</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">            x == nodeMap.getRight(y)) {</span>
            //System.out.println(&quot;y=&quot; + y + &quot; setting x=&quot; + x + &quot; to y&quot;);
<span class="fc" id="L1379">            x = y;</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L1381">                y = nodeMap.getParent(x);</span>
            } else {
<span class="fc" id="L1383">                yIsSet = false;</span>
<span class="fc" id="L1384">                y = -1;</span>
            }
        }
<span class="pc bpc" id="L1387" title="2 of 6 branches missed.">        if (x &gt; key &amp;&amp; yIsSet &amp;&amp; y &gt; key) {</span>
<span class="fc" id="L1388">            output[0] = 0;</span>
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">            if (x &lt; y) {</span>
<span class="fc" id="L1390">                output[1] = x;</span>
            } else {
<span class="nc" id="L1392">                output[1] = y;</span>
            }
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">        } else if (x &gt; key) {</span>
<span class="nc" id="L1395">            output[0] = 0;</span>
<span class="nc" id="L1396">            output[1] = x;</span>
<span class="pc bpc" id="L1397" title="1 of 4 branches missed.">        } else if (yIsSet &amp;&amp; y &gt; key) {</span>
<span class="fc" id="L1398">            output[0] = 0;</span>
<span class="fc" id="L1399">            output[1] = y;</span>
        } else {
<span class="fc" id="L1401">            output[0] = -1;</span>
        }
<span class="fc" id="L1403">    }</span>

    /**
     * Return the kth smallest key in the symbol table.
     * @param k the order statistic
     * @return the {@code k}th smallest key in the symbol table
     * @throws IllegalArgumentException unless {@code k} is between 0 and
     *     &lt;em&gt;n&lt;/em&gt;â€“1
     */
    public long select(int k) {
<span class="pc bpc" id="L1413" title="2 of 4 branches missed.">        if (k &lt; 0 || k &gt;= size()) {</span>
<span class="nc" id="L1414">            throw new IllegalArgumentException(&quot;called select() with invalid argument: &quot; + k);</span>
        }
<span class="fc" id="L1416">        long[] output = new long[2];</span>
<span class="fc" id="L1417">        select(root, k, output);</span>
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L1419">            return -1;</span>
        }
<span class="fc" id="L1421">        return output[1];</span>
    }

    // the key of rank k in the subtree rooted at x
    private void select(long x, int k, long[] output) {
        
        //TODO: make this iterative
        
<span class="pc bnc" id="L1429" title="All 2 branches missed.">        assert(nodeMap.containsKey(x));</span>
<span class="pc bnc" id="L1430" title="All 4 branches missed.">        assert(k &gt;= 0 &amp;&amp; k &lt; size(x));</span>
        
<span class="fc" id="L1432">        output[0] = 0;</span>
        
<span class="fc" id="L1434">        int t = sizeLeft(x); </span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (t &gt; k) {</span>
<span class="fc" id="L1436">            select(nodeMap.getLeft(x),  k, output);</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">        } else if (t &lt; k) {</span>
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1439">                select(nodeMap.getRight(x), k-t-1, output);</span>
            } else {
<span class="nc" id="L1441">                output[0] = -1;</span>
            }
        } else {
<span class="fc" id="L1444">            output[1] = x;</span>
        }
<span class="fc" id="L1446">    } </span>

    /**
     * Return the number of keys in the symbol table strictly less than {@code key}.
     * @param key the key
     * @return the number of keys in the symbol table strictly less than {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public int rank(long key) {
<span class="fc" id="L1455">        int[] output = new int[2];</span>
<span class="fc" id="L1456">        rank(key, root, output);</span>
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L1458">            return 0;</span>
        }
<span class="fc" id="L1460">        return output[1];</span>
    } 

    // number of keys less than key in the subtree rooted at x
    private void rank(long key, long x, int[] output) {
        
        //TODO: make this iterative
<span class="fc" id="L1467">        output[0] = 0;</span>
        
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1470">            output[1] = 0;</span>
<span class="nc" id="L1471">            return;</span>
        } 
<span class="fc bfc" id="L1473" title="All 4 branches covered.">        int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0;  </span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        if (cmp &lt; 0) {</span>
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1476">                rank(key, nodeMap.getLeft(x), output);</span>
            } else {
<span class="nc" id="L1478">                output[1] = 0;</span>
            }
<span class="fc bfc" id="L1480" title="All 2 branches covered.">        } else if (cmp &gt; 0) {</span>
            //1 + size(x.left) + rank(key, x.right);
            int sz;
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1484">                output[0] = 0;</span>
<span class="fc" id="L1485">                rank(key, nodeMap.getRight(x), output);</span>
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">                if (output[0] == -1) {</span>
<span class="nc" id="L1487">                    sz = 1 + sizeLeft(x);</span>
                } else {
<span class="fc" id="L1489">                    sz = 1 + sizeLeft(x) + output[1];</span>
                }
            } else {
<span class="nc" id="L1492">                sz = 1 + sizeLeft(x);</span>
            }
<span class="fc" id="L1494">            output[1] = sz;</span>
<span class="fc" id="L1495">        } else {</span>
<span class="fc" id="L1496">            int sz = sizeLeft(x);</span>
<span class="fc" id="L1497">            output[1] = sz;</span>
        } 
<span class="fc" id="L1499">    } </span>

   /***************************************************************************
    *  Range count and range search.
    ***************************************************************************/

    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     * @return all keys in the symbol table as an {@code Iterable}
     */
    public TLongList keys() {
        
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">        if (isEmpty()) return new TLongArrayList();</span>
        
<span class="fc" id="L1515">        long[] output = new long[2];</span>
<span class="fc" id="L1516">        min(output);</span>
<span class="pc bnc" id="L1517" title="All 2 branches missed.">        assert(output[0] != -1);</span>
<span class="fc" id="L1518">        long lo = output[1];</span>
        
<span class="fc" id="L1520">        max(output);</span>
<span class="pc bnc" id="L1521" title="All 2 branches missed.">        assert(output[0] != -1);</span>
<span class="fc" id="L1522">        long hi = output[1];</span>
        
<span class="fc" id="L1524">        return keys(lo, hi);</span>
    }

    /**
     * Returns all keys in the symbol table in the given range,
     * as an {@code Iterable}.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return all keys in the sybol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive) as an {@code Iterable}
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */
    public TLongList keys(long lo, long hi) {

<span class="fc" id="L1540">        TLongList queue = new TLongArrayList();</span>
<span class="pc bpc" id="L1541" title="2 of 4 branches missed.">        if (isEmpty() || lo &gt; hi) return queue;</span>
        
<span class="fc" id="L1543">        keys(root, queue, lo, hi);</span>
        
<span class="fc" id="L1545">        return queue;</span>
    } 

    // add the keys between lo and hi in the subtree rooted at x
    // to the queue
    private void keys(long x, TLongList queue, long lo, long hi) {
        
        //TODO: make this iterative
        
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1555">            return;</span>
        } 
<span class="pc bpc" id="L1557" title="1 of 4 branches missed.">        int cmplo = lo &lt; x ? -1 : (lo &gt; x) ? 1 : 0;</span>
<span class="pc bpc" id="L1558" title="1 of 4 branches missed.">        int cmphi = hi &lt; x ? -1 : (hi &gt; x) ? 1 : 0; </span>
<span class="fc bfc" id="L1559" title="All 2 branches covered.">        if (cmplo &lt; 0) {</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1561">                keys(nodeMap.getLeft(x), queue, lo, hi);</span>
            }
        } 
<span class="pc bpc" id="L1564" title="2 of 4 branches missed.">        if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) {</span>
<span class="fc" id="L1565">            queue.add(x);</span>
        } 
<span class="fc bfc" id="L1567" title="All 2 branches covered.">        if (cmphi &gt; 0) {</span>
<span class="fc bfc" id="L1568" title="All 2 branches covered.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1569">                keys(nodeMap.getRight(x), queue, lo, hi);</span>
            }
        } 
<span class="fc" id="L1572">    } </span>

    /**
     * Returns the number of keys in the symbol table in the given range.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return the number of keys in the sybol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */
    public int size(long lo, long hi) {

<span class="nc bnc" id="L1586" title="All 2 branches missed.">        if (lo &gt; hi) return 0;</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if (contains(hi)) return rank(hi) - rank(lo) + 1;</span>
<span class="nc" id="L1588">        else              return rank(hi) - rank(lo);</span>
    }


   /***************************************************************************
    *  Check integrity of red-black tree data structure.
    ***************************************************************************/
    protected boolean check() {
<span class="fc" id="L1596">        boolean t1 = isParentChildConsistent();</span>
<span class="fc" id="L1597">        boolean t2 = isBST();</span>
<span class="fc" id="L1598">        boolean t3 = isSizeConsistent();</span>
<span class="fc" id="L1599">        boolean t4 = isRankConsistent();</span>
<span class="fc" id="L1600">        boolean t5 = is23();</span>
<span class="fc" id="L1601">        boolean t6 = isBalanced();</span>
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">        if (!t1) System.out.println(&quot;Not consistent parent child relationships&quot;);</span>
<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">        if (!t2) System.out.println(&quot;Not in symmetric order&quot;);</span>
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">        if (!t3) System.out.println(&quot;Subtree counts not consistent&quot;);</span>
<span class="pc bpc" id="L1605" title="1 of 2 branches missed.">        if (!t4) System.out.println(&quot;Ranks not consistent&quot;);</span>
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">        if (!t5) System.out.println(&quot;Not a 2-3 tree&quot;);</span>
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">        if (!t6) System.out.println(&quot;Not balanced&quot;);</span>
<span class="fc" id="L1608">        System.out.flush();</span>
<span class="pc bpc" id="L1609" title="6 of 12 branches missed.">        return t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t6;</span>
    }

    // does this binary tree satisfy symmetric order?
    // Note: this test also ensures that data structure is a binary tree since order is strict
    private boolean isBST() {
<span class="fc" id="L1615">        return isBST(root, null, null);</span>
    }

    // is the tree rooted at x a BST with all keys strictly between min and max
    // (if min or max is null, treat as empty constraint)
    // Credit: Bob Dondero's elegant solution
    private boolean isBST(long x, Long min, Long max) {
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1623">            return true;</span>
        }
<span class="pc bpc" id="L1625" title="1 of 4 branches missed.">        if (min != null &amp;&amp; x &lt;= min.longValue()) {</span>
<span class="nc" id="L1626">            return false;</span>
        }
<span class="pc bpc" id="L1628" title="1 of 4 branches missed.">        if (max != null &amp;&amp; x &gt;= max.longValue()) {</span>
<span class="nc" id="L1629">            return false;</span>
        }
<span class="fc" id="L1631">        Long key = Long.valueOf(x);</span>
<span class="pc bpc" id="L1632" title="2 of 4 branches missed.">        return isBSTLeft(x, min, key) &amp;&amp; isBSTRight(x, key, max);</span>
    }
    private boolean isBSTLeft(long x, Long min, Long max) {
<span class="fc bfc" id="L1635" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1636">            return true;</span>
        }
<span class="fc" id="L1638">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1639">        return isBST(key, min, max);</span>
    }
    private boolean isBSTRight(long x, Long min, Long max) {
<span class="fc bfc" id="L1642" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1643">            return true;</span>
        }
<span class="fc" id="L1645">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1646">        return isBST(key, min, max);</span>
    }

<span class="fc" id="L1649">    private boolean isSizeConsistent() { return isSizeConsistent(root); }</span>
    private boolean isSizeConsistent(long x) {
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return true;</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">        if (nodeMap.getNodeSize(x) != sizeLeft(x) + sizeRight(x) + 1) return false;</span>
<span class="pc bpc" id="L1653" title="2 of 4 branches missed.">        return isSizeConsistentLeft(x) &amp;&amp; isSizeConsistentRight(x);</span>
    }
    private boolean isSizeConsistentLeft(long x) {
<span class="fc bfc" id="L1656" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return true;</span>
<span class="fc" id="L1657">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1658">        return isSizeConsistent(key);</span>
    }
    private boolean isSizeConsistentRight(long x) {
<span class="fc bfc" id="L1661" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return true;</span>
<span class="fc" id="L1662">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1663">        return isSizeConsistent(key);</span>
    }

    // check that ranks are consistent
    private boolean isRankConsistent() {
<span class="fc bfc" id="L1668" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++) {</span>
<span class="fc" id="L1669">            int r = rank(select(i));</span>
            //System.out.println(&quot;i=&quot; + i + &quot; r=&quot; + r + &quot; size=&quot; + size());
<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">            if (i != r) return false;</span>
        }
<span class="fc" id="L1673">        TLongList keys = keys();</span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.size(); ++i) {</span>
<span class="fc" id="L1675">            long key = keys.get(i);</span>
<span class="fc" id="L1676">            int r = rank(key);</span>
<span class="fc" id="L1677">            long s = select(r);</span>
            //System.out.println(&quot;i=&quot; + i + &quot; key=&quot; + key + &quot; r=&quot; + r + &quot; s=&quot; + s);
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">            if (key != s) {</span>
<span class="nc" id="L1680">                return false;</span>
            }
        }
<span class="fc" id="L1683">        return true;</span>
    }

    // Does the tree have no red right links, and at most one (left)
    // red links in a row on any path?
<span class="fc" id="L1688">    private boolean is23() { return is23(root); }</span>
    private boolean is23(long x) {
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1691">            return true;</span>
        }
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">        if (isRightRed(x)) {</span>
<span class="nc" id="L1694">            return false;</span>
        }
<span class="pc bpc" id="L1696" title="1 of 6 branches missed.">        if (x != root &amp;&amp; isRed(x) &amp;&amp; isLeftRed(x)) {</span>
<span class="nc" id="L1697">            return false;</span>
        }
<span class="pc bpc" id="L1699" title="2 of 4 branches missed.">        return is23Left(x) &amp;&amp; is23Right(x);</span>
    }
    private boolean is23Left(long x) {
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return true;</span>
<span class="fc" id="L1703">        return is23(nodeMap.getLeft(x));</span>
    }
    private boolean is23Right(long x) {
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return true;</span>
<span class="fc" id="L1707">        return is23(nodeMap.getRight(x));</span>
    }

    // do all paths from root to leaf have same number of black edges?
    private boolean isBalanced() { 
<span class="pc bpc" id="L1712" title="1 of 2 branches missed.">        if (!rootIsSet) {</span>
<span class="nc" id="L1713">            return true;</span>
        }
<span class="fc" id="L1715">        int black = 0;     // number of black links on path from root to min</span>
<span class="fc" id="L1716">        long x = root;</span>
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">            if (!isRed(x)) {</span>
<span class="fc" id="L1719">                black++;</span>
            }
<span class="fc bfc" id="L1721" title="All 2 branches covered.">            if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1722">                break;</span>
            }
<span class="fc" id="L1724">            x = nodeMap.getLeft(x);</span>
        }
<span class="fc" id="L1726">        return isBalanced(root, black);</span>
    }

    // does every path from the root to a leaf have the given number of black links?
    private boolean isBalanced(long x, int black) {
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">            return black == 0;</span>
        }
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        if (!isRed(x)) {</span>
<span class="fc" id="L1735">            black--;</span>
        }
<span class="pc bpc" id="L1737" title="2 of 4 branches missed.">        return isLeftBalanced(x, black) &amp;&amp; isRightBalanced(x, black);</span>
    }
    private boolean isLeftBalanced(long x, int black) {
<span class="fc bfc" id="L1740" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">            return black == 0;</span>
        }
<span class="fc" id="L1743">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1744">        return isBalanced(key, black);</span>
    } 
    private boolean isRightBalanced(long x, int black) {
<span class="fc bfc" id="L1747" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">            return black == 0;</span>
        }
<span class="fc" id="L1750">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1751">        return isBalanced(key, black);</span>
    } 
    
    /**
     * left subtree, root, right subtree
     */
    public void printInOrderTraversal() {
<span class="fc" id="L1758">        System.out.print(&quot;root=&quot;);</span>
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">        if (rootIsSet) {</span>
<span class="fc" id="L1760">            System.out.print(root);</span>
        }
<span class="fc" id="L1762">        System.out.println(&quot;&quot;);</span>
<span class="fc" id="L1763">        long[] nodes = getInOrderTraversalIterative(root);</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1765">            System.out.println(&quot;node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1767">    }</span>
    
    /**
     * root, left subtree, right subtree
     */
    public void printPreOrderTraversal() {
<span class="fc" id="L1773">        System.out.print(&quot;root=&quot;);</span>
<span class="pc bpc" id="L1774" title="1 of 2 branches missed.">        if (rootIsSet) {</span>
<span class="fc" id="L1775">            System.out.print(root);</span>
        }
<span class="fc" id="L1777">        System.out.println(&quot; size=&quot; + size());</span>
<span class="fc" id="L1778">        long[] nodes = getPreOrderTraversalIterative(root, 1);</span>
<span class="fc bfc" id="L1779" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1780">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1782">    }</span>
    public void printPreOrderTraversal2(long topNode) {
<span class="nc" id="L1784">        System.out.print(&quot;root=&quot;);</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">        if (rootIsSet) {</span>
<span class="nc" id="L1786">            System.out.print(root);</span>
        }
<span class="nc" id="L1788">        System.out.println(&quot; size=&quot; + size());</span>
<span class="nc" id="L1789">        long[] nodes = getPreOrderTraversalIterative(topNode, 1);</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        for (long node : nodes) {</span>
<span class="nc" id="L1791">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="nc" id="L1793">    }</span>
    private void printPreOrderTraversal(int addExtraToSize) {
<span class="nc" id="L1795">        long[] nodes = getPreOrderTraversalIterative(root, </span>
            addExtraToSize);
<span class="nc" id="L1797">        System.out.print(&quot;root=&quot;);</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">        if (rootIsSet) {</span>
<span class="nc" id="L1799">            System.out.print(root);</span>
        }
<span class="nc" id="L1801">        System.out.println(&quot;&quot;);</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">        for (long node : nodes) {</span>
<span class="nc" id="L1803">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="nc" id="L1805">    }</span>
    
    /**
     * left subtree, right subtree, root subtree
     */
    public void printPostOrderTraversal() {
<span class="fc" id="L1811">        long[] nodes = getPostOrderTraversalIterative(root);</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1813">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1815">    }</span>

    /**
     * visit each node using pattern left subtree, root, right subtree
     * in an iterative manner rather than invoking the method recursively.
     */
    protected long[] getInOrderTraversalIterative(Long node) {
       
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1824">            return new long[0];</span>
        }
        
<span class="fc" id="L1827">        int sz = size();</span>
        
<span class="fc" id="L1829">        long[] array = new long[sz];</span>
<span class="fc" id="L1830">        int count = 0;</span>
        
<span class="fc" id="L1832">        Stack&lt;Long&gt; stack = new Stack&lt;&gt;();</span>
               
<span class="fc bfc" id="L1834" title="All 4 branches covered.">        while (!stack.isEmpty() || (node != null)) {</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">            if (node != null) {</span>
                 
<span class="fc" id="L1837">                stack.push(node);</span>
                
<span class="fc bfc" id="L1839" title="All 2 branches covered.">                node = nodeMap.leftIsSet(node.longValue()) ?</span>
<span class="fc" id="L1840">                    nodeMap.getLeft(node.longValue()) : null;</span>
            
<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">            } else if (count &lt; sz) {</span>
                
<span class="fc" id="L1844">                node = stack.pop();</span>
                
<span class="fc" id="L1846">                array[count] = node;</span>
<span class="fc" id="L1847">                count++;</span>
                
                //System.out.println(node.key);
                
<span class="fc bfc" id="L1851" title="All 2 branches covered.">                node = nodeMap.rightIsSet(node.longValue()) ?</span>
<span class="fc" id="L1852">                    nodeMap.getRight(node.longValue()) : null;</span>
            }
        }
<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">        if (count &lt; sz) {</span>
            // can happen during debugging when insert is not complete yet
<span class="nc" id="L1857">            array = Arrays.copyOf(array, count);</span>
        }
        
<span class="fc" id="L1860">        return array;</span>
    }
    
    /**
     * visit each node using pattern: 
     *     root, left subtree, right subtree
     * in an iterative manner rather than invoking the method recursively.
     */
    protected long[] getPreOrderTraversalIterative(Long node, int addExtraToSize) {
       
        //NOTE: added additional integer and conditions 
        //   for size because may be printing tree
        //   in the middle of a put where the node size is not yet updated.
        // The count conditionals below are otherwise, not needed.
        
<span class="pc bpc" id="L1875" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1876">            return new long[0];</span>
        }
                
<span class="fc" id="L1879">        int sz = size(node) + addExtraToSize;</span>
        
<span class="fc" id="L1881">        long[] array = new long[sz];</span>
<span class="fc" id="L1882">        int count = 0;</span>
        
<span class="fc" id="L1884">        Stack&lt;Long&gt; stack = new Stack&lt;&gt;();</span>
        
<span class="fc bfc" id="L1886" title="All 6 branches covered.">        while (count &lt; sz &amp;&amp; (!stack.isEmpty() || node != null)) {</span>
<span class="pc bpc" id="L1887" title="1 of 4 branches missed.">            if (node != null &amp;&amp; count &lt; sz) {</span>
                
<span class="fc" id="L1889">                array[count] = node;</span>
<span class="fc" id="L1890">                count++;</span>
                //System.out.println(node);
                
<span class="fc bfc" id="L1893" title="All 2 branches covered.">                if (count &lt; sz) {</span>
<span class="fc" id="L1894">                    stack.push(node);</span>
                }
                
<span class="fc bfc" id="L1897" title="All 2 branches covered.">                node = nodeMap.leftIsSet(node.longValue()) ?</span>
<span class="fc" id="L1898">                    nodeMap.getLeft(node.longValue()) : null;</span>
            
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">            } else if (count &lt; sz) {</span>
                
<span class="fc" id="L1902">                node = stack.pop();</span>
                
<span class="fc bfc" id="L1904" title="All 2 branches covered.">                node = nodeMap.rightIsSet(node.longValue()) ?</span>
<span class="fc" id="L1905">                    nodeMap.getRight(node.longValue()) : null;</span>
            }
        }
        
<span class="fc bfc" id="L1909" title="All 2 branches covered.">        if (count &lt; sz) {</span>
<span class="fc" id="L1910">            array = Arrays.copyOf(array, count);</span>
        }
        
<span class="fc" id="L1913">        return array;</span>
    }

    /**
     * visit each node using pattern: 
     *     left subtree, right subtree, root subtree
     * in an iterative manner rather than invoking the method recursively.
     */
    protected long[] getPostOrderTraversalIterative(Long node) {
    
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1924">            return new long[0];</span>
        }
        
<span class="fc" id="L1927">        int sz = size();</span>
        
<span class="fc" id="L1929">        long[] array = new long[sz];</span>
<span class="fc" id="L1930">        int count = 0;</span>
        
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L1933">            return array;</span>
        }
        
<span class="fc" id="L1936">        Stack&lt;Long&gt; stack = new Stack&lt;Long&gt;();</span>
<span class="fc" id="L1937">        Stack&lt;Long&gt; stack2 = new Stack&lt;Long&gt;();</span>
<span class="fc" id="L1938">        stack.push(node);</span>
        
<span class="fc bfc" id="L1940" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
            
<span class="fc" id="L1942">            node = stack.pop();</span>
            
<span class="fc" id="L1944">            stack2.push(node);</span>
            
<span class="fc bfc" id="L1946" title="All 2 branches covered.">            if (nodeMap.leftIsSet(node.longValue())) {</span>
<span class="fc" id="L1947">                stack.push(nodeMap.getLeft(node.longValue()));</span>
            }

<span class="fc bfc" id="L1950" title="All 2 branches covered.">            if (nodeMap.rightIsSet(node.longValue())) {</span>
<span class="fc" id="L1951">                stack.push(nodeMap.getRight(node.longValue()));</span>
            }
        }
        
<span class="pc bpc" id="L1955" title="1 of 4 branches missed.">        while (!stack2.isEmpty() &amp;&amp; count &lt; sz) {</span>
            
<span class="fc" id="L1957">            node = stack2.pop();</span>
            
            //process(node);
<span class="fc" id="L1960">            array[count] = node;</span>
<span class="fc" id="L1961">            count++;</span>
            //System.out.println(node);
        }
        
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">        if (count &lt; sz) {</span>
            // can happen during debugging when insert is not complete yet
<span class="nc" id="L1967">            array = Arrays.copyOf(array, count);</span>
        }
         
<span class="fc" id="L1970">        return array;</span>
    }
   
    /**
    visit each node using pattern root node, then all direct children of root node (=level 2),
    then all direct children of those children (=level 3), etc
    in an iterative manner.
    */
    protected long[] getLevelOrderTraversalIterative(Long node) {
<span class="nc bnc" id="L1979" title="All 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1980">            return new long[0];</span>
        }
        
<span class="nc" id="L1983">        int sz = size();</span>
        
<span class="nc" id="L1985">        long[] array = new long[sz];</span>
<span class="nc" id="L1986">        int count = 0;</span>
        
<span class="nc bnc" id="L1988" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L1989">            return array;</span>
        }
        
        // can use stacks or queues interchangeably here, but if prefer 
        //   left to right norder, will want queues.
<span class="nc" id="L1994">        java.util.Queue&lt;Long&gt; level = new ArrayDeque&lt;Long&gt;();</span>
<span class="nc" id="L1995">        java.util.Queue&lt;Long&gt; nextLevel = new ArrayDeque&lt;Long&gt;();</span>
        
<span class="nc" id="L1997">        level.add(node);</span>
        
        while (true) {
<span class="nc bnc" id="L2000" title="All 2 branches missed.">            while (!level.isEmpty()) {</span>
<span class="nc" id="L2001">                node = level.poll();</span>
<span class="nc" id="L2002">                array[count] = node;</span>
<span class="nc" id="L2003">                count++;</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">                if (nodeMap.leftIsSet(node.longValue())) {</span>
<span class="nc" id="L2005">                    nextLevel.add(nodeMap.getLeft(node.longValue()));</span>
                }
<span class="nc bnc" id="L2007" title="All 2 branches missed.">                if (nodeMap.rightIsSet(node.longValue())) {</span>
<span class="nc" id="L2008">                    nextLevel.add(nodeMap.getRight(node.longValue()));</span>
                } 
            }
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (nextLevel.isEmpty()) {</span>
<span class="nc" id="L2012">                break;</span>
            }
<span class="nc" id="L2014">            level.addAll(nextLevel);</span>
<span class="nc" id="L2015">            nextLevel.clear();</span>
        }
                
<span class="nc" id="L2018">        return array;</span>
    }
    
    /**
     * estimate the size that an instance of RedBlackBSTLongInt with
     * n entries would occupy in heap space in Bytes.
     * 
     * @param numberOfEntries amount of space for this object's instance
     * with n entries in Bytes on the heap.
     * 
     * @return 
     */
    public static long estimateSizeOnHeap(int numberOfEntries) {
        
<span class="fc" id="L2032">        long total = 0;</span>
       
<span class="fc" id="L2034">        ObjectSpaceEstimator est = new ObjectSpaceEstimator();</span>
<span class="fc" id="L2035">        est.setNBooleanFields(1);</span>
<span class="fc" id="L2036">        est.setNLongFields(1);</span>
<span class="fc" id="L2037">        est.setNArrayRefsFields(1);</span>
<span class="fc" id="L2038">        est.setNIntFields(4);</span>
       
<span class="fc" id="L2040">        total += est.estimateSizeOnHeap();</span>
        
<span class="fc" id="L2042">        total += NodeMap.estimateSizeOnHeap(numberOfEntries);</span>
             
<span class="fc" id="L2044">        return total;</span>
    }
    
    private String nodeToString(long key) {
        //assert(nodeMap.containsKey(key));
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(key)) {</span>
            // this can happen in the middle of a method, for example,
            // when root has been removed and new is not yet assigned
<span class="nc" id="L2052">            System.out.println(&quot;ERROR: key &quot; + key + &quot; not in maps&quot;);</span>
<span class="nc" id="L2053">            return &quot;&quot;;</span>
        }
        
<span class="fc" id="L2056">        StringBuilder sb = new StringBuilder();</span>
        //node=key=0 val=0 color=false size=1
<span class="fc" id="L2058">        sb.append(&quot;key=&quot;).append(key).append(&quot; val=&quot;).append(nodeMap.getNodeValue(key));</span>
<span class="fc" id="L2059">        sb.append(&quot; color=&quot;).append(nodeMap.getNodeColor(key));</span>
<span class="fc" id="L2060">        sb.append(&quot; size=&quot;).append(nodeMap.getNodeSize(key));</span>
<span class="fc" id="L2061">        sb.append(&quot; p=&quot;);</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">        if (nodeMap.parentIsSet(key)) {</span>
<span class="fc" id="L2063">           sb.append(nodeMap.getParent(key));</span>
        }
<span class="fc" id="L2065">        sb.append(&quot; l=&quot;);</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">        if (nodeMap.leftIsSet(key)) {</span>
<span class="fc" id="L2067">           sb.append(nodeMap.getLeft(key));</span>
        }
<span class="fc" id="L2069">        sb.append(&quot; r=&quot;);</span>
<span class="fc bfc" id="L2070" title="All 2 branches covered.">        if (nodeMap.rightIsSet(key)) {</span>
<span class="fc" id="L2071">           sb.append(nodeMap.getRight(key));</span>
        }
<span class="fc" id="L2073">        return sb.toString();</span>
    }

    private boolean isParentChildConsistent() {
        
<span class="fc" id="L2078">        boolean passed = true;</span>
        
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">        if (!rootIsSet) {</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">            if (!nodeMap.isEmpty()) {</span>
<span class="nc" id="L2082">                System.err.println(&quot;maps not empty, but root is&quot;);</span>
<span class="nc" id="L2083">                passed = false;</span>
            }
        }
        
        //System.out.println(&quot;root=&quot; + nodeToString(root));
        
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">        if (nodeMap.parentIsSet(root)) {</span>
<span class="nc" id="L2090">            System.err.println(&quot;root should not have parent key&quot;);</span>
<span class="nc" id="L2091">            passed = false;</span>
        }
        
<span class="fc" id="L2094">        long[] nodes = getPreOrderTraversalIterative(root, 0);</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">        for (long key : nodes) {</span>
<span class="fc bfc" id="L2096" title="All 2 branches covered.">            if (nodeMap.leftIsSet(key)) {</span>
<span class="fc" id="L2097">                long child = nodeMap.getLeft(key);</span>
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">                if (!nodeMap.parentIsSet(child)) {</span>
<span class="nc" id="L2099">                    System.err.format(</span>
                        &quot;error in %d.left=%d has no parent\n&quot;,
<span class="nc" id="L2101">                        key, child);</span>
<span class="nc" id="L2102">                    passed = false;</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">                } else if (nodeMap.getParent(child) != key) {</span>
<span class="nc" id="L2104">                    System.err.format(</span>
                        &quot;error in left: %d.left=%d but %d.parent=%d\n&quot;,
<span class="nc" id="L2106">                        key, child, child, nodeMap.getParent(child));</span>
<span class="nc" id="L2107">                    passed = false;</span>
                }
            }
<span class="fc bfc" id="L2110" title="All 2 branches covered.">            if (nodeMap.rightIsSet(key)) {</span>
<span class="fc" id="L2111">                long child = nodeMap.getRight(key);</span>
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">                if (!nodeMap.parentIsSet(child)) {</span>
<span class="nc" id="L2113">                    System.err.format(</span>
                        &quot;error in %d.right=%d has no parent\n&quot;,
<span class="nc" id="L2115">                        key, child);</span>
<span class="nc" id="L2116">                    passed = false;</span>
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">                } else if (nodeMap.getParent(child) != key) {</span>
<span class="nc" id="L2118">                    System.err.format(</span>
                        &quot;error in right: %d.right=%d but %d.parent=%d\n&quot;,
<span class="nc" id="L2120">                        key, child, child, nodeMap.getParent(child));</span>
<span class="nc" id="L2121">                    passed = false;</span>
                }
            }
        }
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">        if (nodes.length != size()) {</span>
<span class="nc" id="L2126">            System.out.println(&quot;ERROR in nodes extraction&quot;);</span>
<span class="nc" id="L2127">            passed = false;</span>
        }
        
<span class="fc" id="L2130">        return passed;</span>
    }
    
    /**
     Print node and its left and right subtrees, but note that one can
     only print if the height and maxValue of the numbers fit into a line 
     limited to 100 characters.
     Each node takes w=log10(maxValue)+1 characters + 1 space.
     The number of characters of the bottom leaves should be.lt. 100 total.
         (w+1) * (1 left-shift (h-1)) .lt. 100.
      
     The restriction is to make it easy to read an ascii tree on a text terminal. 
     
     Example use: for maxValue=99, the number of base-10 digits is 2, so
     the maximum height printable by this method would be a tree 
     with 6 levels (results in leaf level using .lte.  100 characters).
     
     &lt;pre&gt;
                1              
          2           2       
       3     3     3     3     
      4  4  4  4  4  4  4  4   
     &lt;/pre&gt;
     @param node
     @param maxValue
     */
    public void printSmallTree(long node, long maxValue) {
       
<span class="fc" id="L2158">        int w = (int)Math.ceil(Math.log(maxValue)/Math.log(10));</span>
        
<span class="fc" id="L2160">        int n = nodeMap.getNodeSize(node);</span>
<span class="fc" id="L2161">        int h = (int)Math.ceil(Math.log(n + 1)/Math.log(2));</span>
        
        //System.out.println(&quot;w=&quot; + w + &quot; n=&quot; + n + &quot; h=&quot; + h);
        
<span class="fc" id="L2165">        int baselineLength = (w + 1) * (1 &lt;&lt; (h - 1));</span>
       
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">        if (baselineLength &gt; 100) {</span>
<span class="nc" id="L2168">            throw new IllegalArgumentException(&quot;the number of characters needed&quot;</span>
                + &quot; for the leaves is &gt; 100&quot;);
        }
        
<span class="fc" id="L2172">        ArrayDeque&lt;Long&gt; levelQ = new ArrayDeque();</span>
<span class="fc" id="L2173">        ArrayDeque&lt;Long&gt; nextLevelQ = new ArrayDeque&lt;Long&gt;();</span>
<span class="fc" id="L2174">        levelQ.add(node);</span>
<span class="fc" id="L2175">        int level = 0;</span>
<span class="fc" id="L2176">        int hw = (w+1)/2;</span>
<span class="fc" id="L2177">        int indent = (baselineLength - (w+1))/2;</span>
<span class="pc bpc" id="L2178" title="3 of 4 branches missed.">        while (!levelQ.isEmpty() || !nextLevelQ.isEmpty()) {</span>
<span class="fc" id="L2179">            level++;</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">            if (level &gt; h) {</span>
<span class="fc" id="L2181">                break;</span>
            }
<span class="fc bfc" id="L2183" title="All 2 branches covered.">            if (level &gt; 1) {</span>
<span class="fc" id="L2184">                indent /= 2;</span>
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">                if (indent - hw &gt; 1) {</span>
<span class="nc" id="L2186">                    indent -= hw;</span>
                }
            }
<span class="fc" id="L2189">            int nn = 1 &lt;&lt; (level - 1);</span>
<span class="fc" id="L2190">            int nodeSpace = (w+1) * nn;</span>
<span class="fc" id="L2191">            int spacing = baselineLength - nodeSpace - 2*indent;</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">            if ((nn - 1) &gt; 0) {</span>
<span class="fc" id="L2193">                spacing /= (nn-1);</span>
            }
            //System.out.println(&quot;spacing=&quot; + spacing + &quot; indent=&quot; + indent
            //    + &quot; bl=&quot; + baselineLength + &quot; ns=&quot; + nodeSpace);
<span class="fc" id="L2197">            int prevPos = -1;</span>
<span class="fc" id="L2198">            StringBuilder sb0 = new StringBuilder(baselineLength);</span>
<span class="fc" id="L2199">            StringBuilder sb1 = new StringBuilder(baselineLength);</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">            while (!levelQ.isEmpty()) {</span>
<span class="fc" id="L2201">                long z = levelQ.pop();</span>
                int nSpaces;
<span class="fc bfc" id="L2203" title="All 2 branches covered.">                if (level == 1) {</span>
<span class="fc" id="L2204">                    nSpaces = indent;</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                } else if (prevPos == -1) {</span>
<span class="fc" id="L2206">                    nSpaces = indent;</span>
                } else {
<span class="fc" id="L2208">                    nSpaces = spacing;</span>
                }
<span class="fc" id="L2210">                addSpaces(nSpaces, sb0);</span>
<span class="fc" id="L2211">                addSpaces(nSpaces, sb1);</span>
<span class="fc" id="L2212">                prevPos += nSpaces;</span>
<span class="fc bfc" id="L2213" title="All 2 branches covered.">                if (z == Long.MIN_VALUE) {</span>
<span class="fc" id="L2214">                    addSpaces(w + 1, sb0);</span>
<span class="fc" id="L2215">                    addSpaces(w + 1, sb1);</span>
                    // add 2 empty placeholders
<span class="fc" id="L2217">                    nextLevelQ.add(Long.MIN_VALUE);</span>
<span class="fc" id="L2218">                    nextLevelQ.add(Long.MIN_VALUE);</span>
<span class="fc" id="L2219">                    continue;                    </span>
                }
<span class="pc bpc" id="L2221" title="1 of 2 branches missed.">                if (!nodeMap.containsKey(z)) {</span>
<span class="nc" id="L2222">                    continue;</span>
                }
<span class="fc" id="L2224">                int clr = nodeMap.getNodeColor(z);</span>
<span class="fc" id="L2225">                String keyC = Long.toString(z);</span>
<span class="fc" id="L2226">                String clrC = Integer.toString(clr);</span>
            
<span class="fc" id="L2228">                sb0.append(keyC);</span>
<span class="fc" id="L2229">                sb1.append(clrC);</span>
<span class="fc" id="L2230">                addSpaces(1, sb0);</span>
<span class="fc" id="L2231">                addSpaces(w + 1 - clrC.length(), sb1);</span>
                
<span class="fc bfc" id="L2233" title="All 2 branches covered.">                if (nodeMap.leftIsSet(z)) {</span>
<span class="fc" id="L2234">                    nextLevelQ.add(nodeMap.getLeft(z));</span>
                } else {
<span class="fc" id="L2236">                    nextLevelQ.add(Long.MIN_VALUE);</span>
                }
<span class="fc bfc" id="L2238" title="All 2 branches covered.">                if (nodeMap.rightIsSet(z)) {</span>
<span class="fc" id="L2239">                    nextLevelQ.add(nodeMap.getRight(z));</span>
                } else {
<span class="fc" id="L2241">                    nextLevelQ.add(Long.MIN_VALUE);</span>
                }
<span class="fc" id="L2243">            }</span>
<span class="fc" id="L2244">            System.out.println(sb0.toString());</span>
<span class="fc" id="L2245">            System.out.println(sb1.toString());</span>
<span class="fc" id="L2246">            System.out.println(&quot;&quot;);</span>
<span class="pc bnc" id="L2247" title="All 2 branches missed.">            assert(levelQ.isEmpty());</span>
<span class="fc" id="L2248">            levelQ.addAll(nextLevelQ);</span>
<span class="fc" id="L2249">            nextLevelQ.clear();</span>
<span class="fc" id="L2250">        }</span>
<span class="fc" id="L2251">    } </span>
    private void addSpaces(int nSpaces, StringBuilder sb) {
<span class="fc bfc" id="L2253" title="All 2 branches covered.">        for (int i = 0; i &lt; nSpaces; ++i) {</span>
<span class="fc" id="L2254">            sb.append(&quot; &quot;);</span>
        }
<span class="fc" id="L2256">    }</span>
    
    private boolean containsLeft(long key) {
<span class="nc" id="L2259">        return nodeMap.leftIsSet(key);</span>
    }
    private boolean containsRight(long key) {
<span class="nc" id="L2262">        return nodeMap.rightIsSet(key);</span>
    }
    private boolean containsParent(long key) {
<span class="nc" id="L2265">        return nodeMap.parentIsSet(key);</span>
    }
    private boolean containsParentLeft(long key) {
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (containsParent(key)) {</span>
<span class="nc" id="L2269">            return containsLeft(nodeMap.getParent(key));</span>
        }
<span class="nc" id="L2271">        return false;</span>
    }
    private boolean containsParentRight(long key) {
<span class="nc bnc" id="L2274" title="All 2 branches missed.">        if (containsParent(key)) {</span>
<span class="nc" id="L2275">            return containsRight(nodeMap.getParent(key));</span>
        }
<span class="nc" id="L2277">        return false;</span>
    }

    private void deleteFromLeftAssignLeft(long delH, long asnH, long key, 
        long[] output) {
       
<span class="fc" id="L2283">        delete(nodeMap.getLeft(delH), key, output);</span>
<span class="fc bfc" id="L2284" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L2285">            nodeMap.unsetLeft(asnH);</span>
        } else {
<span class="fc" id="L2287">            nodeMap.updateLeft(delH, output[1]);</span>
<span class="fc" id="L2288">            nodeMap.updateParent(output[1], delH);</span>
        }
<span class="fc" id="L2290">    }</span>

    private void deleteFromRightAssignRight(long hDel, long hAsn, long key, 
        long[] output) {
        
<span class="pc bnc" id="L2295" title="All 2 branches missed.">        assert(nodeMap.rightIsSet(hDel));</span>
        
        //h.right = delete(h.right, key);

<span class="fc" id="L2299">        delete(nodeMap.getRight(hDel), key, output);</span>
        
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L2302">            nodeMap.unsetRight(hAsn);</span>
        } else {
<span class="fc" id="L2304">            nodeMap.updateRight(hAsn, output[1]);</span>
<span class="fc" id="L2305">            nodeMap.updateParent(output[1], hAsn);</span>
        }
<span class="fc" id="L2307">    }</span>
             
    private void setHFromX(long x, long h, int xVal, int hClr, 
        boolean hLeftExists, long hLeft, 
        boolean hRightExists, long hRight, 
        boolean hParentExists, long hParent, int hSize) {
        
<span class="pc bnc" id="L2314" title="All 2 branches missed.">        assert(x != h);</span>
<span class="fc" id="L2315">        nodeMap.put(x, xVal, hClr, hSize);</span>
     
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">        if (hParentExists) {</span>
<span class="fc" id="L2318">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L2319" title="1 of 2 branches missed.">            if (nodeMap.leftIsSet(hParent) </span>
<span class="pc bpc" id="L2320" title="1 of 2 branches missed.">                &amp;&amp; nodeMap.getLeft(hParent) == h) {</span>
<span class="nc" id="L2321">                nodeMap.updateLeft(hParent, x);</span>
            } else {
<span class="pc bnc" id="L2323" title="All 2 branches missed.">                assert(nodeMap.rightIsSet(hParent) </span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                    &amp;&amp; nodeMap.getRight(hParent) == h);</span>
<span class="fc" id="L2325">                nodeMap.updateRight(hParent, x);</span>
            }
        } else {
            //h is root
        }
        
<span class="pc bpc" id="L2331" title="1 of 2 branches missed.">        if (hLeftExists) {</span>
<span class="fc" id="L2332">            nodeMap.updateParent(hLeft, x);</span>
<span class="fc" id="L2333">            nodeMap.updateLeft(x, hLeft);</span>
        }
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        if (hRightExists) {</span>
<span class="fc" id="L2336">            nodeMap.updateParent(hRight, x);</span>
<span class="fc" id="L2337">            nodeMap.updateRight(x, hRight);</span>
        }
        
<span class="fc" id="L2340">        nodeMap.remove(h); </span>
        
<span class="pc bpc" id="L2342" title="1 of 2 branches missed.">        if (h == root) {</span>
<span class="nc" id="L2343">            root = x;</span>
        }
<span class="fc" id="L2345">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>