<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedBlackBSTLongInt2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.edu.princeton.cs.algs4</a> &gt; <span class="el_source">RedBlackBSTLongInt2.java</span></div><h1>RedBlackBSTLongInt2.java</h1><pre class="source lang-java linenums">package thirdparty.edu.princeton.cs.algs4;

/******************************************************************************
   adapted from RedBlackBST.java 
   from the 
   book &quot;Algorithms&quot; by Sedgewick and Wayne
   http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java
   copyright for authors Robert Sedgewick and Kevin Wayne
   is GPLV3, http://algs4.cs.princeton.edu/faq/

This version uses smaller amount of memory by replacing linked nodes with
associative arrays.

*     x.left.key .lte. x.key
*     x.right.key .gte. x.key
* 
 *  Compilation:  javac RedBlackBST.java
 *  Execution:    java RedBlackBST left-pipe input.txt
 *  Dependencies: StdIn.java StdOut.java  
 *  Data files:   http://algs4.cs.princeton.edu/33balanced/tinyST.txt  
 *    
 *  A symbol table implemented using a left-leaning red-black BST.
 *  This is the 2-3 version.
 *
 *  Note: commented out assertions because DrJava now enables assertions
 *        by default.
 *
 *  % more tinyST.txt
 *  S E A R C H E X A M P L E
 *  
 *  % java RedBlackBST left-pipe tinyST.txt
 *  A 8
 *  C 4
 *  E 12
 *  H 5
 *  L 11
 *  M 9
 *  P 10
 *  R 3
 *  S 0
 *  X 7
 *
 ******************************************************************************/

import algorithms.util.ObjectSpaceEstimator;
import algorithms.util.NodeMap;
import gnu.trove.list.TLongList;
import gnu.trove.list.array.TLongArrayList;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Stack;

/**
 * NOTE: this implementation of the long-int Red Black tree uses the least
 * amount of memory of all versions by replacing the tree structure of linked
 * lists of nodes as objects with associative arrays that use primitive 
 * arrays internally.  Reducing the Red Black tree space used was necessary for building the
 * YFastTrie.
 * 
 * 
 *  The {@code BST} class represents an ordered symbol table of generic
 *  key-value pairs.
 *  It supports the usual &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;get&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;,
 *  &lt;em&gt;delete&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; methods.
 *  It also provides ordered methods for finding the &lt;em&gt;minimum&lt;/em&gt;,
 *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;floor&lt;/em&gt;, and &lt;em&gt;ceiling&lt;/em&gt;.
 *  It also provides a &lt;em&gt;keys&lt;/em&gt; method for iterating over all of the keys.
 *  A symbol table implements the &lt;em&gt;associative array&lt;/em&gt; abstraction:
 *  when associating a value with a key that is already in the symbol table,
 *  the convention is to replace the old value with the new value.
 *  Unlike {@link java.util.Map}, this class uses the convention that
 *  values cannot be {@code null}â€”setting the
 *  value associated with a key to {@code null} is equivalent to deleting the key
 *  from the symbol table.
 *  &lt;p&gt;
 *  This implementation uses a left-leaning red-black BST. It requires that
 *  the key type implements the {@code Comparable} interface and calls the
 *  {@code compareTo()} and method to compare two keys. It does not call either
 *  {@code equals()} or {@code hashCode()}.
 *  The &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;, &lt;em&gt;remove&lt;/em&gt;, &lt;em&gt;minimum&lt;/em&gt;,
 *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;ceiling&lt;/em&gt;, and &lt;em&gt;floor&lt;/em&gt; operations each take
 *  logarithmic time in the worst case, if the tree becomes unbalanced.
 *  The &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; operations take constant time.
 *  Construction takes constant time.
 *  &lt;p&gt;
 *  For additional documentation, see 
 * &lt;a href=&quot;http://algs4.cs.princeton.edu/33balanced&quot;&gt;Section 3.3&lt;/a&gt; of
 *  &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.
 *  For other implementations of the same API, see {@link ST}, {@link BinarySearchST},
 *  {@link SequentialSearchST}, {@link BST},
 *  {@link SeparateChainingHashST}, {@link LinearProbingHashST}, and {@link AVLTreeST}.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 
 * edits made to their original code include replacing the linked object Nodes
 * with an associative array holding multiple values.
 */
<span class="fc" id="L100">public class RedBlackBSTLongInt2 {</span>
    
    private static final int RED   = 1;
    private static final int BLACK = 0;

    /**
     *
     */
<span class="pc" id="L108">    protected long root = -1;</span>

    /**
     *
     */
<span class="pc" id="L113">    protected boolean rootIsSet = false;</span>

    //TODO: as soon as this is debugged,
    //   make a class that extends TLongLongMap for
    //   key long, and values long, int, long, long, int, int
    //   reducing the number of long keys from 6 to 1

    /**
     *
     */
    protected final NodeMap nodeMap;
    
    /**
     * Initializes an empty symbol table.
     */
<span class="fc" id="L128">    public RedBlackBSTLongInt2() {</span>
<span class="fc" id="L129">        nodeMap = new NodeMap();</span>
<span class="fc" id="L130">    }</span>
    
    /**
     * Initializes an empty symbol table.
     @param capacity
     */
<span class="nc" id="L136">    public RedBlackBSTLongInt2(int capacity) {</span>
<span class="nc" id="L137">        nodeMap = new NodeMap(capacity);</span>
<span class="nc" id="L138">    }</span>

    private long addNewNode(long key, int val, int color, int size) {
<span class="fc" id="L141">        nodeMap.put(key, val, color, size);</span>
<span class="fc" id="L142">        return key;</span>
    }
    
   /***************************************************************************
    *  Node helper methods.
     @param x
     @return 
    ***************************************************************************/
    // is node x red; false if x is null ?
    private boolean isRed(long x) {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return false;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        return nodeMap.getNodeColor(x) == RED;</span>
    }
    private boolean isLeftRed(long x) {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L157">            return false;</span>
        }
<span class="fc" id="L159">        return isRed(nodeMap.getLeft(x));</span>
    }
    private boolean isRightRed(long x) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L163">            return false;</span>
        }
<span class="fc" id="L165">        return isRed(nodeMap.getRight(x));</span>
    }
    private boolean isLeftLeftRed(long x) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="nc" id="L169">            return false;</span>
        }
<span class="fc" id="L171">        long left = nodeMap.getLeft(x);</span>
<span class="fc" id="L172">        return isLeftRed(left);</span>
    }
    private boolean isRightLeftRed(long x) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="nc" id="L176">            return false;</span>
        }
<span class="fc" id="L178">        long right = nodeMap.getRight(x);</span>
<span class="fc" id="L179">        return isLeftRed(right);</span>
    }

    // number of node in subtree rooted at x; 0 if x is null
    private int size(long x) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc" id="L185">        return nodeMap.getNodeSize(x);</span>
    }
    private int sizeLeft(long x) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return 0;</span>
<span class="fc" id="L190">        return nodeMap.getNodeSize(nodeMap.getLeft(x));</span>
    }
    private int sizeRight(long x) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return 0;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return 0;</span>
<span class="fc" id="L195">        return nodeMap.getNodeSize(nodeMap.getRight(x));</span>
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     @return the number of key-value pairs in this symbol table
     */
    public int size() {
<span class="fc" id="L203">        return size(root);</span>
    }

   /**
     * Is this symbol table empty?
     @return {@code true} if this symbol table is empty and {@code false} otherwise
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        return !rootIsSet;</span>
    }

   /***************************************************************************
    *  Standard BST search.
    ***************************************************************************/

    /**
     * Returns the value associated with the given key.
     @param key the key
     @param output if output[0] == -1, then key was not present, else the
     *    returned value is found in output[1]
     */
    public void get(long key, int[] output) {
<span class="pc bpc" id="L225" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="fc" id="L228">        output[0] = 0;</span>
<span class="fc" id="L229">        get(root, key, output);</span>
<span class="fc" id="L230">    }</span>

    // value associated with the given key in subtree rooted at x; null if no such key
    private void get(long x, long key, int[] output) {
        //while (x != null) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L236" title="All 4 branches covered.">            int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L239">                    x = nodeMap.getLeft(x);</span>
                } else {
                    break;
                }
<span class="fc bfc" id="L243" title="All 2 branches covered.">            } else if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L245">                    x = nodeMap.getRight(x);</span>
                } else {
                    break;
                }
            } else {
<span class="fc" id="L250">                output[1] = nodeMap.getNodeValue(x);</span>
<span class="fc" id="L251">                return;</span>
            }
<span class="fc" id="L253">        }</span>
<span class="fc" id="L254">        output[0] = -1;</span>
<span class="fc" id="L255">    }</span>

    /**
     * Does this symbol table contain the given key?
     @param key the key
     @return {@code true} if this symbol table contains {@code key} and
     *     {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(long key) {
<span class="fc" id="L265">        get(key, cache0);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        return (cache0[0] != -1);</span>
    }
<span class="pc" id="L268">    private int[] cache0 = new int[2];</span>

   /***************************************************************************
    *  Red-black tree insertion.
    ***************************************************************************/

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     *
     @param key the key
     @param val the value
     */
    public void put(long key, int val) {
        
        //System.out.println(&quot;put &quot; + key + &quot;:&quot;);
        
        //System.out.println(&quot;before put &quot; + key);
        //printPreOrderTraversal();
        
<span class="fc" id="L288">        root = put(root, key, val);</span>
<span class="fc" id="L289">        rootIsSet = true;</span>
<span class="fc" id="L290">        nodeMap.updateNodeColor(root, BLACK);</span>
        
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (nodeMap.parentIsSet(root)) {</span>
<span class="nc" id="L293">            nodeMap.unsetParent(root);</span>
        }
        
        //printPreOrderTraversal();
        //System.out.println(&quot;after put &quot; + key + &quot; root=&quot; + root);
        
<span class="pc bnc" id="L299" title="All 2 branches missed.">        assert(check());</span>
<span class="fc" id="L300">    }</span>

    // insert the key-value pair in the subtree rooted at h
    //private Node put(Node h, long key, int val) {
    private long put(long h, long key, int val) {
        
        //System.out.println(&quot;put h=&quot; + h + &quot; key=&quot; + key);
        
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        if (!rootIsSet || !nodeMap.containsKey(h)) {</span>
<span class="fc" id="L309">            return addNewNode(key, val, RED, 1);</span>
        }
       
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">        int cmp = (key &lt; h) ? -1 : (key &gt; h) ? 1 : 0;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (cmp &lt; 0) {</span>
            //h.left  = put(h.left,  key, val);
            long putKey;
<span class="fc bfc" id="L316" title="All 2 branches covered.">            if (nodeMap.leftIsSet(h)) {</span>
                //h.left = putKey
                //putKey.parent = h
<span class="fc" id="L319">                long hLeft = nodeMap.getLeft(h);</span>
<span class="fc" id="L320">                putKey = put(hLeft,  key, val);</span>
<span class="fc" id="L321">            } else {</span>
<span class="fc" id="L322">                putKey = addNewNode(key, val, RED, 1);</span>
            }
<span class="fc" id="L324">            nodeMap.updateLeft(h, putKey);</span>
<span class="fc" id="L325">            nodeMap.updateParent(putKey, h);</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        } else if (cmp &gt; 0) {</span>
            //h.right = put(h.right, key, val);
            long putKey;
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (nodeMap.rightIsSet(h)) {</span>
<span class="fc" id="L330">                long hRight = nodeMap.getRight(h);</span>
<span class="fc" id="L331">                putKey = put(nodeMap.getRight(h),  key, val);</span>
<span class="fc" id="L332">            } else {</span>
<span class="fc" id="L333">                putKey = addNewNode(key, val, RED, 1);</span>
            }
<span class="fc" id="L335">            nodeMap.updateRight(h, putKey);</span>
<span class="fc" id="L336">            nodeMap.updateParent(putKey, h);</span>
<span class="fc" id="L337">        } else {</span>
            //h.val   = val;
<span class="nc bnc" id="L339" title="All 2 branches missed.">            assert(nodeMap.containsKey(h));</span>
<span class="nc" id="L340">            nodeMap.updateNodeValue(h, val);</span>
        }
        
        // fix-up any right-leaning links
<span class="fc bfc" id="L344" title="All 4 branches covered.">        if (isRightRed(h) &amp;&amp; !isLeftRed(h)) {</span>
<span class="fc" id="L345">            h = rotateLeft(h);</span>
        }
<span class="fc bfc" id="L347" title="All 4 branches covered.">        if (isLeftRed(h)  &amp;&amp;  isLeftLeftRed(h)) {</span>
<span class="fc" id="L348">            h = rotateRight(h);</span>
        }
<span class="fc bfc" id="L350" title="All 4 branches covered.">        if (isLeftRed(h)  &amp;&amp;  isRightRed(h))  {</span>
<span class="fc" id="L351">            flipColors(h);</span>
        }
<span class="fc" id="L353">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L354">        nodeMap.updateNodeSize(h, size);</span>
       
<span class="fc" id="L356">        return h;</span>
    }

   /***************************************************************************
    *  Red-black tree deletion.
    ***************************************************************************/

    private void setRootToRedIfChildrenAreBlack() {
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">        if (!isLeftRed(root) &amp;&amp; !isRightRed(root)) {</span>
<span class="fc" id="L365">            nodeMap.updateNodeColor(root, RED);</span>
        }
<span class="fc" id="L367">    }</span>
    
    /**
     * Removes the smallest key and associated value from the symbol table.
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMin() {
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);</span>

        //System.out.println(&quot;deleteMin.  root=&quot; +root);
        //printPreOrderTraversal();
        
<span class="fc" id="L379">        int sz0 = size();</span>
        
<span class="pc bnc" id="L381" title="All 2 branches missed.">        assert(nodeMap.containsKey(root));</span>
        
        // if both children of root are black, set root to red
<span class="fc" id="L384">        setRootToRedIfChildrenAreBlack();</span>
        
        //root = deleteMin(root);
<span class="fc" id="L387">        long[] output = new long[2];</span>
<span class="fc" id="L388">        deleteMin(root, output);</span>
        
        //System.out.println(&quot;deleteMin=&quot; + Arrays.toString(output));
        
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L393">            rootIsSet = false;</span>
<span class="nc" id="L394">            nodeMap.remove(root);</span>
<span class="nc" id="L395">            root = -1;</span>
        } else {
            //System.out.println(&quot;in deleteMin: assigning root=&quot; + output[1]);
<span class="fc" id="L398">            root = output[1];</span>
<span class="fc" id="L399">            nodeMap.unsetParent(root);</span>
        }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
            //root.color = BLACK;
<span class="fc" id="L403">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //System.out.format(&quot;AFTER deleteMin()\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="pc bnc" id="L409" title="All 2 branches missed.">        assert(check());</span>
        
<span class="pc bnc" id="L411" title="All 2 branches missed.">        assert(sz0 == (size() + 1));</span>
<span class="fc" id="L412">    }</span>

    // delete the key-value pair with the minimum key rooted at h.
    // output is length==2, output[0] holds the error code
    // and is -1 when there is an error.  output[1] holds the top node
    // from which the min was deleted (note that the top node may have
    // been rotated, so might not equal h).
    // if output.length == 3, the third item is set to be the
    // minimum node which was deleted.
    private void deleteMin(long h, long[] output) { 
        
        //System.out.println(&quot;deleteMin &quot; + nodeToString(h));
        
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(h)) {</span>
<span class="nc" id="L426">            output[0] = -1;</span>
<span class="nc" id="L427">            return;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        } else if (!nodeMap.leftIsSet(h)) {</span>
<span class="fc" id="L429">            output[0] = -1;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (output.length == 3) {</span>
<span class="fc" id="L431">                output[2] = h;</span>
            }
<span class="fc" id="L433">            return;</span>
        }

        //System.out.format(&quot;BEFORE deleteMin(%d)\n&quot;, h);
        //printPreOrderTraversal(1);
        
        
<span class="fc bfc" id="L440" title="All 4 branches covered.">        if (!isLeftRed(h) &amp;&amp; !isLeftLeftRed(h)) {</span>
<span class="fc" id="L441">            h = moveRedLeft(h);</span>
        }
        
        //h.left = deleteMin(h.left);
        
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (!nodeMap.leftIsSet(h)) {</span>
<span class="nc" id="L447">            output[0] = -1;</span>
<span class="nc" id="L448">            return;</span>
        }
<span class="fc" id="L450">        long left = nodeMap.getLeft(h);</span>
        //assert(parent == h);
        
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (output.length == 3) {</span>
<span class="fc" id="L454">            output[2] = left;</span>
        }
        
<span class="fc" id="L457">        deleteMin(left, output);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (output[0] == -1) {</span>
            //h.left = null
<span class="fc" id="L460">            nodeMap.unsetLeft(h);</span>
<span class="fc" id="L461">            output[0] = 0;</span>
        } else {
            //System.out.println(&quot; deleteMin return is &quot; + output[1] 
            //   + &quot; h.left gets assigned it&quot;);
<span class="fc" id="L465">            nodeMap.updateParent(output[1], h);</span>
<span class="fc" id="L466">            nodeMap.updateLeft(h, output[1]);</span>
        }
<span class="fc" id="L468">        output[1] = balance(h);</span>
        
        //printPreOrderTraversal(1);
        //System.out.format(&quot;AFTER deleteMin(h)\n&quot;);
<span class="fc" id="L472">    }</span>

    /**
     * Removes the largest key and associated value from the symbol table.
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMax() {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);</span>

        //System.out.println(&quot;deleteMax.  root=&quot; +root);
        //printPreOrderTraversal();
        
        // if both children of root are black, set root to red
<span class="fc" id="L485">        setRootToRedIfChildrenAreBlack();</span>

        //root = deleteMax(root);
        
<span class="fc" id="L489">        long[] output = new long[2];</span>
<span class="fc" id="L490">        deleteMax(root, output);</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L492">            nodeMap.remove(root);</span>
<span class="nc" id="L493">            rootIsSet = false;</span>
<span class="nc" id="L494">            root = -1;</span>
<span class="nc" id="L495">            return;</span>
        }
<span class="fc" id="L497">        root = output[1];</span>
<span class="fc" id="L498">        nodeMap.unsetParent(root);</span>
        
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
            //root.color = BLACK;
<span class="fc" id="L502">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //System.out.format(&quot;AFTER deleteMax()\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="pc bnc" id="L508" title="All 2 branches missed.">        assert(check());</span>
<span class="fc" id="L509">    }</span>

    // delete the key-value pair with the maximum key rooted at h
    private void deleteMax(long h, long[] output) { 
    
        //System.out.format(&quot;BEFORE deleteMax(%d)\n&quot;, h);
        //printPreOrderTraversal(1);
        
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (isLeftRed(h)) {</span>
<span class="fc" id="L518">            h = rotateRight(h);</span>
        }
      
<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(h)) {</span>
            // h is max key
<span class="fc" id="L523">            output[0] = -1;</span>
<span class="fc" id="L524">            return;</span>
        }

<span class="fc bfc" id="L527" title="All 4 branches covered.">        if (!isRightRed(h) &amp;&amp; !isRightLeftRed(h)) {</span>
            //move red node down the right spine of the tree
<span class="fc" id="L529">            h = moveRedRight(h);</span>
        }
        
        //h.right = deleteMax(h.right);
        
<span class="pc bnc" id="L534" title="All 2 branches missed.">        assert(nodeMap.rightIsSet(h));</span>
        
<span class="fc" id="L536">        deleteMax(nodeMap.getRight(h), output);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L538">            nodeMap.unsetRight(h);</span>
        } else {
<span class="fc" id="L540">            nodeMap.updateParent(output[1], h);</span>
<span class="fc" id="L541">            nodeMap.updateRight(h, output[1]);</span>
        }

<span class="fc" id="L544">        output[0] = 0;</span>
<span class="fc" id="L545">        output[1] = balance(h);</span>
        
        
        //System.out.format(&quot;AFTER deleteMax(h)\n&quot;);
        //printPreOrderTraversal(1);
        
<span class="fc" id="L551">    }</span>

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     @param  key the key
     */
    public void delete(long key) { 
        
<span class="fc" id="L561">        int sz0 = size();</span>
        
        //System.out.println(&quot;\nbefore delete &quot; + key + &quot; root=&quot; + root);
        //printPreOrderTraversal();
        
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (!contains(key)) return;</span>

        // if both children of root are black, set root to red
<span class="fc" id="L569">        setRootToRedIfChildrenAreBlack();</span>
        
        ////root = delete(root, key);
        
<span class="fc" id="L573">        long[] output = new long[2];</span>
<span class="fc" id="L574">        delete(root, key, output);</span>
        
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L577">            rootIsSet = false;</span>
<span class="fc" id="L578">            nodeMap.remove(root);</span>
<span class="fc" id="L579">            root = -1;</span>
<span class="fc" id="L580">            return;</span>
        }
<span class="fc" id="L582">        root = output[1];</span>
<span class="fc" id="L583">        nodeMap.unsetParent(root);</span>
        
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if (!isEmpty()) {</span>
<span class="fc" id="L586">            nodeMap.updateNodeColor(root, BLACK);</span>
        }
        
        //printPreOrderTraversal();
        //System.out.println(&quot;after delete &quot; + key + &quot; root=&quot; + root);
        
<span class="pc bnc" id="L592" title="All 2 branches missed.">        assert(check());</span>
        
<span class="pc bnc" id="L594" title="All 2 branches missed.">        assert(sz0 == (size() + 1));</span>
<span class="fc" id="L595">    }</span>

    // delete the key-value pair with the given key rooted at h
    private void delete(long h, long key, long[] output) { 
        
        //System.out.format(&quot;delete(%d, %d)\n&quot;, h, key);
        
<span class="pc bnc" id="L602" title="All 2 branches missed.">        assert(nodeMap.containsKey(key));</span>
<span class="pc bnc" id="L603" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
        
        // assert get(h, key) != null;
        {//DEBUG
<span class="fc" id="L607">            int[] vOutput = new int[2];</span>
<span class="fc" id="L608">            get(h, key, vOutput);</span>
<span class="pc bnc" id="L609" title="All 2 branches missed.">            assert(vOutput[0] != -1);</span>
        }
        
<span class="fc" id="L612">        output[0] = 0;</span>
        
        //NOTE: this method and the methods it uses do not always
        //check for nulls and handle them
                    
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (key &lt; h)  {</span>
<span class="pc bpc" id="L618" title="1 of 4 branches missed.">            if (!isLeftRed(h) &amp;&amp; !isLeftLeftRed(h)) {</span>
<span class="fc" id="L619">                h = moveRedLeft(h);</span>
            }
<span class="pc bnc" id="L621" title="All 2 branches missed.">            assert(nodeMap.leftIsSet(h));</span>
            //h.left = delete(h.left, key);
<span class="fc" id="L623">            deleteFromLeftAssignLeft(h, h, key, output);</span>
<span class="fc" id="L624">            output[0] = 0;</span>
        } else {
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (isLeftRed(h)) {</span>
<span class="fc" id="L627">                h = rotateRight(h);</span>
            }
<span class="fc bfc" id="L629" title="All 4 branches covered.">            if (key == h &amp;&amp; !nodeMap.rightIsSet(h)) {</span>
<span class="fc" id="L630">                output[0] = -1;</span>
<span class="fc" id="L631">                return;</span>
            }
<span class="fc bfc" id="L633" title="All 4 branches covered.">            if (!isRightRed(h) &amp;&amp; !isRightLeftRed(h)) {</span>
<span class="fc" id="L634">                h = moveRedRight(h);</span>
            }
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (key == h) {</span>
               
                //NLK: TODO: revisit this code. it or similar had a bug I fixed,
                //    but forgot to communicate the fix back to the authors or
                //    follow up on whether they fixed it.
                
                /*
                useful in visualizing this case is
                https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf
                pg 66, &quot;Deleting an arbitrary node&quot;
                
                To delete 'D':
                
                               H
                        D             L
                    B      F       J     N
                   A C    E G     I K   M
                
                  D.key = min(D.right)
                  D.value = get(D.right, D.key)
                  D.right = deleteMin(D.right)
                  then delete the min node
                  then fix right-leaning red link of F, the parent
                    of the just deleted E node
                              H
                        E             L
                    B      F       J     N
                   A C      G     I K   M   
                
                
                              H
                        E             L
                    B      F       J     N
                   A C    G       I K   M   
                */
                
                //Node x = min(h.right);
                // Note: need to use deleteMin all in one because there
                //   are rotations in it that may change the branch
                //   traversed and hence the minimum of that branch
                //   might not be the same as x.
<span class="fc" id="L677">                long[] output3 = new long[3];</span>
<span class="fc" id="L678">                deleteMin(nodeMap.getRight(h), output3);</span>
                        
                //System.out.println(&quot;deleteMin=&quot; + Arrays.toString(output3));
        
<span class="fc" id="L682">                int hClr = nodeMap.getNodeColor(h);</span>
<span class="fc" id="L683">                boolean hLeftExists = nodeMap.leftIsSet(h);</span>
<span class="fc" id="L684">                boolean hRightExists = nodeMap.rightIsSet(h);</span>
<span class="fc" id="L685">                boolean hParentExists = nodeMap.parentIsSet(h);</span>
<span class="fc" id="L686">                long hLeft = nodeMap.getLeft(h);</span>
<span class="fc" id="L687">                long hRight = nodeMap.getRight(h);</span>
<span class="fc" id="L688">                long hParent = nodeMap.getParent(h);</span>
<span class="fc" id="L689">                int hSize = nodeMap.getNodeSize(h);</span>
               
<span class="fc" id="L691">                String hDBG = nodeToString(h);</span>
                
<span class="fc" id="L693">                long x = output3[2];</span>
               
                //System.out.println(
                //    &quot;   x to get h fields except val. &quot; + 
                //    &quot;\n   x=&quot; + nodeToString(x)
                //    + &quot;\n   h=&quot; + hDBG
                //);
               
<span class="pc bnc" id="L701" title="All 2 branches missed.">                assert(x != h);</span>
                
                //int xClr = nodeMap.getNodeColor(x);
                //boolean xLeftExists = nodeMap.leftIsSet(x);
                //boolean xRightExists = nodeMap.rightIsSet(x);
<span class="fc" id="L706">                boolean xParentExists = nodeMap.parentIsSet(x);</span>
                //long xLeft = nodeMap.getLeft(x);
                //long xRight = nodeMap.getRight(x);
<span class="fc" id="L709">                long xParent = nodeMap.getParent(x);</span>
<span class="fc" id="L710">                int xVal = nodeMap.getNodeValue(x);</span>
                
                // finish deleting x if not already
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">                if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L714">                    long minParent = nodeMap.getParent(x);</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">                    if (nodeMap.leftIsSet(minParent)</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">                        &amp;&amp; nodeMap.getLeft(minParent) == x) {</span>
<span class="nc" id="L717">                        nodeMap.unsetLeft(minParent);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">                    } else if (nodeMap.rightIsSet(minParent)</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">                            &amp;&amp; nodeMap.getRight(minParent) == x) {</span>
<span class="fc" id="L720">                        nodeMap.unsetRight(minParent);</span>
                    }
<span class="fc" id="L722">                    nodeMap.unsetParent(x);</span>
                }
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">                if (nodeMap.containsKey(x)) {</span>
<span class="fc" id="L725">                    nodeMap.remove(x);</span>
                }
                
<span class="pc bpc" id="L728" title="1 of 4 branches missed.">                if (hRightExists &amp;&amp; hRight == x) {</span>
<span class="fc" id="L729">                    hRightExists = false;</span>
                }
                
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (xParentExists) {</span>
<span class="pc bnc" id="L733" title="All 2 branches missed.">                    assert(!nodeMap.parentIsSet(x));</span>
                }
                
<span class="fc" id="L736">                setHFromX(x, h, xVal, hClr, </span>
                    hLeftExists, hLeft, 
                    hRightExists, hRight, hParentExists, hParent, hSize - 1);
                    
<span class="fc" id="L740">                h = x;</span>
                
                //System.out.println(&quot;  merged=&quot; + nodeToString(h));
                
<span class="fc" id="L744">                output[0] = 0;</span>
                 
<span class="fc" id="L746">            } else {</span>
                //h.right = delete(h.right, key);
<span class="fc" id="L748">                deleteFromRightAssignRight(h, h, key, output);</span>
<span class="fc" id="L749">                output[0] = 0;</span>
            }
        }
                
<span class="fc" id="L753">        output[0] = 0;</span>
<span class="fc" id="L754">        output[1] = balance(h);  </span>
<span class="fc" id="L755">    }</span>
    
   /***************************************************************************
    *  Red-black tree helper functions.
    ***************************************************************************/

    /**
     * make a left-leaning link lean to the right.
     Note that the parent link logic is from Cormen, Leiserson, Rivest, and Stein &quot;Introduction to
     Algorithms&quot;.
     @param h
     @return 
     */
    protected long rotateRight(long h) {
        
        //System.out.println(&quot;  *RR &quot; + h);
        
        // assert (h != null) &amp;&amp; isRed(h.left);
<span class="pc bnc" id="L773" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L774" title="All 2 branches missed.">        assert(isLeftRed(h));</span>
        
        /*
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = x.right.color;
        x.right.color = RED;
        x.size = h.size;
        h.size = size(h.left) + size(h.right) + 1;
        */
        
<span class="fc" id="L786">        long x = nodeMap.getLeft(h);</span>

        //System.out.println(&quot;  before RR h=&quot; + nodeToString(h));
        //System.out.println(&quot;  before RR x=&quot; + nodeToString(x));
        
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
            //System.out.println(&quot;--0&quot;);
            //h.left = x.right;
<span class="fc" id="L794">            long xRight = nodeMap.getRight(x);</span>
            
<span class="fc" id="L796">            nodeMap.updateLeft(h, xRight);</span>
<span class="fc" id="L797">            nodeMap.updateParent(xRight, h);</span>
<span class="fc" id="L798">        } else {</span>
            //System.out.println(&quot;--1&quot;);
<span class="fc" id="L800">            nodeMap.unsetLeft(h);</span>
        }
<span class="fc bfc" id="L802" title="All 2 branches covered.">        if (nodeMap.parentIsSet(h)) {</span>
            //System.out.println(&quot;--2&quot;);
<span class="fc" id="L804">            long hParent = nodeMap.getParent(h);</span>
            // assign x as child of its new parent
            
<span class="fc" id="L807">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L808" title="1 of 4 branches missed.">            if (nodeMap.leftIsSet(hParent) &amp;&amp; nodeMap.getLeft(hParent) ==</span>
                h) {
                //System.out.println(&quot;--3&quot;);
<span class="fc" id="L811">                nodeMap.updateLeft(hParent, x);</span>
            } else {
                //System.out.println(&quot;--4&quot;);
<span class="fc" id="L814">                nodeMap.updateRight(hParent, x);</span>
            }
<span class="fc" id="L816">        } else {</span>
            //System.out.println(&quot;--5&quot;);
<span class="fc" id="L818">            nodeMap.unsetParent(x);</span>
            //root = x;
        }
        
        //System.out.println(&quot;  in RR after h.left h=&quot; + nodeToString(h));
        
        //x.right = h;
<span class="fc" id="L825">        nodeMap.updateRight(x, h);</span>
<span class="fc" id="L826">        nodeMap.updateParent(h, x);</span>
        
        //System.out.println(&quot;  in RR after x.right h=&quot; + nodeToString(h));
        //System.out.println(&quot;  in RR after x.right x=&quot; + nodeToString(x));
        
        //x.color = x.right.color;
        //x.right.color = RED;
        //x.size = h.size;
<span class="fc" id="L834">        nodeMap.updateNodeColor(x, nodeMap.getNodeColor(nodeMap.getRight(x)));</span>
<span class="fc" id="L835">        nodeMap.updateNodeColor(nodeMap.getRight(x), RED);</span>
        
<span class="fc" id="L837">        nodeMap.updateNodeSize(x, nodeMap.getNodeSize(h));</span>
        
        //h.size = size(h.left) + size(h.right) + 1;
<span class="fc" id="L840">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L841">        nodeMap.updateNodeSize(h, size);</span>
        
        //System.out.println(&quot;  after RR: h=&quot; + nodeToString(h));
        
        //System.out.println(&quot;after rotateRight:&quot;);
        //printPreOrderTraversal();
        
<span class="fc" id="L848">        return x;</span>
    }

    /**
     make a right-leaning link lean to the left.
     Note that the parent link logic is from Cormen, Leiserson, Rivest, and Stein &quot;Introduction to
     Algorithms&quot;.
     @param h
     @return 
     */
    protected long rotateLeft(long h) {
        
        //System.out.println(&quot;  *RL h=&quot; + h);
        
        // assert (h != null) &amp;&amp; isRed(h.right);
<span class="pc bnc" id="L863" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L864" title="All 2 branches missed.">        assert(isRightRed(h));</span>
        
        //Node x = h.right;
<span class="fc" id="L867">        long x = nodeMap.getRight(h);</span>
        
        //System.out.println(&quot;  before RL h=&quot; + nodeToString(h));
        //System.out.println(&quot;  before RL x=&quot; + nodeToString(x));

        //h.right = x.left;
<span class="fc bfc" id="L873" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
            //System.out.println(&quot;---0&quot;);
<span class="fc" id="L875">            long left = nodeMap.getLeft(x);</span>
            
<span class="fc" id="L877">            nodeMap.updateRight(h, left);</span>
<span class="fc" id="L878">            nodeMap.updateParent(left, h);</span>
            
<span class="fc" id="L880">        } else {</span>
            //System.out.println(&quot;---1&quot;);
<span class="fc" id="L882">            nodeMap.unsetRight(h);</span>
        }
       
        //System.out.println(&quot;  in RL after h.right h=&quot; + nodeToString(h));
        
<span class="fc bfc" id="L887" title="All 2 branches covered.">        if (nodeMap.parentIsSet(h)) {</span>
            //System.out.println(&quot;---2&quot;);
<span class="fc" id="L889">            long hParent = nodeMap.getParent(h);</span>
<span class="fc" id="L890">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L891" title="1 of 4 branches missed.">            if (nodeMap.leftIsSet(hParent) &amp;&amp; nodeMap.getLeft(hParent) ==</span>
                h) {
                //System.out.println(&quot;---3&quot;);
<span class="fc" id="L894">                nodeMap.updateLeft(hParent, x);</span>
            } else {
                //System.out.println(&quot;---4&quot;);
<span class="fc" id="L897">                nodeMap.updateRight(hParent, x);</span>
            }
<span class="fc" id="L899">        } else {</span>
            //System.out.println(&quot;---5&quot;);
<span class="fc" id="L901">            nodeMap.unsetParent(x);</span>
        }
                
        //x.left = h;
<span class="fc" id="L905">        nodeMap.updateLeft(x, h);</span>
<span class="fc" id="L906">        nodeMap.updateParent(h, x);</span>
        
        //System.out.println(&quot;  in RL after x.left h=&quot; + nodeToString(h));
        //System.out.println(&quot;  in RL after x.left x=&quot; + nodeToString(x));

        //x.color = x.left.color;
<span class="fc" id="L912">        nodeMap.updateNodeColor(x, nodeMap.getNodeColor(h));</span>
        //x.left.color = RED;
<span class="fc" id="L914">        nodeMap.updateNodeColor(h, RED);</span>
        
<span class="fc" id="L916">        nodeMap.updateNodeSize(x, nodeMap.getNodeSize(h));</span>
        
<span class="fc" id="L918">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L919">        nodeMap.updateNodeSize(h, size);</span>
               
        //System.out.println(&quot;  after RL: h=&quot; + nodeToString(h));
        
<span class="fc" id="L923">        return x;</span>
    }

    // flip the colors of a node and its two children

    /**
     *
     @param h
     */
    protected void flipColors(long h) {
        // h must have opposite color of its two children
<span class="pc bnc" id="L934" title="All 4 branches missed.">        assert(nodeMap.containsKey(h) &amp;&amp; nodeMap.leftIsSet(h) </span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            &amp;&amp; nodeMap.rightIsSet(h));</span>
<span class="pc bnc" id="L936" title="All 6 branches missed.">        assert(!isRed(h) &amp;&amp;  isLeftRed(h) &amp;&amp;  isRightRed(h))</span>
<span class="nc bnc" id="L937" title="All 6 branches missed.">        || (isRed(h)  &amp;&amp; !isLeftRed(h) &amp;&amp; !isRightRed(h));</span>
        
        /*
        h.color = !h.color;
        h.left.color = !h.left.color;
        h.right.color = !h.right.color;
        */
<span class="fc" id="L944">        int clr = nodeMap.getNodeColor(h);</span>
<span class="fc" id="L945">        clr ^= 1;</span>
<span class="fc" id="L946">        nodeMap.updateNodeColor(h, clr);</span>
        
<span class="fc" id="L948">        clr = nodeMap.getNodeColor(nodeMap.getLeft(h));</span>
<span class="fc" id="L949">        clr ^= 1;</span>
<span class="fc" id="L950">        nodeMap.updateNodeColor(nodeMap.getLeft(h), clr);</span>
        
<span class="fc" id="L952">        clr = nodeMap.getNodeColor(nodeMap.getRight(h));</span>
<span class="fc" id="L953">        clr ^= 1;</span>
<span class="fc" id="L954">        nodeMap.updateNodeColor(nodeMap.getRight(h), clr);</span>
<span class="fc" id="L955">    }</span>

    // Assuming that h is red and both h.left and h.left.left
    // are black, make h.left or one of its children red.

    /**
     *
     @param h
     @return
     */
    protected long moveRedLeft(long h) {
<span class="pc bnc" id="L966" title="All 2 branches missed.">        assert(nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L967" title="All 6 branches missed.">        assert(isRed(h) &amp;&amp; !isLeftRed(h) &amp;&amp; !isLeftLeftRed(h));</span>

        //System.out.println(&quot;moveRedLeft &quot; + nodeToString(h));
        
<span class="fc" id="L971">        flipColors(h);</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">        if (isRightLeftRed(h)) {</span>
            //h.right = rotateRight(h.right);
<span class="fc" id="L974">            long rKey = rotateRight(nodeMap.getRight(h));</span>
<span class="fc" id="L975">            nodeMap.updateRight(h, rKey);</span>
<span class="fc" id="L976">            nodeMap.updateParent(rKey, h);</span>
<span class="fc" id="L977">            h = rotateLeft(h);</span>
<span class="fc" id="L978">            flipColors(h);</span>
        }
<span class="fc" id="L980">        return h;</span>
    }

    //move red node down the right spine of the tree
    // Assuming that h is red and both h.right and h.right.left
    // are black, make h.right or one of its children red.
    private long moveRedRight(long h) {
<span class="pc bnc" id="L987" title="All 2 branches missed.">        assert (nodeMap.containsKey(h));</span>
<span class="pc bnc" id="L988" title="All 6 branches missed.">        assert(isRed(h) &amp;&amp; !isRightRed(h) &amp;&amp; !isRightLeftRed(h));</span>
        
<span class="fc" id="L990">        flipColors(h);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">        if (isLeftLeftRed(h)) { </span>
<span class="fc" id="L992">            h = rotateRight(h);</span>
<span class="fc" id="L993">            flipColors(h);</span>
        }
        
        //System.out.println(&quot;after moveRedRight h=&quot; + nodeToString(h));
        //printPreOrderTraversal();
        
<span class="fc" id="L999">        return h;</span>
    }

    // restore red-black tree invariant
    private long balance(long h) {
        
        //System.out.println(&quot;balance &quot; + nodeToString(h));
        
<span class="pc bnc" id="L1007" title="All 2 branches missed.">        assert (nodeMap.containsKey(h));</span>

<span class="fc bfc" id="L1009" title="All 2 branches covered.">        if (isRightRed(h))   {</span>
<span class="fc" id="L1010">            h = rotateLeft(h);</span>
        }
<span class="fc bfc" id="L1012" title="All 4 branches covered.">        if (isLeftRed(h) &amp;&amp; isLeftLeftRed(h)) {</span>
<span class="fc" id="L1013">            h = rotateRight(h);</span>
        }
<span class="fc bfc" id="L1015" title="All 4 branches covered.">        if (isLeftRed(h) &amp;&amp; isRightRed(h))  {</span>
<span class="fc" id="L1016">            flipColors(h);</span>
        }

<span class="fc" id="L1019">        int size = sizeLeft(h) + sizeRight(h) + 1;</span>
<span class="fc" id="L1020">        nodeMap.updateNodeSize(h, size);</span>
        
<span class="fc" id="L1022">        return h;</span>
    }


   /***************************************************************************
    *  Utility functions.
    ***************************************************************************/

    /**
     * Returns the height of the BST (for debugging).
     @return the height of the BST (a 1-node tree has height 0)
     */
    public int height() {
<span class="nc" id="L1035">        return height(root);</span>
    }
    private int height(long x) {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (!nodeMap.containsKey(x)) return -1;</span>
<span class="nc" id="L1039">        return 1 + Math.max(heightLeft(x), heightRight(x));</span>
    }
    private int heightLeft(long x) {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (!nodeMap.leftIsSet(x)) return -1;</span>
<span class="nc" id="L1043">        return height(nodeMap.getLeft(x));</span>
    }
    private int heightRight(long x) {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (!nodeMap.rightIsSet(x)) return -1;</span>
<span class="nc" id="L1047">        return height(nodeMap.getRight(x));</span>
    }

   /***************************************************************************
    *  Ordered symbol table methods.
    ***************************************************************************/

    /**
     * Returns the smallest key in the symbol table.
     @param output if output[0] == -1 no minimum was present,
     * else output[1] holds the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void min(long[] output) {
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;called min() with empty symbol table&quot;);</span>
<span class="fc" id="L1062">        output[0] = 0;</span>
<span class="fc" id="L1063">        min(root, output);</span>
<span class="fc" id="L1064">    }</span>

    // the smallest key in subtree rooted at x; null if no such key
    private void min(long x, long[] output) { 
        //assert(nodeMap.containsKey(x));
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1070">            output[0] = -1;</span>
<span class="nc" id="L1071">            return;</span>
        }
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        while (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1074">            x = nodeMap.getLeft(x);</span>
        }
<span class="fc" id="L1076">        output[1] = x;</span>
<span class="fc" id="L1077">    }</span>

    /**
     * Returns the largest key in the symbol table.
     @param output if output[0] == -1 no minimum was present,
     * else output[1] holds the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void max(long[] output) {
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">        if (isEmpty()) throw new NoSuchElementException(&quot;called max() with empty symbol table&quot;);</span>
<span class="fc" id="L1087">        output[0] = 0;</span>
<span class="fc" id="L1088">        max(root, output);</span>
<span class="fc" id="L1089">    } </span>

    // the largest key in the subtree rooted at x; null if no such key
    private void max(long x, long[] output) { 
        //assert(nodeMap.containsKey(x));
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1095">            output[0] = -1;</span>
<span class="nc" id="L1096">            return;</span>
        }
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        while (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1099">            x = nodeMap.getRight(x);</span>
        }
<span class="fc" id="L1101">        output[1] = x;</span>
<span class="fc" id="L1102">    }</span>

    /**
     * Returns the largest key in the symbol table less than or equal to {@code key}.
     @param key the key
     @param output if output[0] == -1, the key was not present, 
     * else output[1] holds the largest key in the symbol table less than or equal to {@code key}
     @throws NoSuchElementException if the tree is empty
     */
    public void floor(long key, long[] output) {
<span class="pc bpc" id="L1112" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1113">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1116">            output[0] = -1;</span>
<span class="nc" id="L1117">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1119">        floor(root, key, output);</span>
<span class="fc" id="L1120">    }    </span>

    /**
     * Returns the largest key in the symbol table less than {@code key}.
     @param key the key
     @param output if output[0] == -1, the key was not present, 
     * else output[1] holds the largest key in the symbol table less than or equal to {@code key}
     @throws NoSuchElementException if the tree is empty
     */
    public void lower(long key, long[] output) {
<span class="pc bpc" id="L1130" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1131">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1134">            output[0] = -1;</span>
<span class="nc" id="L1135">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1137">        TLongList stack = new TLongArrayList();</span>
<span class="fc" id="L1138">        output[0] = 0;</span>
<span class="fc" id="L1139">        lower(root, key, stack, output);</span>
<span class="fc" id="L1140">    }    </span>
    
    // the largest key in the subtree rooted at x less than or equal to the given key
    private void floor(long x, long key, long[] output) {
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1145">            output[0] = -1;</span>
<span class="nc" id="L1146">            return;</span>
        }
<span class="fc" id="L1148">        output[0] = 0;</span>
<span class="pc bpc" id="L1149" title="1 of 4 branches missed.">        int cmp = (key &lt; x) ? -1 : (key &gt; x) ? 1 : 0;</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">        if (cmp == 0) {</span>
<span class="nc" id="L1151">            output[1] = x;</span>
<span class="nc" id="L1152">            return;</span>
        }
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        if (cmp &lt; 0)  {</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1156">                floor(nodeMap.getLeft(x), key, output);</span>
<span class="fc" id="L1157">                return;</span>
            }
<span class="fc" id="L1159">            output[0] = -1;</span>
<span class="fc" id="L1160">            return;</span>
        }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1163">            floor(nodeMap.getRight(x), key, output);</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">            if (output[0] == -1) {</span>
<span class="fc" id="L1165">                output[0] = 0;</span>
<span class="fc" id="L1166">                output[1] = x;</span>
            }
<span class="fc" id="L1168">            return;</span>
        }
<span class="fc" id="L1170">        output[0] = 0;</span>
<span class="fc" id="L1171">        output[1] = x;</span>
<span class="fc" id="L1172">    }</span>
    
    /** the largest key in the subtree rooted at x less than the given key
     * 
     * The method is symmetric t the successor method called 
     * higher, as suggested by Cormen, Leiserson, Rivest, and Stein in
     * the book &quot;Introduction to Algorithms&quot;.
     * 
     @param x
     @param key
     @param stack
     @param output
     @return 
     */
    private void lower(long x, long key, TLongList stack, long[] output) { 
       
        //binary search until overshoot
<span class="fc" id="L1189">        long maxLower = Long.MAX_VALUE;</span>
<span class="pc bpc" id="L1190" title="1 of 4 branches missed.">        while (nodeMap.containsKey(x) &amp;&amp; key != x) {</span>
<span class="fc" id="L1191">            stack.add(x);</span>
            //System.out.println(&quot;lower: x=&quot; + x + &quot; q=&quot; + key);
<span class="fc bfc" id="L1193" title="All 2 branches covered.">            if (x &lt; key) {</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">                if (maxLower == Long.MAX_VALUE) {</span>
<span class="fc" id="L1195">                    maxLower = x;</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">                } else if (x &gt; maxLower) {</span>
<span class="fc" id="L1197">                    maxLower = x;</span>
                }
            }
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            if (key &lt; x) {</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1202">                    break;</span>
                }
<span class="fc" id="L1204">                x = nodeMap.getLeft(x);</span>
            } else {
                //System.out.println(&quot;   x=&quot; + x.key);
<span class="fc bfc" id="L1207" title="All 2 branches covered.">                if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1208">                    break;</span>
                }
<span class="fc" id="L1210">                x = nodeMap.getRight(x);</span>
            }
        }
        
<span class="fc" id="L1214">        long y = -1;</span>
<span class="fc" id="L1215">        int yIdx = -1;</span>
<span class="fc" id="L1216">        boolean yIsSet = false;</span>
        
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">            if (stack.size() &gt; 1) {</span>
<span class="nc" id="L1220">                x = stack.get(stack.size() - 1);</span>
<span class="nc" id="L1221">                yIdx = stack.size() - 2;</span>
<span class="nc" id="L1222">                y = stack.get(yIdx);</span>
<span class="nc" id="L1223">                yIsSet = true;</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">            } else if (stack.size() == 1) {</span>
<span class="nc" id="L1225">                x = stack.get(stack.size() - 1);</span>
            }
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        } else if (!stack.isEmpty()) {</span>
<span class="fc" id="L1228">            yIdx = stack.size() - 1;</span>
<span class="fc" id="L1229">            y = stack.get(yIdx);</span>
<span class="fc" id="L1230">            yIsSet = true;</span>
        }
        
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1234">            max(nodeMap.getLeft(x), output);</span>
<span class="fc" id="L1235">            return;</span>
        }
      
        //while (y != null &amp;&amp; x == y.left) {
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">        while (yIsSet &amp;&amp; </span>
            (
<span class="pc bpc" id="L1241" title="1 of 4 branches missed.">            (nodeMap.leftIsSet(y) &amp;&amp; nodeMap.containsKey(x) &amp;&amp;</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">            nodeMap.getLeft(y) == nodeMap.getNodeValue(x)) </span>
            || 
<span class="pc bpc" id="L1244" title="1 of 4 branches missed.">            (!nodeMap.leftIsSet(y) &amp;&amp; !nodeMap.containsKey(x))</span>
            )
            ) {
            
            //System.out.println(&quot;lower: y=&quot; + y.key + &quot; q=&quot; + key);
<span class="fc" id="L1249">            x = y;</span>
<span class="fc" id="L1250">            yIdx--;</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">            if (yIdx &lt; 0) break;</span>
<span class="fc" id="L1252">            y = stack.get(yIdx);</span>
<span class="fc" id="L1253">            yIsSet = true;</span>
        }
        
        //System.out.println(&quot;    y=&quot; + y.key + &quot; q=&quot; + key);
<span class="pc bpc" id="L1257" title="1 of 4 branches missed.">        if (yIsSet &amp;&amp; y &gt;= key) {</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">            if (maxLower &lt; Long.MAX_VALUE) {</span>
<span class="fc" id="L1259">                output[1] = maxLower;</span>
<span class="fc" id="L1260">                return;</span>
            }
<span class="fc" id="L1262">            output[0] = -1;</span>
<span class="fc" id="L1263">            return;</span>
        }
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">        if (yIsSet) {</span>
<span class="fc" id="L1266">            output[0] = 0;</span>
<span class="fc" id="L1267">            output[1] = y;</span>
        } else {
<span class="nc" id="L1269">            output[0] = -1;</span>
        }
<span class="fc" id="L1271">    }</span>

    /**
     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
     @param key the key
     @param output if output[0] == -1, the key was not present, 
     * else output[1] holds
     * the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if the tree is empty
     */
    public void ceiling(long key, long[] output) {
<span class="pc bpc" id="L1282" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1283">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1286">            output[0] = -1;</span>
<span class="nc" id="L1287">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1289">        output[0] = 0;</span>
<span class="fc" id="L1290">        ceiling(root, key, output);</span>
<span class="fc" id="L1291">    }</span>

    /**
     * Returns the smallest key in the symbol table greater than {@code key}.
     @param key the key
     @param output if output[0] == -1, the key was not present, 
     * else output[1] holds
     * the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if the tree is empty
     */
    public void higher(long key, final long[] output) {
<span class="pc bpc" id="L1302" title="2 of 4 branches missed.">        if (output == null || output.length != 2) {</span>
<span class="nc" id="L1303">            throw new IllegalArgumentException(&quot;output must be length 2&quot;);</span>
        }
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1306">            output[0] = -1;</span>
<span class="nc" id="L1307">            throw new NoSuchElementException(&quot;called floor() with empty symbol table&quot;);</span>
        }
<span class="fc" id="L1309">        higher(root, key, output);</span>
<span class="fc" id="L1310">    }</span>
    
    // the smallest key in the subtree rooted at x greater than or equal to the given key
    private void ceiling(long x, long key, long[] output) {
        
        //TODO: make this iterative
        
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1318">            output[0] = -1;</span>
<span class="nc" id="L1319">            return;</span>
        }
<span class="fc" id="L1321">        output[0] = 0;</span>
<span class="pc bpc" id="L1322" title="1 of 4 branches missed.">        int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">        if (cmp == 0) {</span>
<span class="nc" id="L1324">            output[1] = x;</span>
<span class="nc" id="L1325">            return;</span>
        }
<span class="fc bfc" id="L1327" title="All 2 branches covered.">        if (cmp &gt; 0)  {</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1329">                ceiling(nodeMap.getRight(x), key, output);</span>
            } else {
<span class="fc" id="L1331">                output[0] = -1;</span>
            }
<span class="fc" id="L1333">            return;</span>
        }
        /*
        Node t = ceiling(x.left, key);
        if (t != null) {
            return t;
        } else {
            return x;
        }*/
<span class="fc bfc" id="L1342" title="All 2 branches covered.">        if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1343">            ceiling(nodeMap.getLeft(x), key, output);</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">            if (output[0] == -1) {</span>
<span class="fc" id="L1345">                output[0] = 0;</span>
<span class="fc" id="L1346">                output[1] = x;</span>
            }
        } else {
<span class="fc" id="L1349">            output[0] = 0;</span>
<span class="fc" id="L1350">            output[1] = x;</span>
        }
<span class="fc" id="L1352">    }</span>
    
    /** the smallest key in the subtree rooted at x greater than the given key.
     * 
     * NOTE: the method uses in part, a pattern adapted from the Cormen, Leiserson, Rivest, and Stein
     * book &quot;Introduction to Algorithms&quot; for their Red Black Tree.
     * 
     @param x
     @param key
     @param output
     @return 
     */
    private void higher(long x, long key, final long[] output) {  
        
        //System.out.println(&quot;higher: x=&quot; + x + &quot; key=&quot; + key);
        
        /*
                    X
        left .lte.     right .gte.
        */
        
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L1374" title="All 4 branches covered.">            int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0; </span>
            //System.out.println(&quot;higher: x=&quot; + x + &quot; cmp=&quot; + cmp);
<span class="fc bfc" id="L1376" title="All 2 branches covered.">            if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1378">                    x = nodeMap.getLeft(x);</span>
                } else {
                    break;
                }
<span class="fc bfc" id="L1382" title="All 2 branches covered.">            } else if (cmp &gt; 0) {</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">                if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1384">                    x = nodeMap.getRight(x);</span>
                } else {
                    break;
                }
            } else {
                break;
            }
<span class="fc" id="L1391">        }</span>
                
        // right node has larger key
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1395">            output[0] = 0;</span>
<span class="fc" id="L1396">            min(nodeMap.getRight(x), output);</span>
            //System.out.println(&quot;min=&quot; + Arrays.toString(output));
<span class="fc" id="L1398">            return;</span>
        }
<span class="fc" id="L1400">        boolean yIsSet = false;</span>
<span class="fc" id="L1401">        long y = -1;</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L1403">            y = nodeMap.getParent(x);</span>
<span class="fc" id="L1404">            yIsSet = true;</span>
            //System.out.println(&quot;y=&quot; + y);
        }
<span class="fc bfc" id="L1407" title="All 4 branches covered.">        while (yIsSet &amp;&amp; nodeMap.rightIsSet(y) &amp;&amp;</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">            x == nodeMap.getRight(y)) {</span>
            //System.out.println(&quot;y=&quot; + y + &quot; setting x=&quot; + x + &quot; to y&quot;);
<span class="fc" id="L1410">            x = y;</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">            if (nodeMap.parentIsSet(x)) {</span>
<span class="fc" id="L1412">                y = nodeMap.getParent(x);</span>
            } else {
<span class="fc" id="L1414">                yIsSet = false;</span>
<span class="fc" id="L1415">                y = -1;</span>
            }
        }
<span class="pc bpc" id="L1418" title="2 of 6 branches missed.">        if (x &gt; key &amp;&amp; yIsSet &amp;&amp; y &gt; key) {</span>
<span class="fc" id="L1419">            output[0] = 0;</span>
<span class="pc bpc" id="L1420" title="1 of 2 branches missed.">            if (x &lt; y) {</span>
<span class="fc" id="L1421">                output[1] = x;</span>
            } else {
<span class="nc" id="L1423">                output[1] = y;</span>
            }
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">        } else if (x &gt; key) {</span>
<span class="nc" id="L1426">            output[0] = 0;</span>
<span class="nc" id="L1427">            output[1] = x;</span>
<span class="pc bpc" id="L1428" title="1 of 4 branches missed.">        } else if (yIsSet &amp;&amp; y &gt; key) {</span>
<span class="fc" id="L1429">            output[0] = 0;</span>
<span class="fc" id="L1430">            output[1] = y;</span>
        } else {
<span class="fc" id="L1432">            output[0] = -1;</span>
        }
<span class="fc" id="L1434">    }</span>

    /**
     * Return the kth smallest key in the symbol table.
     @param k the order statistic
     @return the {@code k}th smallest key in the symbol table
     * @throws IllegalArgumentException unless {@code k} is between 0 and
     *     &lt;em&gt;n&lt;/em&gt;â€“1
     */
    public long select(int k) {
<span class="pc bpc" id="L1444" title="2 of 4 branches missed.">        if (k &lt; 0 || k &gt;= size()) {</span>
<span class="nc" id="L1445">            throw new IllegalArgumentException(&quot;called select() with invalid argument: &quot; + k);</span>
        }
<span class="fc" id="L1447">        long[] output = new long[2];</span>
<span class="fc" id="L1448">        select(root, k, output);</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L1450">            return -1;</span>
        }
<span class="fc" id="L1452">        return output[1];</span>
    }

    // the key of rank k in the subtree rooted at x
    private void select(long x, int k, long[] output) {
        
        //TODO: make this iterative
        
<span class="pc bnc" id="L1460" title="All 2 branches missed.">        assert(nodeMap.containsKey(x));</span>
<span class="pc bnc" id="L1461" title="All 4 branches missed.">        assert(k &gt;= 0 &amp;&amp; k &lt; size(x));</span>
        
<span class="fc" id="L1463">        output[0] = 0;</span>
        
<span class="fc" id="L1465">        int t = sizeLeft(x); </span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (t &gt; k) {</span>
<span class="fc" id="L1467">            select(nodeMap.getLeft(x),  k, output);</span>
<span class="fc bfc" id="L1468" title="All 2 branches covered.">        } else if (t &lt; k) {</span>
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1470">                select(nodeMap.getRight(x), k-t-1, output);</span>
            } else {
<span class="nc" id="L1472">                output[0] = -1;</span>
            }
        } else {
<span class="fc" id="L1475">            output[1] = x;</span>
        }
<span class="fc" id="L1477">    } </span>

    /**
     * Return the number of keys in the symbol table strictly less than {@code key}.
     @param key the key
     @return the number of keys in the symbol table strictly less than {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public int rank(long key) {
<span class="fc" id="L1486">        int[] output = new int[2];</span>
<span class="fc" id="L1487">        rank(key, root, output);</span>
<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">        if (output[0] == -1) {</span>
<span class="nc" id="L1489">            return 0;</span>
        }
<span class="fc" id="L1491">        return output[1];</span>
    } 

    // number of keys less than key in the subtree rooted at x
    private void rank(long key, long x, int[] output) {
        
        //TODO: make this iterative
<span class="fc" id="L1498">        output[0] = 0;</span>
        
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1501">            output[1] = 0;</span>
<span class="nc" id="L1502">            return;</span>
        } 
<span class="fc bfc" id="L1504" title="All 4 branches covered.">        int cmp = key &lt; x ? -1 : (key &gt; x) ? 1 : 0;  </span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">        if (cmp &lt; 0) {</span>
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1507">                rank(key, nodeMap.getLeft(x), output);</span>
            } else {
<span class="nc" id="L1509">                output[1] = 0;</span>
            }
<span class="fc bfc" id="L1511" title="All 2 branches covered.">        } else if (cmp &gt; 0) {</span>
            //1 + size(x.left) + rank(key, x.right);
            int sz;
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1515">                output[0] = 0;</span>
<span class="fc" id="L1516">                rank(key, nodeMap.getRight(x), output);</span>
<span class="pc bpc" id="L1517" title="1 of 2 branches missed.">                if (output[0] == -1) {</span>
<span class="nc" id="L1518">                    sz = 1 + sizeLeft(x);</span>
                } else {
<span class="fc" id="L1520">                    sz = 1 + sizeLeft(x) + output[1];</span>
                }
            } else {
<span class="nc" id="L1523">                sz = 1 + sizeLeft(x);</span>
            }
<span class="fc" id="L1525">            output[1] = sz;</span>
<span class="fc" id="L1526">        } else {</span>
<span class="fc" id="L1527">            int sz = sizeLeft(x);</span>
<span class="fc" id="L1528">            output[1] = sz;</span>
        } 
<span class="fc" id="L1530">    } </span>

   /***************************************************************************
    *  Range count and range search.
    ***************************************************************************/

    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     @return all keys in the symbol table as an {@code Iterable}
     */
    public TLongList keys() {
        
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">        if (isEmpty()) return new TLongArrayList();</span>
        
<span class="fc" id="L1546">        long[] output = new long[2];</span>
<span class="fc" id="L1547">        min(output);</span>
<span class="pc bnc" id="L1548" title="All 2 branches missed.">        assert(output[0] != -1);</span>
<span class="fc" id="L1549">        long lo = output[1];</span>
        
<span class="fc" id="L1551">        max(output);</span>
<span class="pc bnc" id="L1552" title="All 2 branches missed.">        assert(output[0] != -1);</span>
<span class="fc" id="L1553">        long hi = output[1];</span>
        
<span class="fc" id="L1555">        return keys(lo, hi);</span>
    }

    /**
     * Returns all keys in the symbol table in the given range,
     * as an {@code Iterable}.
     *
     @param  lo minimum endpoint
     @param  hi maximum endpoint
     @return all keys in the sybol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive) as an {@code Iterable}
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */
    public TLongList keys(long lo, long hi) {

<span class="fc" id="L1571">        TLongList queue = new TLongArrayList();</span>
<span class="pc bpc" id="L1572" title="2 of 4 branches missed.">        if (isEmpty() || lo &gt; hi) return queue;</span>
        
<span class="fc" id="L1574">        keys(root, queue, lo, hi);</span>
        
<span class="fc" id="L1576">        return queue;</span>
    } 

    // add the keys between lo and hi in the subtree rooted at x
    // to the queue
    private void keys(long x, TLongList queue, long lo, long hi) {
        
        //TODO: make this iterative
        
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1586">            return;</span>
        } 
<span class="pc bpc" id="L1588" title="1 of 4 branches missed.">        int cmplo = lo &lt; x ? -1 : (lo &gt; x) ? 1 : 0;</span>
<span class="pc bpc" id="L1589" title="1 of 4 branches missed.">        int cmphi = hi &lt; x ? -1 : (hi &gt; x) ? 1 : 0; </span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">        if (cmplo &lt; 0) {</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">            if (nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1592">                keys(nodeMap.getLeft(x), queue, lo, hi);</span>
            }
        } 
<span class="pc bpc" id="L1595" title="2 of 4 branches missed.">        if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) {</span>
<span class="fc" id="L1596">            queue.add(x);</span>
        } 
<span class="fc bfc" id="L1598" title="All 2 branches covered.">        if (cmphi &gt; 0) {</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">            if (nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1600">                keys(nodeMap.getRight(x), queue, lo, hi);</span>
            }
        } 
<span class="fc" id="L1603">    } </span>

    /**
     * Returns the number of keys in the symbol table in the given range.
     *
     @param  lo minimum endpoint
     @param  hi maximum endpoint
     @return the number of keys in the sybol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */
    public int size(long lo, long hi) {

<span class="nc bnc" id="L1617" title="All 2 branches missed.">        if (lo &gt; hi) return 0;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if (contains(hi)) return rank(hi) - rank(lo) + 1;</span>
<span class="nc" id="L1619">        else              return rank(hi) - rank(lo);</span>
    }


   /***************************************************************************
    *  Check integrity of red-black tree data structure.
     @return 
    ***************************************************************************/
    protected boolean check() {
<span class="fc" id="L1628">        boolean t1 = isParentChildConsistent();</span>
<span class="fc" id="L1629">        boolean t2 = isBST();</span>
<span class="fc" id="L1630">        boolean t3 = isSizeConsistent();</span>
<span class="fc" id="L1631">        boolean t4 = isRankConsistent();</span>
<span class="fc" id="L1632">        boolean t5 = is23();</span>
<span class="fc" id="L1633">        boolean t6 = isBalanced();</span>
<span class="pc bpc" id="L1634" title="1 of 2 branches missed.">        if (!t1) System.out.println(&quot;Not consistent parent child relationships&quot;);</span>
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        if (!t2) System.out.println(&quot;Not in symmetric order&quot;);</span>
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">        if (!t3) System.out.println(&quot;Subtree counts not consistent&quot;);</span>
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">        if (!t4) System.out.println(&quot;Ranks not consistent&quot;);</span>
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">        if (!t5) System.out.println(&quot;Not a 2-3 tree&quot;);</span>
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">        if (!t6) System.out.println(&quot;Not balanced&quot;);</span>
<span class="fc" id="L1640">        System.out.flush();</span>
<span class="pc bpc" id="L1641" title="6 of 12 branches missed.">        return t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4 &amp;&amp; t5 &amp;&amp; t6;</span>
    }

    // does this binary tree satisfy symmetric order?
    // Note: this test also ensures that data structure is a binary tree since order is strict
    private boolean isBST() {
<span class="fc" id="L1647">        return isBST(root, null, null);</span>
    }

    // is the tree rooted at x a BST with all keys strictly between min and max
    // (if min or max is null, treat as empty constraint)
    // Credit: Bob Dondero's elegant solution
    private boolean isBST(long x, Long min, Long max) {
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1655">            return true;</span>
        }
<span class="pc bpc" id="L1657" title="1 of 4 branches missed.">        if (min != null &amp;&amp; x &lt;= min.longValue()) {</span>
<span class="nc" id="L1658">            return false;</span>
        }
<span class="pc bpc" id="L1660" title="1 of 4 branches missed.">        if (max != null &amp;&amp; x &gt;= max.longValue()) {</span>
<span class="nc" id="L1661">            return false;</span>
        }
<span class="fc" id="L1663">        Long key = Long.valueOf(x);</span>
<span class="pc bpc" id="L1664" title="2 of 4 branches missed.">        return isBSTLeft(x, min, key) &amp;&amp; isBSTRight(x, key, max);</span>
    }
    private boolean isBSTLeft(long x, Long min, Long max) {
<span class="fc bfc" id="L1667" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1668">            return true;</span>
        }
<span class="fc" id="L1670">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1671">        return isBST(key, min, max);</span>
    }
    private boolean isBSTRight(long x, Long min, Long max) {
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="fc" id="L1675">            return true;</span>
        }
<span class="fc" id="L1677">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1678">        return isBST(key, min, max);</span>
    }

<span class="fc" id="L1681">    private boolean isSizeConsistent() { return isSizeConsistent(root); }</span>
    private boolean isSizeConsistent(long x) {
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) return true;</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">        if (nodeMap.getNodeSize(x) != sizeLeft(x) + sizeRight(x) + 1) return false;</span>
<span class="pc bpc" id="L1685" title="2 of 4 branches missed.">        return isSizeConsistentLeft(x) &amp;&amp; isSizeConsistentRight(x);</span>
    }
    private boolean isSizeConsistentLeft(long x) {
<span class="fc bfc" id="L1688" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return true;</span>
<span class="fc" id="L1689">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1690">        return isSizeConsistent(key);</span>
    }
    private boolean isSizeConsistentRight(long x) {
<span class="fc bfc" id="L1693" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return true;</span>
<span class="fc" id="L1694">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1695">        return isSizeConsistent(key);</span>
    }

    // check that ranks are consistent
    private boolean isRankConsistent() {
<span class="fc bfc" id="L1700" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++) {</span>
<span class="fc" id="L1701">            int r = rank(select(i));</span>
            //System.out.println(&quot;i=&quot; + i + &quot; r=&quot; + r + &quot; size=&quot; + size());
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">            if (i != r) return false;</span>
        }
<span class="fc" id="L1705">        TLongList keys = keys();</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.size(); ++i) {</span>
<span class="fc" id="L1707">            long key = keys.get(i);</span>
<span class="fc" id="L1708">            int r = rank(key);</span>
<span class="fc" id="L1709">            long s = select(r);</span>
            //System.out.println(&quot;i=&quot; + i + &quot; key=&quot; + key + &quot; r=&quot; + r + &quot; s=&quot; + s);
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">            if (key != s) {</span>
<span class="nc" id="L1712">                return false;</span>
            }
        }
<span class="fc" id="L1715">        return true;</span>
    }

    // Does the tree have no red right links, and at most one (left)
    // red links in a row on any path?
<span class="fc" id="L1720">    private boolean is23() { return is23(root); }</span>
    private boolean is23(long x) {
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc" id="L1723">            return true;</span>
        }
<span class="pc bpc" id="L1725" title="1 of 2 branches missed.">        if (isRightRed(x)) {</span>
<span class="nc" id="L1726">            return false;</span>
        }
<span class="pc bpc" id="L1728" title="1 of 6 branches missed.">        if (x != root &amp;&amp; isRed(x) &amp;&amp; isLeftRed(x)) {</span>
<span class="nc" id="L1729">            return false;</span>
        }
<span class="pc bpc" id="L1731" title="2 of 4 branches missed.">        return is23Left(x) &amp;&amp; is23Right(x);</span>
    }
    private boolean is23Left(long x) {
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) return true;</span>
<span class="fc" id="L1735">        return is23(nodeMap.getLeft(x));</span>
    }
    private boolean is23Right(long x) {
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) return true;</span>
<span class="fc" id="L1739">        return is23(nodeMap.getRight(x));</span>
    }

    // do all paths from root to leaf have same number of black edges?
    private boolean isBalanced() { 
<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">        if (!rootIsSet) {</span>
<span class="nc" id="L1745">            return true;</span>
        }
<span class="fc" id="L1747">        int black = 0;     // number of black links on path from root to min</span>
<span class="fc" id="L1748">        long x = root;</span>
<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">        while (nodeMap.containsKey(x)) {</span>
<span class="fc bfc" id="L1750" title="All 2 branches covered.">            if (!isRed(x)) {</span>
<span class="fc" id="L1751">                black++;</span>
            }
<span class="fc bfc" id="L1753" title="All 2 branches covered.">            if (!nodeMap.leftIsSet(x)) {</span>
<span class="fc" id="L1754">                break;</span>
            }
<span class="fc" id="L1756">            x = nodeMap.getLeft(x);</span>
        }
<span class="fc" id="L1758">        return isBalanced(root, black);</span>
    }

    // does every path from the root to a leaf have the given number of black links?
    private boolean isBalanced(long x, int black) {
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(x)) {</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">            return black == 0;</span>
        }
<span class="fc bfc" id="L1766" title="All 2 branches covered.">        if (!isRed(x)) {</span>
<span class="fc" id="L1767">            black--;</span>
        }
<span class="pc bpc" id="L1769" title="2 of 4 branches missed.">        return isLeftBalanced(x, black) &amp;&amp; isRightBalanced(x, black);</span>
    }
    private boolean isLeftBalanced(long x, int black) {
<span class="fc bfc" id="L1772" title="All 2 branches covered.">        if (!nodeMap.leftIsSet(x)) {</span>
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">            return black == 0;</span>
        }
<span class="fc" id="L1775">        long key = nodeMap.getLeft(x);</span>
<span class="fc" id="L1776">        return isBalanced(key, black);</span>
    } 
    private boolean isRightBalanced(long x, int black) {
<span class="fc bfc" id="L1779" title="All 2 branches covered.">        if (!nodeMap.rightIsSet(x)) {</span>
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">            return black == 0;</span>
        }
<span class="fc" id="L1782">        long key = nodeMap.getRight(x);</span>
<span class="fc" id="L1783">        return isBalanced(key, black);</span>
    } 
    
    /**
     * left subtree, root, right subtree
     */
    public void printInOrderTraversal() {
<span class="fc" id="L1790">        System.out.print(&quot;root=&quot;);</span>
<span class="pc bpc" id="L1791" title="1 of 2 branches missed.">        if (rootIsSet) {</span>
<span class="fc" id="L1792">            System.out.print(root);</span>
        }
<span class="fc" id="L1794">        System.out.println(&quot;&quot;);</span>
<span class="fc" id="L1795">        long[] nodes = getInOrderTraversalIterative(root);</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1797">            System.out.println(&quot;node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1799">    }</span>
    
    /**
     * root, left subtree, right subtree
     */
    public void printPreOrderTraversal() {
<span class="fc" id="L1805">        System.out.print(&quot;root=&quot;);</span>
<span class="pc bpc" id="L1806" title="1 of 2 branches missed.">        if (rootIsSet) {</span>
<span class="fc" id="L1807">            System.out.print(root);</span>
        }
<span class="fc" id="L1809">        System.out.println(&quot; size=&quot; + size());</span>
<span class="fc" id="L1810">        long[] nodes = getPreOrderTraversalIterative(root, 1);</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1812">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1814">    }</span>

    /**
     *
     @param topNode
     */
    public void printPreOrderTraversal2(long topNode) {
<span class="nc" id="L1821">        System.out.print(&quot;root=&quot;);</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (rootIsSet) {</span>
<span class="nc" id="L1823">            System.out.print(root);</span>
        }
<span class="nc" id="L1825">        System.out.println(&quot; size=&quot; + size());</span>
<span class="nc" id="L1826">        long[] nodes = getPreOrderTraversalIterative(topNode, 1);</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        for (long node : nodes) {</span>
<span class="nc" id="L1828">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="nc" id="L1830">    }</span>
    private void printPreOrderTraversal(int addExtraToSize) {
<span class="nc" id="L1832">        long[] nodes = getPreOrderTraversalIterative(root, </span>
            addExtraToSize);
<span class="nc" id="L1834">        System.out.print(&quot;root=&quot;);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        if (rootIsSet) {</span>
<span class="nc" id="L1836">            System.out.print(root);</span>
        }
<span class="nc" id="L1838">        System.out.println(&quot;&quot;);</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        for (long node : nodes) {</span>
<span class="nc" id="L1840">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="nc" id="L1842">    }</span>
    
    /**
     * left subtree, right subtree, root subtree
     */
    public void printPostOrderTraversal() {
<span class="fc" id="L1848">        long[] nodes = getPostOrderTraversalIterative(root);</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        for (long node : nodes) {</span>
<span class="fc" id="L1850">            System.out.println(&quot;  node=&quot; + nodeToString(node));</span>
        }
<span class="fc" id="L1852">    }</span>

    /**
     * visit each node using pattern left subtree, root, right subtree
     * in an iterative manner rather than invoking the method recursively.
     @param node
     @return 
     */
    protected long[] getInOrderTraversalIterative(Long node) {
       
<span class="pc bpc" id="L1862" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1863">            return new long[0];</span>
        }
        
<span class="fc" id="L1866">        int sz = size();</span>
        
<span class="fc" id="L1868">        long[] array = new long[sz];</span>
<span class="fc" id="L1869">        int count = 0;</span>
        
<span class="fc" id="L1871">        Stack&lt;Long&gt; stack = new Stack&lt;&gt;();</span>
               
<span class="fc bfc" id="L1873" title="All 4 branches covered.">        while (!stack.isEmpty() || (node != null)) {</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">            if (node != null) {</span>
                 
<span class="fc" id="L1876">                stack.push(node);</span>
                
<span class="fc bfc" id="L1878" title="All 2 branches covered.">                node = nodeMap.leftIsSet(node.longValue()) ?</span>
<span class="fc" id="L1879">                    nodeMap.getLeft(node.longValue()) : null;</span>
            
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">            } else if (count &lt; sz) {</span>
                
<span class="fc" id="L1883">                node = stack.pop();</span>
                
<span class="fc" id="L1885">                array[count] = node;</span>
<span class="fc" id="L1886">                count++;</span>
                
                //System.out.println(node.key);
                
<span class="fc bfc" id="L1890" title="All 2 branches covered.">                node = nodeMap.rightIsSet(node.longValue()) ?</span>
<span class="fc" id="L1891">                    nodeMap.getRight(node.longValue()) : null;</span>
            }
        }
<span class="pc bpc" id="L1894" title="1 of 2 branches missed.">        if (count &lt; sz) {</span>
            // can happen during debugging when insert is not complete yet
<span class="nc" id="L1896">            array = Arrays.copyOf(array, count);</span>
        }
        
<span class="fc" id="L1899">        return array;</span>
    }
    
    /**
     * visit each node using pattern: 
     *     root, left subtree, right subtree
     * in an iterative manner rather than invoking the method recursively.
     @param node
     @param addExtraToSize
     @return 
     */
    protected long[] getPreOrderTraversalIterative(Long node, int addExtraToSize) {
       
        //NOTE: added additional integer and conditions 
        //   for size because may be printing tree
        //   in the middle of a put where the node size is not yet updated.
        // The count conditionals below are otherwise, not needed.
        
<span class="pc bpc" id="L1917" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1918">            return new long[0];</span>
        }
                
<span class="fc" id="L1921">        int sz = size(node) + addExtraToSize;</span>
        
<span class="fc" id="L1923">        long[] array = new long[sz];</span>
<span class="fc" id="L1924">        int count = 0;</span>
        
<span class="fc" id="L1926">        Stack&lt;Long&gt; stack = new Stack&lt;&gt;();</span>
        
<span class="fc bfc" id="L1928" title="All 6 branches covered.">        while (count &lt; sz &amp;&amp; (!stack.isEmpty() || node != null)) {</span>
<span class="pc bpc" id="L1929" title="1 of 4 branches missed.">            if (node != null &amp;&amp; count &lt; sz) {</span>
                
<span class="fc" id="L1931">                array[count] = node;</span>
<span class="fc" id="L1932">                count++;</span>
                //System.out.println(node);
                
<span class="fc bfc" id="L1935" title="All 2 branches covered.">                if (count &lt; sz) {</span>
<span class="fc" id="L1936">                    stack.push(node);</span>
                }
                
<span class="fc bfc" id="L1939" title="All 2 branches covered.">                node = nodeMap.leftIsSet(node.longValue()) ?</span>
<span class="fc" id="L1940">                    nodeMap.getLeft(node.longValue()) : null;</span>
            
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">            } else if (count &lt; sz) {</span>
                
<span class="fc" id="L1944">                node = stack.pop();</span>
                
<span class="fc bfc" id="L1946" title="All 2 branches covered.">                node = nodeMap.rightIsSet(node.longValue()) ?</span>
<span class="fc" id="L1947">                    nodeMap.getRight(node.longValue()) : null;</span>
            }
        }
        
<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (count &lt; sz) {</span>
<span class="fc" id="L1952">            array = Arrays.copyOf(array, count);</span>
        }
        
<span class="fc" id="L1955">        return array;</span>
    }

    /**
     * visit each node using pattern: 
     *     left subtree, right subtree, root subtree
     * in an iterative manner rather than invoking the method recursively.
     @param node
     @return 
     */
    protected long[] getPostOrderTraversalIterative(Long node) {
    
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L1968">            return new long[0];</span>
        }
        
<span class="fc" id="L1971">        int sz = size();</span>
        
<span class="fc" id="L1973">        long[] array = new long[sz];</span>
<span class="fc" id="L1974">        int count = 0;</span>
        
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L1977">            return array;</span>
        }
        
<span class="fc" id="L1980">        Stack&lt;Long&gt; stack = new Stack&lt;Long&gt;();</span>
<span class="fc" id="L1981">        Stack&lt;Long&gt; stack2 = new Stack&lt;Long&gt;();</span>
<span class="fc" id="L1982">        stack.push(node);</span>
        
<span class="fc bfc" id="L1984" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
            
<span class="fc" id="L1986">            node = stack.pop();</span>
            
<span class="fc" id="L1988">            stack2.push(node);</span>
            
<span class="fc bfc" id="L1990" title="All 2 branches covered.">            if (nodeMap.leftIsSet(node.longValue())) {</span>
<span class="fc" id="L1991">                stack.push(nodeMap.getLeft(node.longValue()));</span>
            }

<span class="fc bfc" id="L1994" title="All 2 branches covered.">            if (nodeMap.rightIsSet(node.longValue())) {</span>
<span class="fc" id="L1995">                stack.push(nodeMap.getRight(node.longValue()));</span>
            }
        }
        
<span class="pc bpc" id="L1999" title="1 of 4 branches missed.">        while (!stack2.isEmpty() &amp;&amp; count &lt; sz) {</span>
            
<span class="fc" id="L2001">            node = stack2.pop();</span>
            
            //process(node);
<span class="fc" id="L2004">            array[count] = node;</span>
<span class="fc" id="L2005">            count++;</span>
            //System.out.println(node);
        }
        
<span class="pc bpc" id="L2009" title="1 of 2 branches missed.">        if (count &lt; sz) {</span>
            // can happen during debugging when insert is not complete yet
<span class="nc" id="L2011">            array = Arrays.copyOf(array, count);</span>
        }
         
<span class="fc" id="L2014">        return array;</span>
    }
   
    /**
    visit each node using pattern root node, then all direct children of root node (=level 2),
    then all direct children of those children (=level 3), etc
    in an iterative manner.
     @param node
     @return 
    */
    protected long[] getLevelOrderTraversalIterative(Long node) {
<span class="nc bnc" id="L2025" title="All 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L2026">            return new long[0];</span>
        }
        
<span class="nc" id="L2029">        int sz = size();</span>
        
<span class="nc" id="L2031">        long[] array = new long[sz];</span>
<span class="nc" id="L2032">        int count = 0;</span>
        
<span class="nc bnc" id="L2034" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L2035">            return array;</span>
        }
        
        // can use stacks or queues interchangeably here, but if prefer 
        //   left to right norder, will want queues.
<span class="nc" id="L2040">        java.util.Queue&lt;Long&gt; level = new ArrayDeque&lt;Long&gt;();</span>
<span class="nc" id="L2041">        java.util.Queue&lt;Long&gt; nextLevel = new ArrayDeque&lt;Long&gt;();</span>
        
<span class="nc" id="L2043">        level.add(node);</span>
        
        while (true) {
<span class="nc bnc" id="L2046" title="All 2 branches missed.">            while (!level.isEmpty()) {</span>
<span class="nc" id="L2047">                node = level.poll();</span>
<span class="nc" id="L2048">                array[count] = node;</span>
<span class="nc" id="L2049">                count++;</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">                if (nodeMap.leftIsSet(node.longValue())) {</span>
<span class="nc" id="L2051">                    nextLevel.add(nodeMap.getLeft(node.longValue()));</span>
                }
<span class="nc bnc" id="L2053" title="All 2 branches missed.">                if (nodeMap.rightIsSet(node.longValue())) {</span>
<span class="nc" id="L2054">                    nextLevel.add(nodeMap.getRight(node.longValue()));</span>
                } 
            }
<span class="nc bnc" id="L2057" title="All 2 branches missed.">            if (nextLevel.isEmpty()) {</span>
<span class="nc" id="L2058">                break;</span>
            }
<span class="nc" id="L2060">            level.addAll(nextLevel);</span>
<span class="nc" id="L2061">            nextLevel.clear();</span>
        }
                
<span class="nc" id="L2064">        return array;</span>
    }
    
    /**
     * estimate the size that an instance of RedBlackBSTLongInt with
     * n entries would occupy in heap space in Bytes.
     * 
     @param numberOfEntries amount of space for this object's instance
     * with n entries in Bytes on the heap.
     * 
     @return 
     */
    public static long estimateSizeOnHeap(int numberOfEntries) {
        
<span class="fc" id="L2078">        long total = 0;</span>
       
<span class="fc" id="L2080">        ObjectSpaceEstimator est = new ObjectSpaceEstimator();</span>
<span class="fc" id="L2081">        est.setNBooleanFields(1);</span>
<span class="fc" id="L2082">        est.setNLongFields(1);</span>
<span class="fc" id="L2083">        est.setNArrayRefsFields(1);</span>
<span class="fc" id="L2084">        est.setNIntFields(4);</span>
       
<span class="fc" id="L2086">        total += est.estimateSizeOnHeap();</span>
        
<span class="fc" id="L2088">        total += NodeMap.estimateSizeOnHeap(numberOfEntries);</span>
             
<span class="fc" id="L2090">        return total;</span>
    }
    
    private String nodeToString(long key) {
        //assert(nodeMap.containsKey(key));
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">        if (!nodeMap.containsKey(key)) {</span>
            // this can happen in the middle of a method, for example,
            // when root has been removed and new is not yet assigned
<span class="nc" id="L2098">            System.out.println(&quot;ERROR: key &quot; + key + &quot; not in maps&quot;);</span>
<span class="nc" id="L2099">            return &quot;&quot;;</span>
        }
        
<span class="fc" id="L2102">        StringBuilder sb = new StringBuilder();</span>
        //node=key=0 val=0 color=false size=1
<span class="fc" id="L2104">        sb.append(&quot;key=&quot;).append(key).append(&quot; val=&quot;).append(nodeMap.getNodeValue(key));</span>
<span class="fc" id="L2105">        sb.append(&quot; color=&quot;).append(nodeMap.getNodeColor(key));</span>
<span class="fc" id="L2106">        sb.append(&quot; size=&quot;).append(nodeMap.getNodeSize(key));</span>
<span class="fc" id="L2107">        sb.append(&quot; p=&quot;);</span>
<span class="fc bfc" id="L2108" title="All 2 branches covered.">        if (nodeMap.parentIsSet(key)) {</span>
<span class="fc" id="L2109">           sb.append(nodeMap.getParent(key));</span>
        }
<span class="fc" id="L2111">        sb.append(&quot; l=&quot;);</span>
<span class="fc bfc" id="L2112" title="All 2 branches covered.">        if (nodeMap.leftIsSet(key)) {</span>
<span class="fc" id="L2113">           sb.append(nodeMap.getLeft(key));</span>
        }
<span class="fc" id="L2115">        sb.append(&quot; r=&quot;);</span>
<span class="fc bfc" id="L2116" title="All 2 branches covered.">        if (nodeMap.rightIsSet(key)) {</span>
<span class="fc" id="L2117">           sb.append(nodeMap.getRight(key));</span>
        }
<span class="fc" id="L2119">        return sb.toString();</span>
    }

    private boolean isParentChildConsistent() {
        
<span class="fc" id="L2124">        boolean passed = true;</span>
        
<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">        if (!rootIsSet) {</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">            if (!nodeMap.isEmpty()) {</span>
<span class="nc" id="L2128">                System.err.println(&quot;maps not empty, but root is&quot;);</span>
<span class="nc" id="L2129">                passed = false;</span>
            }
        }
        
        //System.out.println(&quot;root=&quot; + nodeToString(root));
        
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (nodeMap.parentIsSet(root)) {</span>
<span class="nc" id="L2136">            System.err.println(&quot;root should not have parent key&quot;);</span>
<span class="nc" id="L2137">            passed = false;</span>
        }
        
<span class="fc" id="L2140">        long[] nodes = getPreOrderTraversalIterative(root, 0);</span>
<span class="fc bfc" id="L2141" title="All 2 branches covered.">        for (long key : nodes) {</span>
<span class="fc bfc" id="L2142" title="All 2 branches covered.">            if (nodeMap.leftIsSet(key)) {</span>
<span class="fc" id="L2143">                long child = nodeMap.getLeft(key);</span>
<span class="pc bpc" id="L2144" title="1 of 2 branches missed.">                if (!nodeMap.parentIsSet(child)) {</span>
<span class="nc" id="L2145">                    System.err.format(</span>
                        &quot;error in %d.left=%d has no parent\n&quot;,
<span class="nc" id="L2147">                        key, child);</span>
<span class="nc" id="L2148">                    passed = false;</span>
<span class="pc bpc" id="L2149" title="1 of 2 branches missed.">                } else if (nodeMap.getParent(child) != key) {</span>
<span class="nc" id="L2150">                    System.err.format(</span>
                        &quot;error in left: %d.left=%d but %d.parent=%d\n&quot;,
<span class="nc" id="L2152">                        key, child, child, nodeMap.getParent(child));</span>
<span class="nc" id="L2153">                    passed = false;</span>
                }
            }
<span class="fc bfc" id="L2156" title="All 2 branches covered.">            if (nodeMap.rightIsSet(key)) {</span>
<span class="fc" id="L2157">                long child = nodeMap.getRight(key);</span>
<span class="pc bpc" id="L2158" title="1 of 2 branches missed.">                if (!nodeMap.parentIsSet(child)) {</span>
<span class="nc" id="L2159">                    System.err.format(</span>
                        &quot;error in %d.right=%d has no parent\n&quot;,
<span class="nc" id="L2161">                        key, child);</span>
<span class="nc" id="L2162">                    passed = false;</span>
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">                } else if (nodeMap.getParent(child) != key) {</span>
<span class="nc" id="L2164">                    System.err.format(</span>
                        &quot;error in right: %d.right=%d but %d.parent=%d\n&quot;,
<span class="nc" id="L2166">                        key, child, child, nodeMap.getParent(child));</span>
<span class="nc" id="L2167">                    passed = false;</span>
                }
            }
        }
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">        if (nodes.length != size()) {</span>
<span class="nc" id="L2172">            System.out.println(&quot;ERROR in nodes extraction&quot;);</span>
<span class="nc" id="L2173">            passed = false;</span>
        }
        
<span class="fc" id="L2176">        return passed;</span>
    }
    
    /**
     Print node and its left and right subtrees, but note that one can
     only print if the height and maxValue of the numbers fit into a line 
     limited to 100 characters.
     Each node takes w=log10(maxValue)+1 characters + 1 space.
     The number of characters of the bottom leaves should be.lt. 100 total.
         (w+1) * (1 left-shift (h-1)) .lt. 100.
      
     The restriction is to make it easy to read an ascii tree on a text terminal. 
     
     Example use: for maxValue=99, the number of base-10 digits is 2, so
     the maximum height printable by this method would be a tree 
     with 6 levels (results in leaf level using .lte.  100 characters).
     
     &lt;pre&gt;
                1              
          2           2       
       3     3     3     3     
      4  4  4  4  4  4  4  4   
     &lt;/pre&gt;
     @param node
     @param maxValue
     */
    public void printSmallTree(long node, long maxValue) {
       
<span class="fc" id="L2204">        int w = (int)Math.ceil(Math.log(maxValue)/Math.log(10));</span>
        
<span class="fc" id="L2206">        int n = nodeMap.getNodeSize(node);</span>
<span class="fc" id="L2207">        int h = (int)Math.ceil(Math.log(n + 1)/Math.log(2));</span>
        
        //System.out.println(&quot;w=&quot; + w + &quot; n=&quot; + n + &quot; h=&quot; + h);
        
<span class="fc" id="L2211">        int baselineLength = (w + 1) * (1 &lt;&lt; (h - 1));</span>
       
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">        if (baselineLength &gt; 100) {</span>
<span class="nc" id="L2214">            throw new IllegalArgumentException(&quot;the number of characters needed&quot;</span>
                + &quot; for the leaves is &gt; 100&quot;);
        }
        
<span class="fc" id="L2218">        ArrayDeque&lt;Long&gt; levelQ = new ArrayDeque();</span>
<span class="fc" id="L2219">        ArrayDeque&lt;Long&gt; nextLevelQ = new ArrayDeque&lt;Long&gt;();</span>
<span class="fc" id="L2220">        levelQ.add(node);</span>
<span class="fc" id="L2221">        int level = 0;</span>
<span class="fc" id="L2222">        int hw = (w+1)/2;</span>
<span class="fc" id="L2223">        int indent = (baselineLength - (w+1))/2;</span>
<span class="pc bpc" id="L2224" title="3 of 4 branches missed.">        while (!levelQ.isEmpty() || !nextLevelQ.isEmpty()) {</span>
<span class="fc" id="L2225">            level++;</span>
<span class="fc bfc" id="L2226" title="All 2 branches covered.">            if (level &gt; h) {</span>
<span class="fc" id="L2227">                break;</span>
            }
<span class="fc bfc" id="L2229" title="All 2 branches covered.">            if (level &gt; 1) {</span>
<span class="fc" id="L2230">                indent /= 2;</span>
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">                if (indent - hw &gt; 1) {</span>
<span class="nc" id="L2232">                    indent -= hw;</span>
                }
            }
<span class="fc" id="L2235">            int nn = 1 &lt;&lt; (level - 1);</span>
<span class="fc" id="L2236">            int nodeSpace = (w+1) * nn;</span>
<span class="fc" id="L2237">            int spacing = baselineLength - nodeSpace - 2*indent;</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">            if ((nn - 1) &gt; 0) {</span>
<span class="fc" id="L2239">                spacing /= (nn-1);</span>
            }
            //System.out.println(&quot;spacing=&quot; + spacing + &quot; indent=&quot; + indent
            //    + &quot; bl=&quot; + baselineLength + &quot; ns=&quot; + nodeSpace);
<span class="fc" id="L2243">            int prevPos = -1;</span>
<span class="fc" id="L2244">            StringBuilder sb0 = new StringBuilder(baselineLength);</span>
<span class="fc" id="L2245">            StringBuilder sb1 = new StringBuilder(baselineLength);</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">            while (!levelQ.isEmpty()) {</span>
<span class="fc" id="L2247">                long z = levelQ.pop();</span>
                int nSpaces;
<span class="fc bfc" id="L2249" title="All 2 branches covered.">                if (level == 1) {</span>
<span class="fc" id="L2250">                    nSpaces = indent;</span>
<span class="fc bfc" id="L2251" title="All 2 branches covered.">                } else if (prevPos == -1) {</span>
<span class="fc" id="L2252">                    nSpaces = indent;</span>
                } else {
<span class="fc" id="L2254">                    nSpaces = spacing;</span>
                }
<span class="fc" id="L2256">                addSpaces(nSpaces, sb0);</span>
<span class="fc" id="L2257">                addSpaces(nSpaces, sb1);</span>
<span class="fc" id="L2258">                prevPos += nSpaces;</span>
<span class="fc bfc" id="L2259" title="All 2 branches covered.">                if (z == Long.MIN_VALUE) {</span>
<span class="fc" id="L2260">                    addSpaces(w + 1, sb0);</span>
<span class="fc" id="L2261">                    addSpaces(w + 1, sb1);</span>
                    // add 2 empty placeholders
<span class="fc" id="L2263">                    nextLevelQ.add(Long.MIN_VALUE);</span>
<span class="fc" id="L2264">                    nextLevelQ.add(Long.MIN_VALUE);</span>
<span class="fc" id="L2265">                    continue;                    </span>
                }
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">                if (!nodeMap.containsKey(z)) {</span>
<span class="nc" id="L2268">                    continue;</span>
                }
<span class="fc" id="L2270">                int clr = nodeMap.getNodeColor(z);</span>
<span class="fc" id="L2271">                String keyC = Long.toString(z);</span>
<span class="fc" id="L2272">                String clrC = Integer.toString(clr);</span>
            
<span class="fc" id="L2274">                sb0.append(keyC);</span>
<span class="fc" id="L2275">                sb1.append(clrC);</span>
<span class="fc" id="L2276">                addSpaces(1, sb0);</span>
<span class="fc" id="L2277">                addSpaces(w + 1 - clrC.length(), sb1);</span>
                
<span class="fc bfc" id="L2279" title="All 2 branches covered.">                if (nodeMap.leftIsSet(z)) {</span>
<span class="fc" id="L2280">                    nextLevelQ.add(nodeMap.getLeft(z));</span>
                } else {
<span class="fc" id="L2282">                    nextLevelQ.add(Long.MIN_VALUE);</span>
                }
<span class="fc bfc" id="L2284" title="All 2 branches covered.">                if (nodeMap.rightIsSet(z)) {</span>
<span class="fc" id="L2285">                    nextLevelQ.add(nodeMap.getRight(z));</span>
                } else {
<span class="fc" id="L2287">                    nextLevelQ.add(Long.MIN_VALUE);</span>
                }
<span class="fc" id="L2289">            }</span>
<span class="fc" id="L2290">            System.out.println(sb0.toString());</span>
<span class="fc" id="L2291">            System.out.println(sb1.toString());</span>
<span class="fc" id="L2292">            System.out.println(&quot;&quot;);</span>
<span class="pc bnc" id="L2293" title="All 2 branches missed.">            assert(levelQ.isEmpty());</span>
<span class="fc" id="L2294">            levelQ.addAll(nextLevelQ);</span>
<span class="fc" id="L2295">            nextLevelQ.clear();</span>
<span class="fc" id="L2296">        }</span>
<span class="fc" id="L2297">    } </span>
    private void addSpaces(int nSpaces, StringBuilder sb) {
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        for (int i = 0; i &lt; nSpaces; ++i) {</span>
<span class="fc" id="L2300">            sb.append(&quot; &quot;);</span>
        }
<span class="fc" id="L2302">    }</span>
    
    private boolean containsLeft(long key) {
<span class="nc" id="L2305">        return nodeMap.leftIsSet(key);</span>
    }
    private boolean containsRight(long key) {
<span class="nc" id="L2308">        return nodeMap.rightIsSet(key);</span>
    }
    private boolean containsParent(long key) {
<span class="nc" id="L2311">        return nodeMap.parentIsSet(key);</span>
    }
    private boolean containsParentLeft(long key) {
<span class="nc bnc" id="L2314" title="All 2 branches missed.">        if (containsParent(key)) {</span>
<span class="nc" id="L2315">            return containsLeft(nodeMap.getParent(key));</span>
        }
<span class="nc" id="L2317">        return false;</span>
    }
    private boolean containsParentRight(long key) {
<span class="nc bnc" id="L2320" title="All 2 branches missed.">        if (containsParent(key)) {</span>
<span class="nc" id="L2321">            return containsRight(nodeMap.getParent(key));</span>
        }
<span class="nc" id="L2323">        return false;</span>
    }

    private void deleteFromLeftAssignLeft(long delH, long asnH, long key, 
        long[] output) {
       
<span class="fc" id="L2329">        delete(nodeMap.getLeft(delH), key, output);</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L2331">            nodeMap.unsetLeft(asnH);</span>
        } else {
<span class="fc" id="L2333">            nodeMap.updateLeft(delH, output[1]);</span>
<span class="fc" id="L2334">            nodeMap.updateParent(output[1], delH);</span>
        }
<span class="fc" id="L2336">    }</span>

    private void deleteFromRightAssignRight(long hDel, long hAsn, long key, 
        long[] output) {
        
<span class="pc bnc" id="L2341" title="All 2 branches missed.">        assert(nodeMap.rightIsSet(hDel));</span>
        
        //h.right = delete(h.right, key);

<span class="fc" id="L2345">        delete(nodeMap.getRight(hDel), key, output);</span>
        
<span class="fc bfc" id="L2347" title="All 2 branches covered.">        if (output[0] == -1) {</span>
<span class="fc" id="L2348">            nodeMap.unsetRight(hAsn);</span>
        } else {
<span class="fc" id="L2350">            nodeMap.updateRight(hAsn, output[1]);</span>
<span class="fc" id="L2351">            nodeMap.updateParent(output[1], hAsn);</span>
        }
<span class="fc" id="L2353">    }</span>
             
    private void setHFromX(long x, long h, int xVal, int hClr, 
        boolean hLeftExists, long hLeft, 
        boolean hRightExists, long hRight, 
        boolean hParentExists, long hParent, int hSize) {
        
<span class="pc bnc" id="L2360" title="All 2 branches missed.">        assert(x != h);</span>
<span class="fc" id="L2361">        nodeMap.put(x, xVal, hClr, hSize);</span>
     
<span class="fc bfc" id="L2363" title="All 2 branches covered.">        if (hParentExists) {</span>
<span class="fc" id="L2364">            nodeMap.updateParent(x, hParent);</span>
<span class="pc bpc" id="L2365" title="1 of 2 branches missed.">            if (nodeMap.leftIsSet(hParent) </span>
<span class="pc bpc" id="L2366" title="1 of 2 branches missed.">                &amp;&amp; nodeMap.getLeft(hParent) == h) {</span>
<span class="nc" id="L2367">                nodeMap.updateLeft(hParent, x);</span>
            } else {
<span class="pc bnc" id="L2369" title="All 2 branches missed.">                assert(nodeMap.rightIsSet(hParent) </span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">                    &amp;&amp; nodeMap.getRight(hParent) == h);</span>
<span class="fc" id="L2371">                nodeMap.updateRight(hParent, x);</span>
            }
        } else {
            //h is root
        }
        
<span class="pc bpc" id="L2377" title="1 of 2 branches missed.">        if (hLeftExists) {</span>
<span class="fc" id="L2378">            nodeMap.updateParent(hLeft, x);</span>
<span class="fc" id="L2379">            nodeMap.updateLeft(x, hLeft);</span>
        }
<span class="fc bfc" id="L2381" title="All 2 branches covered.">        if (hRightExists) {</span>
<span class="fc" id="L2382">            nodeMap.updateParent(hRight, x);</span>
<span class="fc" id="L2383">            nodeMap.updateRight(x, hRight);</span>
        }
        
<span class="fc" id="L2386">        nodeMap.remove(h); </span>
        
<span class="fc bfc" id="L2388" title="All 2 branches covered.">        if (h == root) {</span>
<span class="fc" id="L2389">            root = x;</span>
        }
<span class="fc" id="L2391">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>