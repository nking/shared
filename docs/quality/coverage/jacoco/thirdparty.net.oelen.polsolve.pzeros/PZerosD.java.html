<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PZerosD.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.net.oelen.polsolve.pzeros</a> &gt; <span class="el_source">PZerosD.java</span></div><h1>PZerosD.java</h1><pre class="source lang-java linenums">/*
The author of this code is Wilco Oelen and he offers it
freely without copyright, but asks that his pages are referenced
as the source if used.
He has a webpage with information on the polynomial software
he ported and more modern versions which require jini bindings:
https://woelen.homescience.net/science/math/exps/polynomials/
https://woelen.homescience.net/science/math/exps/polynomials/software.html
The code here is from the Java port of RPoly, CPoly and MPSolve 1996 algorithms:
https://woelen.homescience.net/science/math/exps/polynomials/software/polsolve.tgz
*/
package thirdparty.net.oelen.polsolve.pzeros;

// PolSolve code for double precision (53 bits)

import thirdparty.net.oelen.polarith.Complex;


/************************************************************************
*    NUMERICAL COMPUTATION OF THE ROOTS OF A POLYNOMIAL HAVING          *
*        COMPLEX COEFFICIENTS, BASED ON ABERTH'S METHOD.                *
*                      Version 1.4, June   1996                         *
*    (D. Bini, Dipartimento di Matematica, Universita' di Pisa)         *
*                         (bini@dm.unipi.it)                            *
*************************************************************************
* Work performed under the support of the ESPRIT BRA project 6846 POSSO *
*************************************************************************
***********         SUBROUTINES AND FUNCTIONS                 ***********
*************************************************************************
*  The following modules are listed:                                    *
*  POLZEROS  :  computes polynomial roots by means of Aberth's method   *
*    ABERTH  :  computes the Aberth correction                          *
*    NEWTON  :  computes p(x)/p'(x) by means of Ruffini-Horner's rule   *
*    START   :  Selects N starting points by means of Rouche's theorem  *
*    CNVEX   :  Computes the convex hull, used by START                 *
*    CMERGE  :  Used by CNVEX                                           *
*    LEFT    :  Used by CMERGE                                          *
*    RIGHT   :  Used by CMERGE                                          *
*    CTEST   :  Convexity test, Used by CMERGE                          *
*************************************************************************/

<span class="nc" id="L42">strictfp class PZerosD {</span>
    
    
    /************************************************************************
    *                             SUBROUTINE NEWTON                         *
    *************************************************************************
    * Compute  the Newton's correction, the inclusion radius (4) and checks *
    * the stop condition (3)                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial p(x)                             *
    *     POLY  : coefficients of the polynomial p(x)                       *
    *     APOLY : upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying Ruffini-Horner's rule  *
    *     APOLYR: upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying (2), (2')              *
    *     Z     : value at which the Newton correction is computed          *
    *     SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *************************************************************************
    * Output variables:                                                     *
    *     RADIUS: upper bound to the distance of Z from the closest root of *
    *             the polynomial computed according to (4).                 *
    *     CORR  : Newton's correction                                       *
    *     AGAIN : this variable is .true. if the computed value p(z) is     *
    *             reliable, i.e., (3) is not satisfied in Z. AGAIN is       *
    *             .false., otherwise.                                       *
    *************************************************************************/
    // Version for a polynomial with complex coefficients.
    // All complex arithmetic is broken down in real arithmetic.
    // This strongly improves performance, because there is no
    // need to create a Complex object after every calculation
    // step.
    // The version of newton() for complex coefficients is left
    // in the code, commented out, just under this method.
    private static Complex newton(int n, Complex[] poly, double[] apoly, double[] apolyr,
                                  Complex z, double small, double eps,
                                  /* out */ double[] radius, /* out */ boolean[] again,
                                  int outIndex) {
        int i;
        double pre, pim, p1re, p1im;
        Complex corr;
        double ap, az;
<span class="fc" id="L84">        double zre = z.re;</span>
<span class="fc" id="L85">        double zim = z.im;</span>
        double t;
        
<span class="fc" id="L88">        az = z.abs();</span>

        // If |z|&lt;=1 then apply Ruffini-Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply Ruffini-Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L96">            pre = poly[n].re;</span>
<span class="fc" id="L97">            pim = poly[n].im;</span>
<span class="fc" id="L98">            p1re = pre;</span>
<span class="fc" id="L99">            p1im = pim;</span>
<span class="fc" id="L100">            ap = apoly[n];</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
                //p = poly[i].add(p.mul(z));
<span class="fc" id="L103">                t = poly[i].re + pre * zre - pim * zim;</span>
<span class="fc" id="L104">                pim = poly[i].im + pim * zre + pre * zim;</span>
<span class="fc" id="L105">                pre = t;</span>
                // p1 = p.add(p1.mul(z));
<span class="fc" id="L107">                t = pre + p1re*zre - p1im*zim;</span>
<span class="fc" id="L108">                p1im = pim + p1im*zre + p1re*zim;</span>
<span class="fc" id="L109">                p1re = t;</span>
                
<span class="fc" id="L111">                ap = apoly[i] + ap * az;</span>
            }
            //p = poly[0].add(p.mul(z));
<span class="fc" id="L114">            t = poly[0].re + pre * zre - pim * zim;</span>
<span class="fc" id="L115">            pim = poly[0].im + pim * zre + pre * zim;</span>
<span class="fc" id="L116">            pre = t;</span>

<span class="fc" id="L118">            ap = apoly[0] + ap * az;</span>
            // corr = p.div(p1);
<span class="fc" id="L120">            corr = new Complex(pre, pim).div(p1re, p1im);</span>

<span class="fc" id="L122">            double epsap = eps * ap;</span>
<span class="fc" id="L123">            double absp = Math.abs(pre) + Math.abs(pim);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L126">                radius[outIndex] = n * (absp + epsap) / new Complex(p1re,p1im).abs();</span>
            }
<span class="fc" id="L128">        } else // az &gt;= 1.0</span>
        {
            Complex zi, ppsp;
            double azi;
            double denre, denim;

<span class="fc" id="L134">            zi = z.recip();</span>
<span class="fc" id="L135">            azi = 1.0 / az;</span>
<span class="fc" id="L136">            pre = poly[0].re;</span>
<span class="fc" id="L137">            pim = poly[0].im;</span>
<span class="fc" id="L138">            p1re = pre;</span>
<span class="fc" id="L139">            p1im = pim;</span>
<span class="fc" id="L140">            ap = apolyr[n];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
                //p = poly[n - i].add(p.mul(zi));
<span class="fc" id="L143">                t = poly[n-i].re + pre*zi.re - pim*zi.im;</span>
<span class="fc" id="L144">                pim = poly[n-i].im + pim*zi.re + pre*zi.im;</span>
<span class="fc" id="L145">                pre = t;</span>
                // p1 = p.add(p1.mul(zi));
<span class="fc" id="L147">                t = pre + p1re*zi.re - p1im*zi.im;</span>
<span class="fc" id="L148">                p1im = pim + p1im*zi.re + p1re*zi.im;</span>
<span class="fc" id="L149">                p1re = t;</span>
<span class="fc" id="L150">                ap = apolyr[i] + ap * azi;</span>
            }
            // p = poly[n].add(p.mul(zi));
<span class="fc" id="L153">            t = poly[n].re + pre*zi.re - pim*zi.im;</span>
<span class="fc" id="L154">            pim = poly[n].im + pim*zi.re + pre*zi.im;</span>
<span class="fc" id="L155">            pre = t;</span>
<span class="fc" id="L156">            ap = apolyr[0] + ap * azi;</span>

            // ppsp = p.mul(z).div(p1);
<span class="fc" id="L159">            ppsp = new Complex(pre*zre-pim*zim, pre*zim+pim*zre).div(p1re, p1im);</span>
            //den = ppsp.mul(n).sub1();
<span class="fc" id="L161">            denre = ppsp.re*n - 1.0;</span>
<span class="fc" id="L162">            denim = ppsp.im*n;</span>
<span class="fc" id="L163">            corr = z.mul(ppsp.div(denre, denim));</span>
<span class="fc" id="L164">            double epsap = eps * ap;</span>
<span class="fc" id="L165">            double absp = Math.abs(pre) + Math.abs(pim);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L168">                radius[outIndex] = ppsp.abs() + (epsap * az) / new Complex(p1re,p1im).abs();</span>
<span class="fc" id="L169">                radius[outIndex] *= n / new Complex(denre, denim).abs();</span>
<span class="fc" id="L170">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L174">        return corr;</span>
    }
    
    /*
    private static Complex newton(int n, Complex[] poly, double[] apoly, double[] apolyr,
                                  Complex z, double small, double eps,
                                  double[] radius, boolean[] again,
                                  int outIndex) {
        int i;
        Complex p, p1;
        Complex corr;
        double ap, az;
        
        az = z.abs();

        // If |z|&lt;=1 then apply Ruffini-Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply Ruffini-Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
        if (az &lt; 1.0) {
            p = poly[n];
            p1 = p;
            ap = apoly[n];
            for (i = n - 1; i &gt;= 1; i--) {
                p = poly[i].add(p.mul(z));
                p1 = p.add(p1.mul(z));
                ap = apoly[i] + ap * az;
            }
            p = poly[0].add(p.mul(z));
            ap = apoly[0] + ap * az;
            corr = p.div(p1);

            double epsap = eps * ap;
            double absp = p.abs1();
            again[outIndex] = (absp &gt; PolSolve.SQRTN[n]*(small + epsap));  // WILCO: Relaxed error bound with factor sqrt(n), original was absp &gt; small + epsap
            if (!again[outIndex]) {
                radius[outIndex] = n * (absp + epsap) / p1.abs();
            }
        } else // az &gt;= 1.0
        {
            Complex zi, den, ppsp;
            double azi;

            zi = z.recip();
            azi = 1.0 / az;
            p = poly[0];
            p1 = p;
            ap = apolyr[n];
            for (i = n - 1; i &gt;= 1; i--) {
                p = poly[n - i].add(p.mul(zi));
                p1 = p.add(p1.mul(zi));
                ap = apolyr[i] + ap * azi;
            }
            p = poly[n].add(p.mul(zi));
            ap = apolyr[0] + ap * azi;

            ppsp = p.mul(z).div(p1);
            den = ppsp.mul(n).sub1();
            corr = z.mul(ppsp.div(den));
            double epsap = eps * ap;
            double absp = p.abs1();
            again[outIndex] = (absp &gt; small + epsap);
            if (!again[outIndex]) {
                radius[outIndex] = ppsp.abs() + (epsap * az) / p1.abs();
                radius[outIndex] *= n / den.abs();
                radius[outIndex] *= az;
            }
        }
        
        return corr;
    }
    */
    
    

    // Version for a polynomial with real coefficients.
    private static Complex newton(int n, double[] poly, double[] apoly, double[] apolyr,
                                  Complex z, double small, double eps,
                                  /* out */ double[] radius, /* out */ boolean[] again,
                                  int outIndex) {
        int i;
        Complex p, p1;
        double ap, az;
        
<span class="fc" id="L259">        az = z.abs();</span>
        
        Complex corr;

        // Use a method like Horner's method, but developed especially for
        // evaluation of real polynomials for complex values.
        // This method requires only half amount of the number of real
        // multiplications as standard Horner's rule.
        // BIT 5 (1965), 142, see also G. Goertzel, AMM 65 (1958), 34-35
        // This method only works for polynomials of degree &gt;= 2.

        // If |z|&lt;=1 then apply modified Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply modified Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L276">            double zre = z.real();</span>
<span class="fc" id="L277">            double zim = z.imag();</span>
<span class="fc" id="L278">            double r = 2*zre;</span>
<span class="fc" id="L279">            double s = zre*zre + zim*zim;</span>
<span class="fc" id="L280">            double aa = poly[n];</span>
<span class="fc" id="L281">            double bb = poly[n - 1];</span>

            // Compute p(z) and |p|(|z|)
<span class="fc" id="L284">            ap = apoly[n - 1] + az * apoly[n];</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L287">                double tmp = bb + r*aa;</span>
<span class="fc" id="L288">                bb = poly[i] - s*aa;</span>
<span class="fc" id="L289">                aa = tmp;</span>

                // Next step for |p|(|z|)
<span class="fc" id="L292">                ap = apoly[i] + ap * az;</span>
            }
<span class="fc" id="L294">            p = z.mul(aa).add(bb);</span>

            // Compute p'(z)
<span class="fc" id="L297">            aa = n*poly[n];</span>
<span class="fc" id="L298">            bb = (n-1)*poly[n - 1];</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L300">                double tmp = bb + r*aa;</span>
<span class="fc" id="L301">                bb = i*poly[i] - s*aa;</span>
<span class="fc" id="L302">                aa = tmp;</span>
            }
<span class="fc" id="L304">            p1 = z.mul(aa).add(bb);</span>

<span class="fc" id="L306">            double epsap = eps * ap;</span>
<span class="fc" id="L307">            corr = p.div(p1);</span>
<span class="fc" id="L308">            double absp = p.abs1();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L311">                radius[outIndex] = n * (absp + epsap) / p1.abs();</span>
            }
<span class="fc" id="L313">        } </span>
        else // az &gt;= 1.0
        {
            Complex den, ppsp;

<span class="fc" id="L318">            Complex zi = z.recip();</span>
<span class="fc" id="L319">            double zire = zi.real();</span>
<span class="fc" id="L320">            double ziim = zi.imag();</span>
<span class="fc" id="L321">            double azi = 1.0 / az;</span>

<span class="fc" id="L323">            double r = 2*zire;</span>
<span class="fc" id="L324">            double s = zire*zire + ziim*ziim;</span>
<span class="fc" id="L325">            double aa = poly[0];</span>
<span class="fc" id="L326">            double bb = poly[1];</span>

            // Compute q(zi) and |q|(|zi|), where
            // q equals p with reversed coefficients.
<span class="fc" id="L330">            ap = apolyr[n - 1] + azi * apolyr[n];</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L333">                double tmp = bb + r*aa;</span>
<span class="fc" id="L334">                bb = poly[n - i] - s * aa;</span>
<span class="fc" id="L335">                aa = tmp;</span>

                // Next step for |q|(|zi|)
<span class="fc" id="L338">                ap = apolyr[i] + ap * azi;</span>
            }
<span class="fc" id="L340">            p = zi.mul(aa).add(bb);</span>

            // Compute q'(zi)
<span class="fc" id="L343">            aa = n * poly[0];</span>
<span class="fc" id="L344">            bb = (n-1)*poly[1];</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L346">                double tmp = bb + r*aa;</span>
<span class="fc" id="L347">                bb = i*poly[n - i] - s*aa;</span>
<span class="fc" id="L348">                aa = tmp;</span>
            }
<span class="fc" id="L350">            p1 = zi.mul(aa).add(bb);</span>

<span class="fc" id="L352">            ppsp = p.mul(z).div(p1);</span>
<span class="fc" id="L353">            den = ppsp.mul(n).sub1();</span>
<span class="fc" id="L354">            corr = z.mul(ppsp.div(den));</span>
<span class="fc" id="L355">            double epsap = eps * ap;</span>
<span class="fc" id="L356">            double absp = p.abs1();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L359">                radius[outIndex] = (ppsp.abs() + (epsap * az) / p1.abs());</span>
<span class="fc" id="L360">                radius[outIndex] *= n / den.abs();</span>
<span class="fc" id="L361">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L365">        return corr;</span>
    }

    
    
    
    
    /************************************************************************
    *                             SUBROUTINE ABERTH                         *
    *************************************************************************
    * Compute  the Aberth correction. To save time, the reciprocation of    *
    * ROOT(J)-ROOT(I) could be performed in single precision (complex*8)    *
    * In principle this might cause overflow if both ROOT(J) and ROOT(I)    *
    * have too small moduli.                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial                                  *
    *     ROOT  : vector containing the current approximations to the roots *
    *     J     : index of the component of ROOT with respect to which the  *
    *             Aberth correction is computed                             *
    *************************************************************************
    * Output variable:                                                      *
    *     ABCORR: Aberth's correction (compare (1))                         *
    *************************************************************************/
    
    /* The pseudocode below is left here for documentation purposes, the real
     * code is further below. By doing the aberth correction in normal double
     * precision, the algorithm hardly suffers but the speedup is considerable
     * (more than a factor 2 speedup for quad double arithmatic in a typical
     * case). Only the difference between the roots is computed, using full
     * precision (this may be necessary in case of (nearly) equal roots), but
     * the 1/(z-zj) correction can be computed in standard precision.

       static complex aberth(int n, int j, complex[] root) { 
           int i; 
           complex zj;
     
           complex abcorr = 0.0; 
           zj = root[j]; 
           for (i=0; i&lt;n; i++) {
               if (i != j) {
                   complex z = zj - root[i];
                   abcorr += 1.0 / z;
               }
           }
           return abcorr;
       }

     */
    
    private static Complex aberth(int n, int j, Complex root[]) {
<span class="fc" id="L416">        double zj_re = root[j].real();</span>
<span class="fc" id="L417">        double zj_im = root[j].imag();</span>

<span class="fc" id="L419">        double corr_re = 0.0;</span>
<span class="fc" id="L420">        double corr_im = 0.0;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            if (i != j) {</span>
<span class="fc" id="L423">                double z_re = zj_re - root[i].real();</span>
<span class="fc" id="L424">                double z_im = zj_im - root[i].imag();</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                double absr = (z_re &gt; 0) ? z_re : -z_re;</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                double absi = (z_im &gt; 0) ? z_im : -z_im;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                if (absr &gt; absi) {</span>
<span class="fc" id="L428">                    double r = z_im / z_re;</span>
<span class="fc" id="L429">                    double den = z_re + r * z_im;</span>
<span class="fc" id="L430">                    corr_re += 1.0/den;</span>
<span class="fc" id="L431">                    corr_im -= r/den;</span>
<span class="fc" id="L432">                } </span>
                else {
<span class="fc" id="L434">                    double r = z_re / z_im;</span>
<span class="fc" id="L435">                    double den = z_im + r * z_re;</span>
<span class="fc" id="L436">                    corr_re += r/den;</span>
<span class="fc" id="L437">                    corr_im -= 1.0/den;</span>
                }
            }
        }

<span class="fc" id="L442">        return new Complex(corr_re, corr_im);</span>
    }
    
    
    

    /************************************************************************
    *                             SUBROUTINE START                          *
    *************************************************************************
    * Compute  the starting approximations of the roots                     *
    *************************************************************************
    * Input variables:                                                      *
    *     N     :  number of the coefficients of the polynomial             *
    *     A     :  moduli of the coefficients of the polynomial             *
    *     SMALL : the min positive real*8, SMALL=2**(-1074) for the IEEE.   *
    *     BIG   : the max real*8, BIG=2**1023 for the IEEE standard.        *
    * Output variables:                                                     *
    *     Y     :  starting approximations                                  *
    *     RADIUS:  if a component is -1 then the corresponding root has a   *
    *              too big or too small modulus in order to be represented  *
    *              as double float with no overflow/underflow               *
    *     NZ    :  number of roots which cannot be represented without      *
    *              overflow/underflow                                       *
    * Auxiliary variables:                                                  *
    *     H     :  needed for the computation of the convex hull            *
    *************************************************************************
    * This routine selects starting approximations along circles center at  *
    * 0 and having suitable radii. The computation of the number of circles *
    * and of the corresponding radii is performed by computing the upper    *
    * convex hull of the set (i,log(A(i))), i=1,...,n+1.                    *
    *************************************************************************/
    
    private static int start(int n, double[] a, Complex[] y, double[] radius, double big) {
        int i, iold, nzeros, j, jj;
        double r, th, ang, temp;
<span class="fc" id="L477">        final double sigma = 0.7;</span>
<span class="fc" id="L478">        final double pi2 = 6.2831853071796;</span>
<span class="fc" id="L479">        double xbig = Math.log(big);</span>
<span class="fc" id="L480">        double xsmall = -xbig;</span>
<span class="fc" id="L481">        boolean[] h = new boolean[n + 1];</span>
        int nz;   // number of zeros which cannot be represented without under/overflow.

<span class="fc" id="L484">        nz = 0;</span>

        // Compute the logarithm A(I) of the moduli of the coefficients of
        // the polynomial and then the upper convex hull of the set (A(I),I)
<span class="fc bfc" id="L488" title="All 2 branches covered.">        for (i = 0; i &lt;= n; i++) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (a[i] != 0.0) {</span>
<span class="fc" id="L490">                a[i] = Math.log(a[i]);</span>
            } else {
<span class="fc" id="L492">                a[i] = -1e30;   // -infinity</span>
            }
        }
<span class="fc" id="L495">        Convex.cnvex(n, a, h);</span>

        // Given the upper convex hull of the set (A(I),I) compute the moduli
        // of the starting approximations by means of Rouche's theorem
<span class="fc" id="L499">        iold = 0;</span>
<span class="fc" id="L500">        th = pi2 / n;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        for (i = 1; i &lt;= n; i++) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (h[i]) {</span>
<span class="fc" id="L503">                nzeros = i - iold;</span>
<span class="fc" id="L504">                temp = (a[iold] - a[i]) / nzeros;</span>
<span class="fc" id="L505">                boolean underflow = false, overflow = false;</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">                if (temp &lt;= xsmall) {</span>
                    // Radii are too small, underflow situation.
<span class="nc" id="L508">                    underflow = true;</span>
<span class="nc" id="L509">                    r = 0.0;</span>
<span class="nc" id="L510">                    nz += nzeros;</span>
                } 
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                else if (temp &gt;= xbig) {</span>
                    // Overflow situation.
<span class="nc" id="L514">                    overflow = true;</span>
<span class="nc" id="L515">                    r = big;</span>
<span class="nc" id="L516">                    nz += nzeros;</span>
                } 
                else {
                    // In range of floating point arithmetic.
<span class="fc" id="L520">                    r = Math.exp(temp);</span>
                }

<span class="fc" id="L523">                ang = pi2 / nzeros;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                for (j = iold; j &lt; i; j++) {</span>
<span class="fc" id="L525">                    jj = j - iold;</span>
<span class="pc bpc" id="L526" title="2 of 4 branches missed.">                    if (underflow || overflow) {</span>
<span class="nc" id="L527">                        radius[j] = -1.0;</span>
<span class="nc" id="L528">                        y[j] = new Complex(r);</span>
                    } 
                    else {
<span class="fc" id="L531">                        double re = r * Math.cos(ang * jj + th * i + sigma);</span>
<span class="fc" id="L532">                        double im = r * Math.sin(ang * jj + th * i + sigma);</span>
<span class="fc" id="L533">                        y[j] = new Complex(re, im);</span>
                    }
                }

                // Make the current vertex the basis for the
                // new set of roots.
<span class="fc" id="L539">                iold = i;</span>
            }
        }
        
<span class="fc" id="L543">        return nz;</span>
    }
    
    
    
    

    /************************************************************************
    *                             SUBROUTINE SORT                           *
    *************************************************************************
    *   SORT  the vector X, according to nonincreasing real parts,          *
    *   the same permutation is applied to vectors Y and E.                 *
    *************************************************************************/
    
    private static void sort(int n, Complex[] x, double[] y, boolean[] e) {
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int k = 0; k &lt; n - 1; k++) {</span>
<span class="fc" id="L559">            double amax = x[k].real();</span>
<span class="fc" id="L560">            int imax = k;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">            for (int i = k + 1; i &lt; n; i++) {</span>
<span class="fc" id="L562">                double rxi = x[i].real();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                if (amax &lt; rxi) {</span>
<span class="fc" id="L564">                    amax = rxi;</span>
<span class="fc" id="L565">                    imax = i;</span>
                }
            }

<span class="fc" id="L569">            Complex temp = x[k];</span>
<span class="fc" id="L570">            x[k] = x[imax];</span>
<span class="fc" id="L571">            x[imax] = temp;</span>

<span class="fc" id="L573">            double yt = y[k];</span>
<span class="fc" id="L574">            y[k] = y[imax];</span>
<span class="fc" id="L575">            y[imax] = yt;</span>

<span class="fc" id="L577">            boolean et = e[k];</span>
<span class="fc" id="L578">            e[k] = e[imax];</span>
<span class="fc" id="L579">            e[imax] = et;</span>
        }
<span class="fc" id="L581">    }</span>

    
    
    
    
    /************************************************************************
    *********************** SUBROUTINE POLZEROS *****************************
    *************************************************************************
    *                        GENERAL COMMENTS                               *
    *************************************************************************
    *  This routine approximates the roots of   the  polynomial             *
    *  p(x)=a(n)x^n+a(n-1)x^(n-1)+...+a(0), a(j)=cr(j)+I ci(j), I**2=-1,    *
    *  where a(0) and a(n) are nonzero.                                     *
    *  The coefficients are complex*16 numbers. The routine is fast, robust *
    *  against overflow, and allows to deal with polynomials of any degree. *
    *  Overflow situations are very unlikely and may occurr if there exist  *
    *  simultaneously coefficients of moduli close to BIG and close to      *
    *  SMALL, i.e., the greatest and the smallest positive real*8 numbers,  *
    *  respectively. In this limit situation the program outputs a warning  *
    *  message. The computation can be speeded up by performing some side   *
    *  computations in single precision, thus slightly reducing the         *
    *  robustness of the program (see the comments in the routine ABERTH).  *
    *  Besides a set of approximations to the roots, the program delivers a *
    *  set of a-posteriori error bounds which are guaranteed in the most    *
    *  part of cases. In the situation where underflow does not allow to    *
    *  compute a guaranteed bound, the program outputs a warning message    *
    *  and sets the bound to 0. In the situation where the root cannot be   *
    *  represented as a complex*16 number the error bound is set to -1.     *
    *************************************************************************
    *  The computation is performed by means of Aberth's method             *
    *  according to the formula                                             *
    *           x(i)=x(i)-newt/(1-newt*abcorr), i=1,...,n             (1)   *
    *  where newt=p(x(i))/p'(x(i)) is the Newton correction and abcorr=     *
    *  =1/(x(i)-x(1))+...+1/(x(i)-x(i-1))+1/(x(i)-x(i+1))+...+1/(x(i)-x(n)) *
    *  is the Aberth correction to the Newton method.                       *
    *************************************************************************
    *  The value of the Newton correction is computed by means of the       *
    *  synthetic division algorithm (Ruffini-Horner's rule) if |x|&lt;=1,      *
    *  otherwise the following more robust (with respect to overflow)       *
    *  formula is applied:                                                  *
    *                    newt=1/(n*y-y**2 R'(y)/R(y))                 (2)   *
    *  where                                                                *
    *                    y=1/x                                              *
    *                    R(y)=a(0)*y**n+...+a(n-1)*y+a(n)            (2')   *
    *  This computation is performed by the routine NEWTON.                 *
    *************************************************************************
    *  The starting approximations are complex numbers that are             *
    *  equispaced on circles of suitable radii. The radius of each          *
    *  circle, as well as the number of roots on each circle and the        *
    *  number of circles, is determined by applying Rouche's theorem        *
    *  to the functions a(k)*x**k and p(x)-a(k)*x**k, k=0,...,n.            *
    *  This computation is performed by the routine START.                  *
    *************************************************************************
    *                              STOP CONDITION                           *
    *************************************************************************
    * If the condition                                                      *
    *                     |p(x(j))|&lt;EPS s(|x(j)|)                      (3)  *
    * is satisfied,    where      s(x)=s(0)+x*s(1)+...+x**n * s(n),         *
    * s(i)=|a(i)|*(1+3.8*i),  EPS is the machine precision (EPS=2**-53      *
    * for the IEEE arithmetic), then the approximation x(j) is not updated  *
    * and the subsequent iterations (1)  for i=j are skipped.               *
    * The program stops if the condition (3) is satisfied for j=1,...,n,    *
    * or if the maximum number NITMAX of  iterations   has   been reached.  *
    * The condition (3) is motivated by a backward rounding error analysis  *
    * of the Ruffini-Horner rule, moreover the condition (3) guarantees     *
    * that the computed approximation x(j) is an exact root of a slightly   *
    * perturbed polynomial.                                                 *
    *************************************************************************
    *             INCLUSION DISKS, A-POSTERIORI ERROR BOUNDS                *
    *************************************************************************
    * For each approximation x of a root, an a-posteriori absolute error    *
    * bound r is computed according to the formula                          *
    *                   r=n(|p(x)|+EPS s(|x|))/|p'(x)|                 (4)  *
    * This provides an inclusion disk of center x and radius r containing a *
    * root.                                                                 *
    *************************************************************************
    *************************************************************************
    **************       MEANING OF THE INPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *                                                                       *
    *  -- N     : degree of the polynomial.                                 *
    *  -- POLY  : complex vector of N+1 components, POLY(i) is the          *
    *           coefficient of x**(i), i=0,1,...,N of the polynomial p(x)   *
    *  -- EPS   : machine precision of the floating point arithmetic used   *
    *            by the computer, EPS=2**(-53)  for the IEEE standard.      *
    *  -- BIG   : the max real*8, BIG=2**1024 for the IEEE standard.        *
    *  -- SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *  -- NITMAX: the max number of allowed iterations.                     *
    *************************************************************************
    *************************************************************************
    **************      MEANING OF THE OUTPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  ROOT   : complex vector of N components, containing the              *
    *           approximations to the roots of p(x).                        *
    *  RADIUS : real vector of N components, containing the error bounds to *
    *           the approximations of the roots, i.e. the disk of center    *
    *           ROOT(i) and radius RADIUS(i) contains a root of p(x), for   *
    *           i=1,...,N. RADIUS(i) is set to -1 if the corresponding root *
    *           cannot be represented as floating point due to overflow or  *
    *           underflow.                                                  *
    *  ERR    : vector of N components detecting an error condition;        *
    *           ERR(j)=.TRUE. if after NITMAX iterations the stop condition *
    *                         (3) is not satisfied for x(j)=ROOT(j);        *
    *           ERR(j)=.FALSE.  otherwise, i.e., the root is reliable,      *
    *                         i.e., it can be viewed as an exact root of a  *
    *                         slightly perturbed polynomial.                *
    *           The vector ERR is used also in the routine convex hull for  *
    *           storing the abscissae of the vertices of the convex hull.   *
    *  ITER   : number of iterations performed.                             *
    *************************************************************************
    *************************************************************************
    *************    MEANING OF THE AUXILIARY VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  APOLY  : real vector of N+1 components used to store the moduli of   *
    *           the coefficients of p(x) and the coefficients of s(x) used  *
    *           to test the stop condition (3).                             *
    *  APOLYR : real vector of N+1 components used to test the stop         *
    *           condition                                                   *
    *************************************************************************
    ******         WARNING:   2 is the output unit                    *******
    *************************************************************************/
    // Version for polynomial with real coefficients.
    static int polzeros(int n, double[] poly, double eps, double big,
                        int nitmax, Complex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
        double amax;
<span class="fc" id="L713">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if (poly[n] == 0.0) {</span>
<span class="nc" id="L718">                return -1;</span>
            }
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (poly[0] == 0.0) {</span>
<span class="nc" id="L721">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="fc" id="L726">            amax = 0.0;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L728">                apoly[i] = Math.abs(poly[i]);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                if (amax &lt; apoly[i]) {</span>
<span class="fc" id="L730">                    amax = apoly[i];</span>
                }
<span class="fc" id="L732">                apolyr[i] = apoly[i];</span>
            }

<span class="pc bpc" id="L735" title="1 of 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L736">                return -3;</span>
            }

<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L741">                root[0] = new Complex(-poly[0]/poly[1]);</span>
<span class="nc" id="L742">                err[0] = false;</span>
<span class="nc" id="L743">                iter[0] = 1;</span>
<span class="nc" id="L744">                radius[0] = eps * root[0].abs();</span>
<span class="nc" id="L745">                return 0;</span>
            }

            // Initialize
<span class="fc bfc" id="L749" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L750">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="fc" id="L759">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="fc bfc" id="L762" title="All 2 branches covered.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L763">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="fc" id="L764">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="fc bfc" id="L767" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="fc" id="L772">            iter[0] = 0;</span>
        } 
        else {
<span class="nc" id="L775">            nzeros = 0;</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L778">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L790">                    Complex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L791">                    Complex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L792">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L796">                        nzeros++;</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">                            if (needSort) {</span>
<span class="fc" id="L799">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L801">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L808">        return -4;</span>
    }

    
    
    // Version for complex coefficients.
    static int polzeros(int n, Complex[] poly, double eps, double big,
                        int nitmax, Complex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
<span class="fc" id="L819">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">            if (poly[n].isZero()) {</span>
<span class="nc" id="L824">                return -1;</span>
            }
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">            if (poly[0].isZero()) {</span>
<span class="nc" id="L827">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="fc" id="L832">            double amax = 0.0;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L834">                apoly[i] = poly[i].abs();</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                if (amax &lt; apoly[i]) {</span>
<span class="fc" id="L836">                    amax = apoly[i];</span>
                }
<span class="fc" id="L838">                apolyr[i] = apoly[i];</span>
            }

<span class="pc bpc" id="L841" title="1 of 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L842">                return -3;</span>
            }

<span class="pc bpc" id="L845" title="1 of 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L847">                root[0] = poly[0].div(poly[1]).neg();</span>
<span class="nc" id="L848">                err[0] = false;</span>
<span class="nc" id="L849">                iter[0] = 1;</span>
<span class="nc" id="L850">                radius[0] = eps * root[0].abs();</span>
<span class="nc" id="L851">                return 0;</span>
            }

            // Initialize
<span class="fc bfc" id="L855" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L856">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="fc" id="L865">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="fc bfc" id="L868" title="All 2 branches covered.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L869">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="fc" id="L870">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="fc bfc" id="L873" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="fc" id="L878">            iter[0] = 0;</span>
<span class="fc" id="L879">        }</span>
        else {
<span class="nc" id="L881">            nzeros = 0;</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L884">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L896">                    Complex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L897">                    Complex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L898">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L902">                        nzeros++;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">                            if (needSort) {</span>
<span class="fc" id="L905">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L907">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L914">        return -4;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>