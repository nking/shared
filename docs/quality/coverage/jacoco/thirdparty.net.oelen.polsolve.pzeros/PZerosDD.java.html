<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PZerosDD.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.net.oelen.polsolve.pzeros</a> &gt; <span class="el_source">PZerosDD.java</span></div><h1>PZerosDD.java</h1><pre class="source lang-java linenums">/*
The author of this code is Wilco Oelen and he offers it
freely without copyright, but asks that his pages are referenced
as the source if used.
He has a webpage with information on the polynomial software
he ported and more modern versions which require jini bindings:
https://woelen.homescience.net/science/math/exps/polynomials/
https://woelen.homescience.net/science/math/exps/polynomials/software.html
The code here is from the Java port of RPoly, CPoly and MPSolve 1996 algorithms:
https://woelen.homescience.net/science/math/exps/polynomials/software/polsolve.tgz
*/
package thirdparty.net.oelen.polsolve.pzeros;

// PolSolve code for DoubleDouble precision (105 bits)

import thirdparty.net.oelen.polarith.DoubleComplex;
import thirdparty.net.oelen.polarith.DoubleDouble;



/************************************************************************
*    NUMERICAL COMPUTATION OF THE ROOTS OF A POLYNOMIAL HAVING          *
*        COMPLEX COEFFICIENTS, BASED ON ABERTH'S METHOD.                *
*                      Version 1.4, June   1996                         *
*    (D. Bini, Dipartimento di Matematica, Universita' di Pisa)         *
*                         (bini@dm.unipi.it)                            *
*************************************************************************
* Work performed under the support of the ESPRIT BRA project 6846 POSSO *
*************************************************************************
***********         SUBROUTINES AND FUNCTIONS                 ***********
*************************************************************************
*  The following modules are listed:                                    *
*  POLZEROS  :  computes polynomial roots by means of Aberth's method   *
*    ABERTH  :  computes the Aberth correction                          *
*    NEWTON  :  computes p(x)/p'(x) by means of Ruffini-Horner's rule   *
*    START   :  Selects N starting points by means of Rouche's theorem  *
*    CNVEX   :  Computes the convex hull, used by START                 *
*    CMERGE  :  Used by CNVEX                                           *
*    LEFT    :  Used by CMERGE                                          *
*    RIGHT   :  Used by CMERGE                                          *
*    CTEST   :  Convexity test, Used by CMERGE                          *
*************************************************************************/

<span class="nc" id="L44">strictfp class PZerosDD {</span>

    
    
    
    
    /************************************************************************
    *                             SUBROUTINE NEWTON                         *
    *************************************************************************
    * Compute  the Newton's correction, the inclusion radius (4) and checks *
    * the stop condition (3)                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial p(x)                             *
    *     POLY  : coefficients of the polynomial p(x)                       *
    *     APOLY : upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying Ruffini-Horner's rule  *
    *     APOLYR: upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying (2), (2')              *
    *     Z     : value at which the Newton correction is computed          *
    *     SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *************************************************************************
    * Output variables:                                                     *
    *     RADIUS: upper bound to the distance of Z from the closest root of *
    *             the polynomial computed according to (4).                 *
    *     CORR  : Newton's correction                                       *
    *     AGAIN : this variable is .true. if the computed value p(z) is     *
    *             reliable, i.e., (3) is not satisfied in Z. AGAIN is       *
    *             .false., otherwise.                                       *
    *************************************************************************/
    // Version for a polynomial with complex coefficients.
    private static DoubleComplex newton(int n, DoubleComplex[] poly, double[] apoly, double[] apolyr,
                                        DoubleComplex z, double small, double eps,
                                        /* out */ double[] radius, /* out */ boolean[] again,
                                        int outIndex) {
        int i;
        DoubleComplex p, p1;
        DoubleComplex corr;
        double ap, az;

<span class="fc" id="L84">        az = z.ComplexValue().abs();</span>

        // If |z|&lt;=1 then apply Ruffini-Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply Ruffini-Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L92">            p = poly[n];</span>
<span class="fc" id="L93">            p1 = p;</span>
<span class="fc" id="L94">            ap = apoly[n];</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
<span class="fc" id="L96">                p = poly[i].add(p.mul(z));</span>
<span class="fc" id="L97">                p1 = p.add(p1.mul(z));</span>
<span class="fc" id="L98">                ap = apoly[i] + ap * az;</span>
            }
<span class="fc" id="L100">            p = poly[0].add(p.mul(z));</span>
<span class="fc" id="L101">            ap = apoly[0] + ap * az;</span>
<span class="fc" id="L102">            corr = p.div(p1);</span>

<span class="fc" id="L104">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L106">            double absp = Math.abs(p.re.doubleValue()) + Math.abs(p.im.doubleValue());</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L109">                radius[outIndex] = n * (absp + epsap) / p1.abs().doubleValue();</span>
            }
<span class="fc" id="L111">        } else // az &gt;= 1.0</span>
        {
            DoubleComplex zi, den, ppsp;
            double azi;

<span class="fc" id="L116">            zi = z.recip();</span>
<span class="fc" id="L117">            azi = 1.0 / az;</span>
<span class="fc" id="L118">            p = poly[0];</span>
<span class="fc" id="L119">            p1 = p;</span>
<span class="fc" id="L120">            ap = apolyr[n];</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
<span class="fc" id="L122">                p = poly[n - i].add(p.mul(zi));</span>
<span class="fc" id="L123">                p1 = p.add(p1.mul(zi));</span>
<span class="fc" id="L124">                ap = apolyr[i] + ap * azi;</span>
            }
<span class="fc" id="L126">            p = poly[n].add(p.mul(zi));</span>
<span class="fc" id="L127">            ap = apolyr[0] + ap * azi;</span>

<span class="fc" id="L129">            ppsp = p.mul(z).div(p1);</span>
<span class="fc" id="L130">            den = ppsp.mul(n).sub1();</span>
<span class="fc" id="L131">            corr = z.mul(ppsp.div(den));</span>
<span class="fc" id="L132">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L134">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L137">                radius[outIndex] = ppsp.abs().doubleValue() + (epsap * az) / p1.abs().doubleValue();</span>
<span class="fc" id="L138">                radius[outIndex] *= n / den.abs().doubleValue();</span>
<span class="fc" id="L139">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L143">        return corr;</span>
    }
    
    
    

    // Version for a polynomial with real coefficients.
    private static DoubleComplex newton(int n, DoubleDouble[] poly, double[] apoly, double[] apolyr,
                                        DoubleComplex z, double small, double eps,
                                        /* out */ double[] radius, /* out */ boolean[] again,
                                        int outIndex) {
        int i;
        DoubleComplex p, p1;
        double ap, az;

<span class="fc" id="L158">        az = z.abs().doubleValue();</span>
        
        DoubleComplex corr;

        // Use a method like Horner's method, but developed especially for
        // evaluation of real polynomials for complex values.
        // This method requires only half amount of the number of real
        // multiplications as standard Horner's rule.
        // BIT 5 (1965), 142, see also G. Goertzel, AMM 65 (1958), 34-35
        // This method only works for polynomials of degree &gt;= 2.

        // If |z|&lt;=1 then apply modified Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply modified Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L175">            DoubleDouble r = z.real().mulPowerOf2(2);</span>
<span class="fc" id="L176">            DoubleDouble s = z.sqrabs();</span>
<span class="fc" id="L177">            DoubleDouble aa = poly[n];</span>
<span class="fc" id="L178">            DoubleDouble bb = poly[n - 1];</span>

            // Compute p(z) and |p|(|z|)
<span class="fc" id="L181">            ap = apoly[n - 1] + az * apoly[n];</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L184">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L185">                bb = poly[i].sub(s.mul(aa));</span>
<span class="fc" id="L186">                aa = tmp;</span>

                // Next step for |p|(|z|)
<span class="fc" id="L189">                ap = apoly[i] + ap * az;</span>
            }
<span class="fc" id="L191">            p = z.mul(aa).add(bb);</span>

            // Compute p'(z)
<span class="fc" id="L194">            aa = poly[n].mul(n);</span>
<span class="fc" id="L195">            bb = poly[n - 1].mul(n - 1);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L197">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L198">                bb = poly[i].mul(i).sub(s.mul(aa));</span>
<span class="fc" id="L199">                aa = tmp;</span>
            }
<span class="fc" id="L201">            p1 = z.mul(aa).add(bb);</span>

<span class="fc" id="L203">            double epsap = eps * ap;</span>
<span class="fc" id="L204">            corr = p.div(p1);</span>
            //double absp = p.abs().doubleValue();
<span class="fc" id="L206">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L209">                radius[outIndex] = n * (absp + epsap) / p1.abs().doubleValue();</span>
            }
<span class="fc" id="L211">        } </span>
        else // az &gt;= 1.0
        {
            DoubleComplex den, ppsp;

<span class="fc" id="L216">            DoubleComplex zi = z.recip();</span>
<span class="fc" id="L217">            double azi = 1.0 / az;</span>

<span class="fc" id="L219">            DoubleDouble r = zi.real().mulPowerOf2(2);</span>
<span class="fc" id="L220">            DoubleDouble s = zi.sqrabs();</span>
<span class="fc" id="L221">            DoubleDouble aa = poly[0];</span>
<span class="fc" id="L222">            DoubleDouble bb = poly[1];</span>

            // Compute q(zi) and |q|(|zi|), where
            // q equals p with reversed coefficients.
<span class="fc" id="L226">            ap = apolyr[n - 1] + azi * apolyr[n];</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L229">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L230">                bb = poly[n - i].sub(s.mul(aa));</span>
<span class="fc" id="L231">                aa = tmp;</span>

                // Next step for |q|(|zi|)
<span class="fc" id="L234">                ap = apolyr[i] + ap * azi;</span>
            }
<span class="fc" id="L236">            p = zi.mul(aa).add(bb);</span>

            // Compute q'(zi)
<span class="fc" id="L239">            aa = poly[0].mul(n);</span>
<span class="fc" id="L240">            bb = poly[1].mul(n - 1);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L242">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L243">                bb = poly[n - i].mul(i).sub(s.mul(aa));</span>
<span class="fc" id="L244">                aa = tmp;</span>
            }
<span class="fc" id="L246">            p1 = zi.mul(aa).add(bb);</span>

<span class="fc" id="L248">            ppsp = p.mul(z).div(p1);</span>
<span class="fc" id="L249">            den = ppsp.mul(n).sub1();</span>
<span class="fc" id="L250">            corr = z.mul(ppsp.div(den));</span>
<span class="fc" id="L251">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L253">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L256">                radius[outIndex] = (ppsp.abs().doubleValue() + (epsap * az) / p1.abs().doubleValue());</span>
<span class="fc" id="L257">                radius[outIndex] *= n / den.abs().doubleValue();</span>
<span class="fc" id="L258">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L262">        return corr;</span>
    }

    
    
    
    
    /************************************************************************
    *                             SUBROUTINE ABERTH                         *
    *************************************************************************
    * Compute  the Aberth correction. To save time, the reciprocation of    *
    * ROOT(J)-ROOT(I) could be performed in single precision (complex*8)    *
    * In principle this might cause overflow if both ROOT(J) and ROOT(I)    *
    * have too small moduli.                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial                                  *
    *     ROOT  : vector containing the current approximations to the roots *
    *     J     : index of the component of ROOT with respect to which the  *
    *             Aberth correction is computed                             *
    *************************************************************************
    * Output variable:                                                      *
    *     ABCORR: Aberth's correction (compare (1))                         *
    *************************************************************************/
    
    /* The pseudocode below is left here for documentation purposes, the real
     * code is further below. By doing the aberth correction in normal double
     * precision, the algorithm hardly suffers but the speedup is considerable
     * (more than a factor 2 speedup for quad double arithmatic in a typical
     * case). Only the difference between the roots is computed, using full
     * precision (this may be necessary in case of (nearly) equal roots), but
     * the 1/(z-zj) correction can be computed in standard precision.

       static complex aberth(int n, int j, complex[] root) { 
           int i; 
           complex zj;
     
           complex abcorr = 0.0; 
           zj = root[j]; 
           for (i=0; i&lt;n; i++) {
               if (i != j) {
                   complex z = zj - root[i];
                   abcorr += 1.0 / z;
               }
           }
           return abcorr;
       }

     */
    
    private static DoubleComplex aberth(int n, int j, DoubleComplex root[]) {
<span class="fc" id="L313">        DoubleDouble zj_re = root[j].re;</span>
<span class="fc" id="L314">        DoubleDouble zj_im = root[j].im;</span>

<span class="fc" id="L316">        double corr_re = 0.0;</span>
<span class="fc" id="L317">        double corr_im = 0.0;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (i != j) {</span>
<span class="fc" id="L320">                double z_re = zj_re.sub(root[i].re).doubleValue();</span>
<span class="fc" id="L321">                double z_im = zj_im.sub(root[i].im).doubleValue();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                double absr = (z_re &gt; 0) ? z_re : -z_re;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                double absi = (z_im &gt; 0) ? z_im : -z_im;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                if (absr &gt; absi) {</span>
<span class="fc" id="L325">                    double r = z_im / z_re;</span>
<span class="fc" id="L326">                    double den = z_re + r * z_im;</span>
<span class="fc" id="L327">                    corr_re += 1.0/den;</span>
<span class="fc" id="L328">                    corr_im -= r/den;</span>
<span class="fc" id="L329">                } </span>
                else {
<span class="fc" id="L331">                    double r = z_re / z_im;</span>
<span class="fc" id="L332">                    double den = z_im + r * z_re;</span>
<span class="fc" id="L333">                    corr_re += r/den;</span>
<span class="fc" id="L334">                    corr_im -= 1.0/den;</span>
                }
            }
        }

<span class="fc" id="L339">        return new DoubleComplex(corr_re, corr_im);  // Aberth correction</span>
    }
    
    
    

    /************************************************************************
    *                             SUBROUTINE START                          *
    *************************************************************************
    * Compute  the starting approximations of the roots                     *
    *************************************************************************
    * Input variables:                                                      *
    *     N     :  number of the coefficients of the polynomial             *
    *     A     :  moduli of the coefficients of the polynomial             *
    *     SMALL : the min positive real*8, SMALL=2**(-1074) for the IEEE.   *
    *     BIG   : the max real*8, BIG=2**1023 for the IEEE standard.        *
    * Output variables:                                                     *
    *     Y     :  starting approximations                                  *
    *     RADIUS:  if a component is -1 then the corresponding root has a   *
    *              too big or too small modulus in order to be represented  *
    *              as double float with no overflow/underflow               *
    *     NZ    :  number of roots which cannot be represented without      *
    *              overflow/underflow                                       *
    * Auxiliary variables:                                                  *
    *     H     :  needed for the computation of the convex hull            *
    *************************************************************************
    * This routine selects starting approximations along circles center at  *
    * 0 and having suitable radii. The computation of the number of circles *
    * and of the corresponding radii is performed by computing the upper    *
    * convex hull of the set (i,log(A(i))), i=1,...,n+1.                    *
    *************************************************************************/
    private static int start(int n, double[] a, DoubleComplex[] y, double[] radius, double big) {
        int i, iold, nzeros, j, jj;
        double r, th, ang, temp;
<span class="nc" id="L373">        final double sigma = 0.7;</span>
<span class="nc" id="L374">        final double pi2 = 6.2831853071796;</span>
<span class="nc" id="L375">        double xbig = Math.log(big);</span>
<span class="nc" id="L376">        double xsmall = -xbig;</span>
<span class="nc" id="L377">        boolean[] h = new boolean[n + 1];</span>
        int nz;   // number of zeros which cannot be represented without under/overflow.

<span class="nc" id="L380">        nz = 0;</span>

        // Compute the logarithm A(I) of the moduli of the coefficients of
        // the polynomial and then the upper convex hull of the set (A(I),I)
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (i = 0; i &lt;= n; i++) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (a[i] != 0.0) {</span>
<span class="nc" id="L386">                a[i] = Math.log(a[i]);</span>
            } else {
<span class="nc" id="L388">                a[i] = -1e30;   // -infinity</span>
            }
        }
<span class="nc" id="L391">        Convex.cnvex(n, a, h);</span>

        // Given the upper convex hull of the set (A(I),I) compute the moduli
        // of the starting approximations by means of Rouche's theorem
<span class="nc" id="L395">        iold = 0;</span>
<span class="nc" id="L396">        th = pi2 / n;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        for (i = 1; i &lt;= n; i++) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (h[i]) {</span>
<span class="nc" id="L399">                nzeros = i - iold;</span>
<span class="nc" id="L400">                temp = (a[iold] - a[i]) / nzeros;</span>
<span class="nc" id="L401">                boolean underflow = false, overflow = false;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (temp &lt;= xsmall) {</span>
                    // Radii are too small, underflow situation.
<span class="nc" id="L404">                    underflow = true;</span>
<span class="nc" id="L405">                    r = 0.0;</span>
<span class="nc" id="L406">                    nz += nzeros;</span>
                } 
<span class="nc bnc" id="L408" title="All 2 branches missed.">                else if (temp &gt;= xbig) {</span>
                    // Overflow situation.
<span class="nc" id="L410">                    overflow = true;</span>
<span class="nc" id="L411">                    r = big;</span>
<span class="nc" id="L412">                    nz += nzeros;</span>
                } 
                else {
                    // In range of floating point arithmetic.
<span class="nc" id="L416">                    r = Math.exp(temp);</span>
                }

<span class="nc" id="L419">                ang = pi2 / nzeros;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                for (j = iold; j &lt; i; j++) {</span>
<span class="nc" id="L421">                    jj = j - iold;</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">                    if (underflow || overflow) {</span>
<span class="nc" id="L423">                        radius[j] = -1.0;</span>
<span class="nc" id="L424">                        y[j] = new DoubleComplex(r);</span>
                    } 
                    else {
<span class="nc" id="L427">                        double re = r * Math.cos(ang * jj + th * i + sigma);</span>
<span class="nc" id="L428">                        double im = r * Math.sin(ang * jj + th * i + sigma);</span>
<span class="nc" id="L429">                        y[j] = new DoubleComplex(re, im);</span>
                    }
                }

                // Make the current vertex the basis for the
                // new set of roots.
<span class="nc" id="L435">                iold = i;</span>
            }
        }
        
<span class="nc" id="L439">        return nz;</span>
    }
    
    

    /************************************************************************
    *                             SUBROUTINE SORT                           *
    *************************************************************************
    *   SORT  the vector X, according to nonincreasing real parts,          *
    *   the same permutation is applied to vectors Y and E.                 *
    *************************************************************************/
    private static void sort(int n, DoubleComplex[] x, double[] y, boolean[] e) {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        for (int k = 0; k &lt; n - 1; k++) {</span>
<span class="fc" id="L452">            DoubleDouble amax = x[k].real();</span>
<span class="fc" id="L453">            int imax = k;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            for (int i = k + 1; i &lt; n; i++) {</span>
<span class="fc" id="L455">                DoubleDouble rxi = x[i].real();</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">                if (amax.compareTo(rxi) &lt; 0) {</span>
<span class="fc" id="L457">                    amax = rxi;</span>
<span class="fc" id="L458">                    imax = i;</span>
                }
            }

<span class="fc" id="L462">            DoubleComplex temp = x[k];</span>
<span class="fc" id="L463">            x[k] = x[imax];</span>
<span class="fc" id="L464">            x[imax] = temp;</span>

<span class="fc" id="L466">            double yt = y[k];</span>
<span class="fc" id="L467">            y[k] = y[imax];</span>
<span class="fc" id="L468">            y[imax] = yt;</span>

<span class="fc" id="L470">            boolean et = e[k];</span>
<span class="fc" id="L471">            e[k] = e[imax];</span>
<span class="fc" id="L472">            e[imax] = et;</span>
        }
<span class="fc" id="L474">    }</span>

    
    
    
    
    /************************************************************************
    *********************** SUBROUTINE POLZEROS *****************************
    *************************************************************************
    *                        GENERAL COMMENTS                               *
    *************************************************************************
    *  This routine approximates the roots of   the  polynomial             *
    *  p(x)=a(n)x^n+a(n-1)x^(n-1)+...+a(0), a(j)=cr(j)+I ci(j), I**2=-1,    *
    *  where a(0) and a(n) are nonzero.                                     *
    *  The coefficients are complex*16 numbers. The routine is fast, robust *
    *  against overflow, and allows to deal with polynomials of any degree. *
    *  Overflow situations are very unlikely and may occurr if there exist  *
    *  simultaneously coefficients of moduli close to BIG and close to      *
    *  SMALL, i.e., the greatest and the smallest positive real*8 numbers,  *
    *  respectively. In this limit situation the program outputs a warning  *
    *  message. The computation can be speeded up by performing some side   *
    *  computations in single precision, thus slightly reducing the         *
    *  robustness of the program (see the comments in the routine ABERTH).  *
    *  Besides a set of approximations to the roots, the program delivers a *
    *  set of a-posteriori error bounds which are guaranteed in the most    *
    *  part of cases. In the situation where underflow does not allow to    *
    *  compute a guaranteed bound, the program outputs a warning message    *
    *  and sets the bound to 0. In the situation where the root cannot be   *
    *  represented as a complex*16 number the error bound is set to -1.     *
    *************************************************************************
    *  The computation is performed by means of Aberth's method             *
    *  according to the formula                                             *
    *           x(i)=x(i)-newt/(1-newt*abcorr), i=1,...,n             (1)   *
    *  where newt=p(x(i))/p'(x(i)) is the Newton correction and abcorr=     *
    *  =1/(x(i)-x(1))+...+1/(x(i)-x(i-1))+1/(x(i)-x(i+1))+...+1/(x(i)-x(n)) *
    *  is the Aberth correction to the Newton method.                       *
    *************************************************************************
    *  The value of the Newton correction is computed by means of the       *
    *  synthetic division algorithm (Ruffini-Horner's rule) if |x|&lt;=1,      *
    *  otherwise the following more robust (with respect to overflow)       *
    *  formula is applied:                                                  *
    *                    newt=1/(n*y-y**2 R'(y)/R(y))                 (2)   *
    *  where                                                                *
    *                    y=1/x                                              *
    *                    R(y)=a(0)*y**n+...+a(n-1)*y+a(n)            (2')   *
    *  This computation is performed by the routine NEWTON.                 *
    *************************************************************************
    *  The starting approximations are complex numbers that are             *
    *  equispaced on circles of suitable radii. The radius of each          *
    *  circle, as well as the number of roots on each circle and the        *
    *  number of circles, is determined by applying Rouche's theorem        *
    *  to the functions a(k)*x**k and p(x)-a(k)*x**k, k=0,...,n.            *
    *  This computation is performed by the routine START.                  *
    *************************************************************************
    *                              STOP CONDITION                           *
    *************************************************************************
    * If the condition                                                      *
    *                     |p(x(j))|&lt;EPS s(|x(j)|)                      (3)  *
    * is satisfied,    where      s(x)=s(0)+x*s(1)+...+x**n * s(n),         *
    * s(i)=|a(i)|*(1+3.8*i),  EPS is the machine precision (EPS=2**-53      *
    * for the IEEE arithmetic), then the approximation x(j) is not updated  *
    * and the subsequent iterations (1)  for i=j are skipped.               *
    * The program stops if the condition (3) is satisfied for j=1,...,n,    *
    * or if the maximum number NITMAX of  iterations   has   been reached.  *
    * The condition (3) is motivated by a backward rounding error analysis  *
    * of the Ruffini-Horner rule, moreover the condition (3) guarantees     *
    * that the computed approximation x(j) is an exact root of a slightly   *
    * perturbed polynomial.                                                 *
    *************************************************************************
    *             INCLUSION DISKS, A-POSTERIORI ERROR BOUNDS                *
    *************************************************************************
    * For each approximation x of a root, an a-posteriori absolute error    *
    * bound r is computed according to the formula                          *
    *                   r=n(|p(x)|+EPS s(|x|))/|p'(x)|                 (4)  *
    * This provides an inclusion disk of center x and radius r containing a *
    * root.                                                                 *
    *************************************************************************
    *************************************************************************
    **************       MEANING OF THE INPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *                                                                       *
    *  -- N     : degree of the polynomial.                                 *
    *  -- POLY  : complex vector of N+1 components, POLY(i) is the          *
    *           coefficient of x**(i), i=0,1,...,N of the polynomial p(x)   *
    *  -- EPS   : machine precision of the floating point arithmetic used   *
    *            by the computer, EPS=2**(-53)  for the IEEE standard.      *
    *  -- BIG   : the max real*8, BIG=2**1024 for the IEEE standard.        *
    *  -- SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *  -- NITMAX: the max number of allowed iterations.                     *
    *************************************************************************
    *************************************************************************
    **************      MEANING OF THE OUTPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  ROOT   : complex vector of N components, containing the              *
    *           approximations to the roots of p(x).                        *
    *  RADIUS : real vector of N components, containing the error bounds to *
    *           the approximations of the roots, i.e. the disk of center    *
    *           ROOT(i) and radius RADIUS(i) contains a root of p(x), for   *
    *           i=1,...,N. RADIUS(i) is set to -1 if the corresponding root *
    *           cannot be represented as floating point due to overflow or  *
    *           underflow.                                                  *
    *  ERR    : vector of N components detecting an error condition;        *
    *           ERR(j)=.TRUE. if after NITMAX iterations the stop condition *
    *                         (3) is not satisfied for x(j)=ROOT(j);        *
    *           ERR(j)=.FALSE.  otherwise, i.e., the root is reliable,      *
    *                         i.e., it can be viewed as an exact root of a  *
    *                         slightly perturbed polynomial.                *
    *           The vector ERR is used also in the routine convex hull for  *
    *           storing the abscissae of the vertices of the convex hull.   *
    *  ITER   : number of iterations performed.                             *
    *************************************************************************
    *************************************************************************
    *************    MEANING OF THE AUXILIARY VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  APOLY  : real vector of N+1 components used to store the moduli of   *
    *           the coefficients of p(x) and the coefficients of s(x) used  *
    *           to test the stop condition (3).                             *
    *  APOLYR : real vector of N+1 components used to test the stop         *
    *           condition                                                   *
    *************************************************************************
    ******         WARNING:   2 is the output unit                    *******
    *************************************************************************/
    // Version for polynomial with real coefficients.
    static int polzeros(int n, DoubleDouble[] poly, double eps, double big,
                        int nitmax, DoubleComplex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
        double amax;
<span class="fc" id="L606">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (poly[n].isZero()) {</span>
<span class="nc" id="L611">                return -1;</span>
            }
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (poly[0].isZero()) {</span>
<span class="nc" id="L614">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="nc" id="L619">            amax = 0.0;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L621">                apoly[i] = poly[i].abs().doubleValue();</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (amax &lt; apoly[i]) {</span>
<span class="nc" id="L623">                    amax = apoly[i];</span>
                }
<span class="nc" id="L625">                apolyr[i] = apoly[i];</span>
            }

<span class="nc bnc" id="L628" title="All 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L629">                return -3;</span>
            }

<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L634">                root[0] = new DoubleComplex(poly[0].div(poly[1]).neg());</span>
<span class="nc" id="L635">                err[0] = false;</span>
<span class="nc" id="L636">                iter[0] = 1;</span>
<span class="nc" id="L637">                radius[0] = eps * root[0].abs().doubleValue();</span>
<span class="nc" id="L638">                return 0;</span>
            }

            // Initialize
<span class="nc bnc" id="L642" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L643">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="nc" id="L652">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="nc bnc" id="L655" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L656">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="nc" id="L657">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="nc bnc" id="L660" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="nc" id="L665">            iter[0] = 0;</span>
        } 
        else {
<span class="fc" id="L668">            nzeros = 0;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L671">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L683">                    DoubleComplex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L684">                    DoubleComplex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L685">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L689">                        nzeros++;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">                            if (needSort) {</span>
<span class="fc" id="L692">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L694">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L701">        return -4;</span>
    }

    
    // Version for polynomial with complex coefficients.
    static int polzeros(int n, DoubleComplex[] poly, double eps, double big,
                        int nitmax, DoubleComplex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
<span class="fc" id="L711">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (poly[n].isZero()) {</span>
<span class="nc" id="L716">                return -1;</span>
            }
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (poly[0].isZero()) {</span>
<span class="nc" id="L719">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="nc" id="L724">            double amax = 0.0;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L726">                apoly[i] = poly[i].abs().doubleValue();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (amax &lt; apoly[i]) {</span>
<span class="nc" id="L728">                    amax = apoly[i];</span>
                }
<span class="nc" id="L730">                apolyr[i] = apoly[i];</span>
            }

<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L734">                return -3;</span>
            }

<span class="nc bnc" id="L737" title="All 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L739">                root[0] = poly[0].div(poly[1]).neg();</span>
<span class="nc" id="L740">                err[0] = false;</span>
<span class="nc" id="L741">                iter[0] = 1;</span>
<span class="nc" id="L742">                radius[0] = eps * root[0].abs().doubleValue();</span>
<span class="nc" id="L743">                return 0;</span>
            }

            // Initialize
<span class="nc bnc" id="L747" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L748">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="nc" id="L757">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="nc bnc" id="L760" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L761">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="nc" id="L762">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="nc bnc" id="L765" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="nc" id="L770">            iter[0] = 0;</span>
<span class="nc" id="L771">        }</span>
        else {
<span class="fc" id="L773">            nzeros = 0;</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L776">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L788">                    DoubleComplex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L789">                    DoubleComplex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L790">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L794">                        nzeros++;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                            if (needSort) {</span>
<span class="fc" id="L797">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L799">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L806">        return -4;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>