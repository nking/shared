<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PZerosDD.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.net.oelen.polsolve.pzeros</a> &gt; <span class="el_source">PZerosDD.java</span></div><h1>PZerosDD.java</h1><pre class="source lang-java linenums">/*
The author of this code is Wilco Oelen and he offers it
freely without copyright, but asks that his pages are referenced
as the source if used.
He has a webpage with information on the polynomial software
he ported and more modern versions which require jini bindings:
https://woelen.homescience.net/science/math/exps/polynomials/
https://woelen.homescience.net/science/math/exps/polynomials/software.html
The code here is from the Java port of RPoly, CPoly and MPSolve 1996 algorithms:
https://woelen.homescience.net/science/math/exps/polynomials/software/polsolve.tgz
*/
package thirdparty.net.oelen.polsolve.pzeros;

// PolSolve code for DoubleDouble precision (105 bits)

import thirdparty.net.oelen.polarith.DoubleComplex;
import thirdparty.net.oelen.polarith.DoubleDouble;



/************************************************************************
*    NUMERICAL COMPUTATION OF THE ROOTS OF A POLYNOMIAL HAVING          *
*        COMPLEX COEFFICIENTS, BASED ON ABERTH'S METHOD.                *
*                      Version 1.4, June   1996                         *
*    (D. Bini, Dipartimento di Matematica, Universita' di Pisa)         *
*                         (bini@dm.unipi.it)                            *
*************************************************************************
* Work performed under the support of the ESPRIT BRA project 6846 POSSO *
*************************************************************************
***********         SUBROUTINES AND FUNCTIONS                 ***********
*************************************************************************
*  The following modules are listed:                                    *
*  POLZEROS  :  computes polynomial roots by means of Aberth's method   *
*    ABERTH  :  computes the Aberth correction                          *
*    NEWTON  :  computes p(x)/p'(x) by means of Ruffini-Horner's rule   *
*    START   :  Selects N starting points by means of Rouche's theorem  *
*    CNVEX   :  Computes the convex hull, used by START                 *
*    CMERGE  :  Used by CNVEX                                           *
*    LEFT    :  Used by CMERGE                                          *
*    RIGHT   :  Used by CMERGE                                          *
*    CTEST   :  Convexity test, Used by CMERGE                          *
*************************************************************************/

<span class="nc" id="L44">strictfp class PZerosDD {</span>

    
    
    
    
    /************************************************************************
    *                             SUBROUTINE NEWTON                         *
    *************************************************************************
    * Compute  the Newton's correction, the inclusion radius (4) and checks *
    * the stop condition (3)                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial p(x)                             *
    *     POLY  : coefficients of the polynomial p(x)                       *
    *     APOLY : upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying Ruffini-Horner's rule  *
    *     APOLYR: upper bounds on the backward perturbations on the         *
    *             coefficients of p(x) when applying (2), (2')              *
    *     Z     : value at which the Newton correction is computed          *
    *     SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *************************************************************************
    * Output variables:                                                     *
    *     RADIUS: upper bound to the distance of Z from the closest root of *
    *             the polynomial computed according to (4).                 *
    *     CORR  : Newton's correction                                       *
    *     AGAIN : this variable is .true. if the computed value p(z) is     *
    *             reliable, i.e., (3) is not satisfied in Z. AGAIN is       *
    *             .false., otherwise.                                       *
     @param n
     @param again
     @param apoly
     @param apolyr
     @param poly
     @param z
     @param outIndex
     @param small
     @param eps
     @param radius
     @return 
    *************************************************************************/
    // Version for a polynomial with complex coefficients.
    private static DoubleComplex newton(int n, DoubleComplex[] poly, double[] apoly, double[] apolyr,
                                        DoubleComplex z, double small, double eps,
                                        /* out */ double[] radius, /* out */ boolean[] again,
                                        int outIndex) {
        int i;
        DoubleComplex p, p1;
        DoubleComplex corr;
        double ap, az;

<span class="fc" id="L95">        az = z.ComplexValue().abs();</span>

        // If |z|&lt;=1 then apply Ruffini-Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply Ruffini-Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L103">            p = poly[n];</span>
<span class="fc" id="L104">            p1 = p;</span>
<span class="fc" id="L105">            ap = apoly[n];</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
<span class="fc" id="L107">                p = poly[i].add(p.mul(z));</span>
<span class="fc" id="L108">                p1 = p.add(p1.mul(z));</span>
<span class="fc" id="L109">                ap = apoly[i] + ap * az;</span>
            }
<span class="fc" id="L111">            p = poly[0].add(p.mul(z));</span>
<span class="fc" id="L112">            ap = apoly[0] + ap * az;</span>
<span class="fc" id="L113">            corr = p.div(p1);</span>

<span class="fc" id="L115">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L117">            double absp = Math.abs(p.re.doubleValue()) + Math.abs(p.im.doubleValue());</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L120">                radius[outIndex] = n * (absp + epsap) / p1.abs().doubleValue();</span>
            }
<span class="fc" id="L122">        } else // az &gt;= 1.0</span>
        {
            DoubleComplex zi, den, ppsp;
            double azi;

<span class="fc" id="L127">            zi = z.recip();</span>
<span class="fc" id="L128">            azi = 1.0 / az;</span>
<span class="fc" id="L129">            p = poly[0];</span>
<span class="fc" id="L130">            p1 = p;</span>
<span class="fc" id="L131">            ap = apolyr[n];</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            for (i = n - 1; i &gt;= 1; i--) {</span>
<span class="fc" id="L133">                p = poly[n - i].add(p.mul(zi));</span>
<span class="fc" id="L134">                p1 = p.add(p1.mul(zi));</span>
<span class="fc" id="L135">                ap = apolyr[i] + ap * azi;</span>
            }
<span class="fc" id="L137">            p = poly[n].add(p.mul(zi));</span>
<span class="fc" id="L138">            ap = apolyr[0] + ap * azi;</span>

<span class="fc" id="L140">            ppsp = p.mul(z).div(p1);</span>
<span class="fc" id="L141">            den = ppsp.mul(n).sub1();</span>
<span class="fc" id="L142">            corr = z.mul(ppsp.div(den));</span>
<span class="fc" id="L143">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L145">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L148">                radius[outIndex] = ppsp.abs().doubleValue() + (epsap * az) / p1.abs().doubleValue();</span>
<span class="fc" id="L149">                radius[outIndex] *= n / den.abs().doubleValue();</span>
<span class="fc" id="L150">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L154">        return corr;</span>
    }
    
    
    

    // Version for a polynomial with real coefficients.
    private static DoubleComplex newton(int n, DoubleDouble[] poly, double[] apoly, double[] apolyr,
                                        DoubleComplex z, double small, double eps,
                                        /* out */ double[] radius, /* out */ boolean[] again,
                                        int outIndex) {
        int i;
        DoubleComplex p, p1;
        double ap, az;

<span class="fc" id="L169">        az = z.abs().doubleValue();</span>
        
        DoubleComplex corr;

        // Use a method like Horner's method, but developed especially for
        // evaluation of real polynomials for complex values.
        // This method requires only half amount of the number of real
        // multiplications as standard Horner's rule.
        // BIT 5 (1965), 142, see also G. Goertzel, AMM 65 (1958), 34-35
        // This method only works for polynomials of degree &gt;= 2.

        // If |z|&lt;=1 then apply modified Horner's rule for p(z)/p'(z) 
        // and for the computation of the inclusion radius.
        // If |z|&gt;1 then apply modified Horner's rule to the reversed polynomial
        // and use formula (2) for p(z)/p'(z). Analogously do for the inclusion
        // radius.
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (az &lt; 1.0) {</span>
<span class="fc" id="L186">            DoubleDouble r = z.real().mulPowerOf2(2);</span>
<span class="fc" id="L187">            DoubleDouble s = z.sqrabs();</span>
<span class="fc" id="L188">            DoubleDouble aa = poly[n];</span>
<span class="fc" id="L189">            DoubleDouble bb = poly[n - 1];</span>

            // Compute p(z) and |p|(|z|)
<span class="fc" id="L192">            ap = apoly[n - 1] + az * apoly[n];</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L195">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L196">                bb = poly[i].sub(s.mul(aa));</span>
<span class="fc" id="L197">                aa = tmp;</span>

                // Next step for |p|(|z|)
<span class="fc" id="L200">                ap = apoly[i] + ap * az;</span>
            }
<span class="fc" id="L202">            p = z.mul(aa).add(bb);</span>

            // Compute p'(z)
<span class="fc" id="L205">            aa = poly[n].mul(n);</span>
<span class="fc" id="L206">            bb = poly[n - 1].mul(n - 1);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L208">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L209">                bb = poly[i].mul(i).sub(s.mul(aa));</span>
<span class="fc" id="L210">                aa = tmp;</span>
            }
<span class="fc" id="L212">            p1 = z.mul(aa).add(bb);</span>

<span class="fc" id="L214">            double epsap = eps * ap;</span>
<span class="fc" id="L215">            corr = p.div(p1);</span>
            //double absp = p.abs().doubleValue();
<span class="fc" id="L217">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L220">                radius[outIndex] = n * (absp + epsap) / p1.abs().doubleValue();</span>
            }
<span class="fc" id="L222">        } </span>
        else // az &gt;= 1.0
        {
            DoubleComplex den, ppsp;

<span class="fc" id="L227">            DoubleComplex zi = z.recip();</span>
<span class="fc" id="L228">            double azi = 1.0 / az;</span>

<span class="fc" id="L230">            DoubleDouble r = zi.real().mulPowerOf2(2);</span>
<span class="fc" id="L231">            DoubleDouble s = zi.sqrabs();</span>
<span class="fc" id="L232">            DoubleDouble aa = poly[0];</span>
<span class="fc" id="L233">            DoubleDouble bb = poly[1];</span>

            // Compute q(zi) and |q|(|zi|), where
            // q equals p with reversed coefficients.
<span class="fc" id="L237">            ap = apolyr[n - 1] + azi * apolyr[n];</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 0; i--) {</span>
                // Next step for polynomial.
<span class="fc" id="L240">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L241">                bb = poly[n - i].sub(s.mul(aa));</span>
<span class="fc" id="L242">                aa = tmp;</span>

                // Next step for |q|(|zi|)
<span class="fc" id="L245">                ap = apolyr[i] + ap * azi;</span>
            }
<span class="fc" id="L247">            p = zi.mul(aa).add(bb);</span>

            // Compute q'(zi)
<span class="fc" id="L250">            aa = poly[0].mul(n);</span>
<span class="fc" id="L251">            bb = poly[1].mul(n - 1);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            for (i = n - 2; i &gt;= 1; i--) {</span>
<span class="fc" id="L253">                DoubleDouble tmp = bb.add(r.mul(aa));</span>
<span class="fc" id="L254">                bb = poly[n - i].mul(i).sub(s.mul(aa));</span>
<span class="fc" id="L255">                aa = tmp;</span>
            }
<span class="fc" id="L257">            p1 = zi.mul(aa).add(bb);</span>

<span class="fc" id="L259">            ppsp = p.mul(z).div(p1);</span>
<span class="fc" id="L260">            den = ppsp.mul(n).sub1();</span>
<span class="fc" id="L261">            corr = z.mul(ppsp.div(den));</span>
<span class="fc" id="L262">            double epsap = eps * ap;</span>
            // double absp = p.abs().doubleValue();
<span class="fc" id="L264">            double absp = Math.abs(p.real().doubleValue()) + Math.abs(p.imag().doubleValue());</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            again[outIndex] = (absp &gt; small + epsap);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (!again[outIndex]) {</span>
<span class="fc" id="L267">                radius[outIndex] = (ppsp.abs().doubleValue() + (epsap * az) / p1.abs().doubleValue());</span>
<span class="fc" id="L268">                radius[outIndex] *= n / den.abs().doubleValue();</span>
<span class="fc" id="L269">                radius[outIndex] *= az;</span>
            }
        }
        
<span class="fc" id="L273">        return corr;</span>
    }

    
    
    
    
    /************************************************************************
    *                             SUBROUTINE ABERTH                         *
    *************************************************************************
    * Compute  the Aberth correction. To save time, the reciprocation of    *
    * ROOT(J)-ROOT(I) could be performed in single precision (complex*8)    *
    * In principle this might cause overflow if both ROOT(J) and ROOT(I)    *
    * have too small moduli.                                                *
    *************************************************************************
    * Input variables:                                                      *
    *     N     : degree of the polynomial                                  *
    *     ROOT  : vector containing the current approximations to the roots *
    *     J     : index of the component of ROOT with respect to which the  *
    *             Aberth correction is computed                             *
    *************************************************************************
    * Output variable:                                                      *
    *     ABCORR: Aberth's correction (compare (1))                         *
     @param n
     @param j
     @param root
     @return 
    *************************************************************************/
    
    /* The pseudocode below is left here for documentation purposes, the real
     * code is further below. By doing the aberth correction in normal double
     * precision, the algorithm hardly suffers but the speedup is considerable
     * (more than a factor 2 speedup for quad double arithmatic in a typical
     * case). Only the difference between the roots is computed, using full
     * precision (this may be necessary in case of (nearly) equal roots), but
     * the 1/(z-zj) correction can be computed in standard precision.

       static complex aberth(int n, int j, complex[] root) { 
           int i; 
           complex zj;
     
           complex abcorr = 0.0; 
           zj = root[j]; 
           for (i=0; i&lt;n; i++) {
               if (i != j) {
                   complex z = zj - root[i];
                   abcorr += 1.0 / z;
               }
           }
           return abcorr;
       }

     */
    
    private static DoubleComplex aberth(int n, int j, DoubleComplex root[]) {
<span class="fc" id="L328">        DoubleDouble zj_re = root[j].re;</span>
<span class="fc" id="L329">        DoubleDouble zj_im = root[j].im;</span>

<span class="fc" id="L331">        double corr_re = 0.0;</span>
<span class="fc" id="L332">        double corr_im = 0.0;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            if (i != j) {</span>
<span class="fc" id="L335">                double z_re = zj_re.sub(root[i].re).doubleValue();</span>
<span class="fc" id="L336">                double z_im = zj_im.sub(root[i].im).doubleValue();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                double absr = (z_re &gt; 0) ? z_re : -z_re;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                double absi = (z_im &gt; 0) ? z_im : -z_im;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                if (absr &gt; absi) {</span>
<span class="fc" id="L340">                    double r = z_im / z_re;</span>
<span class="fc" id="L341">                    double den = z_re + r * z_im;</span>
<span class="fc" id="L342">                    corr_re += 1.0/den;</span>
<span class="fc" id="L343">                    corr_im -= r/den;</span>
<span class="fc" id="L344">                } </span>
                else {
<span class="fc" id="L346">                    double r = z_re / z_im;</span>
<span class="fc" id="L347">                    double den = z_im + r * z_re;</span>
<span class="fc" id="L348">                    corr_re += r/den;</span>
<span class="fc" id="L349">                    corr_im -= 1.0/den;</span>
                }
            }
        }

<span class="fc" id="L354">        return new DoubleComplex(corr_re, corr_im);  // Aberth correction</span>
    }
    
    
    

    /************************************************************************
    *                             SUBROUTINE START                          *
    *************************************************************************
    * Compute  the starting approximations of the roots                     *
    *************************************************************************
    * Input variables:                                                      *
    *     N     :  number of the coefficients of the polynomial             *
    *     A     :  moduli of the coefficients of the polynomial             *
    *     SMALL : the min positive real*8, SMALL=2**(-1074) for the IEEE.   *
    *     BIG   : the max real*8, BIG=2**1023 for the IEEE standard.        *
    * Output variables:                                                     *
    *     Y     :  starting approximations                                  *
    *     RADIUS:  if a component is -1 then the corresponding root has a   *
    *              too big or too small modulus in order to be represented  *
    *              as double float with no overflow/underflow               *
    *     NZ    :  number of roots which cannot be represented without      *
    *              overflow/underflow                                       *
    * Auxiliary variables:                                                  *
    *     H     :  needed for the computation of the convex hull            *
    *************************************************************************
    * This routine selects starting approximations along circles center at  *
    * 0 and having suitable radii. The computation of the number of circles *
    * and of the corresponding radii is performed by computing the upper    *
    * convex hull of the set (i,log(A(i))), i=1,...,n+1.                    *
     @param n
     @param a
     @param y
     @param radius
     @param big
     @return 
    *************************************************************************/
    private static int start(int n, double[] a, DoubleComplex[] y, double[] radius, double big) {
        int i, iold, nzeros, j, jj;
        double r, th, ang, temp;
<span class="nc" id="L394">        final double sigma = 0.7;</span>
<span class="nc" id="L395">        final double pi2 = 6.2831853071796;</span>
<span class="nc" id="L396">        double xbig = Math.log(big);</span>
<span class="nc" id="L397">        double xsmall = -xbig;</span>
<span class="nc" id="L398">        boolean[] h = new boolean[n + 1];</span>
        int nz;   // number of zeros which cannot be represented without under/overflow.

<span class="nc" id="L401">        nz = 0;</span>

        // Compute the logarithm A(I) of the moduli of the coefficients of
        // the polynomial and then the upper convex hull of the set (A(I),I)
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (i = 0; i &lt;= n; i++) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (a[i] != 0.0) {</span>
<span class="nc" id="L407">                a[i] = Math.log(a[i]);</span>
            } else {
<span class="nc" id="L409">                a[i] = -1e30;   // -infinity</span>
            }
        }
<span class="nc" id="L412">        Convex.cnvex(n, a, h);</span>

        // Given the upper convex hull of the set (A(I),I) compute the moduli
        // of the starting approximations by means of Rouche's theorem
<span class="nc" id="L416">        iold = 0;</span>
<span class="nc" id="L417">        th = pi2 / n;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        for (i = 1; i &lt;= n; i++) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (h[i]) {</span>
<span class="nc" id="L420">                nzeros = i - iold;</span>
<span class="nc" id="L421">                temp = (a[iold] - a[i]) / nzeros;</span>
<span class="nc" id="L422">                boolean underflow = false, overflow = false;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (temp &lt;= xsmall) {</span>
                    // Radii are too small, underflow situation.
<span class="nc" id="L425">                    underflow = true;</span>
<span class="nc" id="L426">                    r = 0.0;</span>
<span class="nc" id="L427">                    nz += nzeros;</span>
                } 
<span class="nc bnc" id="L429" title="All 2 branches missed.">                else if (temp &gt;= xbig) {</span>
                    // Overflow situation.
<span class="nc" id="L431">                    overflow = true;</span>
<span class="nc" id="L432">                    r = big;</span>
<span class="nc" id="L433">                    nz += nzeros;</span>
                } 
                else {
                    // In range of floating point arithmetic.
<span class="nc" id="L437">                    r = Math.exp(temp);</span>
                }

<span class="nc" id="L440">                ang = pi2 / nzeros;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                for (j = iold; j &lt; i; j++) {</span>
<span class="nc" id="L442">                    jj = j - iold;</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">                    if (underflow || overflow) {</span>
<span class="nc" id="L444">                        radius[j] = -1.0;</span>
<span class="nc" id="L445">                        y[j] = new DoubleComplex(r);</span>
                    } 
                    else {
<span class="nc" id="L448">                        double re = r * Math.cos(ang * jj + th * i + sigma);</span>
<span class="nc" id="L449">                        double im = r * Math.sin(ang * jj + th * i + sigma);</span>
<span class="nc" id="L450">                        y[j] = new DoubleComplex(re, im);</span>
                    }
                }

                // Make the current vertex the basis for the
                // new set of roots.
<span class="nc" id="L456">                iold = i;</span>
            }
        }
        
<span class="nc" id="L460">        return nz;</span>
    }
    
    

    /************************************************************************
    *                             SUBROUTINE SORT                           *
    *************************************************************************
    *   SORT  the vector X, according to nonincreasing real parts,          *
    *   the same permutation is applied to vectors Y and E.                 *
     @param n
     @param x
     @param y
     @param e
    *************************************************************************/
    private static void sort(int n, DoubleComplex[] x, double[] y, boolean[] e) {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        for (int k = 0; k &lt; n - 1; k++) {</span>
<span class="fc" id="L477">            DoubleDouble amax = x[k].real();</span>
<span class="fc" id="L478">            int imax = k;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (int i = k + 1; i &lt; n; i++) {</span>
<span class="fc" id="L480">                DoubleDouble rxi = x[i].real();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (amax.compareTo(rxi) &lt; 0) {</span>
<span class="fc" id="L482">                    amax = rxi;</span>
<span class="fc" id="L483">                    imax = i;</span>
                }
            }

<span class="fc" id="L487">            DoubleComplex temp = x[k];</span>
<span class="fc" id="L488">            x[k] = x[imax];</span>
<span class="fc" id="L489">            x[imax] = temp;</span>

<span class="fc" id="L491">            double yt = y[k];</span>
<span class="fc" id="L492">            y[k] = y[imax];</span>
<span class="fc" id="L493">            y[imax] = yt;</span>

<span class="fc" id="L495">            boolean et = e[k];</span>
<span class="fc" id="L496">            e[k] = e[imax];</span>
<span class="fc" id="L497">            e[imax] = et;</span>
        }
<span class="fc" id="L499">    }</span>

    
    
    
    
    /************************************************************************
    *********************** SUBROUTINE POLZEROS *****************************
    *************************************************************************
    *                        GENERAL COMMENTS                               *
    *************************************************************************
    *  This routine approximates the roots of   the  polynomial             *
    *  p(x)=a(n)x^n+a(n-1)x^(n-1)+...+a(0), a(j)=cr(j)+I ci(j), I**2=-1,    *
    *  where a(0) and a(n) are nonzero.                                     *
    *  The coefficients are complex*16 numbers. The routine is fast, robust *
    *  against overflow, and allows to deal with polynomials of any degree. *
    *  Overflow situations are very unlikely and may occurr if there exist  *
    *  simultaneously coefficients of moduli close to BIG and close to      *
    *  SMALL, i.e., the greatest and the smallest positive real*8 numbers,  *
    *  respectively. In this limit situation the program outputs a warning  *
    *  message. The computation can be speeded up by performing some side   *
    *  computations in single precision, thus slightly reducing the         *
    *  robustness of the program (see the comments in the routine ABERTH).  *
    *  Besides a set of approximations to the roots, the program delivers a *
    *  set of a-posteriori error bounds which are guaranteed in the most    *
    *  part of cases. In the situation where underflow does not allow to    *
    *  compute a guaranteed bound, the program outputs a warning message    *
    *  and sets the bound to 0. In the situation where the root cannot be   *
    *  represented as a complex*16 number the error bound is set to -1.     *
    *************************************************************************
    *  The computation is performed by means of Aberth's method             *
    *  according to the formula                                             *
    *           x(i)=x(i)-newt/(1-newt*abcorr), i=1,...,n             (1)   *
    *  where newt=p(x(i))/p'(x(i)) is the Newton correction and abcorr=     *
    *  =1/(x(i)-x(1))+...+1/(x(i)-x(i-1))+1/(x(i)-x(i+1))+...+1/(x(i)-x(n)) *
    *  is the Aberth correction to the Newton method.                       *
    *************************************************************************
    *  The value of the Newton correction is computed by means of the       *
    *  synthetic division algorithm (Ruffini-Horner's rule) if |x|&lt;=1,      *
    *  otherwise the following more robust (with respect to overflow)       *
    *  formula is applied:                                                  *
    *                    newt=1/(n*y-y**2 R'(y)/R(y))                 (2)   *
    *  where                                                                *
    *                    y=1/x                                              *
    *                    R(y)=a(0)*y**n+...+a(n-1)*y+a(n)            (2')   *
    *  This computation is performed by the routine NEWTON.                 *
    *************************************************************************
    *  The starting approximations are complex numbers that are             *
    *  equispaced on circles of suitable radii. The radius of each          *
    *  circle, as well as the number of roots on each circle and the        *
    *  number of circles, is determined by applying Rouche's theorem        *
    *  to the functions a(k)*x**k and p(x)-a(k)*x**k, k=0,...,n.            *
    *  This computation is performed by the routine START.                  *
    *************************************************************************
    *                              STOP CONDITION                           *
    *************************************************************************
    * If the condition                                                      *
    *                     |p(x(j))|&lt;EPS s(|x(j)|)                      (3)  *
    * is satisfied,    where      s(x)=s(0)+x*s(1)+...+x**n * s(n),         *
    * s(i)=|a(i)|*(1+3.8*i),  EPS is the machine precision (EPS=2**-53      *
    * for the IEEE arithmetic), then the approximation x(j) is not updated  *
    * and the subsequent iterations (1)  for i=j are skipped.               *
    * The program stops if the condition (3) is satisfied for j=1,...,n,    *
    * or if the maximum number NITMAX of  iterations   has   been reached.  *
    * The condition (3) is motivated by a backward rounding error analysis  *
    * of the Ruffini-Horner rule, moreover the condition (3) guarantees     *
    * that the computed approximation x(j) is an exact root of a slightly   *
    * perturbed polynomial.                                                 *
    *************************************************************************
    *             INCLUSION DISKS, A-POSTERIORI ERROR BOUNDS                *
    *************************************************************************
    * For each approximation x of a root, an a-posteriori absolute error    *
    * bound r is computed according to the formula                          *
    *                   r=n(|p(x)|+EPS s(|x|))/|p'(x)|                 (4)  *
    * This provides an inclusion disk of center x and radius r containing a *
    * root.                                                                 *
    *************************************************************************
    *************************************************************************
    **************       MEANING OF THE INPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *                                                                       *
    *  -- N     : degree of the polynomial.                                 *
    *  -- POLY  : complex vector of N+1 components, POLY(i) is the          *
    *           coefficient of x**(i), i=0,1,...,N of the polynomial p(x)   *
    *  -- EPS   : machine precision of the floating point arithmetic used   *
    *            by the computer, EPS=2**(-53)  for the IEEE standard.      *
    *  -- BIG   : the max real*8, BIG=2**1024 for the IEEE standard.        *
    *  -- SMALL : the min positive real*8, SMALL=2**(-1022) for the IEEE.   *
    *  -- NITMAX: the max number of allowed iterations.                     *
    *************************************************************************
    *************************************************************************
    **************      MEANING OF THE OUTPUT VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  ROOT   : complex vector of N components, containing the              *
    *           approximations to the roots of p(x).                        *
    *  RADIUS : real vector of N components, containing the error bounds to *
    *           the approximations of the roots, i.e. the disk of center    *
    *           ROOT(i) and radius RADIUS(i) contains a root of p(x), for   *
    *           i=1,...,N. RADIUS(i) is set to -1 if the corresponding root *
    *           cannot be represented as floating point due to overflow or  *
    *           underflow.                                                  *
    *  ERR    : vector of N components detecting an error condition;        *
    *           ERR(j)=.TRUE. if after NITMAX iterations the stop condition *
    *                         (3) is not satisfied for x(j)=ROOT(j);        *
    *           ERR(j)=.FALSE.  otherwise, i.e., the root is reliable,      *
    *                         i.e., it can be viewed as an exact root of a  *
    *                         slightly perturbed polynomial.                *
    *           The vector ERR is used also in the routine convex hull for  *
    *           storing the abscissae of the vertices of the convex hull.   *
    *  ITER   : number of iterations performed.                             *
    *************************************************************************
    *************************************************************************
    *************    MEANING OF THE AUXILIARY VARIABLES         *************
    *************************************************************************
    *************************************************************************
    *  APOLY  : real vector of N+1 components used to store the moduli of   *
    *           the coefficients of p(x) and the coefficients of s(x) used  *
    *           to test the stop condition (3).                             *
    *  APOLYR : real vector of N+1 components used to test the stop         *
    *           condition                                                   *
    *************************************************************************
    ******         WARNING:   2 is the output unit                    *******
     @param n
     @param init
     @param eps
     @param poly
     @param radius
     @param root
     @param nitmax
     @param big
     @param err
     @param iter
     @param needSort
     @param apolyr
     @param apoly
     @return 
    *************************************************************************/
    // Version for polynomial with real coefficients.
    static int polzeros(int n, DoubleDouble[] poly, double eps, double big,
                        int nitmax, DoubleComplex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
        double amax;
<span class="fc" id="L645">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (poly[n].isZero()) {</span>
<span class="nc" id="L650">                return -1;</span>
            }
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (poly[0].isZero()) {</span>
<span class="nc" id="L653">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="nc" id="L658">            amax = 0.0;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L660">                apoly[i] = poly[i].abs().doubleValue();</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (amax &lt; apoly[i]) {</span>
<span class="nc" id="L662">                    amax = apoly[i];</span>
                }
<span class="nc" id="L664">                apolyr[i] = apoly[i];</span>
            }

<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L668">                return -3;</span>
            }

<span class="nc bnc" id="L671" title="All 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L673">                root[0] = new DoubleComplex(poly[0].div(poly[1]).neg());</span>
<span class="nc" id="L674">                err[0] = false;</span>
<span class="nc" id="L675">                iter[0] = 1;</span>
<span class="nc" id="L676">                radius[0] = eps * root[0].abs().doubleValue();</span>
<span class="nc" id="L677">                return 0;</span>
            }

            // Initialize
<span class="nc bnc" id="L681" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L682">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="nc" id="L691">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="nc bnc" id="L694" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L695">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="nc" id="L696">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="nc bnc" id="L699" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="nc" id="L704">            iter[0] = 0;</span>
        } 
        else {
<span class="fc" id="L707">            nzeros = 0;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L710">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L722">                    DoubleComplex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L723">                    DoubleComplex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L724">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L728">                        nzeros++;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">                            if (needSort) {</span>
<span class="fc" id="L731">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L733">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L740">        return -4;</span>
    }

    
    // Version for polynomial with complex coefficients.
    static int polzeros(int n, DoubleComplex[] poly, double eps, double big,
                        int nitmax, DoubleComplex[] root, double[] radius, boolean[] err,
                        /* out */ int[] iter, boolean init, double[] apoly, double[] apolyr, boolean needSort) {
        int i;
        int nzeros;
<span class="fc" id="L750">        double small = 1.0 / big;</span>

<span class="pc bpc" id="L752" title="1 of 2 branches missed.">        if (init) {</span>
            // Check consistency of data
<span class="nc bnc" id="L754" title="All 2 branches missed.">            if (poly[n].isZero()) {</span>
<span class="nc" id="L755">                return -1;</span>
            }
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (poly[0].isZero()) {</span>
<span class="nc" id="L758">                return -2;</span>
            }

            // Compute the moduli of the coefficients
            // and the largest of the absolute values.
<span class="nc" id="L763">            double amax = 0.0;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L765">                apoly[i] = poly[i].abs().doubleValue();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (amax &lt; apoly[i]) {</span>
<span class="nc" id="L767">                    amax = apoly[i];</span>
                }
<span class="nc" id="L769">                apolyr[i] = apoly[i];</span>
            }

<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (amax &gt; big / (4 * n + 1)) {</span>
<span class="nc" id="L773">                return -3;</span>
            }

<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (n == 1) {</span>
                // Linear equation, subsequent code is not called.
<span class="nc" id="L778">                root[0] = poly[0].div(poly[1]).neg();</span>
<span class="nc" id="L779">                err[0] = false;</span>
<span class="nc" id="L780">                iter[0] = 1;</span>
<span class="nc" id="L781">                radius[0] = eps * root[0].abs().doubleValue();</span>
<span class="nc" id="L782">                return 0;</span>
            }

            // Initialize
<span class="nc bnc" id="L786" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L787">                radius[i] = 0.0;</span>
            }

            // Select the starting points. We use the array apolyr
            // as the array of absolute values of the polynomial
            // coefficients. The storage for apolyr is overwritten
            // by start(), but that is of no cencern. After calling
            // start(), the apoly and apolyr arrays are derived
            // from the apoly array values.
<span class="nc" id="L796">            nzeros = start(n, apolyr, root, radius, big);</span>

            // Compute the coefficients of the backward-error polynomial.
<span class="nc bnc" id="L799" title="All 2 branches missed.">            for (i = 0; i &lt;= n; i++) {</span>
<span class="nc" id="L800">                apolyr[n - i] = apoly[i] * (3.8 * (n - i) + 1.0);</span>
<span class="nc" id="L801">                apoly[i] = apoly[i] * (3.8 * i + 1.0);</span>
            }

<span class="nc bnc" id="L804" title="All 2 branches missed.">            for (i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                err[i] = (radius[i] &gt;= 0.0);</span>
            }

            // Set number of iterations equal to 0.
<span class="nc" id="L809">            iter[0] = 0;</span>
<span class="nc" id="L810">        }</span>
        else {
<span class="fc" id="L812">            nzeros = 0;</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">                if (!err[i]) {</span>
<span class="nc" id="L815">                    nzeros++;</span>
                }
            }
        }

        // Starts Aberth's iterations.
        // Beware: The vector err[] is now used as a flags vector
        // again[] in order to determine whether we need to iterate
        // again or not.
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">        for (; iter[0] &lt; nitmax; iter[0]++) {</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">            for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">                if (err[i]) {</span>
<span class="fc" id="L827">                    DoubleComplex corr = newton(n, poly, apoly, apolyr, root[i], small, eps, radius, err, i);</span>
<span class="fc" id="L828">                    DoubleComplex abcorr = aberth(n, i, root);</span>
<span class="fc" id="L829">                    root[i] = root[i].sub(corr.div(corr.mul(abcorr).sub1().neg()));</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">                    if (!err[i]) {</span>
                        // We have found a new root, increment the total
                        // number of roots and advance to the next root.
<span class="fc" id="L833">                        nzeros++;</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">                        if (nzeros == n) {</span>
<span class="pc bpc" id="L835" title="1 of 2 branches missed.">                            if (needSort) {</span>
<span class="fc" id="L836">                                sort(n, root, radius, err);</span>
                            }
<span class="fc" id="L838">                            return 0;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L845">        return -4;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>