<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TSPChristofidesSerdyukov.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.optimization</a> &gt; <span class="el_source">TSPChristofidesSerdyukov.java</span></div><h1>TSPChristofidesSerdyukov.java</h1><pre class="source lang-java linenums">package algorithms.optimization;

import algorithms.graphs.HierholzersEulerCircuit;
import algorithms.msts.PrimsMST;
import gnu.trove.iterator.TIntIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import thirdparty.HungarianAlgorithm;

/**
 * An approximate solution to the Traveling Salesman Problem.
 * It is an approximation algorithm that guarantees that its solutions will be 
 * within a factor of 3/2 of the optimal solution length, and is named after 
 * Nicos Christofides and Anatoliy I. Serdyukov, who discovered it 
 * independently in 1976.  The runtime compexity is O(n^3)
 * 
 * following the pseudocode in
 * https://en.m.wikipedia.org/wiki/Christofides_algorithm
 * 
 * &lt;pre&gt;
 * k-approximation:
    for minimization problems, cost function c():
         c(approxSoln)/c(OPT) .leq. k
    for maximimization problems:
         c(approxSoln)/c(OPT) .geq. k
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * (1) T=MST(G) where G is a complete graph with vertices v and non-negative edge weights w.
        (a complete graph is an undirected graph w/ edge between every pair of nodes)
        ==&gt; can use PrimsMST
    (2) O = the vertices in T w/ odd degree.  in the subgraph O, connect all 
            vertices to one another.
    (3) M = min weight perfect matching in O
        ==&gt; can use Hungarian algorithm or MinCostUnbalancedAssignment.java
    (4) H = connected multigraph from combining the edges of M and T, such that
        each vertex has even degree.
        (a multigraph may have more than 1 edge between same 2 end nodes).
    (5) EC = form a eulerian circuit
        ==&gt; can use HierholzersEulerCircuit
    (6) Make the EC circuit into a Hamiltonian circuit by skipping repeated 
          vertices (shortcutting).
 * &lt;/pre&gt;
 * @author nichole
 */
<span class="fc" id="L56">public class TSPChristofidesSerdyukov {</span>
        
    /**
     * find a Hamiltonian tour of the given graph (simple cycle including all vertexes once) 
     * that is 3/2 - approximate for minimum total cost.
     * @param nVertexes
     * @param adjCostMap a graph represented as an adjacency cost map which obeys
     * the triangle inequality.x
     * @return the Hamiltonian cycle within a factor of no more than 1.5 of the
     * optimal tour's minimum cost.  the array returned contains the vertex numbers
     * from the adjacency cost map.
     */
    public int[] approxTSPTour(final int nVertexes, final TIntObjectMap&lt;TIntIntMap&gt; adjCostMap) {
        
        //(1) T = mst(G)
<span class="fc" id="L71">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; mstTree = buildMST(adjCostMap);</span>
        
        //(2) W = odd degree vertices in T
<span class="fc" id="L74">        int[] degrees = calculateDegrees(mstTree, nVertexes);</span>
<span class="fc" id="L75">        int[] oddDVertexes = oddPassFilter(degrees);</span>
        // there are an even number of odd vertexes
<span class="pc bnc" id="L77" title="All 2 branches missed.">        assert((oddDVertexes.length &amp; 1) != 1);</span>
        
        int i;
        
        //(3) O is subgraph of G induced by the vertices in oddDVertexes.
        //    make perfect min-cost matching from it
        // format: [nMatchings][2]
<span class="fc" id="L84">        int[][] m = bipartiteMinCostMatchingFromSubgraph(oddDVertexes, adjCostMap);</span>
                
        //(4) H is the union of graphs T and M
        //    where each edges present in both T and M are present twice in H
<span class="fc" id="L88">        TIntObjectMap&lt;TIntSet&gt; h = unionMSTAndAssignments(mstTree, m);</span>
        
        //(5) EC is the eulerian circuit in H. each edge is visited exactly once.
<span class="fc" id="L91">        HierholzersEulerCircuit hec = new HierholzersEulerCircuit();</span>
<span class="fc" id="L92">        int[] ec = hec.createCircuit(h); // assuming start node = 0.</span>

        //(6) T2 is the hamiltonian circuit of EC made by skipping over previously visited vertices.
<span class="fc" id="L95">        TIntSet visited = new TIntHashSet();</span>
<span class="fc" id="L96">        TIntList t2 = new TIntArrayList();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (i = 0; i &lt; ec.length; ++i) {</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (!visited.contains(ec[i])) {</span>
<span class="fc" id="L99">                t2.add(ec[i]);</span>
<span class="fc" id="L100">                visited.add(ec[i]);</span>
            }
        }
<span class="fc" id="L103">        t2.add(t2.get(0));</span>
        //int[] _t2 = t2.toArray();
<span class="fc" id="L105">        return t2.toArray();</span>
    }
    
    /**
     * return an array of the indexes which have odd degrees.
     * @param degrees array where indexes are the vertex number and values are
     * the degree for the vertex.
     * @return array of indexes in degrees which have odd values stored in the degrees array.
     */
    protected int[] oddPassFilter(int[] degrees) {
<span class="fc" id="L115">        int[] odd = new int[degrees.length];</span>
<span class="fc" id="L116">        int i, c = 0;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (i = 0; i &lt; degrees.length; ++i) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if ((degrees[i] &amp; 1) == 1) {</span>
<span class="fc" id="L119">                odd[c] = i;</span>
<span class="fc" id="L120">                c++;</span>
            }
        }
<span class="fc" id="L123">        odd = Arrays.copyOf(odd, c);</span>
<span class="fc" id="L124">        return odd;</span>
    }

    protected int[] calculateDegrees(Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; mstTree, 
        int nVertexes) {
        
<span class="fc" id="L130">        int[] d = new int[nVertexes];</span>
        
        int u, v;
        LinkedList&lt;Integer&gt; neighbors;
<span class="fc" id="L134">        Iterator&lt;Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt;&gt; iter = mstTree.entrySet().iterator();</span>
        Iterator&lt;Integer&gt; iterV;
        Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry;
        
<span class="fc bfc" id="L138" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L139">            entry = iter.next();</span>
<span class="fc" id="L140">            u = entry.getKey();</span>
<span class="fc" id="L141">            neighbors = entry.getValue();</span>
            
<span class="fc" id="L143">            iterV = neighbors.iterator();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            while (iterV.hasNext()) {</span>
<span class="fc" id="L145">                v = iterV.next();</span>
<span class="fc" id="L146">                d[u]++;</span>
<span class="fc" id="L147">                d[v]++;</span>
            }
        }
        
<span class="fc" id="L151">        return d;</span>
    }

    /**
     * create a cost matrix from the vertexes listed in oddDVertexes where the
     * adjacency and costs are within adjCostMap.
     * @param oddDVertexes values are the vertex numbers with odd degrees
     * @param adjCostMap the cost map within the original adjacency map.
     * @return a cost matrix whose indexes are relative to oddDVertexes.
     * Note that non-existing connections have a cost of Float.MAX_VALUE.
     */
    protected float[][] buildCostMatrix(int[] oddDVertexes, 
        TIntObjectMap&lt;TIntIntMap&gt; adjCostMap) {

        int i, u, v, uvCost;
<span class="fc" id="L166">        float[][] out = new float[oddDVertexes.length][];</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (i = 0; i &lt; oddDVertexes.length; ++i) {</span>
<span class="fc" id="L168">            out[i] = new float[oddDVertexes.length];</span>
<span class="fc" id="L169">            Arrays.fill(out[i], Float.MAX_VALUE);</span>
        }
  
        // a reverse index map to find where v is in oddDVertexes
<span class="fc" id="L173">        TIntIntMap rIdxs = new TIntIntHashMap();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (i = 0; i &lt; oddDVertexes.length; ++i) {</span>
<span class="fc" id="L175">            u = oddDVertexes[i];</span>
<span class="fc" id="L176">            rIdxs.put(u, i);</span>
        }
                
        int idxV;
        TIntIntMap neighborCost;
        TIntIntIterator iter;
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (i = 0; i &lt; oddDVertexes.length; ++i) {            </span>
<span class="fc" id="L183">            u = oddDVertexes[i];</span>
<span class="fc" id="L184">            neighborCost = adjCostMap.get(u);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (neighborCost != null) {</span>
<span class="fc" id="L186">                iter = neighborCost.iterator();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                while (iter.hasNext()) {</span>
<span class="fc" id="L188">                    iter.advance();</span>
<span class="fc" id="L189">                    v = iter.key();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                    if (!rIdxs.containsKey(v)) {</span>
<span class="fc" id="L191">                        continue;</span>
                    }
<span class="fc" id="L193">                    uvCost = iter.value();</span>
<span class="fc" id="L194">                    idxV = rIdxs.get(v);</span>
<span class="fc" id="L195">                    out[i][idxV] = uvCost;</span>
                }
            }
        }
        
<span class="fc" id="L200">        return out;</span>
    }

    protected Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; buildMST(TIntObjectMap&lt;TIntIntMap&gt; adjCostMap) {
                
        // finding the max cost in the graph G.  the value is needed for a bit length used by a trie in Prim's MST
<span class="fc" id="L206">        int maxCost = PrimsMST.maxEdgeCost(adjCostMap);</span>
        
<span class="fc" id="L208">        PrimsMST prims = new PrimsMST();</span>
        
<span class="fc" id="L210">        prims.calculateMinimumSpanningTree(adjCostMap, maxCost);</span>
        
        //(1) T = mst(G)
<span class="fc" id="L213">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; mstTree = prims.makeTreeFromPrev();</span>
        //print(mstTree);
        
        //TIntList treeWalk = prims.getPreorderIndexes();
        //System.out.printf(&quot;treeWalk=%s%n&quot;, Arrays.toString(treeWalk.toArray()));
        
<span class="fc" id="L219">        return mstTree;</span>
    }
    
    /*
    protected Map&lt;Integer, LinkedList&lt;Double&gt;&gt; buildMST2(TIntObjectMap&lt;TIntDoubleMap&gt; adjCostMap) {

        SimpleLinkedListNode[] graph, TObjectDoubleMap&lt;PairInt&gt; edgeWeights;
        
        TIntObjectMap&lt;SimpleLinkedListNode&gt; mst = KruskalsMinimumSpanningTree.mst(
            graph, edgeWeights);
        
        return mstTree;
    }*/

    /**
     * perfect min-cost bipartite matchings of the subgraph of G induced by the
     * odd vertexes.  The results are in a double array where each row
     * is a pair of matching vertexes in context of graph G.
     * @param oddDVertexes
     * @param adjCostMap
     * @return 
     */
    protected int[][] bipartiteMinCostMatchingFromSubgraph(
        int[] oddDVertexes, TIntObjectMap&lt;TIntIntMap&gt; adjCostMap) {
        
        // building O as a cost matrix for input to the Hungarian algorithm
<span class="fc" id="L245">        float[][] oCostMatrix = buildCostMatrix(oddDVertexes, adjCostMap);</span>
        // indexes of the oCostMatrix are the values of oddDVertexes
        //   so should be transformed back to vertex numbers after
        //   mincost matching.
                
        // for min-cost perfect matching can use Hungarian Algorithm.
        // alternatively, can use MinCostUnbalancedAssignment.
        // hungarian algorithm accepts argument: computeAssignments(float[][] matrix).
        // MinCostUnbalancedAssignment needs a Graph g.
<span class="fc" id="L254">        int[][] assignmentsM = new HungarianAlgorithm().computeAssignments(oCostMatrix);</span>
        
<span class="fc" id="L256">        int i, n = 0, k, v;</span>
<span class="fc" id="L257">        TIntIntMap keep = new TIntIntHashMap();</span>
<span class="fc" id="L258">        TIntSet included = new TIntHashSet();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for (i = 0; i &lt; assignmentsM.length; ++i) {</span>
<span class="fc" id="L260">            k = assignmentsM[i][0];</span>
<span class="fc" id="L261">            v = assignmentsM[i][1];</span>
            //System.out.printf(&quot;%d, %d%n&quot;, k, v);
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">            if (included.contains(k) || included.contains(v)) {</span>
<span class="nc" id="L264">                continue;</span>
            }
<span class="fc" id="L266">            keep.put(k, v);</span>
<span class="fc" id="L267">            included.add(k);</span>
<span class="fc" id="L268">            included.add(v);</span>
<span class="fc" id="L269">            n++;</span>
        }
        
<span class="fc" id="L272">        int[][] m = new int[n][];</span>
<span class="fc" id="L273">        TIntIntIterator iterK = keep.iterator();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L275">            iterK.advance();</span>
<span class="fc" id="L276">            k = iterK.key();</span>
<span class="fc" id="L277">            v = iterK.value();</span>
<span class="fc" id="L278">            m[i] = new int[]{oddDVertexes[k], oddDVertexes[v]};</span>
        }
        
<span class="fc" id="L281">        return m;</span>
    }

    protected TIntObjectMap&lt;TIntSet&gt; unionMSTAndAssignments(
        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; mstTree, int[][] m) {
        
        int i, u, v;
        
<span class="fc" id="L289">        TIntObjectMap&lt;TIntSet&gt; h = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

<span class="fc" id="L291">        Iterator&lt;Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt;&gt; iterMST = mstTree.entrySet().iterator();</span>
        Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry;

        LinkedList&lt;Integer&gt; lList;
        Iterator&lt;Integer&gt; iterList;
        TIntSet s;
<span class="fc bfc" id="L297" title="All 2 branches covered.">        while (iterMST.hasNext()) {</span>
<span class="fc" id="L298">            entry = iterMST.next();</span>
<span class="fc" id="L299">            u = entry.getKey();</span>
<span class="fc" id="L300">            lList = entry.getValue();</span>
<span class="fc" id="L301">            iterList = lList.iterator();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            while (iterList.hasNext()) {</span>
<span class="fc" id="L303">                v = iterList.next();</span>
<span class="fc" id="L304">                s = h.get(u);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                if (s == null) {</span>
<span class="fc" id="L306">                    s = new TIntHashSet();</span>
<span class="fc" id="L307">                    h.put(u, s);</span>
                }
<span class="fc" id="L309">                s.add(v);</span>
            }
        }

<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (i = 0; i &lt; m.length; ++i) {</span>
<span class="fc" id="L314">            s = h.get(m[i][0]);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (s == null) {</span>
<span class="fc" id="L316">                s = new TIntHashSet();</span>
<span class="fc" id="L317">                h.put(m[i][0], s);</span>
            }
<span class="fc" id="L319">            s.add(m[i][1]);</span>
        }        
        
<span class="fc" id="L322">        return h;</span>
    }
    
    public static long totalCost(int[] hamiltonian, TIntObjectMap&lt;TIntIntMap&gt; adjCostMap) {
<span class="fc" id="L326">        long sum = 0;</span>
        int i, u, v, cost;
        TIntIntMap assoc;
<span class="fc bfc" id="L329" title="All 2 branches covered.">        for (i = 1; i &lt; hamiltonian.length;++i) {</span>
<span class="fc" id="L330">            u = hamiltonian[i - 1];</span>
<span class="fc" id="L331">            v = hamiltonian[i];</span>
<span class="fc" id="L332">            assoc = adjCostMap.get(u);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (assoc == null) {</span>
<span class="nc" id="L334">                throw new IllegalStateException(&quot;node &quot; + u + &quot; is not a key in the adjCostMap&quot;);</span>
            }
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (!assoc.containsKey(v)) {</span>
<span class="nc" id="L337">                throw new IllegalStateException(&quot;node &quot; + v + &quot; is not a value in the adjCostMapfor key=&quot; + u);</span>
            }
<span class="fc" id="L339">            sum += assoc.get(v);</span>
        }
<span class="fc" id="L341">        return sum;</span>
    }

    private void print(Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; mstTree) {
<span class="nc" id="L345">        Iterator&lt;Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt;&gt; intIter = mstTree.entrySet().iterator();</span>
        Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry;
        Iterator&lt;Integer&gt; intIter2;
        int u, v;
<span class="nc" id="L349">        System.out.println(&quot;MST:&quot;);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        while (intIter.hasNext()) {</span>
<span class="nc" id="L351">            entry = intIter.next();</span>
<span class="nc" id="L352">            u = entry.getKey();</span>
<span class="nc" id="L353">            intIter2 = entry.getValue().iterator();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            while (intIter2.hasNext()) {</span>
<span class="nc" id="L355">                v = intIter2.next();</span>
<span class="nc" id="L356">                System.out.printf(&quot;%d:%d%n&quot;, u, v);</span>
            }
        }
<span class="nc" id="L359">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>