<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Betweenness.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.graphs</a> &gt; <span class="el_source">Betweenness.java</span></div><h1>Betweenness.java</h1><pre class="source lang-java linenums">package algorithms.graphs;

import algorithms.util.PairInt;
import algorithms.util.SimpleLinkedListNode;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TObjectFloatIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TObjectFloatMap;
import gnu.trove.map.hash.TObjectFloatHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Queue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * &quot;Betweenness&quot; is an algorithm to find non-overlapping communities 
 * within an unweighted, undirected network, and it does so by
 *  finding the edges that are least likely to be inside a community.
 * 
 * Edges that are most frequently in the shortest paths between 2 nodes
 * have high betweenness scores.
 * &lt;pre&gt;
 * e.g. edge BD in Fig 10.3 below from Chapter 10 of
 * &quot;Mining of Massive Datasets&quot; by Leskovec,  Rajaraman, &amp; Ullman
 * has a high betweenness score as it lies on the path
 * from A to any node to the right of D, same for C and B and vice versa.
 * 
 *    A-----B-----D--E
 *     \   /      |\ |
 *      \ /       |_\|
 *       C        G  F
 * 
 * The term is related to a graph bridge but is not necessarily
 * an edge which disconnects 2 subgraphs
 * (see FindAllBridgesDFS.java).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
      for more information, see:
 
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
 
    The simplest form of the algorithm attempts to find the edges that are least 
    likely to be inside a community.

    Define the betweenness of an edge (a, b) to be the number of pairs of nodes
    x and y such that the edge (a, b) lies on the shortest path between x and y.
    To be more precise, since there can be several shortest paths between x and y,
    edge (a, b) is credited with the fraction of those shortest paths that 
    include the edge (a, b). As in golf, a high score is bad. 
    It suggests that the edge (a, b) runs between two different communities; 
    that is, a and b do not belong to the same community.
    
 * @author nichole
 */
<span class="fc" id="L75">public class Betweenness {</span>
    
<span class="fc" id="L77">    private Logger log = Logger.getLogger(getClass().getSimpleName());</span>
    
<span class="fc" id="L79">    private Level logLevel = Level.FINE;</span>
    
    /**
     * implementation of unweighted graph edge scoring from Girvan-Newman 
     * algorithm, accepting a DAG.   Each graph node without a predecessor
     * is iterated over to calculate node and edge weights.  
     * The choice of the src node as a method argument does not affect the 
     * final scored edge weights,
       but is present in case information about the graph provides a best src
       node to start with (e.g. when the graph only has one parent node).
     
     * Reference is 2004 Newman and Girvan,
     * &quot;Finding and evaluating community structure in networks&quot;.
     * 
     * The runtime complexity is &lt;em&gt;1 + the number of graph roots (i.e. nodes without predecessors)
     *   times  O(|V| + |E|)&lt;/em&gt;.
     * 
     * For more information and other graph scoring and distance algorithms and 
     * cluster finding (a.k.a. community finding) see also
      &lt;pre&gt;
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
     * @param adjacencyList an adjacency list for an unweighted DAG.
     * @param s source node to begin the graph traversal
     * @return scores for the edges of the graph, calculated using the Girvan-Newman algorithm.
     */
    public Results girvanNewmanDAG(SimpleLinkedListNode[] adjacencyList, final int s) {
        
        //avg O(|E|);  worst: O(|V| + |E|)
<span class="fc" id="L122">        int[] rootIndexes = findRoots(adjacencyList, s);</span>
        
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (rootIndexes.length == 0) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(&quot;this algorithm operates on a &quot; </span>
            + &quot; DAG and has been given a graph without a true root node.  &quot; +
            &quot; If have a directionless adjacency list (i.e. u:v and v:u exist)&quot; +
            &quot; then use girvanNewmanDirectionless with a choise of a source node&quot;);
        }
        
        // print(adjacencyList);
<span class="fc" id="L132">        System.out.printf(&quot;nV=%d, roots=%s&quot;, adjacencyList.length, </span>
<span class="fc" id="L133">            Arrays.toString(rootIndexes));</span>
        
<span class="fc" id="L135">        final int nV = adjacencyList.length;</span>
        // init
<span class="fc" id="L137">        final int[] d = new int[nV];</span>
<span class="fc" id="L138">        final int[] dBest = new int[nV];</span>
<span class="fc" id="L139">        Arrays.fill(dBest, Integer.MAX_VALUE);</span>
<span class="fc" id="L140">        final TIntList[] p = new TIntList[nV];</span>
<span class="fc" id="L141">        final int[] color = new int[nV];</span>
        
        // index is vertex index
<span class="fc" id="L144">        final int[] w = new int[nV];</span>
<span class="fc" id="L145">        final int[] wG = new int[nV];</span>
        
        // key = edge vertexes (u, v) where u is closer to the root, value = edge weight
<span class="fc" id="L148">        final TObjectFloatMap&lt;PairInt&gt; wEdges = new TObjectFloatHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L150">        final TIntSet members = new TIntHashSet();</span>
        
        // runtime is # of roots * O(|V| + |E|)
        
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (int src : rootIndexes) {</span>
        
<span class="fc" id="L156">            Arrays.fill(w, 0);</span>
<span class="fc" id="L157">            Arrays.fill(color, 0);</span>
<span class="fc" id="L158">            Arrays.fill(d, Integer.MAX_VALUE);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            for (int i = 0; i &lt; nV; ++i) {</span>
<span class="fc" id="L160">                p[i] = new TIntArrayList();</span>
            }
            
<span class="fc" id="L163">            color[src] = 1;</span>
<span class="fc" id="L164">            d[src] = 0;</span>
<span class="fc" id="L165">            dBest[src] = 0;</span>
<span class="fc" id="L166">            w[src] = 1;</span>
            
            /*
            1) d[s]=0  w[s]=1
            2) Every vertex i adjacent to s is given distance d[i]=d[s]+1 and w[i]=w[s]=1
            3) For each vertex j adjacent to one of those vertices i:
                a) If j has not yet been assigned a distance, 
                       it is assigned distance d[j]=d[i]+1 and weight w[j]=w[i]
                b) if j has already been assigned a distance and d[j]==d[1]+1 then w[j]=w[j]+w[i]
                c) if j has already been assigned a distance and d[j]&lt;d[i]+1, do nothing.
            */
<span class="fc" id="L177">            log.log(logLevel, &quot;root=&quot; + src);</span>
      
            // calc vertex weights
<span class="fc" id="L180">            final TIntList leaf = new TIntArrayList();</span>
<span class="fc" id="L181">            final Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span>
<span class="fc" id="L182">            queue.add(src);</span>
            int u;
            
<span class="fc bfc" id="L185" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
            //    log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
            //    log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
            //    log.log(logLevel, &quot;dBest=&quot; + Arrays.toString(dBest));
            //    log.log(logLevel, &quot;color=&quot; + Arrays.toString(color));
<span class="fc" id="L190">                u = queue.remove().intValue();</span>
<span class="fc" id="L191">                members.add(u);</span>
<span class="fc" id="L192">                log.log(logLevel, String.format(&quot;u=%d&quot;, u));</span>
<span class="fc" id="L193">                SimpleLinkedListNode vNode = adjacencyList[u];</span>
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">                if (vNode == null || vNode.getKey() == -1) {</span>
<span class="fc" id="L195">                    leaf.add(u);</span>
<span class="fc" id="L196">                    color[u] = 2;</span>
<span class="fc" id="L197">                    log.log(logLevel, &quot;    LEAF&quot;);</span>
<span class="fc" id="L198">                    continue;</span>
                }
<span class="pc bpc" id="L200" title="1 of 4 branches missed.">                while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L201">                    int v = vNode.getKey();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                    if (color[v] == 0) {</span>
<span class="fc" id="L203">                        color[v] = 1;</span>
<span class="fc" id="L204">                        d[v] = d[u] + 1;</span>
<span class="fc" id="L205">                        w[v] = w[u];</span>
<span class="fc" id="L206">                        queue.add(v);</span>
<span class="fc" id="L207">                        log.log(logLevel, String.format(&quot;  v=%d&quot;, v));</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                        if (d[v] &lt; dBest[v]) {</span>
<span class="fc" id="L209">                            dBest[v] = d[v];</span>
                        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">                    } else if (d[v] == (d[u] + 1)) {</span>
<span class="fc" id="L212">                        w[v] += w[u];</span>
                    }
                    //if (d[u] &lt; d[v]) {
<span class="fc" id="L215">                        p[v].add(u);</span>
<span class="fc" id="L216">                        log.log(logLevel, String.format(&quot;    p[%d]=%d&quot;, v, u));</span>
                    //}
<span class="fc" id="L218">                    vNode = vNode.getNext();</span>
<span class="fc" id="L219">                }</span>
<span class="fc" id="L220">                color[u] = 2;</span>
<span class="fc" id="L221">            }</span>
<span class="pc bnc" id="L222" title="All 2 branches missed.">            assert(queue.isEmpty());</span>
         
            //add weights from previous root traversals
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (rootIndexes.length &gt; 1) {</span>
            //    log.log(logLevel, &quot;%n  w=&quot; + Arrays.toString(w));
<span class="fc bfc" id="L227" title="All 2 branches covered.">                for (int i = 0; i &lt; w.length; ++i) {</span>
<span class="fc" id="L228">                    w[i] += wG[i];</span>
                }
            //    log.log(logLevel, &quot;  wG=&quot; + Arrays.toString(wG));
            //    log.log(logLevel, &quot;-&gt;w=&quot; + Arrays.toString(w));
            }        
            
            // calc edge weights
<span class="fc" id="L235">            TIntSet enqd = new TIntHashSet();</span>
            float e;
<span class="fc" id="L237">            TIntIterator tIter = leaf.iterator();</span>
            int t, i, ip;
            TIntIterator pIter;
            PairInt uv;
<span class="fc bfc" id="L241" title="All 2 branches covered.">            while (tIter.hasNext()) {</span>
<span class="fc" id="L242">                t = tIter.next();</span>
<span class="fc" id="L243">                log.log(logLevel, String.format(&quot;t leaf=%d&quot;, t));</span>
                // calc edge for all edges into leaf:
<span class="fc" id="L245">                pIter = p[t].iterator();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L247">                    i = pIter.next();</span>
<span class="fc" id="L248">                    log.log(logLevel, String.format(&quot;    p=%d&quot;, i));</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if (!enqd.contains(i)) {</span>
<span class="fc" id="L250">                        queue.add(i);</span>
<span class="fc" id="L251">                        enqd.add(i);</span>
                    }
<span class="fc" id="L253">                    e = (float) w[i] / (float) w[t];</span>
 //                   assert(d[i] &lt; d[t]);
<span class="fc" id="L255">                    uv = new PairInt(i, t);</span>
<span class="fc" id="L256">                    wEdges.put(uv, e);</span>
<span class="fc" id="L257">                    log.log(logLevel, String.format(&quot;  edge=(%d, %d) w=%.3e&quot;, i, t, e));</span>
                }
            }
         //   log.log(logLevel, &quot;w={0}&quot;, Arrays.toString(w));
         //   log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
<span class="fc" id="L262">            log.log(logLevel, &quot;q=&quot;+ queue.toString());</span>
            float e2;
            PairInt ij;
<span class="fc bfc" id="L265" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
<span class="fc" id="L266">                i = queue.remove();</span>
<span class="fc" id="L267">                e = 1;</span>
<span class="fc" id="L268">                log.log(logLevel, String.format(&quot;  e0[%d]=%.3f&quot;, i, e));</span>
<span class="fc" id="L269">                SimpleLinkedListNode jNode = adjacencyList[i];</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">                while (jNode != null &amp;&amp; jNode.getKey() != -1) {</span>
<span class="fc" id="L271">                    int j = jNode.getKey();</span>
<span class="fc" id="L272">                    ij = new PairInt(i, j);</span>
<span class="fc" id="L273">                    log.log(logLevel, String.format(&quot;  i=%d j=%d&quot;, i, j));</span>
//                    assert(d[i] &lt; d[j]);
                    
                    //assert(wEdges.containsKey(ij));
<span class="fc bfc" id="L277" title="All 2 branches covered.">                    if (!wEdges.containsKey(ij)) {</span>
<span class="fc" id="L278">                        e += ((float) w[i] / (float) w[j]);</span>
                        //wEdges.put(ij, (float) w[i] / (float) w[j]);
                    } else {
<span class="fc" id="L281">                        e += wEdges.get(ij);</span>
                    }
                    
<span class="fc" id="L284">                    log.log(logLevel, String.format(&quot;  + (w[%d]/w[%d]=%.3f)&quot;, i, j, wEdges.get(ij)));</span>
<span class="fc" id="L285">                    jNode = jNode.getNext();</span>
<span class="fc" id="L286">                }</span>
<span class="fc" id="L287">                log.log(logLevel, String.format(&quot;     =&gt;%.3f&quot;, e));</span>

<span class="fc" id="L289">                pIter = p[i].iterator();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L291">                    ip = pIter.next();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">                    if (!enqd.contains(ip)) {</span>
<span class="fc" id="L293">                        queue.add(ip);</span>
<span class="fc" id="L294">                        enqd.add(ip);</span>
                    }
<span class="fc" id="L296">                    log.log(logLevel, String.format(&quot;  d[%d]=%d,  d[%d]=%d&quot;, ip, d[ip], i, d[i]));</span>
                 //   assert(d[ip] &lt; d[i]);
<span class="fc" id="L298">                    e2 = (float) w[ip] / (float) w[i];</span>
<span class="fc" id="L299">                    e2 *= e;</span>
<span class="fc" id="L300">                    log.log(logLevel, String.format(&quot;    e=(%.3f)*(w[%d]/w[%d]=%.3f)&quot;, e, ip, i, (float) w[ip] / (float) w[i]));</span>
<span class="fc" id="L301">                    uv = new PairInt(ip, i);</span>
<span class="fc" id="L302">                    log.log(logLevel, String.format(&quot;    edge=(%d, %d) w=%.3e&quot;, ip, i, e2));</span>
<span class="fc" id="L303">                    wEdges.put(uv, e2);</span>
                }
<span class="fc" id="L305">            }</span>
            
            //update the total tree weights with current
<span class="fc bfc" id="L308" title="All 2 branches covered.">            for (int ii = 0; ii &lt; w.length; ++ii) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                if (w[ii] &gt; 0) {</span>
<span class="pc bnc" id="L310" title="All 2 branches missed.">                    assert(wG[ii] &lt;= w[ii]);</span>
<span class="fc" id="L311">                    wG[ii] = w[ii];</span>
                }
            }
        }
        
<span class="fc" id="L316">        Results results = new Results();</span>
<span class="fc" id="L317">        results.edges = wEdges;</span>
<span class="fc" id="L318">        results.rootIndexes = rootIndexes;</span>
<span class="fc" id="L319">        results.vertexes = members;</span>
<span class="fc" id="L320">        return results;</span>
    }

    /**
     * implementation of unweighted graph edge scoring from Girvan-Newman 
     * algorithm, accepting a directionless graph.   The given source node is
     * the root of the search.  Each graph node without a predecessor
     * is iterated over also to calculate node and edge weights.  
    
    * The directionless method here has a longer runtime complexity than the
    * DAG method because it has to check for leaf nodes as nodes without 
    * links further from source than it is, so this adds an iteration over edges.
     
     * Reference is 2004 Newman and Girvan,
     * &quot;Finding and evaluating community structure in networks&quot;.
     * 
     * The runtime complexity is &lt;em&gt;1 + the number of graph roots (i.e. nodes without predecessors)
     *   times (add here)&lt;/em&gt;.
     * 
     * For more information and other graph scoring and distance algorithms and 
     * cluster finding (a.k.a. community finding) see also
      &lt;pre&gt;
       Chapter 10 from &quot;Mining of Massive Datasets&quot;
       by Leskovec, Rajaraman, and Ullman
       http://infolab.stanford.edu/~ullman/mmds/ch10n.pdf
       
       and
       
       2005 paper &quot;Complex networks: Structure and dynamics&quot; by
                Boccalettia, Latorab, Morenod, Chavezf, and  Hwanga
                Physics Reports
               
       and
       
       2010 WWW2010 conference paper &quot;Empirical Comparison of Algorithms for
            Network Community Detection&quot; by Leskovec, Lang, and Mahoney
     
     &lt;/pre&gt;
     * @param adjacencyList an adjacency list for an unweighted DAG.
     * @param s source node to begin the graph traversal
     * @return scores for the edges of the graph, calculated using the Girvan-Newman algorithm.
     */
    public Results girvanNewmanUndirected(SimpleLinkedListNode[] adjacencyList, final int s) {
        
        //avg O(|E|);  worst: O(|V| + |E|)
<span class="fc" id="L365">        int[] rootIndexes = findRoots(adjacencyList, s);</span>
        
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (rootIndexes.length == 0) {</span>
<span class="fc" id="L368">            rootIndexes = new int[]{s};</span>
        }
        
<span class="fc" id="L371">        final int nV = adjacencyList.length;</span>
        // init
<span class="fc" id="L373">        final int[] d = new int[nV];</span>
<span class="fc" id="L374">        final int[] dBest = new int[nV];</span>
<span class="fc" id="L375">        Arrays.fill(dBest, Integer.MAX_VALUE);</span>
        
        // holds parents of index.  e.g. for root node 0, p[0] is empty.
<span class="fc" id="L378">        final TIntList[] p = new TIntList[nV];</span>
<span class="fc" id="L379">        final int[] color = new int[nV];</span>
        
        // index is vertex index
<span class="fc" id="L382">        final int[] w = new int[nV];</span>
<span class="fc" id="L383">        final int[] wG = new int[nV];</span>
        
        // key = edge vertexes (u, v) where u is closer to the root, value = edge weight
<span class="fc" id="L386">        final TObjectFloatMap&lt;PairInt&gt; wEdges = new TObjectFloatHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L388">        final TIntSet members = new TIntHashSet();</span>
        
        // runtime is # of roots * O(|V| + |E|)
        
<span class="fc bfc" id="L392" title="All 2 branches covered.">        for (int src : rootIndexes) {</span>
        
<span class="fc" id="L394">            Arrays.fill(w, 0);</span>
<span class="fc" id="L395">            Arrays.fill(color, 0);</span>
<span class="fc" id="L396">            Arrays.fill(d, Integer.MAX_VALUE);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            for (int i = 0; i &lt; nV; ++i) {</span>
<span class="fc" id="L398">                p[i] = new TIntArrayList();</span>
            }
            
<span class="fc" id="L401">            color[src] = 1;</span>
<span class="fc" id="L402">            d[src] = 0;</span>
<span class="fc" id="L403">            dBest[src] = 0;</span>
<span class="fc" id="L404">            w[src] = 1;</span>
            
<span class="fc" id="L406">            log.log(logLevel, &quot;root=&quot; + src);</span>
      
            // calc vertex weights
<span class="fc" id="L409">            final TIntList leaf = new TIntArrayList();</span>
<span class="fc" id="L410">            final Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span>
<span class="fc" id="L411">            queue.add(src);</span>
            int u;
            
<span class="fc bfc" id="L414" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
                //log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
                //log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
                //log.log(logLevel, &quot;dBest=&quot; + Arrays.toString(dBest));
                //log.log(logLevel, &quot;color=&quot; + Arrays.toString(color));
<span class="fc" id="L419">                u = queue.remove().intValue();</span>
<span class="fc" id="L420">                members.add(u);</span>
<span class="fc" id="L421">                log.log(logLevel, String.format(&quot;u=%d%n&quot;, u));</span>
<span class="fc" id="L422">                SimpleLinkedListNode vNode = adjacencyList[u];</span>
                // for adjacencyLists that are directionless, edges from u to v and v to u exist,
                // so need to make one additional check for a pseudo-leaf:
                //     a pseudo-leaf has no descendants that are not also predecessors.
<span class="fc" id="L426">                boolean isALeafNode = isALeafNode(u, adjacencyList, d);</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                if (isALeafNode) {</span>
<span class="fc" id="L428">                    leaf.add(u);</span>
<span class="fc" id="L429">                    color[u] = 2;</span>
<span class="fc" id="L430">                    log.log(logLevel, &quot;    LEAF%n&quot;);</span>
<span class="fc" id="L431">                    continue;</span>
                }
<span class="pc bpc" id="L433" title="1 of 4 branches missed.">                while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L434">                    int v = vNode.getKey();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">                    if (color[v] == 0) {</span>
<span class="fc" id="L436">                        color[v] = 1;</span>
<span class="fc" id="L437">                        d[v] = d[u] + 1;</span>
<span class="fc" id="L438">                        w[v] = w[u];</span>
<span class="fc" id="L439">                        queue.add(v);</span>
<span class="fc" id="L440">                        log.log(logLevel, String.format(&quot;  v=%d%n&quot;, v));</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                        if (d[v] &lt; dBest[v]) {</span>
<span class="fc" id="L442">                            dBest[v] = d[v];</span>
                        }
<span class="fc bfc" id="L444" title="All 2 branches covered.">                    } else if (d[v] == (d[u] + 1)) {</span>
<span class="fc" id="L445">                        w[v] += w[u];</span>
                    }
<span class="fc bfc" id="L447" title="All 2 branches covered.">                    if (d[u] &lt; d[v]) {</span>
<span class="fc" id="L448">                        log.log(logLevel, String.format(&quot;adding parent=%d of node=%d (d[%d]=%d, d[%d]=%d])%n&quot;,</span>
<span class="fc" id="L449">                            u, v, u, d[u], v, d[v]));</span>
<span class="fc" id="L450">                        p[v].add(u);</span>
                    }
<span class="fc" id="L452">                    vNode = vNode.getNext();</span>
<span class="fc" id="L453">                }</span>
<span class="fc" id="L454">                color[u] = 2;</span>
<span class="fc" id="L455">            }</span>
<span class="pc bnc" id="L456" title="All 2 branches missed.">            assert(queue.isEmpty());</span>
         
            //add weights from previous root traversals
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            if (rootIndexes.length &gt; 1) {</span>
            //    log.log(logLevel, &quot;%n  w=&quot; + Arrays.toString(w));
<span class="nc bnc" id="L461" title="All 2 branches missed.">                for (int i = 0; i &lt; w.length; ++i) {</span>
<span class="nc" id="L462">                    w[i] += wG[i];</span>
                }
            //    log.log(logLevel, &quot;  wG=&quot; + Arrays.toString(wG));
            //    log.log(logLevel, &quot;-&gt;w=&quot; + Arrays.toString(w));
            }        
            
            // calc edge weights
<span class="fc" id="L469">            TIntSet enqd = new TIntHashSet();</span>
            float e;
<span class="fc" id="L471">            TIntIterator tIter = leaf.iterator();</span>
            int t, i, ip;
            TIntIterator pIter;
            PairInt uv;
<span class="fc bfc" id="L475" title="All 2 branches covered.">            while (tIter.hasNext()) {</span>
<span class="fc" id="L476">                t = tIter.next();</span>
<span class="fc" id="L477">                log.log(logLevel, String.format(&quot;t leaf=%d%n&quot;, t));</span>
<span class="fc" id="L478">                pIter = p[t].iterator();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L480">                    i = pIter.next();</span>
<span class="fc" id="L481">                    log.log(logLevel, String.format(&quot;  p=%d%n&quot;, i));</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                    if (!enqd.contains(i)) {</span>
<span class="fc" id="L483">                        queue.add(i);</span>
<span class="fc" id="L484">                        enqd.add(i);</span>
                    }
<span class="fc" id="L486">                    e = (float) w[i] / (float) w[t];</span>
<span class="pc bnc" id="L487" title="All 2 branches missed.">                    assert(d[i] &lt; d[t]);</span>
<span class="fc" id="L488">                    uv = new PairInt(i, t);</span>
<span class="fc" id="L489">                    wEdges.put(uv, e);</span>
<span class="fc" id="L490">                    log.log(logLevel, String.format(&quot;  edge=(%d, %d) w=%.3e%n&quot;, i, t, e));</span>
                }
            }
          //  log.log(logLevel, &quot;w=&quot; + Arrays.toString(w));
          //  log.log(logLevel, &quot;d=&quot; + Arrays.toString(d));
          //  log.log(logLevel, &quot;q=&quot;+ queue.toString());
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if (logLevel.equals(Level.INFO)) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                for (int iv=0; iv&lt;nV;++iv) {</span>
<span class="nc" id="L498">                    TIntList ps = p[iv];</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (!ps.isEmpty()) {</span>
<span class="nc" id="L500">                        log.log(logLevel, String.format(&quot;   *p[%d]=%s&quot;, iv, ps.toString()));</span>
                    }
                }
            }
            float e2;
            PairInt ij;
<span class="fc bfc" id="L506" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
<span class="fc" id="L507">                i = queue.remove().intValue();</span>
<span class="fc" id="L508">                e = 1;</span>
<span class="fc" id="L509">                log.log(logLevel, String.format(&quot;  e0[%d]=%.3f&quot;, i, e));</span>
<span class="fc" id="L510">                SimpleLinkedListNode jNode = adjacencyList[i];</span>
<span class="pc bpc" id="L511" title="1 of 4 branches missed.">                while (jNode != null &amp;&amp; jNode.getKey() != -1) {</span>
<span class="fc" id="L512">                    int j = jNode.getKey();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">                    if (d[i] &lt; d[j]) {</span>
<span class="fc" id="L514">                        ij = new PairInt(i, j);</span>
<span class="pc bnc" id="L515" title="All 2 branches missed.">                        assert (d[i] &lt; d[j]);</span>
<span class="pc bnc" id="L516" title="All 2 branches missed.">                        assert (wEdges.containsKey(ij));</span>
<span class="fc" id="L517">                        e += wEdges.get(ij);</span>
<span class="fc" id="L518">                        log.log(logLevel, String.format(&quot;  + (w[%d]/w[%d]=%.3f)&quot;, i, j, wEdges.get(ij)));</span>
                    }
<span class="fc" id="L520">                    jNode = jNode.getNext();</span>
<span class="fc" id="L521">                }</span>
<span class="fc" id="L522">                log.log(logLevel, String.format(&quot;  %n   =&gt;%.3f%n&quot;, e));</span>

<span class="fc" id="L524">                pIter = p[i].iterator();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                while (pIter.hasNext()) {</span>
<span class="fc" id="L526">                    ip = pIter.next();</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    if (!enqd.contains(ip)) {</span>
<span class="fc" id="L528">                        queue.add(ip);</span>
<span class="fc" id="L529">                        enqd.add(ip);</span>
                    }
<span class="fc" id="L531">                    log.log(logLevel, String.format(&quot;  parent=d[%d]=%d,  child=d[%d]=%d%n&quot;,</span>
<span class="fc" id="L532">                        ip, d[ip], i, d[i]));</span>
<span class="pc bnc" id="L533" title="All 2 branches missed.">                    assert(d[ip] &lt; d[i]);</span>
<span class="fc" id="L534">                    e2 = (float) w[ip] / (float) w[i];</span>
<span class="fc" id="L535">                    e2 *= e;</span>
<span class="fc" id="L536">                    log.log(logLevel, String.format(&quot;    e=(%.3f)*(w[%d]/w[%d]=%.3f)%n&quot;, e, ip, i, (float) w[ip] / (float) w[i]));</span>
<span class="fc" id="L537">                    uv = new PairInt(ip, i);</span>
<span class="fc" id="L538">                    log.log(logLevel, String.format(&quot;    edge=(%d, %d) w=%.3e%n&quot;, ip, i, e2));</span>
<span class="fc" id="L539">                    wEdges.put(uv, e2);</span>
                }
<span class="fc" id="L541">            }</span>
            
            //update the total tree weights with current
<span class="fc bfc" id="L544" title="All 2 branches covered.">            for (int ii = 0; ii &lt; w.length; ++ii) {</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">                if (w[ii] &gt; 0) {</span>
<span class="pc bnc" id="L546" title="All 2 branches missed.">                    assert(wG[ii] &lt;= w[ii]);</span>
<span class="fc" id="L547">                    wG[ii] = w[ii];</span>
                }
            }
        }
        
<span class="fc" id="L552">        Results results = new Results();</span>
<span class="fc" id="L553">        results.edges = wEdges;</span>
<span class="fc" id="L554">        results.rootIndexes = rootIndexes;</span>
<span class="fc" id="L555">        results.vertexes = members;</span>
<span class="fc" id="L556">        return results;</span>
    }
    
    private int[] findRoots(SimpleLinkedListNode[] adjacencyList, int s) {
         
        // walk all nodes in graph to get the predecessor nodes
        //   using DFS
<span class="fc" id="L563">        DFS dfs = new DFS(adjacencyList);</span>
<span class="fc" id="L564">        dfs.walk();</span>
        
<span class="fc" id="L566">        int[] p = dfs.getPredecessorIndexes();</span>
<span class="fc" id="L567">        int nRoots = 0;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        for (int i = 0; i &lt; p.length; ++i) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (p[i] == -1) {</span>
<span class="fc" id="L570">                nRoots++;</span>
            }
        }
<span class="fc" id="L573">        int[] roots = new int[nRoots];</span>
<span class="fc" id="L574">        nRoots = 0;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        for (int i = 0; i &lt; p.length; ++i) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            if (p[i] == -1) {</span>
<span class="fc" id="L577">                roots[nRoots] = i;</span>
<span class="fc" id="L578">                nRoots++;</span>
            }
        }
<span class="fc" id="L581">        return roots;</span>
    }

    private boolean isALeafNode(int u, SimpleLinkedListNode[] adjacencyList,
        int[] d) {
        
        // for directionless graphs, presumably the input adjacency list has been
        // created such that all U-&gt;V edges have V-&gt;U edges. 
        // Looking for the equivalent of a leaf w.r.t. a source node:
        //    would expect no u-&gt; pairs where d[u] &lt; d[v].
        
        //Set&lt;PairInt&gt; uvs = new HashSet&lt;PairInt&gt;();
<span class="fc" id="L593">        SimpleLinkedListNode vNode = adjacencyList[u];</span>
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">        while (vNode != null &amp;&amp; vNode.getKey() != -1) {</span>
<span class="fc" id="L595">            int v = vNode.getKey();</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (d[v] &gt; d[u]) {</span>
<span class="fc" id="L597">                return false;</span>
            }
<span class="fc" id="L599">            vNode = vNode.getNext();</span>
<span class="fc" id="L600">        }</span>
<span class="fc" id="L601">        return true;</span>
    }

    /*private void print(SimpleLinkedListNode[] adjacencyList) {
        
        StringBuffer sb = new StringBuffer();
        
        for (int u = 0; u &lt; adjacencyList.length; ++u) {
            sb.append(String.format(&quot;u=%d v=[&quot;, u));
            SimpleLinkedListNode vNode = adjacencyList[u];

            while (vNode != null &amp;&amp; vNode.getKey() != -1) {
                int v = vNode.getKey();
                sb.append(String.format(&quot;%d, &quot;, v));
                vNode = vNode.getNext();
            }
            sb.append(String.format(&quot;]%n&quot;));
        }
        System.out.println(sb.toString());
    }*/
    
    public static class Results {
        
        private TObjectFloatMap&lt;PairInt&gt; edges = null;
        
        private int[] rootIndexes = null;
        
        private TIntSet vertexes = null;
       
        /**
         * @return the betweenness scores for the edges
         */
        public TObjectFloatMap&lt;PairInt&gt; getEdges() {
            return edges;
        }

        /**
         * @return the src
         */
        public int[] getRootIndexes() {
            return rootIndexes;
        }

        /**
         * @return the vertexes visited by the algorithm.  any vertex given
         * to algorithm that was not connected to source s is not present in this.
         */
        public TIntSet getVertexes() {
            return vertexes;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;root indexes=&quot;);
            if (rootIndexes != null) {
                sb.append(Arrays.toString(rootIndexes));
            }
            sb.append(&quot;%nedges=&quot;);
            if (edges != null) {
                TObjectFloatIterator&lt;PairInt&gt; iter = edges.iterator();
                for (int i = 0; i &lt; edges.size(); ++i) {
                    iter.advance();
                    PairInt e = iter.key();
                    float w = iter.value();
                    sb.append(String.format(&quot;%n  (%d,%d)=%.3e&quot;, e.getX(), e.getY(), w));
                }
            }
            sb.append(&quot;%nvertex indexes=&quot;);
            if (vertexes != null) {
                sb.append(Arrays.toString(vertexes.toArray()));
            }
            return sb.toString();
        }
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>