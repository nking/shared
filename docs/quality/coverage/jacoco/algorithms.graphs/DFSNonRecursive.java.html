<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DFSNonRecursive.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.graphs</a> &gt; <span class="el_source">DFSNonRecursive.java</span></div><h1>DFSNonRecursive.java</h1><pre class="source lang-java linenums">package algorithms.graphs;

import algorithms.sort.MiscSorter;
import algorithms.util.SimpleLinkedListNode;
import java.util.Arrays;
import java.util.Stack;

/**
   DFS

   searches the full depth of a graph or subgraph when possible first then
      backtracks to the unexplored edges and unexplored nodes repeating until
      all nodes are visited.  unlike BFS, it may contain many predecessor trees, 
      that is a predecessor forest of nodes that are the shortest from the 
      source to each reachable node.  for this reason, DFS searches can need a 
      lot of memory.

   average runtime is approx O(|E|), worst case runtime: O(|V| + |E|)
   worst case space needed: O(|V|)

   implemented using recursion following Cormen, Leiserson, Rivest, and Stein &quot;Introduction To Algorithms&quot;
   then re-factored to non-recursive by using a stack, following advice in 
   https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and

   first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright

   A note on recursion from lecture notes of 
   CS473: Fundamental Algorithms (Spring 2011)
   https://courses.engr.illinois.edu/cs473/sp2011/Lectures/09_lec.pdf
   An iterative algorithm B obtained from a recursive algorithm A for a problem Π 
   does the following: for each instance I of Π, it computes a topological sort 
   of G(I) and evaluates sub-problems according to the topological ordering.
   In some cases (not all) the computation of an optimal solution reduces to a 
   shortest/longest path in DAG G(I).
* 
 * @author nichole
 */
<span class="fc" id="L43">public class DFSNonRecursive {</span>
    /**
     * adjacency matrix with connected i to j indicated by the index and each
     *    node in the linked list, respectively.
     * for example, adjacent to node 3 is found via directedEdges[3] as all in the linked list.
     */
    private SimpleLinkedListNode[] g;
    
    /** 
     * holds state for whether a node has been visited.  0 = not visited,
     * 1 = visiting now, 2 = was visited.
    */
    private int[] visited;

    /**
     * time when node is first discovered
     */
    private int[] td;

    /**
     * time when node's adjacency list has all been visited
     */
    private int[] tf;
   
    private int[] predecessor;

    private int time;

<span class="fc" id="L71">    public DFSNonRecursive() {</span>
        
<span class="fc" id="L73">    }</span>

    /**
     * @param directedEdges  adjacency matrix with connected i to j indicated
     * by the index and each node in the linked list, respectively.
     * Note that the key of each node is expected to be the same as it's index
     * in the adjacency matrix.
     * For example, adjacent to node 3 is found via directedEdges[3] as all in 
     * the linked list.
     */
    public void walk(SimpleLinkedListNode[] directedEdges) {
<span class="pc bpc" id="L84" title="2 of 4 branches missed.">        if (directedEdges == null || directedEdges.length == 0) {</span>
<span class="nc" id="L85">            throw new IllegalArgumentException(&quot;directedEdges cannot be null or empty&quot;);</span>
        }
<span class="fc" id="L87">        g = directedEdges.clone();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (int i = 0; i &lt; g.length; ++i) {</span>
<span class="fc" id="L89">            g[i] = new SimpleLinkedListNode(directedEdges[i]);</span>
        }
<span class="fc" id="L91">        visited = new int[g.length];</span>
<span class="fc" id="L92">        td = new int[g.length];</span>
<span class="fc" id="L93">        tf = new int[g.length];</span>
<span class="fc" id="L94">        predecessor = new int[g.length];</span>
<span class="fc" id="L95">        Arrays.fill(td, -1);</span>
<span class="fc" id="L96">        Arrays.fill(tf, -1);</span>
<span class="fc" id="L97">        Arrays.fill(predecessor, -1);</span>
<span class="fc" id="L98">        time = 0;</span>
        
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (int u = 0; u &lt; g.length; u++) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (visited[u] == 0) {</span>
<span class="fc" id="L102">                walk(u);</span>
            }
        }
<span class="fc" id="L105">    }</span>
    
    private void walk(int u) {
        
<span class="fc" id="L109">        Stack&lt;Snapshot&gt; stack = new Stack&lt;Snapshot&gt;();</span>
        Snapshot current;
        
        //System.out.println(&quot;*load method frame for &quot; + u);
        
<span class="fc" id="L114">        current = new Snapshot(u);</span>
<span class="fc" id="L115">        current.stage = 0;</span>
<span class="fc" id="L116">        stack.push(current);</span>
        
<span class="fc bfc" id="L118" title="All 2 branches covered.">        while(!stack.empty()) {</span>
            
<span class="fc" id="L120">            current = stack.pop();</span>
            
            //System.out.println(current.toString());
            
<span class="pc bpc" id="L124" title="1 of 3 branches missed.">            switch(current.stage) {</span>
                case 0: { 
                    // before recursion is invoked
<span class="fc" id="L127">                    visited[current.node] = 1;</span>
<span class="fc" id="L128">                    time++;</span>
                    //System.out.println(&quot;  0: visiting &quot; + current.node + &quot; to set td=&quot; + time);
<span class="fc" id="L130">                    td[current.node] = time;</span>
                    
<span class="fc" id="L132">                    current.stage = 1;</span>
<span class="fc" id="L133">                    stack.push(current);</span>
                    
                    //System.out.format(&quot;  0: push onto stack u=%d\n&quot;, current.node);
                            
<span class="fc" id="L137">                    SimpleLinkedListNode next = g[current.node];</span>
                    
<span class="pc bpc" id="L139" title="1 of 4 branches missed.">                    if (next != null &amp;&amp; next.getNumberOfKeys() &gt; 0) {</span>
                        
<span class="fc" id="L141">                        int v = next.getKey();</span>
                        
<span class="fc" id="L143">                        g[current.node].delete(next);</span>
                                                      
<span class="fc bfc" id="L145" title="All 2 branches covered.">                        if (visited[v] == 0) {</span>
                            
<span class="fc" id="L147">                            predecessor[v] = current.node;</span>
                            
<span class="fc" id="L149">                            Snapshot newSnapshot = new Snapshot(v);</span>
<span class="fc" id="L150">                            newSnapshot.stage = 0;</span>
<span class="fc" id="L151">                            stack.push(newSnapshot);</span>

                            //System.out.format(&quot;   0: and push onto stack v=%d\n&quot;, v);
                            //System.out.println(&quot;   0: [v: &quot; + newSnapshot.toString() + &quot;]&quot;);
  
<span class="fc" id="L156">                            continue;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                        } else if (predecessor[v] == -1) {</span>
                            // in case the instance graph is not ordered top-down
<span class="fc" id="L159">                            predecessor[v] = current.node;</span>
                        }
<span class="fc" id="L161">                    }</span>
                    break;
                }
                case 1: {
                    //System.out.println(&quot; 1: have all child links been visited?  snap=&quot;
                    //   + current.toString());
                    
<span class="fc" id="L168">                    SimpleLinkedListNode next = g[current.node];</span>
<span class="pc bpc" id="L169" title="1 of 4 branches missed.">                    if (next != null &amp;&amp; next.getNumberOfKeys() &gt; 0) {</span>
                        
<span class="fc" id="L171">                        int v = next.getKey();</span>
                        
                        //System.out.format(&quot; 1: there is a child link %d\n&quot;, v);
                        
<span class="fc" id="L175">                        g[current.node].delete(next);</span>
                        
<span class="fc" id="L177">                        current.stage = 1;</span>
<span class="fc" id="L178">                        stack.push(current);</span>

                        //System.out.format(&quot;  0: push onto stack u=%d\n&quot;, current.node);
                                                      
<span class="fc bfc" id="L182" title="All 2 branches covered.">                        if (visited[v] == 0) {</span>
                            
<span class="fc" id="L184">                            predecessor[v] = current.node;</span>
                            
<span class="fc" id="L186">                            Snapshot newSnapshot = new Snapshot(v);</span>
<span class="fc" id="L187">                            newSnapshot.stage = 0;</span>
<span class="fc" id="L188">                            stack.push(newSnapshot);</span>

                            //System.out.format(&quot;   1: and push onto stack v=%d\n&quot;, v);
                            //System.out.println(&quot;   1: [v: &quot; + newSnapshot.toString() + &quot;]&quot;);
  
<span class="fc" id="L193">                            continue;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                        } else if (predecessor[v] == -1) {</span>
<span class="fc" id="L195">                            predecessor[v] = current.node;</span>
                        }
                        
                        continue;
                    }
                    
<span class="fc" id="L201">                    visited[current.node] = 2;</span>
<span class="fc" id="L202">                    time++;</span>
<span class="fc" id="L203">                    tf[current.node] = time;</span>
                    //System.out.format(&quot; 1: end visit to %d, set tf=%d\n&quot;,
                    //    current.node, time);

<span class="fc" id="L207">                    break;</span>
                }
            }
        }
<span class="fc" id="L211">    }</span>
    
    private class Snapshot {
        
        /**
         * index of current snapshot within DFSIterative instance's arrays.
         */
        protected final int node;
                
        protected int stage = 0;
                        
        public Snapshot(int u) {
            this.node = u;
        }
                
        public Snapshot(Snapshot s) {
            this.stage = s.stage;
            this.node = s.node;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;node=&quot;).append(Integer.toString(node))
                .append(&quot;, stage=&quot;).append(Integer.toString(stage))
                .append(&quot;, prev=&quot;).append(Integer.toString(predecessor[node]))
                .append(&quot;, visited=&quot;).append(Integer.toString(visited[node]))
            ;
            return sb.toString();
        }
        
    }
    
    /**
     * get predecessor indexes
     * @return get predecessor indexes
     */
    public int[] getPredecessorIndexes() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (predecessor == null) {</span>
<span class="nc" id="L250">            return null;</span>
        }
<span class="nc" id="L252">        return Arrays.copyOf(predecessor, predecessor.length);</span>
    }
    
    /**
     * return the indexes in order of the starts of their traversals
     * @return 
     */
    public int[] getOrderedBeginIndexes() {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (td == null) {</span>
<span class="nc" id="L261">            return null;</span>
        }
<span class="fc" id="L263">        return sortForIndexes(td);</span>
    }
    
    private int[] sortForIndexes(int[] a) {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L268">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (g == null) {</span>
<span class="nc" id="L271">            return null;</span>
        }
<span class="pc bnc" id="L273" title="All 2 branches missed.">        assert(a.length == g.length);</span>
<span class="fc" id="L274">        a = Arrays.copyOf(a, a.length);</span>
<span class="fc" id="L275">        int[] idxs = new int[a.length];</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (int i = 0; i &lt; idxs.length; ++i) {</span>
<span class="fc" id="L277">            idxs[i] = i;</span>
        }
<span class="fc" id="L279">        MiscSorter.sortBy1stArg(a, idxs);</span>
<span class="fc" id="L280">        return idxs;</span>
    }
    
    /**
     * return the indexes in order of the ends of their traversal
     * @return 
     */
    public int[] getOrderedEndIndexes() {
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (tf == null) {</span>
<span class="nc" id="L289">            return null;</span>
        }
<span class="fc" id="L291">        return sortForIndexes(tf);</span>
    }
    
    public int[] getTd() {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (td == null) {</span>
<span class="nc" id="L296">            return null;</span>
        }
<span class="fc" id="L298">        return td;</span>
    }

    public int[] getTf() {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (tf == null) {</span>
<span class="nc" id="L303">            return null;</span>
        }
<span class="fc" id="L305">        return tf;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>