<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LeastCommonAncestor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.trees</a> &gt; <span class="el_source">LeastCommonAncestor.java</span></div><h1>LeastCommonAncestor.java</h1><pre class="source lang-java linenums">package algorithms.trees;

import algorithms.graphs.HierholzersEulerCircuit;

import java.util.*;

/**
 * The Least Common Ancestor (LCA) problem (a.k.a. lowest common ancestor):
 * given a tree, find the Least Common Ancestor (LCA) of a pair of nodes.
 * The LCA of nodes and in a tree is the shared ancestor of and that is located farthest
 * from the root.
 * &lt;p&gt;
 * The goal is to pre-process the data so that subsequent queries are fast.
 * &lt;p&gt;
 * This has been written for 0-based indexing, that is, the query indexes start at 0 and
 * are w.r.t. the original array 'a' given to the constructor.
 *
 * &lt;pre&gt;
 * reference:
 * &quot;The LCA Problem Revisited&quot;
 * Michael A. Bender, MartÄ±n Farach-Colton
 * SUNY Stony Brook, Rutgers University
 * May 16, 2000
 * &lt;/pre&gt;
 */
<span class="fc" id="L26">public class LeastCommonAncestor {</span>

    /*
    LCA:
        given:  a rooted tree T having n nodes.

        query:
           For nodes u and v and of tree T, query LCA returns the least common ancestor
           of u and v in T, that is, it returns the node furthest from the root that
           is an ancestor of both and u and v.

        a dFS traversal of the tree for paths that encounter u and v finds the
        LCA(u,v) as the deepest node on both paths before reaching u and v.

    related:
    Range Minimum Query (RMQ) Problem,
        given:  A length array of numbers

        query: for indices i and j between 1 and n, query RMQ_A(x,y) returns the index
               of the smallest element in the subarray A[i...j]

        pre-processing time: f(n)
        query time: q(n)
        r.t.c. stated as &lt;f(n), q(n)&gt;

     */

    protected final int[] tree;
    protected final int treeSrc;
    protected final int[][] eulerCircuitAndDepth;
    protected int[] firstVisit;
    protected int n;

    protected final int[] log2;
    protected final int blockSize;
    protected final int blockCnt;
    protected final int[][] st;
    protected final int[][][] blocks;
    protected final int[] blockMask;

    /**
     * constructor r.t.c. is O(n) where n = a.length.
     *
     * @param a
     */
<span class="fc" id="L71">    public LeastCommonAncestor(int[] a) {</span>

<span class="fc" id="L73">        n = a.length;</span>

        // indices of parent nodes.  e.g. tree[v]=u says a[v] is a child of a[u]
<span class="fc" id="L76">        this.tree = makeCartesianTree(a);</span>
<span class="pc bnc" id="L77" title="All 2 branches missed.">        assert (tree.length == n);</span>

<span class="fc" id="L79">        int src = -1;</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">            if (tree[i] == -1) {</span>
<span class="fc" id="L82">                src = i;</span>
<span class="fc" id="L83">                break;</span>
            }
        }
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (src == -1) {</span>
<span class="nc" id="L87">            throw new IllegalArgumentException(&quot;Error in algorithm. see tree=&quot; + Arrays.toString(tree));</span>
        }
<span class="fc" id="L89">        this.treeSrc = src;</span>


        // create a bi-directional adjacency map out of the indices parent child relationships:
<span class="fc" id="L93">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; adjMap = createBiDirectionalMap(tree);</span>

        // form a euler circuit (traversing edges once to connect all nodes and return to start).
<span class="fc" id="L96">        HierholzersEulerCircuit euler = new HierholzersEulerCircuit();</span>
        // row 0 : the indices of array 'a' in order of the euler circuit.
        // row 1 : the depth of the node in tree.  depth of src = 0.
        // the difference between adjacent elements in eulerCircuitAndDepth[1] is exactly 1
<span class="fc" id="L100">        this.eulerCircuitAndDepth = euler.createCircuitAndDepth(adjMap, src);</span>

<span class="pc bnc" id="L102" title="All 2 branches missed.">        assert (eulerCircuitAndDepth[0].length == (2 * n - 1));</span>

        //Store occurence of first occurrence each vertex in E another array firstVisit.
        // Size will be n as there are n vertices.
<span class="fc" id="L106">        this.firstVisit = new int[n];</span>
<span class="fc" id="L107">        Arrays.fill(firstVisit, -1);</span>
        int aIdx;
<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (int i = 0; i &lt; eulerCircuitAndDepth[0].length; ++i) {</span>
<span class="fc" id="L110">            aIdx = eulerCircuitAndDepth[0][i];</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (firstVisit[aIdx] == -1) {</span>
<span class="fc" id="L112">                firstVisit[aIdx] = i;</span>
            }
        }

        //https://cp-algorithms.com/graph/lca_farachcoltonbender.html

        // precompute all log values
<span class="fc" id="L119">        int m = eulerCircuitAndDepth[0].length;</span>
<span class="fc" id="L120">        this.log2 = new int[m + 1];</span>
<span class="fc" id="L121">        log2[0] = -1;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int i = 1; i &lt;= m; i++) {</span>
<span class="fc" id="L123">            log2[i] = (log2[i/2] + 1);</span>
        }

<span class="fc" id="L126">        this.blockSize = Math.max(1, log2[m]/2);</span>
        // round-up m/blocksize:
<span class="fc" id="L128">        this.blockCnt = (m + blockSize - 1) / blockSize;</span>

        // precompute minimum of each block and build sparse table
        //st.assign(block_cnt, vector&lt;int&gt;(log_2[block_cnt] + 1));
<span class="fc" id="L132">        this.st = new int[blockCnt][log2[blockCnt] + 1];</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (int i = 0, j = 0, b = 0; i &lt; m; i++, j++) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (j == blockSize) {</span>
<span class="fc" id="L135">                j = 0;</span>
<span class="fc" id="L136">                b++;</span>
            }
<span class="fc bfc" id="L138" title="All 4 branches covered.">            if (j == 0 || minByH(i, st[b][0]) == i) {</span>
<span class="fc" id="L139">                st[b][0] = i;</span>
            }
        }
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (int l = 1; l &lt;= log2[blockCnt]; l++) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for (int i = 0; i &lt; blockCnt; i++) {</span>
<span class="fc" id="L144">                int ni = i + (1 &lt;&lt; (l - 1));</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (ni &gt;= blockCnt) {</span>
<span class="fc" id="L146">                    st[i][l] = st[i][l - 1];</span>
                } else {
<span class="fc" id="L148">                    st[i][l] = minByH(st[i][l - 1], st[ni][l - 1]);</span>
                }
            }
        }

        // precompute mask for each block
        //block_mask.assign(blockCnt, 0);
<span class="fc" id="L155">        this.blockMask = new int[blockCnt];</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (int i = 0, j = 0, b = 0; i &lt; m; i++, j++) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (j == blockSize) {</span>
<span class="fc" id="L158">                j = 0;</span>
<span class="fc" id="L159">                b++;</span>
            }
<span class="pc bpc" id="L161" title="1 of 6 branches missed.">            if (j &gt; 0 &amp;&amp; (i &gt;= m || minByH(i - 1, i) == i - 1)) {</span>
<span class="fc" id="L162">                blockMask[b] += 1 &lt;&lt; (j - 1);</span>
            }
        }

        // precompute RMQ for each unique block
<span class="fc" id="L167">        int possibilities = 1 &lt;&lt; (blockSize - 1);</span>
        //blocks.resize(possibilities);
<span class="fc" id="L169">        this.blocks = new int[possibilities][][];</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (int b = 0; b &lt; blockCnt; b++) {</span>
<span class="fc" id="L172">            int mask = blockMask[b];</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (blocks[mask] != null) {</span>
<span class="fc" id="L174">                continue;</span>
            }
            //blocks[mask].assign(block_size, vector&lt;int&gt;(block_size));
<span class="fc" id="L177">            blocks[mask] = new int[blockSize][blockSize];</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            for (int l = 0; l &lt; blockSize; l++) {</span>
<span class="fc" id="L179">                blocks[mask][l][l] = l;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                for (int r = l + 1; r &lt; blockSize; r++) {</span>
<span class="fc" id="L181">                    blocks[mask][l][r] = blocks[mask][l][r - 1];</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                    if (b * blockSize + r &lt; m) {</span>
<span class="fc" id="L183">                        blocks[mask][l][r] = minByH(b * blockSize + blocks[mask][l][r],</span>
                                b * blockSize + r) - b * blockSize;
                    }
                }
            }
        }
<span class="fc" id="L189">    }</span>

    protected int minByH(int i, int j) {
        //return height[euler_tour[i]] &lt; height[euler_tour[j]] ? i : j;
<span class="fc bfc" id="L193" title="All 2 branches covered.">        return eulerCircuitAndDepth[1][i] &lt; eulerCircuitAndDepth[1][j] ? i : j;</span>
    }

    //O(1) method, not yet corrected for possible 1-based indexing
    public int find(int i0, int i1) {
        //https://cp-algorithms.com/graph/lca_farachcoltonbender.html

<span class="fc" id="L200">        int l = firstVisit[i0];</span>
<span class="fc" id="L201">        int r = firstVisit[i1];</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (l &gt; r) { // swap</span>
<span class="nc" id="L203">            l ^= r;</span>
<span class="nc" id="L204">            r ^= l;</span>
<span class="nc" id="L205">            l ^= r;</span>
        }
<span class="fc" id="L207">        int bl = l / blockSize;</span>
<span class="fc" id="L208">        int br = r / blockSize;</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (bl == br) {</span>
<span class="nc" id="L210">            int idx = lcaInBlock(bl, l % blockSize, r % blockSize);</span>
<span class="nc" id="L211">            return eulerCircuitAndDepth[0][idx];</span>
        }
<span class="fc" id="L213">        int ans1 = lcaInBlock(bl, l % blockSize, blockSize - 1);</span>
<span class="fc" id="L214">        int ans2 = lcaInBlock(br, 0, r % blockSize);</span>
<span class="fc" id="L215">        int ans = minByH(ans1, ans2);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (bl + 1 &lt; br) {</span>
<span class="fc" id="L217">            int l2 = log2[br - bl - 1];</span>
<span class="fc" id="L218">            int ans3 = st[bl+1][l2];</span>
<span class="fc" id="L219">            int ans4 = st[br - (1 &lt;&lt; l2)][l2];</span>
<span class="fc" id="L220">            ans = minByH(ans, minByH(ans3, ans4));</span>
        }
<span class="fc" id="L222">        return eulerCircuitAndDepth[0][ans];</span>
    }

    int lcaInBlock(int b, int l, int r) {
<span class="fc" id="L226">        return blocks[blockMask[b]][l][r] + b * blockSize;</span>
    }

    /**
     * find the least common ancestor for indices i0 and i1 where the indices are w/ respect to the
     * original array give to constructor.
     * It finds the index in array 'a' for the minimum value in the query index range [i0, i1].
     * The r.t.c. is O(log_2(n)) where n is a.length.
     *
     * @param i0
     * @param i1
     * @return index into array 'a' of the least common ancestor of
     */
    public int findWithLogN(int i0, int i1) {

<span class="fc" id="L241">        Set&lt;Integer&gt; common = new HashSet&lt;&gt;();</span>

<span class="fc" id="L243">        int iLeft = i0;</span>
<span class="fc" id="L244">        int iRight = i1;</span>
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">        while (iLeft != -1 || iRight != -1) {</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (iLeft == iRight) {</span>
<span class="nc" id="L247">                return iLeft;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            } else if (common.contains(iLeft)) {</span>
<span class="fc" id="L249">                return iLeft;</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            } else if (common.contains(iRight)) {</span>
<span class="fc" id="L251">                return iRight;</span>
            }
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (iLeft != -1) {</span>
<span class="fc" id="L254">                common.add(iLeft);</span>
<span class="fc" id="L255">                iLeft = tree[iLeft];</span>
            }
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (iRight != -1) {</span>
<span class="fc" id="L258">                common.add(iRight);</span>
<span class="fc" id="L259">                iRight = tree[iRight];</span>
            }
        }
<span class="nc" id="L262">        return -1;</span>
    }

    /**
     * makes the parent array of a as a cartesion tree.
     *
     * @param a
     * @return
     */
    protected int[] makeCartesianTree(int[] a) {
<span class="fc" id="L272">        int n = a.length;</span>
<span class="fc" id="L273">        int[] parent = new int[n];</span>
<span class="fc" id="L274">        Arrays.fill(parent, -1);</span>

<span class="fc" id="L276">        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span>

        // build cartesian tree using montonic decr queue
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L280">            int last = -1;</span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">            while (!s.isEmpty() &amp;&amp; a[s.peek()] &gt;= a[i]) {</span>
<span class="fc" id="L282">                last = s.pop();</span>
            }
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (!s.isEmpty()) {</span>
<span class="fc" id="L285">                parent[i] = s.peek();</span>
            }
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (last &gt; -1) {</span>
<span class="fc" id="L288">                parent[last] = i;</span>
            }
<span class="fc" id="L290">            s.push(i);</span>
        }
<span class="fc" id="L292">        return parent;</span>
    }

    private Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; createBiDirectionalMap(int[] tree) {
<span class="fc" id="L296">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; adjMap = new HashMap&lt;&gt;();</span>
        int u;
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (int v = 0; v &lt; tree.length; ++v) {</span>
<span class="fc" id="L299">            u = tree[v];</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (u == -1) {</span>
                // root node
<span class="fc" id="L302">                continue;</span>
            }
<span class="fc" id="L304">            adjMap.putIfAbsent(u, new LinkedList&lt;&gt;());</span>
<span class="fc" id="L305">            adjMap.putIfAbsent(v, new LinkedList&lt;&gt;());</span>
<span class="fc" id="L306">            adjMap.get(u).add(v);</span>
<span class="fc" id="L307">            adjMap.get(v).add(u);</span>
        }
<span class="fc" id="L309">        return adjMap;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>