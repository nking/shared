<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.util.AngleUtil;
import algorithms.util.PairIntWithIndex;
import algorithms.util.PairIntArray;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="fc" id="L22">public class MiscellaneousCurveHelper {</span>

<span class="fc" id="L24">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L27">    private static int minLedgeWidth = 4;</span>

<span class="fc" id="L29">    protected static final int[] eightNeighborsX =</span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L31">    protected static final int[] eightNeighborsY =</span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner 
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {

<span class="pc bpc" id="L50" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L51">            return false;</span>
        }

<span class="fc" id="L54">        int nNeg = 0;</span>
<span class="fc" id="L55">        int n = closedCurve.getN();</span>

<span class="fc bfc" id="L57" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

            long xm1, ym1, x, y, xp1, yp1;

<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L62">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L63">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L64">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L65">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L67">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L68">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L69">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L70">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L72">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L73">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L74">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L75">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L77">            x = closedCurve.getX(i);</span>
<span class="fc" id="L78">            y = closedCurve.getY(i);</span>

<span class="fc" id="L80">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L81">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L82">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L83">            long dyp1my = (yp1 - y);</span>

            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L86">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
                // clockwise when crossProduct is negative
<span class="fc" id="L90">                nNeg++;</span>
            }
        }

<span class="fc" id="L94">        int nPos = n - nNeg;//n - 2 - nNeg;</span>

        //log.info(closedCurve.toString());
        //log.info(&quot;n=&quot; + n + &quot; nNegative=&quot; + nNeg + &quot; nPositive=&quot; + nPos);

<span class="pc bpc" id="L99" title="2 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner by first computing the convex hull then
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise2(PairIntArray closedCurve) {

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L119">            return false;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        } else if (closedCurve.getN() &lt; 4) {</span>
<span class="nc" id="L121">            return curveIsOrderedClockwise(closedCurve);</span>
        }
        
<span class="fc" id="L124">        int n = closedCurve.getN();</span>
        
<span class="fc" id="L126">        PairIntWithIndex[] p = new PairIntWithIndex[n];</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L128">            p[i] = new PairIntWithIndex(closedCurve.getX(i), closedCurve.getY(i),  i);</span>
        }
        
<span class="fc" id="L131">        GrahamScanPairInt&lt;PairIntWithIndex&gt; scan = new GrahamScanPairInt&lt;PairIntWithIndex&gt;();</span>
        try {
<span class="fc" id="L133">            scan.computeHull(p);</span>
            
            // hull returns points in clockwise order
            
<span class="fc" id="L137">            n = scan.getHull().size() - 1;</span>
            //PairIntArray hull = new PairIntArray(n);
            //List&lt;Integer&gt; hullCurveIndexes = new ArrayList&lt;Integer&gt;();
            //int[] deltaIndexes = new int[n];
            
            // nPos or nNeg might be 1 and then other n-2 if there is wrap-around
<span class="fc" id="L143">            int nNeg = 0;</span>
<span class="fc" id="L144">            int nPos = 0;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
                
<span class="fc" id="L147">                PairIntWithIndex p0 = scan.getHull().get(i);</span>
                
                //hull.add(Math.round(p0.getX()), Math.round(p0.getY()));
                //hullCurveIndexes.add(Integer.valueOf(p0.getPixIndex()));
                
                // for CW input, expect these to be + numbers
<span class="fc" id="L153">                int deltaIndex = scan.getHull().get(i + 1).getPixIndex() - p0.getPixIndex();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                if (deltaIndex &gt; 0) {</span>
<span class="fc" id="L155">                    nPos++;</span>
                } else {
<span class="fc" id="L157">                    nNeg++;</span>
                }
            }
            
            //boolean isCW = curveIsOrderedClockwise(hull);
            //assert(isCW);
            
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (nPos &gt; nNeg) {</span>
<span class="fc" id="L165">                return true;</span>
            }
            
<span class="fc" id="L168">            return false;</span>
            
<span class="nc" id="L170">        } catch (GrahamScanTooFewPointsException ex) {</span>
<span class="nc" id="L171">            return curveIsOrderedClockwise(closedCurve);</span>
        }
    }

    /**
         *           Y
         *          90
         *     135   |    +45
         *           |
         *   180------------ 0   X
         *           |
         *    225    |   315
         *          270
         * 
         *  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45
        
     * @param angle360
     * @return 
     */
    private int convert360To45RefFrame(int angle360) {
        
<span class="nc bnc" id="L196" title="All 4 branches missed.">        if ((angle360 &lt; 23) || (angle360 &gt; 337)) {</span>
<span class="nc" id="L197">            return 0;</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">        } else if ((angle360 &gt; 157) &amp;&amp; (angle360 &lt; 203)) {</span>
<span class="nc" id="L199">            return 0;</span>
<span class="nc bnc" id="L200" title="All 8 branches missed.">        } else  if (((angle360 &gt; 22) &amp;&amp; (angle360 &lt; 68)) || </span>
            ((angle360 &gt; 202) &amp;&amp; (angle360 &lt; 248))) {
            // in range of +45 or +225
<span class="nc" id="L203">            return 45;</span>
<span class="nc bnc" id="L204" title="All 8 branches missed.">        } else if (((angle360 &gt; 67) &amp;&amp; (angle360 &lt; 113)) || </span>
            ((angle360 &gt; 247) &amp;&amp; (angle360 &lt; 293))) {
            // in range of +90 or +270
<span class="nc" id="L207">            return 90;</span>
        } else { //if (((t &gt; 112) &amp;&amp; (t &lt; 158)) || ((t &gt; 292) &amp;&amp; (t &lt; 338))) {
            // in range of +135 or +315
<span class="nc" id="L210">            return -45;</span>
        }
    }
    
    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     *
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1,
        int[] correlationOffset) {

<span class="fc" id="L236">        correlationOffset[0] = Integer.MAX_VALUE;</span>

        //TODO: look at string matching algorithms to explore improvements here

        PairIntArray shorter, longer;
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L242">            shorter = curve0;</span>
<span class="fc" id="L243">            longer = curve1;</span>
        } else {
<span class="fc" id="L245">            shorter = curve1;</span>
<span class="fc" id="L246">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++

             #####
             +++++++++++

                       #####
             +++++++++++

        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.

        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that
        offset in correlationOffset and return true, else false
        */

<span class="fc" id="L277">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L278">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L279">        int cSSMinNOverlapping = 0;</span>

<span class="fc" id="L281">        double sqrtTwo = Math.sqrt(2);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L303">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L304">                siIdx = sfIdx - i;</span>
<span class="fc" id="L305">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L307">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L308">                offset = i - sfIdx;</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>

                /*
                      #####
                     +++++++++++  i=5

                       #####
                     +++++++++++

                        #####
                     +++++++++++

                         #####
                     +++++++++++

                          #####
                     +++++++++++

                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L332">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L333">                siIdx = 0;</span>
<span class="fc" id="L334">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L336">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L337">                offset = i - sfIdx;</span>

            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++

                              #####
                     +++++++++++

                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L354">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L356">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L357">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L359">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L360">                offset = liIdx;</span>

            }

<span class="fc" id="L364">            int nOverLapping = (sfIdx - siIdx) + 1;</span>

<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L367">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }

<span class="fc" id="L371">            double sumSq = 0;</span>

<span class="fc" id="L373">            int s = siIdx;</span>
<span class="fc" id="L374">            int l = liIdx;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L376">                int xs = shorter.getX(s);</span>
<span class="fc" id="L377">                int xl = longer.getX(l);</span>
<span class="fc" id="L378">                int dx = xs - xl;</span>
<span class="fc" id="L379">                int ys = shorter.getY(s);</span>
<span class="fc" id="L380">                int yl = longer.getY(l);</span>
<span class="fc" id="L381">                int dy = ys - yl;</span>
<span class="fc" id="L382">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L383">                s++;</span>
<span class="fc" id="L384">                l++;</span>
<span class="fc" id="L385">            }</span>

<span class="fc" id="L387">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>

            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L390" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>

<span class="pc bpc" id="L392" title="5 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {

<span class="fc" id="L396">                    cSSMin = tmp;</span>

<span class="fc" id="L398">                    cSSMinOffset = offset;</span>

<span class="fc" id="L400">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }
        }

<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L407">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L409">            return true;</span>
        }

<span class="fc" id="L412">        return false;</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {

<span class="fc" id="L417">        double xc = 0;</span>
<span class="fc" id="L418">        double yc = 0;</span>

<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L421">            double x1 = xy.getX(i);</span>
<span class="fc" id="L422">            xc += (weights[i] * x1);</span>

<span class="fc" id="L424">            double y1 = xy.getY(i);</span>
<span class="fc" id="L425">            yc += (weights[i] * y1);</span>
        }

<span class="fc" id="L428">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy) {

<span class="fc" id="L433">        double xc = 0;</span>
<span class="fc" id="L434">        double yc = 0;</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L438">            xc += xy.getX(i);</span>

<span class="fc" id="L440">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L443">        xc /= (double)xy.getN();</span>

<span class="fc" id="L445">        yc /= (double)xy.getN();</span>

<span class="fc" id="L447">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairFloatArray xy) {

<span class="fc" id="L452">        double xc = 0;</span>
<span class="fc" id="L453">        double yc = 0;</span>

<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L457">            xc += xy.getX(i);</span>

<span class="fc" id="L459">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L462">        xc /= (double)xy.getN();</span>

<span class="fc" id="L464">        yc /= (double)xy.getN();</span>

<span class="fc" id="L466">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {

<span class="nc" id="L471">        double xc = 0;</span>
<span class="nc" id="L472">        double yc = 0;</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>

<span class="nc" id="L476">            double[] xycen = calculateXYCentroids(points);</span>

<span class="nc" id="L478">            xc += xycen[0];</span>
<span class="nc" id="L479">            yc += xycen[1];</span>
<span class="nc" id="L480">        }</span>

<span class="nc" id="L482">        xc /= (double)xyList.size();</span>
<span class="nc" id="L483">        yc /= (double)xyList.size();</span>

<span class="nc" id="L485">        return new double[]{xc, yc};</span>
    }

    public PairInt calculateXYCentroids2(Collection&lt;PairInt&gt; points) {
        
<span class="nc" id="L490">        double[] xyCen = calculateXYCentroids(points);</span>
        
<span class="nc" id="L492">        PairInt p = new PairInt((int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]));</span>
        
<span class="nc" id="L494">        return p;</span>
    }
    
    public double[] calculateXYCentroids(Collection&lt;PairInt&gt; points) {

<span class="fc" id="L499">        double xc = 0;</span>
<span class="fc" id="L500">        double yc = 0;</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L504">           int x = p.getX();</span>
<span class="fc" id="L505">           int y = p.getY();</span>

<span class="fc" id="L507">            xc += x;</span>
<span class="fc" id="L508">            yc += y;</span>
<span class="fc" id="L509">        }</span>

<span class="fc" id="L511">        xc /= (double)(points.size());</span>

<span class="fc" id="L513">        yc /= (double)(points.size());</span>

<span class="fc" id="L515">        return new double[]{xc, yc};</span>
    }

    public int[] calculateRoundedXYCentroids(Set&lt;PairInt&gt; points) {

<span class="nc" id="L520">        double[] xyCen = calculateXYCentroids(points);</span>

<span class="nc" id="L522">        int[] out = new int[2];</span>
<span class="nc" id="L523">        out[0] = (int)Math.round(xyCen[0]);</span>
<span class="nc" id="L524">        out[1] = (int)Math.round(xyCen[1]);</span>

<span class="nc" id="L526">        return out;</span>
    }
    
    public int[] calculateRoundedXYCentroids(TIntSet pixelIdxs, int imgWidth) {

<span class="nc" id="L531">        double xc = 0;</span>
<span class="nc" id="L532">        double yc = 0;</span>

<span class="nc" id="L534">        TIntIterator iter = pixelIdxs.iterator();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L537">            int pixIdx = iter.next();</span>
            
<span class="nc" id="L539">            int y = pixIdx/imgWidth;</span>
<span class="nc" id="L540">            int x = pixIdx - (y * imgWidth);</span>
            
<span class="nc" id="L542">            xc += x;</span>
<span class="nc" id="L543">            yc += y;</span>
<span class="nc" id="L544">        }</span>

<span class="nc" id="L546">        xc /= (double)pixelIdxs.size();</span>
<span class="nc" id="L547">        yc /= (double)pixelIdxs.size();</span>
        
<span class="nc" id="L549">        int[] out = new int[2];</span>
<span class="nc" id="L550">        out[0] = (int)Math.round(xc);</span>
<span class="nc" id="L551">        out[1] = (int)Math.round(yc);</span>

<span class="nc" id="L553">        return out;</span>
    }

    public double[] calculateXYCentroids(float[] x, float[] y) {

<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L559">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L562">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L565">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L568">        double xc = 0;</span>
<span class="fc" id="L569">        double yc = 0;</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L573">            xc += x[i];</span>

<span class="fc" id="L575">            yc += y[i];</span>
        }

<span class="fc" id="L578">        xc /= (double)(x.length);</span>

<span class="fc" id="L580">        yc /= (double)(x.length);</span>

<span class="fc" id="L582">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(int[] x, int[] y) {

<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L588">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L591">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L594">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L597">        double xc = 0;</span>
<span class="fc" id="L598">        double yc = 0;</span>

<span class="fc bfc" id="L600" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L602">            xc += x[i];</span>

<span class="fc" id="L604">            yc += y[i];</span>
        }

<span class="fc" id="L607">        xc /= (double)(x.length);</span>

<span class="fc" id="L609">        yc /= (double)(x.length);</span>

<span class="fc" id="L611">        return new double[]{xc, yc};</span>
    }

    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     *
     * @param edge
     * @param idx
     * @return
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {

        // test for endpoints first
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (idx == 0) {</span>

<span class="nc bnc" id="L628" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L629">                return true;</span>
            }

            // does this point currently connect to the last point?
<span class="nc" id="L633">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L635">                diffX *= -1;</span>
            }
<span class="nc" id="L637">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L639">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L641" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L644">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L646">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L648" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L649">                    return true;</span>
                }

<span class="nc" id="L652">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L654">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L657">                    return true;</span>
                }
            }
<span class="nc" id="L660">            return false;</span>
        }

<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>

<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L666">                return true;</span>
            }

            // does this point currently connect to the first point?
<span class="nc" id="L670">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L672">                diffX *= -1;</span>
            }
<span class="nc" id="L674">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L676">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L678" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L681">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L683">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L685" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L686">                    return true;</span>
                }

<span class="nc" id="L689">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L691">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L693" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L694">                    return true;</span>
                }
            }
<span class="nc" id="L697">            return false;</span>
        }

<span class="nc bnc" id="L700" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L701">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L703">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L706">                return true;</span>
            }

<span class="nc" id="L709">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L711">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L714">                return true;</span>
            }

<span class="nc" id="L717">            return false;</span>
        }

<span class="nc" id="L720">        return false;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {

        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)

        distance between that edge and a point (xP, yP) is

        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;

        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- )
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )
        */

<span class="fc" id="L743">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L744">        float diffY = lineY1 - lineY0;</span>

<span class="fc bfc" id="L746" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L748">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L751">            return Math.abs(xP - lineX0);</span>
        }

<span class="fc" id="L754">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>

<span class="fc" id="L756">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L758">        double dist = pt1/pt2;</span>

<span class="fc" id="L760">        return dist;</span>
    }

    public void sortByX(PairIntArray curve) {
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">        if (curve.getN() &lt; 2) {</span>
<span class="nc" id="L765">            return;</span>
        }
<span class="fc" id="L767">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L768">    }</span>

    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L772">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L773">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L774">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L776">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {

<span class="fc" id="L780">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L781">        int store = idxLo - 1;      //store to swap after pivot</span>

<span class="fc bfc" id="L783" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L785">                store++;</span>
<span class="fc" id="L786">                int swapX = curve.getX(store);</span>
<span class="fc" id="L787">                int swapY = curve.getY(store);</span>
<span class="fc" id="L788">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L789">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L792">        store++;</span>

<span class="fc" id="L794">        int swapX = curve.getX(store);</span>
<span class="fc" id="L795">        int swapY = curve.getY(store);</span>
<span class="fc" id="L796">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L797">        curve.set(idxHi, swapX, swapY);</span>

<span class="fc" id="L799">        return store;</span>
    }

    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints,
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {

<span class="fc" id="L806">        outputNeighbors.clear();</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L810">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L811">            int y2 = y + eightNeighborsY[i];</span>

<span class="pc bpc" id="L813" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L815">                continue;</span>
            }

<span class="fc" id="L818">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L821">                continue;</span>
            }
<span class="pc bpc" id="L823" title="1 of 4 branches missed.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L824">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L827">    }</span>

    public Set&lt;PairInt&gt; findNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L831">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L833" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L835">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L836">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L838">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L841">                neighbors.add(p2);</span>
            }
        }

<span class="nc" id="L845">        return neighbors;</span>
    }
        
    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, int[] dxs, int[] dys, 
        Set&lt;PairInt&gt; outputNeighbors) {
        
<span class="nc" id="L852">        outputNeighbors.clear();</span>
        
<span class="nc bnc" id="L854" title="All 2 branches missed.">        for (int i = 0; i &lt; dxs.length; i++) {</span>
            
<span class="nc" id="L856">            int x2 = x + dxs[i];</span>
<span class="nc" id="L857">            int y2 = y + dys[i];</span>
            
<span class="nc" id="L859">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L862">                continue;</span>
            }
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L865">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L868">    }</span>

    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L873">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L875" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L877">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L878">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L880" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L882">                continue;</span>
            }

<span class="nc" id="L885">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L887" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L888">                continue;</span>
            }
<span class="nc bnc" id="L890" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L891">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L894">    }</span>

    /**
     * iterate through points, counting the number of pixels on the image
     * boundaries, and return true if the number reaches numberOfPixels.
     * @param numberOfPixels the number of pixels for which to return true
     * if they are on the image boundaries.
     * @param points
     * @param imageWidth
     * @param imageHeight
     * @return
     */
    public boolean hasNumberOfPixelsOnImageBoundaries(int numberOfPixels,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc" id="L909">        int n = 0;</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L913">            int x = p.getX();</span>
<span class="nc" id="L914">            int y = p.getY();</span>

<span class="nc bnc" id="L916" title="All 8 branches missed.">            if ((x == 0) || (y == 0) || (x == (imageWidth - 1)) ||</span>
                (y == (imageHeight - 1))) {

<span class="nc" id="L919">                n++;</span>

<span class="nc bnc" id="L921" title="All 2 branches missed.">                if (n == numberOfPixels) {</span>
<span class="nc" id="L922">                    return true;</span>
                }
            }
<span class="nc" id="L925">        }</span>

<span class="nc bnc" id="L927" title="All 2 branches missed.">        return (n &gt;= numberOfPixels);</span>
    }

    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points, int imageWidth,
        int imageHeight) {

<span class="nc" id="L933">        int nn = 0;</span>

<span class="nc bnc" id="L935" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L937">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L938">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L940" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L942">                continue;</span>
            }

<span class="nc" id="L945">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L948">                nn++;</span>
            }
        }

<span class="nc" id="L952">        return nn;</span>
    }
    
    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L957">        int nn = 0;</span>

<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L961">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L962">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L964">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L967">                nn++;</span>
            }
        }

<span class="nc" id="L971">        return nn;</span>
    }

    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2) {
        
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (idx2 &lt; 0) {</span>
<span class="nc" id="L977">            return false;</span>
        }

<span class="nc" id="L980">        int x1 = edge.getX(idx1);</span>
<span class="nc" id="L981">        int y1 = edge.getY(idx1);</span>

<span class="nc" id="L983">        int x2 = edge.getX(idx2);</span>
<span class="nc" id="L984">        int y2 = edge.getY(idx2);</span>

<span class="nc" id="L986">        int diffX = Math.abs(x1 - x2);</span>
<span class="nc" id="L987">        int diffY = Math.abs(y1 - y2);</span>

<span class="nc bnc" id="L989" title="All 4 branches missed.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="nc" id="L990">            return true;</span>
        }

<span class="nc" id="L993">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx, int x, int y) {
        
<span class="nc bnc" id="L998" title="All 4 branches missed.">        if (idx &lt; 0 || idx &gt; (edge.getN() - 1)) {</span>
<span class="nc" id="L999">            return false;</span>
        }

<span class="nc" id="L1002">        int x1 = edge.getX(idx);</span>
<span class="nc" id="L1003">        int y1 = edge.getY(idx);</span>

<span class="nc" id="L1005">        int diffX = Math.abs(x1 - x);</span>
<span class="nc" id="L1006">        int diffY = Math.abs(y1 - y);</span>

<span class="nc bnc" id="L1008" title="All 4 branches missed.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="nc" id="L1009">            return true;</span>
        }

<span class="nc" id="L1012">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2,
        float spacingBetweenPoints) {

<span class="nc" id="L1018">        int x1 = edge.getX(idx1);</span>
<span class="nc" id="L1019">        int y1 = edge.getY(idx1);</span>

<span class="nc" id="L1021">        int x2 = edge.getX(idx2);</span>
<span class="nc" id="L1022">        int y2 = edge.getY(idx2);</span>

<span class="nc" id="L1024">        int diffX = Math.abs(x1 - x2);</span>
<span class="nc" id="L1025">        int diffY = Math.abs(y1 - y2);</span>
        
<span class="nc" id="L1027">        float dist = (float)Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (dist &lt;= spacingBetweenPoints) {</span>
<span class="nc" id="L1030">            return true;</span>
        }

<span class="nc" id="L1033">        return false;</span>
    }

    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * along the curve at the middle point, its directionCCW is from p0 to p1.
     * &lt;pre&gt;
     * For example:
     * 
     * 135 degrees
     *       .---
     *       | .
     *           p2   
     *             p1
     *                p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleAtMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

        /*
        given the points (x1, y1) (x2, y2) and (x3, y3), 
        calculates the angle at the midpoint (x2, y2) for the path along
        the points.
        */
        
<span class="fc" id="L1066">        double theta1 = AngleUtil.polarAngleCCW(x2 - x1, y2 - y1);</span>
        
<span class="fc" id="L1068">        double theta2 = AngleUtil.polarAngleCCW(x3 - x2, y3 - y2);</span>
        
<span class="fc" id="L1070">        double theta = AngleUtil.getAngleAverageInRadians(theta1, theta2);</span>
                
<span class="fc" id="L1072">        return theta;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * tangent to the curve at the middle point - its directionCCW follows
     * the right hand rule.
     * &lt;pre&gt;
     * For example:
     *                  45 degrees
     *               __
     *               . |
     *       p2    .
     *          p1
     *             p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleTangentToMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

<span class="fc" id="L1099">        double theta = calculateAngleAtMidpoint(x1, y1, x2, y2, x3, y3);</span>
               
<span class="fc" id="L1101">        double thetaMinus90 = theta - Math.PI/2.;</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        if (thetaMinus90 &lt; 0) {</span>
<span class="nc" id="L1103">            thetaMinus90 += (2.*Math.PI);</span>
        }
        
<span class="fc" id="L1106">        return thetaMinus90;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which directionCCW and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.  The points are also
     * checked to make sure they aren't in the points set.
     *
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @param points
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY,
        Set&lt;PairInt&gt; points) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        directionCCW of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="nc" id="L1144">        int xmRot90 = xp + (ym - yp);</span>
<span class="nc" id="L1145">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="nc" id="L1147">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="nc" id="L1148">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="nc" id="L1150">        boolean rot90IsInPoints = points.contains(</span>
<span class="nc" id="L1151">            new PairInt(Math.round(xmRot90), Math.round(ymRot90)));</span>

<span class="nc" id="L1153">        boolean rotNegative90IsInPoints = points.contains(</span>
<span class="nc" id="L1154">            new PairInt(Math.round(xmRotNegative90),</span>
<span class="nc" id="L1155">            Math.round(ymRotNegative90)));</span>

<span class="nc" id="L1157">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="nc" id="L1160">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="nc" id="L1164">        double perp = theta;</span>

<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L1167">            perp += Math.PI/2.;</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        } else if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc bnc" id="L1169" title="All 4 branches missed.">            if (rot90IsInPoints &amp;&amp; !rotNegative90IsInPoints) {</span>
<span class="nc" id="L1170">                perp -= Math.PI/2.;</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">            } else if (!rot90IsInPoints &amp;&amp; rotNegative90IsInPoints) {</span>
<span class="nc" id="L1172">                perp += Math.PI/2.;</span>
            } else {
<span class="nc" id="L1174">                throw new IllegalStateException(&quot;Error in algorithm:&quot; +</span>
                &quot; consider changing the test 90 and -90 points so that&quot; +
                &quot; one will always be in points set.&quot;);
            }
        } else {
<span class="nc" id="L1179">            perp -= Math.PI/2.;</span>
        }

<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L1183">            perp = perp - 2*Math.PI;</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L1185">            perp += 2*Math.PI;</span>
        }

<span class="nc" id="L1188">        return perp;</span>
    }

    public double calculateArea(PairIntArray closedCurve) {
        
<span class="nc" id="L1193">        int n = closedCurve.getN();</span>
        
<span class="nc" id="L1195">        double sum = 0;</span>
        
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        for (int i = 0; i &lt; (n - 1); ++i) {</span>
            
<span class="nc" id="L1199">            double t = 0.5 * (closedCurve.getY(i + 1) + closedCurve.getY(i)) *</span>
<span class="nc" id="L1200">                (closedCurve.getX(i + 1) - closedCurve.getX(i));</span>
            
<span class="nc" id="L1202">            sum += t;</span>
        }
        
<span class="nc" id="L1205">        sum += ((closedCurve.getY(0) + closedCurve.getY(n - 1)) *</span>
<span class="nc" id="L1206">                (closedCurve.getX(0) - closedCurve.getX(n -1)));</span>
        
<span class="nc" id="L1208">        return sum;</span>
    }

    public PairIntArray createContiguousCircle(float radius) {

<span class="nc" id="L1213">        int shift = (int)Math.ceil(radius);</span>
    
<span class="nc" id="L1215">        return createContiguousCircle(radius, shift, shift);</span>
    }
    
    public PairIntArray createContiguousCircle(float radius, int xShift, 
        int yShift) {
        
        // for a change in y to be at least 1 pixel, theta would be:
        //   theta = asin(1/r)
<span class="nc" id="L1223">        double theta = Math.asin(1./radius);</span>
        
<span class="nc" id="L1225">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L1227">        PairIntArray circle = new PairIntArray();</span>
<span class="nc" id="L1228">        double t = 0;</span>
        int x, y;
<span class="nc bnc" id="L1230" title="All 2 branches missed.">        while (t &lt;= Math.PI/2.) {</span>
<span class="nc" id="L1231">            x = xShift + (int)Math.round(radius * Math.cos(t));</span>
<span class="nc" id="L1232">            y = yShift + (int)Math.round(radius * Math.sin(t));</span>
<span class="nc" id="L1233">            PairInt p = new PairInt(x, y);</span>
<span class="nc" id="L1234">            t += theta;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1236">                continue;</span>
            }
<span class="nc" id="L1238">            circle.add(x, y);</span>
<span class="nc" id="L1239">            added.add(p);</span>
<span class="nc" id="L1240">        }</span>
<span class="nc" id="L1241">        int n90 = circle.getN();</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        for (int i = (n90 - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L1243">            x = xShift -1 * (circle.getX(i) - xShift);</span>
<span class="nc" id="L1244">            y = circle.getY(i);</span>
<span class="nc" id="L1245">            PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1247">                continue;</span>
            }
<span class="nc" id="L1249">            circle.add(x, y);</span>
<span class="nc" id="L1250">            added.add(p);</span>
        }
<span class="nc" id="L1252">        int n180 = circle.getN();</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        for (int i = (n180 - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L1254">            x = circle.getX(i);</span>
<span class="nc" id="L1255">            y = yShift -1 * (circle.getY(i) - yShift);</span>
<span class="nc" id="L1256">            PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1258">                continue;</span>
            }
<span class="nc" id="L1260">            circle.add(x, y);</span>
<span class="nc" id="L1261">            added.add(p);</span>
        }
        
<span class="nc" id="L1264">        return circle;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>