<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DoubleDouble.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.net.oelen.polarith</a> &gt; <span class="el_source">DoubleDouble.java</span></div><h1>DoubleDouble.java</h1><pre class="source lang-java linenums">/*
The author of this code is Wilco Oelen and he offers it
freely without copyright, but asks that his pages are referenced
as the source if used.
He has a webpage with information on the polynomial software
he ported and more modern versions which require jini bindings:
https://woelen.homescience.net/science/math/exps/polynomials/
https://woelen.homescience.net/science/math/exps/polynomials/software.html
The code here is from the Java port of RPoly, CPoly and MPSolve 1996 algorithms:
https://woelen.homescience.net/science/math/exps/polynomials/software/polsolve.tgz
*/
package thirdparty.net.oelen.polarith;

import java.io.Serializable;
import java.util.Arrays;

/**
 * Immutable, extended-precision floating-point numbers which maintain 105 bits
 * (approximately 30 decimal digits) of precision.
 * &lt;p&gt;
 * A DoubleDouble uses a representation containing two double-precision values.
 * A number x is represented as a pair of doubles, x.hi and x.lo, such that the
 * number represented by x is x.hi + x.lo, where
 * &lt;pre&gt;
 *    |x.lo| &lt;= 0.5*ulp(x.hi)
 * &lt;/pre&gt; and ulp(y) means &quot;unit in the last place of y&quot;. The basic arithmetic
 * operations are implemented using convenient properties of IEEE-754
 * floating-point arithmetic.
 * &lt;p&gt;
 * The range of values which can be represented is the same as in IEEE-754. The
 * precision of the representable numbers is twice as great as IEEE-754 double
 * precision.
 * &lt;p&gt;
 * The correctness of the arithmetic algorithms relies on operations being
 * performed with standard IEEE-754 double precision and rounding. This is the
 * Java standard arithmetic model, but for performance reasons Java
 * implementations are not constrained to using this standard by default. Some
 * processors (notably the Intel Pentium architecure) perform floating point
 * operations in (non-IEEE-754-standard) extended-precision. A JVM
 * implementation may choose to use the non-standard extended-precision as its
 * default arithmetic mode. To prevent this from happening, this code uses the
 * Java &lt;tt&gt;strictfp&lt;/tt&gt; modifier, which forces all operations to take place in
 * the standard IEEE-754 rounding model.
 * &lt;p&gt;
 * The API provides a value-oriented interface. DoubleDouble values are
 * immutable; operations on them return new objects carrying the result of the
 * operation. This provides a much simpler semantics for writing DoubleDouble
 * expressions, and Java memory management is efficient enough that this imposes
 * very little performance penalty.
 * &lt;p&gt;
 * This implementation uses algorithms originally designed variously by Knuth,
 * Kahan, Dekker, and Linnainmaa. Douglas Priest developed the first C
 * implementation of these techniques. Other more recent C++ implementation are
 * due to Keith M. Briggs and David Bailey et al.
 *
 * &lt;h3&gt;References&lt;/h3&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Priest, D., &lt;i&gt;Algorithms for Arbitrary Precision Floating Point
 * Arithmetic&lt;/i&gt;, in P. Kornerup and D. Matula, Eds., Proc. 10th Symposium on
 * Computer Arithmetic, IEEE Computer Society Press, Los Alamitos, Calif., 1991.
 * &lt;li&gt;Yozo Hida, Xiaoye S. Li and David H. Bailey,
 * &lt;i&gt;Quad-Double Arithmetic: Algorithms, Implementation, and Application&lt;/i&gt;,
 * manuscript, Oct 2000; Lawrence Berkeley National Laboratory Report BNL-46996.
 * &lt;li&gt;David Bailey, &lt;i&gt;High Precision Software Directory&lt;/i&gt;;
 * &lt;tt&gt;http://crd.lbl.gov/~dhbailey/mpdist/index.html&lt;/tt&gt;
 * &lt;/ul&gt;
 *
 *
 * @author Martin Davis
 *
 */
public final strictfp class DoubleDouble implements Serializable, Comparable, Cloneable {
    
    /**
     *
     */
<span class="fc" id="L77">    public static final long serialVersionUID = Hash64.hash(&quot;DoubleDouble_v1.0&quot;);</span>

    /**
     * The value nearest to the constant Pi.
     */
<span class="fc" id="L82">    public static final DoubleDouble PI = new DoubleDouble(</span>
            3.141592653589793116e+00,
            1.224646799147353207e-16);

    /**
     * The value nearest to the constant 2 * Pi.
     */
<span class="fc" id="L89">    public static final DoubleDouble TWO_PI = new DoubleDouble(</span>
            6.283185307179586232e+00,
            2.449293598294706414e-16);

    /**
     * The value nearest to the constant Pi / 2.
     */
<span class="fc" id="L96">    public static final DoubleDouble PI_2 = new DoubleDouble(</span>
            1.570796326794896558e+00,
            6.123233995736766036e-17);

    /**
     * The value nearest to the constant e (the natural logarithm base).
     */
<span class="fc" id="L103">    public static final DoubleDouble E = new DoubleDouble(</span>
            2.718281828459045091e+00,
            1.445646891729250158e-16);
    
    
    
    /**
     * A few simple numerical constants.
     */
<span class="fc" id="L112">    public static final DoubleDouble ZERO = new DoubleDouble();</span>

    /**
     *
     */
<span class="fc" id="L117">    public static final DoubleDouble ONE = new DoubleDouble(1.0);</span>

    /**
     *
     */
<span class="fc" id="L122">    public static final DoubleDouble TWO = new DoubleDouble(2.0);</span>

    /**
     *
     */
<span class="fc" id="L127">    public static final DoubleDouble TEN = new DoubleDouble(10.0);</span>

    /**
     *
     */
<span class="fc" id="L132">    public static final DoubleDouble MAXINT = new DoubleDouble(Integer.MAX_VALUE);</span>

    /**
     *
     */
<span class="fc" id="L137">    public static final DoubleDouble MAXLONG = new DoubleDouble(Long.MAX_VALUE);</span>

    /**
     *
     */
<span class="fc" id="L142">    public static final DoubleDouble MININT = new DoubleDouble(Integer.MIN_VALUE);</span>

    /**
     *
     */
<span class="fc" id="L147">    public static final DoubleDouble MINLONG = new DoubleDouble(Long.MIN_VALUE);</span>

    /**
     * A value representing the result of an operation which does not return a
     * valid number.
     */
<span class="fc" id="L153">    public static final DoubleDouble NaN = new DoubleDouble(Double.NaN, Double.NaN);</span>

    /**
     * The smallest representable relative difference between two {link @
     * DoubleDouble} values
     */
    public static final double EPS = 1.23259516440783e-32;  /* = 2^-106 */


    
    
    /**
     * Converts the string argument to a DoubleDouble number.
     *
     @param str a string containing a representation of a numeric value
     @return the extended precision version of the value
     * @throws NumberFormatException if &lt;tt&gt;s&lt;/tt&gt; is not a valid representation
     * of a number
     */
    public static DoubleDouble valueOf(String str)
            throws NumberFormatException {
<span class="nc" id="L174">        return parse(str);</span>
    }

    
    
    
    /**
     * Converts the &lt;tt&gt;double&lt;/tt&gt; argument to a DoubleDouble number.
     *
     @param x a numeric value
     @return the extended precision version of the value
     */
    public static DoubleDouble valueOf(double x) {
<span class="nc" id="L187">        return new DoubleDouble(x);</span>
    }

    
    
    
    /**
     * Converts the &lt;tt&gt;long&lt;/tt&gt; argument to a DoubleDouble number.
     *
     @param x a numeric value
     @return the extended precision version of the value
     */
    public static DoubleDouble valueOf(long x) {
<span class="nc" id="L200">        return new DoubleDouble(x);</span>
    }

    
    
    
    /**
     * Converts the &lt;tt&gt;int&lt;/tt&gt; argument to a DoubleDouble number.
     *
     @param x a numeric value
     @return the extended precision version of the value
     */
    public static DoubleDouble valueOf(int x) {
<span class="nc" id="L213">        return new DoubleDouble(x);</span>
    }

    
    
    
    /**
     * The value to split a double-precision value on during multiplication
     */
    private static final double SPLIT = 0x08000001; // 2^27+1, for IEEE double

    
    
    
    /**
     * The high-order component of the double-double precision value.
     */
    double hi;  // Not private, must be accessible from same package.

    
    
    
    /**
     * The low-order component of the double-double precision value.
     */
    double lo;  // Not private, must be accessible from same package.

    
    
    
    /**
     * Creates a new DoubleDouble with value 0.0.
     */
<span class="fc" id="L246">    public DoubleDouble() {</span>
<span class="fc" id="L247">        hi = lo = 0.0;</span>
<span class="fc" id="L248">    }</span>
    
    
    

    /**
     * Creates a new DoubleDouble with value x.
     *
     @param x the value to initialize
     */
<span class="fc" id="L258">    public DoubleDouble(double x) {</span>
<span class="fc" id="L259">        hi = x;</span>
<span class="fc" id="L260">        lo = 0.0;</span>
<span class="fc" id="L261">    }</span>

    
    /**
     * Creates a new DoubleDouble with value i.
     *
     @param i the value to initialize
     */
<span class="fc" id="L269">    public DoubleDouble(int i) {</span>
<span class="fc" id="L270">        hi = i;</span>
<span class="fc" id="L271">        lo = 0;</span>
<span class="fc" id="L272">    }</span>
    

    
    /**
     * Creates a new DoubleDouble with value l.
     *
     @param l the value to initialize
     */
<span class="fc" id="L281">    public DoubleDouble(long l) { </span>
<span class="fc" id="L282">        hi = l &amp; 0xfffffffffffff800l;</span>
<span class="fc" id="L283">        lo = l &amp; 0x7ffl;</span>
<span class="fc" id="L284">        double s = hi + lo;</span>
<span class="fc" id="L285">        double err = lo - (s - hi);</span>
<span class="fc" id="L286">        hi = s;</span>
<span class="fc" id="L287">        lo = err;</span>
<span class="fc" id="L288">    }</span>
    
    
    

    /**
     * Creates a new DoubleDouble with value (hi, lo).
     *
     @param hi the high-order component
     @param lo the high-order component
     */
<span class="fc" id="L299">    private DoubleDouble(double hi, double lo) {</span>
        // This method does no normalization of a number, it assumes
        // that hi and lo are correct for further operations. For this
        // reason it only is made available for internal use in this
        // library.
<span class="fc" id="L304">        this.hi = hi;</span>
<span class="fc" id="L305">        this.lo = lo;</span>
<span class="fc" id="L306">    }</span>
    
    
    

    /**
     * Creates a new DoubleDouble with value equal to the argument.
     *
     @param str the value to initialize by
     * @throws NumberFormatException if &lt;tt&gt;str&lt;/tt&gt; is not a valid
     * representation of a number
     */
    public DoubleDouble(String str)
<span class="fc" id="L319">            throws NumberFormatException {</span>
<span class="fc" id="L320">        DoubleDouble val = parse(str);</span>
<span class="fc" id="L321">        this.hi = val.hi;</span>
<span class="fc" id="L322">        this.lo = val.lo;</span>
<span class="fc" id="L323">    }</span>
    
    
    

    /**
     * Creates and returns a copy of this value.
     *
     @return a copy of this value
     * @throws CloneNotSupportedException but in practice this never
     * will occur for a DoubleDouble object
     */
    @Override
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L337">        DoubleDouble cp = (DoubleDouble)super.clone();</span>
<span class="nc" id="L338">        cp.hi = hi;</span>
<span class="nc" id="L339">        cp.lo = lo;</span>
<span class="nc" id="L340">        return cp;</span>
    }
    
    
    

    private void RENORM() {
<span class="nc" id="L347">        double s = hi + lo;</span>
<span class="nc" id="L348">        double err = lo - (s - hi);</span>
<span class="nc" id="L349">        hi = s;</span>
<span class="nc" id="L350">        lo = err;</span>
<span class="nc" id="L351">    }</span>
    
    
    
    
    /**
     * Returns a double[] array with approximate values of the supplied
     * DoubleDouble array. Null values are converted to 0.0.
     *
     @param arr The DoubleDouble[] array to be converted to double[].
     @return A double[] array with approximate values of the input array.
     */
    public static double[] toDouble(DoubleDouble[] arr) {
<span class="fc" id="L364">        double[] a = new double[arr.length];</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (int i=0; i&lt;arr.length; i++) {</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            a[i] = arr[i] == null ? 0.0 : arr[i].hi + arr[i].lo;</span>
        }
<span class="fc" id="L368">        return a;</span>
    }
    
    
    
    
    /**
     * Returns a DoubleDouble[] array with values of the supplied
     * double array.
     *
     @param arr The double[] array to be converted to DoubleDouble[].
     @return A DoubleDouble[] array with values of the input array.
     */
    public static DoubleDouble[] toDoubleDouble(double[] arr) {
<span class="nc" id="L382">        DoubleDouble[] a = new DoubleDouble[arr.length];</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        for (int i=0; i&lt;arr.length; i++) {</span>
<span class="nc" id="L384">            a[i] = new DoubleDouble(arr[i]);</span>
        }
<span class="nc" id="L386">        return a;</span>
    }
    
    
    
    
    /**
     * Converts a DoubleDouble[] array to a double[] array. The
     * output array can optionally be supplied. If no array is
     * supplied (null value is given), then the needed array is
     * created. Null values are converted to 0.0.
     *
     @param a The output double[] array, in which the approximate converted
     * values are stored. A null-value may be supplied. In that case an output
     * array is created. If the output array is too short, then only part of
     * the DoubleDouble values is converted.
     @param arr The DoubleDouble[] array to be converted to double[].
     @return A double[] array with approximate values of the input array.
     * This can be the supplied input array or a newly allocated one.
     */
    public static double[] toDouble(double[] a, DoubleDouble[] arr) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (a == null) a = new double[arr.length];</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">        for (int i=0; i&lt;a.length &amp;&amp; i&lt;arr.length; i++) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            a[i] = arr[i] == null ? 0.0 : arr[i].hi + arr[i].lo;</span>
        }
<span class="nc" id="L411">        return a;</span>
    }
    
    
    
    
    /**
     * Converts a double[] array to a DoubleDouble[] array. The
     * output array can optionally be supplied. If no array is
     * supplied (null value is given), then the needed array is
     * created.
     *
     @param a The output DoubleDouble[] array, in which the converted
     * values are stored. A null-value may be supplied. In that case an
     * output array is created. If the output array is too short, then 
     * only part of the values is converted.
     @param arr The double[] array to be converted to DoubleDouble[].
     @return A DoubleDouble[] array with values of the input array.
     * This can be the supplied input array or a newly allocated one.
     */
    public static DoubleDouble[] toDoubleDouble(DoubleDouble[] a, double[] arr) {
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (a == null) a = new DoubleDouble[arr.length];</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">        for (int i=0; i&lt;a.length &amp;&amp; i&lt;arr.length; i++) {</span>
<span class="nc" id="L434">            a[i] = new DoubleDouble(arr[i]);</span>
        }
<span class="nc" id="L436">        return a;</span>
    }
     
     
     
     
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y)&lt;/tt&gt;.
     *
     @param y the addend
     @return &lt;tt&gt;(this + y)&lt;/tt&gt;
     */
    public DoubleDouble add(DoubleDouble y) {
<span class="pc bpc" id="L449" title="2 of 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L450">            return NaN;</span>
        }
        double a, b, c;
<span class="fc" id="L453">        b = hi + y.hi;</span>
<span class="fc" id="L454">        a = hi - b;</span>
<span class="fc" id="L455">        c = ((hi - (a + b)) + (a + y.hi)) + (lo + y.lo);</span>
<span class="fc" id="L456">        a = b + c;</span>
<span class="fc" id="L457">        return new DoubleDouble(a, c + (b - a));</span>
    }
     
     
     
     
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y)&lt;/tt&gt;.
     *
     @param y the addend
     @return &lt;tt&gt;(this + y)&lt;/tt&gt;
     */
    public DoubleDouble add(long y) {
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L471">            return NaN;</span>
        }
<span class="nc" id="L473">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L474">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L475">        double s = yhi + ylo;</span>
<span class="nc" id="L476">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L477">        yhi = s;</span>
<span class="nc" id="L478">        ylo = err;</span>
        
        double a, b, c;
<span class="nc" id="L481">        b = hi + yhi;</span>
<span class="nc" id="L482">        a = hi - b;</span>
<span class="nc" id="L483">        c = ((hi - (a + b)) + (a + yhi)) + (lo + ylo);</span>
<span class="nc" id="L484">        a = b + c;</span>
<span class="nc" id="L485">        return new DoubleDouble(a, c + (b - a));</span>
    }
    
    

    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y)&lt;/tt&gt;. This
     * method is slightly more accurate than the standard add() method,
     * but it also is slower. This method assures accuracy within one
     * ulp(), while the standard add() method can have an error of two
     * ulp().
     *
     @param y the addend
     @return &lt;tt&gt;(this + y)&lt;/tt&gt;
     */
    public DoubleDouble addStrict(DoubleDouble y) {
<span class="nc bnc" id="L502" title="All 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L503">            return NaN;</span>
        }
        double H, h, T, t, S, s, e, f;
<span class="nc" id="L506">        S = hi + y.hi;</span>
<span class="nc" id="L507">        T = lo + y.lo;</span>
<span class="nc" id="L508">        e = S - hi;</span>
<span class="nc" id="L509">        f = T - lo;</span>
<span class="nc" id="L510">        s = S - e;</span>
<span class="nc" id="L511">        t = T - f;</span>
<span class="nc" id="L512">        s = (y.hi - e) + (hi - s);</span>
<span class="nc" id="L513">        t = (y.lo - f) + (lo - t);</span>
<span class="nc" id="L514">        e = s + T;</span>
<span class="nc" id="L515">        H = S + e;</span>
<span class="nc" id="L516">        h = e + (S - H);</span>
<span class="nc" id="L517">        e = t + h;</span>

<span class="nc" id="L519">        double zhi = H + e;</span>
<span class="nc" id="L520">        double zlo = e + (H - zhi);</span>
<span class="nc" id="L521">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y)&lt;/tt&gt;.
     *
     @param y the addend
     @return &lt;tt&gt;(this + y)&lt;/tt&gt;
     */
    public DoubleDouble add(double y) {
<span class="nc bnc" id="L534" title="All 4 branches missed.">        if (hi!=hi || y!=y) {</span>
<span class="nc" id="L535">            return NaN;</span>
        }

        double a, b, c;
<span class="nc" id="L539">        b = hi + y;</span>
<span class="nc" id="L540">        a = hi - b;</span>
<span class="nc" id="L541">        c = ((hi - (b + a)) + (y + a)) + lo;</span>
<span class="nc" id="L542">        a = b + c;</span>
<span class="nc" id="L543">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y)&lt;/tt&gt;.
     *
     @param y the addend
     @return &lt;tt&gt;(this + y)&lt;/tt&gt;
     */
    public DoubleDouble add(int y) {
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L557">            return NaN;</span>
        }

        double a, b, c;
<span class="fc" id="L561">        b = hi + y;</span>
<span class="fc" id="L562">        a = hi - b;</span>
<span class="fc" id="L563">        c = ((hi - (b + a)) + (y + a)) + lo;</span>
<span class="fc" id="L564">        a = b + c;</span>
<span class="fc" id="L565">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + 1)&lt;/tt&gt;.
     *
     @return &lt;tt&gt;(this + 1)&lt;/tt&gt;
     */
    public DoubleDouble add1() {
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L578">            return NaN;</span>
        }

        double a, b, c;
<span class="fc" id="L582">        b = hi + 1.0;</span>
<span class="fc" id="L583">        a = hi - b;</span>
<span class="fc" id="L584">        c = ((hi - (b + a)) + (1.0 + a)) + lo;</span>
<span class="fc" id="L585">        a = b + c;</span>
<span class="fc" id="L586">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y)&lt;/tt&gt;.
     *
     @param y the subtrahend
     @return &lt;tt&gt;(this - y)&lt;/tt&gt;
     */
    public DoubleDouble sub(DoubleDouble y) {
<span class="pc bpc" id="L599" title="2 of 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L600">            return NaN;</span>
        }
        double a, b, c;
<span class="fc" id="L603">        b = hi - y.hi;</span>
<span class="fc" id="L604">        a = hi - b;</span>
<span class="fc" id="L605">        c = ((hi - (a + b)) + (a - y.hi)) + (lo - y.lo);</span>
<span class="fc" id="L606">        a = b + c;</span>
<span class="fc" id="L607">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y)&lt;/tt&gt;.
     *
     @param y the subtrahend
     @return &lt;tt&gt;(this - y)&lt;/tt&gt;
     */
    public DoubleDouble sub(long y) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L621">            return NaN;</span>
        }
    
<span class="nc" id="L624">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L625">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L626">        double s = yhi + ylo;</span>
<span class="nc" id="L627">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L628">        yhi = s;</span>
<span class="nc" id="L629">        ylo = err;</span>
        
        double a, b, c;
<span class="nc" id="L632">        b = hi - yhi;</span>
<span class="nc" id="L633">        a = hi - b;</span>
<span class="nc" id="L634">        c = ((hi - (a + b)) + (a - yhi)) + (lo - ylo);</span>
<span class="nc" id="L635">        a = b + c;</span>
<span class="nc" id="L636">        return new DoubleDouble(a, c + (b - a));</span>
    }
    

    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y)&lt;/tt&gt;. This
     * method is slightly more accurate than the standard sub() method,
     * but it also is slower. This method assures accuracy within one
     * ulp(), while the standard sub() method can have an error of two
     * ulp().
     *
     @param y the addend
     @return &lt;tt&gt;(this - y)&lt;/tt&gt;
     */
    public DoubleDouble subStrict(DoubleDouble y) {
<span class="nc bnc" id="L652" title="All 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L653">            return NaN;</span>
        }
        
        double H, h, T, t, S, s, e, f;
<span class="nc" id="L657">        S = hi - y.hi;</span>
<span class="nc" id="L658">        T = lo - y.lo;</span>
<span class="nc" id="L659">        e = S - hi;</span>
<span class="nc" id="L660">        f = T - lo;</span>
<span class="nc" id="L661">        s = S - e;</span>
<span class="nc" id="L662">        t = T - f;</span>
<span class="nc" id="L663">        s = (-y.hi - e) + (hi - s);</span>
<span class="nc" id="L664">        t = (-y.lo - f) + (lo - t);</span>
<span class="nc" id="L665">        e = s + T;</span>
<span class="nc" id="L666">        H = S + e;</span>
<span class="nc" id="L667">        h = e + (S - H);</span>
<span class="nc" id="L668">        e = t + h;</span>

<span class="nc" id="L670">        double zhi = H + e;</span>
<span class="nc" id="L671">        double zlo = e + (H - zhi);</span>
<span class="nc" id="L672">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y)&lt;/tt&gt;.
     *
     @param y the subtrahend
     @return &lt;tt&gt;(this - y)&lt;/tt&gt;
     */
    public DoubleDouble sub(double y) {
<span class="nc bnc" id="L685" title="All 4 branches missed.">        if (hi!=hi || y!=y) {</span>
<span class="nc" id="L686">            return NaN;</span>
        }

        double a, b, c;
<span class="nc" id="L690">        b = hi - y;</span>
<span class="nc" id="L691">        a = hi - b;</span>
<span class="nc" id="L692">        c = ((hi - (b + a)) + (a - y)) + lo;</span>
<span class="nc" id="L693">        a = b + c;</span>
<span class="nc" id="L694">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y)&lt;/tt&gt;.
     *
     @param y the subtrahend
     @return &lt;tt&gt;(this - y)&lt;/tt&gt;
     */
    public DoubleDouble sub(int y) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L708">            return NaN;</span>
        }

        double a, b, c;
<span class="fc" id="L712">        b = hi - y;</span>
<span class="fc" id="L713">        a = hi - b;</span>
<span class="fc" id="L714">        c = ((hi - (b + a)) + (a - y)) + lo;</span>
<span class="fc" id="L715">        a = b + c;</span>
<span class="fc" id="L716">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - 1)&lt;/tt&gt;.
     *
     @return &lt;tt&gt;(this - 1)&lt;/tt&gt;
     */
    public DoubleDouble sub1() {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L729">            return NaN;</span>
        }

        double a, b, c;
<span class="fc" id="L733">        b = hi - 1.0;</span>
<span class="fc" id="L734">        a = hi - b;</span>
<span class="fc" id="L735">        c = ((hi - (b + a)) + (a - 1.0)) + lo;</span>
<span class="fc" id="L736">        a = b + c;</span>
<span class="fc" id="L737">        return new DoubleDouble(a, c + (b - a));</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;-this&lt;/tt&gt;.
     *
     @return &lt;tt&gt;-this&lt;/tt&gt;
     */
    public DoubleDouble neg() {
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L750">            return NaN;</span>
        }
<span class="fc" id="L752">        return new DoubleDouble(-hi, -lo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble mul(DoubleDouble y) {
<span class="pc bpc" id="L765" title="2 of 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L766">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, c;
<span class="fc" id="L770">        C = SPLIT * hi;</span>
<span class="fc" id="L771">        hx = C - hi;</span>
<span class="fc" id="L772">        c = SPLIT * y.hi;</span>
<span class="fc" id="L773">        hx = C - hx;</span>
<span class="fc" id="L774">        tx = hi - hx;</span>
<span class="fc" id="L775">        hy = c - y.hi;</span>
<span class="fc" id="L776">        C = hi * y.hi;</span>
<span class="fc" id="L777">        hy = c - hy;</span>
<span class="fc" id="L778">        ty = y.hi - hy;</span>
<span class="fc" id="L779">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * y.lo + lo * y.hi);</span>
<span class="fc" id="L780">        double zhi = C + c;</span>
<span class="fc" id="L781">        hx = C - zhi;</span>
<span class="fc" id="L782">        double zlo = c + hx;</span>
<span class="fc" id="L783">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble mul(long y) {
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L797">            return NaN;</span>
        }
    
<span class="nc" id="L800">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L801">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L802">        double s = yhi + ylo;</span>
<span class="nc" id="L803">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L804">        yhi = s;</span>
<span class="nc" id="L805">        ylo = err;</span>
        
        double hx, tx, hy, ty, C, c;
<span class="nc" id="L808">        C = SPLIT * hi;</span>
<span class="nc" id="L809">        hx = C - hi;</span>
<span class="nc" id="L810">        c = SPLIT * yhi;</span>
<span class="nc" id="L811">        hx = C - hx;</span>
<span class="nc" id="L812">        tx = hi - hx;</span>
<span class="nc" id="L813">        hy = c - yhi;</span>
<span class="nc" id="L814">        C = hi * yhi;</span>
<span class="nc" id="L815">        hy = c - hy;</span>
<span class="nc" id="L816">        ty = yhi - hy;</span>
<span class="nc" id="L817">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * ylo + lo * yhi);</span>
<span class="nc" id="L818">        double zhi = C + c;</span>
<span class="nc" id="L819">        hx = C - zhi;</span>
<span class="nc" id="L820">        double zlo = c + hx;</span>
<span class="nc" id="L821">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble mul(double y) {
<span class="pc bpc" id="L834" title="2 of 4 branches missed.">        if (hi!=hi || y!=y) {</span>
<span class="nc" id="L835">            return NaN;</span>
        }
        double hx, tx, hy, ty, C, c;
<span class="fc" id="L838">        C = SPLIT * hi;</span>
<span class="fc" id="L839">        hx = C - hi;</span>
<span class="fc" id="L840">        c = SPLIT * y;</span>
<span class="fc" id="L841">        hx = C - hx;</span>
<span class="fc" id="L842">        tx = hi - hx;</span>
<span class="fc" id="L843">        hy = c - y;</span>
<span class="fc" id="L844">        C = hi * y;</span>
<span class="fc" id="L845">        hy = c - hy;</span>
<span class="fc" id="L846">        ty = y - hy;</span>
<span class="fc" id="L847">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (lo * y);</span>
<span class="fc" id="L848">        double zhi = C + c;</span>
<span class="fc" id="L849">        hx = C - zhi;</span>
<span class="fc" id="L850">        double zlo = c + hx;</span>
<span class="fc" id="L851">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble mul(int y) {
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L865">            return NaN;</span>
        }
        double hx, tx, hy, ty, C, c;
<span class="fc" id="L868">        C = SPLIT * hi;</span>
<span class="fc" id="L869">        hx = C - hi;</span>
<span class="fc" id="L870">        c = SPLIT * y;</span>
<span class="fc" id="L871">        hx = C - hx;</span>
<span class="fc" id="L872">        tx = hi - hx;</span>
<span class="fc" id="L873">        hy = c - y;</span>
<span class="fc" id="L874">        C = hi * y;</span>
<span class="fc" id="L875">        hy = c - hy;</span>
<span class="fc" id="L876">        ty = y - hy;</span>
<span class="fc" id="L877">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (lo * y);</span>
<span class="fc" id="L878">        double zhi = C + c;</span>
<span class="fc" id="L879">        hx = C - zhi;</span>
<span class="fc" id="L880">        double zlo = c + hx;</span>
<span class="fc" id="L881">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y)&lt;/tt&gt;. This method
     * may ONLY be used when y is an exact power of two, e.g. 0.125, 0.25, 0.5,
     * 1, 2, 4, 8, and so on. A special much more efficient method for
     * multiplication is used in these cases.
     *
     @param y the multiplicand
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble mulPowerOf2(double y) {
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L898">            return NaN;</span>
        }
<span class="fc" id="L900">        return new DoubleDouble(hi * y, lo * y);</span>
    }
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;.
     *
     @param y the divisor
     @return &lt;tt&gt;(this / y)&lt;/tt&gt;
     */
    public DoubleDouble div(DoubleDouble y) {
<span class="pc bpc" id="L913" title="2 of 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L914">            return NaN;</span>
        }
        double hc, tc, hy, ty, C, c, U, u;
<span class="fc" id="L917">        C = hi / y.hi;</span>
<span class="fc" id="L918">        c = SPLIT * C;</span>
<span class="fc" id="L919">        hc = c - C;</span>
<span class="fc" id="L920">        u = SPLIT * y.hi;</span>
<span class="fc" id="L921">        hc = c - hc;</span>
<span class="fc" id="L922">        tc = C - hc;</span>
<span class="fc" id="L923">        hy = u - y.hi;</span>
<span class="fc" id="L924">        U = C * y.hi;</span>
<span class="fc" id="L925">        hy = u - hy;</span>
<span class="fc" id="L926">        ty = y.hi - hy;</span>
<span class="fc" id="L927">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="fc" id="L928">        c = ((((hi - U) - u) + lo) - C * y.lo) / y.hi;</span>
<span class="fc" id="L929">        u = C + c;</span>

<span class="fc" id="L931">        double zhi = u;</span>
<span class="fc" id="L932">        double zlo = (C - u) + c;</span>
<span class="fc" id="L933">        return new DoubleDouble(zhi, zlo);</span>
    }
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;.
     *
     @param y the divisor
     @return &lt;tt&gt;(this / y)&lt;/tt&gt;
     */
    public DoubleDouble div(long y) {
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L947">            return NaN;</span>
        }
    
<span class="nc" id="L950">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L951">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L952">        double s = yhi + ylo;</span>
<span class="nc" id="L953">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L954">        yhi = s;</span>
<span class="nc" id="L955">        ylo = err;</span>
        
        double hc, tc, hy, ty, C, c, U, u;
<span class="nc" id="L958">        C = hi / yhi;</span>
<span class="nc" id="L959">        c = SPLIT * C;</span>
<span class="nc" id="L960">        hc = c - C;</span>
<span class="nc" id="L961">        u = SPLIT * yhi;</span>
<span class="nc" id="L962">        hc = c - hc;</span>
<span class="nc" id="L963">        tc = C - hc;</span>
<span class="nc" id="L964">        hy = u - yhi;</span>
<span class="nc" id="L965">        U = C * yhi;</span>
<span class="nc" id="L966">        hy = u - hy;</span>
<span class="nc" id="L967">        ty = yhi - hy;</span>
<span class="nc" id="L968">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="nc" id="L969">        c = ((((hi - U) - u) + lo) - C * ylo) / yhi;</span>
<span class="nc" id="L970">        u = C + c;</span>

<span class="nc" id="L972">        double zhi = u;</span>
<span class="nc" id="L973">        double zlo = (C - u) + c;</span>
<span class="nc" id="L974">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;.
     * This strict method is more precise than the normally used div()
     * method, but it also is slower. This strict method assures accuracy
     * within one ulp, the div() method sometimes may have one bit less
     * of accuracy, but in normal situations it works well.
     *
     @param y the divisor
     @return &lt;tt&gt;(this / y)&lt;/tt&gt;
     */
    public DoubleDouble divStrict(DoubleDouble y) {
<span class="nc bnc" id="L991" title="All 4 branches missed.">        if (hi!=hi || y.hi!=y.hi) {</span>
<span class="nc" id="L992">            return NaN;</span>
        }
        double a, b, c, d, e, f, g;
<span class="nc" id="L995">        f = hi / y.hi;</span>
<span class="nc" id="L996">        a = 0x08000001 * y.hi;</span>
<span class="nc" id="L997">        a += y.hi - a;</span>
<span class="nc" id="L998">        b = y.hi - a;</span>
<span class="nc" id="L999">        c = 0x08000001 * f;</span>
<span class="nc" id="L1000">        c += f - c;</span>
<span class="nc" id="L1001">        d = f - c;</span>
<span class="nc" id="L1002">        e = y.hi * f;</span>
<span class="nc" id="L1003">        c = (((a * c - e) + (a * d + b * c)) + b * d) + y.lo * f;</span>
<span class="nc" id="L1004">        b = lo - c;</span>
<span class="nc" id="L1005">        d = lo - b;</span>
<span class="nc" id="L1006">        a = hi - e;</span>
<span class="nc" id="L1007">        e = (hi - ((hi - a) + a)) + b;</span>
<span class="nc" id="L1008">        g = a + e;</span>
<span class="nc" id="L1009">        e += (a - g) + ((lo - (d + b)) + (d - c));</span>
<span class="nc" id="L1010">        a = g + e;</span>
<span class="nc" id="L1011">        b = a / y.hi;</span>
<span class="nc" id="L1012">        f += (e + (g - a)) / y.hi;</span>
<span class="nc" id="L1013">        a = f + b;</span>
<span class="nc" id="L1014">        return new DoubleDouble(a, b + (f - a));</span>
    }

    
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;.
     *
     @param y the divisor
     @return &lt;tt&gt;(this / y)&lt;/tt&gt;
     */
    public DoubleDouble div(double y) {
<span class="nc bnc" id="L1029" title="All 4 branches missed.">        if (hi!=hi || y!=y) {</span>
<span class="nc" id="L1030">            return NaN;</span>
        }
        double hc, tc, hy, ty, C, c, U, u;
<span class="nc" id="L1033">        C = hi / y;</span>
<span class="nc" id="L1034">        c = SPLIT * C;</span>
<span class="nc" id="L1035">        hc = c - C;</span>
<span class="nc" id="L1036">        u = SPLIT * y;</span>
<span class="nc" id="L1037">        hc = c - hc;</span>
<span class="nc" id="L1038">        tc = C - hc;</span>
<span class="nc" id="L1039">        hy = u - y;</span>
<span class="nc" id="L1040">        U = C * y;</span>
<span class="nc" id="L1041">        hy = u - hy;</span>
<span class="nc" id="L1042">        ty = y - hy;</span>
<span class="nc" id="L1043">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="nc" id="L1044">        c = (((hi - U) - u) + lo) / y;</span>
<span class="nc" id="L1045">        u = C + c;</span>

<span class="nc" id="L1047">        double zhi = u;</span>
<span class="nc" id="L1048">        double zlo = (C - u) + c;</span>
<span class="nc" id="L1049">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;.
     *
     @param y the divisor
     @return &lt;tt&gt;(this / y)&lt;/tt&gt;
     */
    public DoubleDouble div(int y) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1065">            return NaN;</span>
        }
        double hc, tc, hy, ty, C, c, U, u;
<span class="nc" id="L1068">        C = hi / y;</span>
<span class="nc" id="L1069">        c = SPLIT * C;</span>
<span class="nc" id="L1070">        hc = c - C;</span>
<span class="nc" id="L1071">        u = SPLIT * y;</span>
<span class="nc" id="L1072">        hc = c - hc;</span>
<span class="nc" id="L1073">        tc = C - hc;</span>
<span class="nc" id="L1074">        hy = u - y;</span>
<span class="nc" id="L1075">        U = C * y;</span>
<span class="nc" id="L1076">        hy = u - hy;</span>
<span class="nc" id="L1077">        ty = y - hy;</span>
<span class="nc" id="L1078">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="nc" id="L1079">        c = (((hi - U) - u) + lo) / y;</span>
<span class="nc" id="L1080">        u = C + c;</span>

<span class="nc" id="L1082">        double zhi = u;</span>
<span class="nc" id="L1083">        double zlo = (C - u) + c;</span>
<span class="nc" id="L1084">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this / y)&lt;/tt&gt;. This method
     * may ONLY be used when y is an exact power of two, e.g. 0.125, 0.25, 0.5,
     * 1, 2, 4, 8, and so on. A special much more efficient method for
     * multiplication is used in these cases.
     *
     @param y the divisor
     @return &lt;tt&gt;(this * y)&lt;/tt&gt;
     */
    public DoubleDouble divPowerOf2(double y) {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1101">            return NaN;</span>
        }
<span class="nc" id="L1103">        y = 1.0 / y;</span>
<span class="nc" id="L1104">        return new DoubleDouble(hi * y, lo * y);</span>
    }

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;1 / this&lt;/tt&gt;.
     *
     @return the reciprocal of this value
     */
    public DoubleDouble recip() {
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1117">            return NaN;</span>
        }
        double hc, tc, hy, ty, C, c, U, u;
<span class="fc" id="L1120">        C = 1.0 / hi;</span>
<span class="fc" id="L1121">        c = SPLIT * C;</span>
<span class="fc" id="L1122">        hc = c - C;</span>
<span class="fc" id="L1123">        u = SPLIT * hi;</span>
<span class="fc" id="L1124">        hc = c - hc;</span>
<span class="fc" id="L1125">        tc = C - hc;</span>
<span class="fc" id="L1126">        hy = u - hi;</span>
<span class="fc" id="L1127">        U = C * hi;</span>
<span class="fc" id="L1128">        hy = u - hy;</span>
<span class="fc" id="L1129">        ty = hi - hy;</span>
<span class="fc" id="L1130">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="fc" id="L1131">        c = ((((1.0 - U) - u)) - C * lo) / hi;</span>

<span class="fc" id="L1133">        double zhi = C + c;</span>
<span class="fc" id="L1134">        double zlo = (C - zhi) + c;</span>
<span class="fc" id="L1135">        return new DoubleDouble(zhi, zlo);</span>
    }
    
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(y / this)&lt;/tt&gt;. Using this
     * method is much more efficient than creating a new DoubleDouble(y) and
     * calling div() on that value. This method allows a single double to be
     * divided by a DoubleDouble at DoubleDouble precision.
     *
     @param y the divisor
     @return &lt;tt&gt;(y / this)&lt;/tt&gt;
     */
    public DoubleDouble recip(double y) {
<span class="nc bnc" id="L1152" title="All 4 branches missed.">        if (hi!=hi || y!=y) {</span>
<span class="nc" id="L1153">            return NaN;</span>
        }
        double a, b, c, d, e, f;
<span class="nc" id="L1156">        f = y / hi;</span>
<span class="nc" id="L1157">        a = 0x08000001 * hi;</span>
<span class="nc" id="L1158">        a += hi - a;</span>
<span class="nc" id="L1159">        b = hi - a;</span>
<span class="nc" id="L1160">        c = 0x08000001 * f;</span>
<span class="nc" id="L1161">        c += f - c;</span>
<span class="nc" id="L1162">        d = f - c;</span>
<span class="nc" id="L1163">        e = hi * f;</span>
<span class="nc" id="L1164">        b = ((y - e) - ((((a * c - e) + (a * d + b * c)) + b * d) + lo * f)) / hi;</span>
<span class="nc" id="L1165">        a = f + b;</span>
<span class="nc" id="L1166">        return new DoubleDouble(a, b + (f - a));</span>
    }
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(y / this)&lt;/tt&gt;. Using this
     * method is much more efficient than creating a new DoubleDouble(y) and
     * calling div() on that value. This method allows a single long to be
     * divided by a DoubleDouble at DoubleDouble precision.
     *
     @param y the divisor
     @return &lt;tt&gt;(y / this)&lt;/tt&gt;
     */
    public DoubleDouble recip(long y) {
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1183">            return NaN;</span>
        }
    
<span class="nc" id="L1186">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L1187">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L1188">        double s = yhi + ylo;</span>
<span class="nc" id="L1189">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L1190">        yhi = s;</span>
<span class="nc" id="L1191">        ylo = err;</span>
        
        double hc, tc, hy, ty, C, c, U, u;
<span class="nc" id="L1194">        C = yhi / hi;</span>
<span class="nc" id="L1195">        c = SPLIT * C;</span>
<span class="nc" id="L1196">        hc = c - C;</span>
<span class="nc" id="L1197">        u = SPLIT * hi;</span>
<span class="nc" id="L1198">        hc = c - hc;</span>
<span class="nc" id="L1199">        tc = C - hc;</span>
<span class="nc" id="L1200">        hy = u - hi;</span>
<span class="nc" id="L1201">        U = C * hi;</span>
<span class="nc" id="L1202">        hy = u - hy;</span>
<span class="nc" id="L1203">        ty = hi - hy;</span>
<span class="nc" id="L1204">        u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;</span>
<span class="nc" id="L1205">        c = ((((yhi - U) - u) + ylo) - C * lo) / hi;</span>
<span class="nc" id="L1206">        u = C + c;</span>

<span class="nc" id="L1208">        double zhi = u;</span>
<span class="nc" id="L1209">        double zlo = (C - u) + c;</span>
<span class="nc" id="L1210">        return new DoubleDouble(zhi, zlo);</span>
    }
    
    
    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(y / this)&lt;/tt&gt;. Using this
     * method is much more efficient than creating a new DoubleDouble(y) and
     * calling div() on that value. This method allows a single integer to be
     * divided by a DoubleDouble at DoubleDouble precision.
     *
     @param y the divisor
     @return &lt;tt&gt;(y / this)&lt;/tt&gt;
     */
    public DoubleDouble recip(int y) {
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1228">            return NaN;</span>
        }
        double a, b, c, d, e, f;
<span class="nc" id="L1231">        f = y / hi;</span>
<span class="nc" id="L1232">        a = 0x08000001 * hi;</span>
<span class="nc" id="L1233">        a += hi - a;</span>
<span class="nc" id="L1234">        b = hi - a;</span>
<span class="nc" id="L1235">        c = 0x08000001 * f;</span>
<span class="nc" id="L1236">        c += f - c;</span>
<span class="nc" id="L1237">        d = f - c;</span>
<span class="nc" id="L1238">        e = hi * f;</span>
<span class="nc" id="L1239">        b = ((y - e) - ((((a * c - e) + (a * d + b * c)) + b * d) + lo * f)) / hi;</span>
<span class="nc" id="L1240">        a = f + b;</span>
<span class="nc" id="L1241">        return new DoubleDouble(a, b + (f - a));</span>
    }
    
    


    
    /**
     * Computes the square of this value.
     *
     @return the square of this value.
     */
    public DoubleDouble sqr() {
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1255">            return NaN;</span>
        }
        double a, b, c;
<span class="fc" id="L1258">        a = SPLIT * hi;</span>
<span class="fc" id="L1259">        a += hi - a;</span>
<span class="fc" id="L1260">        b = hi - a;</span>
<span class="fc" id="L1261">        c = hi * hi;</span>
<span class="fc" id="L1262">        b = ((((a * a - c) + a * b * 2) + b * b) + hi * lo * 2) + lo * lo;</span>
<span class="fc" id="L1263">        a = b + c;</span>
<span class="fc" id="L1264">        return new DoubleDouble(a, b + (c - a));</span>
    }
    

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y + yy)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @param yy the addend
     @return &lt;tt&gt;(this * y + yy)&lt;/tt&gt;
     */
    public DoubleDouble muladd(DoubleDouble y, DoubleDouble yy) {
<span class="nc bnc" id="L1279" title="All 6 branches missed.">        if (hi!=hi || y.hi!=y.hi || yy.hi!=yy.hi) {</span>
<span class="nc" id="L1280">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, a, b, c;
        
        // Perform the multiplication.
<span class="nc" id="L1286">        C = SPLIT * hi;</span>
<span class="nc" id="L1287">        hx = C - hi;</span>
<span class="nc" id="L1288">        c = SPLIT * y.hi;</span>
<span class="nc" id="L1289">        hx = C - hx;</span>
<span class="nc" id="L1290">        tx = hi - hx;</span>
<span class="nc" id="L1291">        hy = c - y.hi;</span>
<span class="nc" id="L1292">        C = hi * y.hi;</span>
<span class="nc" id="L1293">        hy = c - hy;</span>
<span class="nc" id="L1294">        ty = y.hi - hy;</span>
<span class="nc" id="L1295">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * y.lo + lo * y.hi);</span>
<span class="nc" id="L1296">        double zhi = C + c;</span>
<span class="nc" id="L1297">        hx = C - zhi;</span>
<span class="nc" id="L1298">        double zlo = c + hx;</span>
        
        // Perform the addition.
<span class="nc" id="L1301">        b = zhi + yy.hi;</span>
<span class="nc" id="L1302">        a = zhi - b;</span>
<span class="nc" id="L1303">        c = ((zhi - (a + b)) + (a + yy.hi)) + (zlo + yy.lo);</span>
<span class="nc" id="L1304">        a = b + c;</span>
<span class="nc" id="L1305">        return new DoubleDouble(a, c + (b - a));</span>
    }
    

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y - yy)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @param yy the addend
     @return &lt;tt&gt;(this * y - yy)&lt;/tt&gt;
     */
    public DoubleDouble mulsub(DoubleDouble y, DoubleDouble yy) {
<span class="nc bnc" id="L1320" title="All 6 branches missed.">        if (hi!=hi || y.hi!=y.hi || yy.hi!=yy.hi) {</span>
<span class="nc" id="L1321">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, a, b, c;
        
        // Perform the multiplication.
<span class="nc" id="L1327">        C = SPLIT * hi;</span>
<span class="nc" id="L1328">        hx = C - hi;</span>
<span class="nc" id="L1329">        c = SPLIT * y.hi;</span>
<span class="nc" id="L1330">        hx = C - hx;</span>
<span class="nc" id="L1331">        tx = hi - hx;</span>
<span class="nc" id="L1332">        hy = c - y.hi;</span>
<span class="nc" id="L1333">        C = hi * y.hi;</span>
<span class="nc" id="L1334">        hy = c - hy;</span>
<span class="nc" id="L1335">        ty = y.hi - hy;</span>
<span class="nc" id="L1336">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * y.lo + lo * y.hi);</span>
<span class="nc" id="L1337">        double zhi = C + c;</span>
<span class="nc" id="L1338">        hx = C - zhi;</span>
<span class="nc" id="L1339">        double zlo = c + hx;</span>
        
        // Perform the subtraction.
<span class="nc" id="L1342">        b = zhi - yy.hi;</span>
<span class="nc" id="L1343">        a = zhi - b;</span>
<span class="nc" id="L1344">        c = ((zhi - (a + b)) + (a - yy.hi)) + (zlo - yy.lo);</span>
<span class="nc" id="L1345">        a = b + c;</span>
<span class="nc" id="L1346">        return new DoubleDouble(a, c + (b - a));</span>
    }
    

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this + y * yy)&lt;/tt&gt;.
     *
     @param y the first factor of the product
     @param yy the second facvtor of the product
     @return &lt;tt&gt;(this + y*yy)&lt;/tt&gt;
     */
    public DoubleDouble addmul(DoubleDouble y, DoubleDouble yy) {
<span class="nc bnc" id="L1361" title="All 6 branches missed.">        if (hi!=hi || y.hi!=y.hi || yy.hi!=yy.hi) {</span>
<span class="nc" id="L1362">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, a, b, c;
        
        // Perform the multiplication and the negation.
<span class="nc" id="L1368">        C = SPLIT * yy.hi;</span>
<span class="nc" id="L1369">        hx = C - yy.hi;</span>
<span class="nc" id="L1370">        c = SPLIT * y.hi;</span>
<span class="nc" id="L1371">        hx = C - hx;</span>
<span class="nc" id="L1372">        tx = yy.hi - hx;</span>
<span class="nc" id="L1373">        hy = c - y.hi;</span>
<span class="nc" id="L1374">        C = yy.hi * y.hi;</span>
<span class="nc" id="L1375">        hy = c - hy;</span>
<span class="nc" id="L1376">        ty = y.hi - hy;</span>
<span class="nc" id="L1377">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (yy.hi * y.lo + yy.lo * y.hi);</span>
<span class="nc" id="L1378">        double zhi = C + c;</span>
<span class="nc" id="L1379">        hx = C - zhi;</span>
<span class="nc" id="L1380">        double zlo = c + hx;</span>
        
        // Perform the addition of this.
<span class="nc" id="L1383">        b = zhi + hi;</span>
<span class="nc" id="L1384">        a = zhi - b;</span>
<span class="nc" id="L1385">        c = ((zhi - (a + b)) + (a + hi)) + (zlo + lo);</span>
<span class="nc" id="L1386">        a = b + c;</span>
<span class="nc" id="L1387">        return new DoubleDouble(a, c + (b - a));</span>
    }
    

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this - y * yy)&lt;/tt&gt;.
     *
     @param y the first factor of the product
     @param yy the second facvtor of the product
     @return &lt;tt&gt;(this - y*yy)&lt;/tt&gt;
     */
    public DoubleDouble submul(DoubleDouble y, DoubleDouble yy) {
<span class="nc bnc" id="L1402" title="All 6 branches missed.">        if (hi!=hi || y.hi!=y.hi || yy.hi!=yy.hi) {</span>
<span class="nc" id="L1403">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, a, b, c;
        
        // Perform the multiplication and the negation.
<span class="nc" id="L1409">        C = -SPLIT * yy.hi;</span>
<span class="nc" id="L1410">        hx = C + yy.hi;</span>
<span class="nc" id="L1411">        c = SPLIT * y.hi;</span>
<span class="nc" id="L1412">        hx = C - hx;</span>
<span class="nc" id="L1413">        tx = -yy.hi - hx;</span>
<span class="nc" id="L1414">        hy = c - y.hi;</span>
<span class="nc" id="L1415">        C = -yy.hi * y.hi;</span>
<span class="nc" id="L1416">        hy = c - hy;</span>
<span class="nc" id="L1417">        ty = y.hi - hy;</span>
<span class="nc" id="L1418">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) - (yy.hi * y.lo + yy.lo * y.hi);</span>
<span class="nc" id="L1419">        double zhi = C + c;</span>
<span class="nc" id="L1420">        hx = C - zhi;</span>
<span class="nc" id="L1421">        double zlo = c + hx;</span>
        
        // Perform the addition of this.
<span class="nc" id="L1424">        b = zhi + hi;</span>
<span class="nc" id="L1425">        a = zhi - b;</span>
<span class="nc" id="L1426">        c = ((zhi - (a + b)) + (a + hi)) + (zlo + lo);</span>
<span class="nc" id="L1427">        a = b + c;</span>
<span class="nc" id="L1428">        return new DoubleDouble(a, c + (b - a));</span>
    }
    

    
    
    
    /**
     * Returns a DoubleDouble whose value is &lt;tt&gt;(this * y * yy)&lt;/tt&gt;.
     *
     @param y the multiplicand
     @param yy the addend
     @return &lt;tt&gt;(this * y * yy)&lt;/tt&gt;
     */
    public DoubleDouble mulmul(DoubleDouble y, DoubleDouble yy) {
<span class="nc bnc" id="L1443" title="All 6 branches missed.">        if (hi!=hi || y.hi!=y.hi || yy.hi!=yy.hi) {</span>
<span class="nc" id="L1444">            return NaN;</span>
        }
        
        double hx, tx, hy, ty, C, a, b, c;
        
        // Perform the first multiplication.
<span class="nc" id="L1450">        C = SPLIT * hi;</span>
<span class="nc" id="L1451">        hx = C - hi;</span>
<span class="nc" id="L1452">        c = SPLIT * y.hi;</span>
<span class="nc" id="L1453">        hx = C - hx;</span>
<span class="nc" id="L1454">        tx = hi - hx;</span>
<span class="nc" id="L1455">        hy = c - y.hi;</span>
<span class="nc" id="L1456">        C = hi * y.hi;</span>
<span class="nc" id="L1457">        hy = c - hy;</span>
<span class="nc" id="L1458">        ty = y.hi - hy;</span>
<span class="nc" id="L1459">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * y.lo + lo * y.hi);</span>
<span class="nc" id="L1460">        double zhi = C + c;</span>
<span class="nc" id="L1461">        hx = C - zhi;</span>
<span class="nc" id="L1462">        double zlo = c + hx;</span>
        
        // Perform the second multiplication.
<span class="nc" id="L1465">        C = SPLIT * zhi;</span>
<span class="nc" id="L1466">        hx = C - zhi;</span>
<span class="nc" id="L1467">        c = SPLIT * yy.hi;</span>
<span class="nc" id="L1468">        hx = C - hx;</span>
<span class="nc" id="L1469">        tx = zhi - hx;</span>
<span class="nc" id="L1470">        hy = c - yy.hi;</span>
<span class="nc" id="L1471">        C = zhi * yy.hi;</span>
<span class="nc" id="L1472">        hy = c - hy;</span>
<span class="nc" id="L1473">        ty = yy.hi - hy;</span>
<span class="nc" id="L1474">        c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (zhi * yy.lo + zlo * yy.hi);</span>
<span class="nc" id="L1475">        zhi = C + c;</span>
<span class="nc" id="L1476">        hx = C - zhi;</span>
<span class="nc" id="L1477">        zlo = c + hx;</span>
        
<span class="nc" id="L1479">        return new DoubleDouble(zhi, zlo);</span>
    }

    
    
    
    /**
     * Returns the largest (closest to positive infinity) value that is not
     * greater than the argument and is equal to a mathematical integer. Special
     * cases:
     * &lt;ul&gt;
     * &lt;li&gt;If this value is NaN, returns NaN.
     * &lt;/ul&gt;
     *
     @return the largest (closest to positive infinity) value that is not
     * greater than the argument and is equal to a mathematical integer.
     */
    public DoubleDouble floor() {
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1498">            return NaN;</span>
        }
<span class="nc" id="L1500">        double fhi = StrictMath.floor(hi);</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if (fhi == hi) {</span>
            // hi is already integral, floor the low word.
<span class="nc" id="L1503">            double flo = StrictMath.floor(lo);</span>
<span class="nc" id="L1504">            double st = fhi + flo; flo = flo + (fhi - st); fhi = st;  </span>
<span class="nc" id="L1505">            return new DoubleDouble(fhi, flo);</span>
        }
        
<span class="nc" id="L1508">        return new DoubleDouble(fhi);</span>
    }

    
    
    /**
     * Returns the smallest (closest to negative infinity) value that is not
     * less than the argument and is equal to a mathematical integer. Special
     * cases:
     * &lt;ul&gt;
     * &lt;li&gt;If this value is NaN, returns NaN.
     * &lt;/ul&gt;
     *
     @return the smallest (closest to negative infinity) value that is not
     * less than the argument and is equal to a mathematical integer.
     */
    public DoubleDouble ceil() {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1526">            return NaN;</span>
        }
<span class="nc" id="L1528">        double fhi = StrictMath.ceil(hi);</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">        if (fhi == hi) {</span>
            // hi is already integral, ceil the low word
<span class="nc" id="L1531">            double flo = StrictMath.ceil(lo);</span>
<span class="nc" id="L1532">            double st = fhi + flo; flo = flo + (fhi - st); fhi = st;  </span>
<span class="nc" id="L1533">            return new DoubleDouble(fhi, flo);</span>
        }
<span class="nc" id="L1535">        return new DoubleDouble(fhi);</span>
    }

    
    

    /**
     * Returns the integer which is largest in absolute value and not further
     * from zero than this value. Special cases:
     * &lt;ul&gt;
     * &lt;li&gt;If this value is NaN, returns NaN.
     * &lt;/ul&gt;
     *
     @return the integer which is largest in absolute value and not further
     * from zero than this value
     */
    public DoubleDouble trunc() {
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1553">            return NaN;</span>
        }
<span class="nc bnc" id="L1555" title="All 6 branches missed.">        return (hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) ? ceil() : floor();</span>
    }

    
    
    
    /**
     * Returns an integer indicating the sign of this value.
     * &lt;ul&gt;
     * &lt;li&gt;if this value is &gt; 0, returns 1
     * &lt;li&gt;if this value is &lt; 0, returns -1 
     * &lt;li&gt;if this value is = 0, returns 0
     * &lt;li&gt;if this value is NaN, returns 0
     * &lt;/ul&gt;
     *
     @return an integer indicating the sign of this value
     */
    public int signum() {
<span class="nc bnc" id="L1573" title="All 6 branches missed.">        if (hi &gt; 0.0 || (hi == 0.0 &amp;&amp; lo &gt; 0.0)) {</span>
<span class="nc" id="L1574">            return 1;</span>
        }
<span class="nc bnc" id="L1576" title="All 6 branches missed.">        if (hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) {</span>
<span class="nc" id="L1577">            return -1;</span>
        }
<span class="nc" id="L1579">        return 0;</span>
    }

    
    
    
    /**
     * Rounds this value to the nearest integer. For positive integers, 0.5
     * is rounded upwards, e.g. 3.5 is rounded to 4. For negative integers,
     * 0.5 is rounded downwards (towards -infinity), e.g. -3.5 is rounded
     * to -4.
     * Special case:
     * &lt;ul&gt;
     * &lt;li&gt;If this value is NaN, returns NaN.
     * &lt;/ul&gt;
     *
     @return this value rounded to the nearest integer.
     */
    public DoubleDouble round() {
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1599">            return NaN;</span>
        }
        
<span class="nc bnc" id="L1602" title="All 6 branches missed.">        return (hi &gt; 0.0 || (hi == 0.0 &amp;&amp; lo &gt; 0.0)) ? add(0.5).floor() : sub(0.5).ceil();</span>
    }

    
    
    
    
    /**
     * Returns the absolute value of this value. Special cases:
     * &lt;ul&gt;
     * &lt;li&gt;If this value is NaN, it is returned.
     * &lt;/ul&gt;
     *
     @return the absolute value of this value
     */
    public DoubleDouble abs() {
<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1619">            return NaN;</span>
        }
<span class="pc bpc" id="L1621" title="1 of 6 branches missed.">        if (hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) {</span>
<span class="fc" id="L1622">            return new DoubleDouble(-hi, -lo);</span>
        }
<span class="fc" id="L1624">        return this;</span>
    }

    
    


    
    /**
     * Computes the positive square root of this value. If the number is NaN or
     * negative, NaN is returned. 
     *
     @return the positive square root of this number. If the argument is NaN
     * or less than zero, the result is NaN.
     */
    public DoubleDouble sqrt() {
<span class="pc bpc" id="L1640" title="3 of 4 branches missed.">        if (hi == 0.0 &amp;&amp; lo == 0.0) {</span>
<span class="nc" id="L1641">            return this;</span>
        }
<span class="pc bpc" id="L1643" title="5 of 8 branches missed.">        if (hi!=hi || hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) {</span>
<span class="nc" id="L1644">            return NaN;</span>
        }

        double a, b, c, d, e;
<span class="fc" id="L1648">        d = 1 / StrictMath.sqrt(hi);</span>
<span class="fc" id="L1649">        e = hi * d;</span>
<span class="fc" id="L1650">        a = 0x08000001 * e;</span>
<span class="fc" id="L1651">        a += e - a;</span>
<span class="fc" id="L1652">        b = e - a;</span>
<span class="fc" id="L1653">        c = e * e;</span>
<span class="fc" id="L1654">        b = ((a * a - c) + a * b * 2) + b * b;</span>
<span class="fc" id="L1655">        a = hi - c;</span>
<span class="fc" id="L1656">        c = hi - a;</span>
        //c = (a + ((((hi - (c + a)) + (c - c)) + lo) - b)) * d * 0.5;
<span class="fc" id="L1658">        c = (a + ((((hi - (c + a))) + lo) - b)) * d * 0.5;</span>
<span class="fc" id="L1659">        a = e + c;</span>
<span class="fc" id="L1660">        b = e - a;</span>
<span class="fc" id="L1661">        return new DoubleDouble(a, (e - (b + a)) + (b + c));</span>
    }
    
    
    
    
    
    /**
     * Computes the positive square root of this value. If the number is NaN or
     * negative, NaN is returned. This strict method is more precise than the
     * sqrt() method, but it also is slower. This strict method assures
     * accuracy within one ulp, the sqrt() method sometimes may have one bit
     * less of accuracy, but in normal situations it works well.
     *
     @return the positive square root of this number. If the argument is NaN
     * or less than zero, the result is NaN.
     */
    
    public DoubleDouble sqrtStrict() {
        // Strategy:  Use Karp's trick:  if x is an approximation
        // to sqrt(a), then
        //
        // sqrt(a) = a*x + [a - (a*x)^2] * x / 2   (approx)
        //
        // The approximation is accurate to twice the accuracy of x.
        // Also, the multiplication (a*x) and [-]*x can be done with
        // only half the precision.
<span class="nc bnc" id="L1688" title="All 4 branches missed.">        if (hi == 0.0 &amp;&amp; lo == 0.0) {</span>
<span class="nc" id="L1689">            return this;</span>
        }
<span class="nc bnc" id="L1691" title="All 8 branches missed.">        if (hi!=hi || hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) {</span>
<span class="nc" id="L1692">            return NaN;</span>
        }

        double a, b, c, d, e, f, g, h;
<span class="nc" id="L1696">        g = 1 / StrictMath.sqrt(hi);</span>
<span class="nc" id="L1697">        h = hi * g;</span>
<span class="nc" id="L1698">        g *= 0.5;</span>
<span class="nc" id="L1699">        a = 0x08000001 * h;</span>
<span class="nc" id="L1700">        a += h - a;</span>
<span class="nc" id="L1701">        b = h - a;</span>
<span class="nc" id="L1702">        c = h * h;</span>
<span class="nc" id="L1703">        b = ((a * a - c) + a * b * 2) + b * b;</span>
<span class="nc" id="L1704">        a = lo - b;</span>
<span class="nc" id="L1705">        f = lo - a;</span>
<span class="nc" id="L1706">        e = hi - c;</span>
<span class="nc" id="L1707">        d = hi - e;</span>
<span class="nc" id="L1708">        d = ((hi - (d + e)) + (d - c)) + a;</span>
<span class="nc" id="L1709">        c = e + d;</span>
<span class="nc" id="L1710">        b = (d + (e - c)) + ((lo - (f + a)) + (f - b));</span>
<span class="nc" id="L1711">        a = c + b;</span>
<span class="nc" id="L1712">        b += (c - a);</span>
<span class="nc" id="L1713">        c = 0x08000001 * a;</span>
<span class="nc" id="L1714">        c += a - c;</span>
<span class="nc" id="L1715">        d = a - c;</span>
<span class="nc" id="L1716">        e = 0x08000001 * g;</span>
<span class="nc" id="L1717">        e += g - e;</span>
<span class="nc" id="L1718">        f = g - e;</span>
<span class="nc" id="L1719">        a = a * g;</span>
<span class="nc" id="L1720">        e = ((c * e - a) + (c * f + d * e)) + d * f;</span>
<span class="nc" id="L1721">        e += b * g;</span>
<span class="nc" id="L1722">        b = a + e;</span>
<span class="nc" id="L1723">        e += a - b;</span>
<span class="nc" id="L1724">        f = b + h;</span>
<span class="nc" id="L1725">        c = b - f;</span>
<span class="nc" id="L1726">        return new DoubleDouble(f, e + ((b - (f + c)) + (h + c)));</span>
    }
    
    // The function below is commented away, but kept here
    // for documenting purposes. This is Karp's trick made
    // explicit in working Java code. The code above is
    // used with everything written out such that no method
    // calls and instantiation overhead occurs.
    // The function below is equally well as the one above.
    /*
    public DoubleDouble sqrt() {

        if (hi == 0.0 &amp;&amp; lo == 0.0) {
            return this;
        }
        if (hi!=hi || hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0)) {
            return NaN;
        }

        double x = 1.0 / StrictMath.sqrt(hi);
        double ax = hi * x;

        DoubleDouble axdd = new DoubleDouble(ax);
        DoubleDouble diffSq = this.sub(axdd.sqr());
        double d2 = diffSq.hi * (x * 0.5);

        return axdd.add(new DoubleDouble(d2));
    }
    */

    
    
    
    /**
     * Computes the value of this number raised to an integral power. Follows
     * semantics of Java Math.pow as closely as possible.
     *
     @param exp the integer exponent
     @return x raised to the integral power exp
     */
    public DoubleDouble pow(int exp) {
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1768">            return NaN;</span>
        }
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        if (exp == 0) {</span>
<span class="fc" id="L1771">            return ONE;</span>
        }

        // Variable r = this;
<span class="fc" id="L1775">        double rhi = hi;</span>
<span class="fc" id="L1776">        double rlo = lo;</span>
        
        // Variable s = 1.0;
<span class="fc" id="L1779">        double shi = 1.0;</span>
<span class="fc" id="L1780">        double slo = 0.0;</span>
        
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        int n = (exp &gt; 0) ? exp : -exp;</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        if (n &gt; 1) {</span>
            /* Use binary exponentiation */
<span class="fc bfc" id="L1785" title="All 2 branches covered.">            while (n &gt; 0) {</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">                if ((n &amp; 1) == 1) {</span>
                    // s = s*r
                    double hx, tx, hy, ty, C, c;
<span class="fc" id="L1789">                    C = SPLIT * shi;</span>
<span class="fc" id="L1790">                    hx = C - shi;</span>
<span class="fc" id="L1791">                    c = SPLIT * rhi;</span>
<span class="fc" id="L1792">                    hx = C - hx;</span>
<span class="fc" id="L1793">                    tx = shi - hx;</span>
<span class="fc" id="L1794">                    hy = c - rhi;</span>
<span class="fc" id="L1795">                    C = shi * rhi;</span>
<span class="fc" id="L1796">                    hy = c - hy;</span>
<span class="fc" id="L1797">                    ty = rhi - hy;</span>
<span class="fc" id="L1798">                    c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (shi * rlo + slo * rhi);</span>
<span class="fc" id="L1799">                    shi = C + c;</span>
<span class="fc" id="L1800">                    hx = C - shi;</span>
<span class="fc" id="L1801">                    slo = c + hx;</span>
                }
<span class="fc" id="L1803">                n &gt;&gt;= 1;</span>
<span class="fc bfc" id="L1804" title="All 2 branches covered.">                if (n &gt; 0) {</span>
                    // r = r^2
                    double a, b, c;
<span class="fc" id="L1807">                    a = SPLIT * rhi;</span>
<span class="fc" id="L1808">                    a += rhi - a;</span>
<span class="fc" id="L1809">                    b = rhi - a;</span>
<span class="fc" id="L1810">                    c = rhi * rhi;</span>
<span class="fc" id="L1811">                    b = ((((a * a - c) + a * b * 2) + b * b) + rhi * rlo * 2) + rlo * rlo;</span>
<span class="fc" id="L1812">                    a = b + c;</span>
<span class="fc" id="L1813">                    rhi = a;</span>
<span class="fc" id="L1814">                    rlo = b + (c - a);</span>
<span class="fc" id="L1815">                }</span>
            }
        } 
        else {
<span class="fc" id="L1819">            shi = rhi;</span>
<span class="fc" id="L1820">            slo = rlo;</span>
        }

        /* Compute the reciprocal if n is negative. */
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        if (exp &lt; 0) {</span>
            // s = 1/s
            double a, b, c, d, e, f;
<span class="fc" id="L1827">            f = 1.0 / shi;</span>
<span class="fc" id="L1828">            a = SPLIT * shi;</span>
<span class="fc" id="L1829">            a += shi - a;</span>
<span class="fc" id="L1830">            b = shi - a;</span>
<span class="fc" id="L1831">            c = SPLIT * f;</span>
<span class="fc" id="L1832">            c += f - c;</span>
<span class="fc" id="L1833">            d = f - c;</span>
<span class="fc" id="L1834">            e = shi * f;</span>
<span class="fc" id="L1835">            b = ((1.0 - e) - ((((a * c - e) + (a * d + b * c)) + b * d) + slo * f)) / shi;</span>
<span class="fc" id="L1836">            a = f + b;</span>
<span class="fc" id="L1837">            shi = a;</span>
<span class="fc" id="L1838">            slo = b + (f - a);</span>
        }
        
<span class="fc" id="L1841">        return new DoubleDouble(shi, slo);</span>
    }
    
    
    
    
    /**
     * Computes y-th root of a DoubleDouble. The number y
     * must be positive.
     *
     @param y the integer telling which root is taken
     @return this, raised to the power 1/y.
     */
    public DoubleDouble root(int y) {
<span class="pc bpc" id="L1855" title="2 of 4 branches missed.">        if (y &lt;=0 || hi != hi) {</span>
<span class="nc" id="L1856">            return NaN;</span>
        }
<span class="pc bpc" id="L1858" title="3 of 6 branches missed.">        boolean isNeg = hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0);</span>

<span class="pc bpc" id="L1860" title="1 of 4 branches missed.">        if (isNeg &amp;&amp; ((y &amp; 1) == 0)) {</span>
<span class="nc" id="L1861">            return NaN;</span>
        }
        
<span class="pc bpc" id="L1864" title="3 of 4 branches missed.">        if (hi == 0 &amp;&amp; lo == 0) {</span>
<span class="nc" id="L1865">            return this;</span>
        }
        
<span class="pc bpc" id="L1868" title="2 of 3 branches missed.">        switch (y) {</span>
            case 1:
<span class="nc" id="L1870">                return this;</span>
            case 2:
<span class="nc" id="L1872">                return sqrt();</span>
            default:
                // fall through.
        }
        
        double a, b, c, d, e, f, g, h, i, j, k, l, m;
        int z;

<span class="fc bfc" id="L1880" title="All 2 branches covered.">        if (isNeg) {</span>
<span class="fc" id="L1881">            b = -hi;</span>
<span class="fc" id="L1882">            c = -lo;</span>
        }
        else {
<span class="fc" id="L1885">            b = hi;</span>
<span class="fc" id="L1886">            c = lo;</span>
        }
        
<span class="fc" id="L1889">        a = StrictMath.exp(StrictMath.log(b) / (-y));</span>
<span class="fc" id="L1890">        z = y;</span>
<span class="fc" id="L1891">        k = a;</span>
<span class="fc" id="L1892">        l = 0;</span>
<span class="fc" id="L1893">        g = 1;</span>
<span class="fc" id="L1894">        h = 0;</span>
<span class="fc bfc" id="L1895" title="All 2 branches covered.">        while (z &gt; 0) {</span>
<span class="fc bfc" id="L1896" title="All 2 branches covered.">            if ((z &amp; 1) &gt; 0) {</span>
<span class="fc" id="L1897">                d = SPLIT * g;</span>
<span class="fc" id="L1898">                d += g - d;</span>
<span class="fc" id="L1899">                e = g - d;</span>
<span class="fc" id="L1900">                f = SPLIT * k;</span>
<span class="fc" id="L1901">                f += k - f;</span>
<span class="fc" id="L1902">                i = k - f;</span>
<span class="fc" id="L1903">                j = g * k;</span>
<span class="fc" id="L1904">                h = (((d * f - j) + (d * i + e * f)) + e * i) + (h * k + g * l);</span>
<span class="fc" id="L1905">                g = j + h;</span>
<span class="fc" id="L1906">                h += j - g;</span>
            }
<span class="fc" id="L1908">            f = SPLIT * k;</span>
<span class="fc" id="L1909">            f = f + (k - f);</span>
<span class="fc" id="L1910">            i = k - f;</span>
<span class="fc" id="L1911">            j = k * k;</span>
<span class="fc" id="L1912">            i = ((f * f - j) + f * i * 2) + i * i;</span>
<span class="fc" id="L1913">            i += k * l * 2;</span>
<span class="fc" id="L1914">            i += l * l;</span>
<span class="fc" id="L1915">            k = i + j;</span>
<span class="fc" id="L1916">            l = i + (j - k);</span>
<span class="fc" id="L1917">            z &gt;&gt;= 1;</span>
        }

<span class="fc" id="L1920">        l = SPLIT * b;</span>
<span class="fc" id="L1921">        l += b - l;</span>
<span class="fc" id="L1922">        m = b - l;</span>
<span class="fc" id="L1923">        d = SPLIT * g;</span>
<span class="fc" id="L1924">        d += g - d;</span>
<span class="fc" id="L1925">        e = g - d;</span>
<span class="fc" id="L1926">        f = b * g;</span>
<span class="fc" id="L1927">        d = (((l * d - f) + (l * e + m * d)) + m * e) + (c * g + b * h);</span>
<span class="fc" id="L1928">        e = 1 - f;</span>
<span class="fc" id="L1929">        l = e - d;</span>
<span class="fc" id="L1930">        m = (e - l) - d;</span>
<span class="fc" id="L1931">        d = SPLIT * l;</span>
<span class="fc" id="L1932">        d += l - d;</span>
<span class="fc" id="L1933">        e = l - d;</span>
<span class="fc" id="L1934">        f = SPLIT * a;</span>
<span class="fc" id="L1935">        f += a - f;</span>
<span class="fc" id="L1936">        g = a - f;</span>
<span class="fc" id="L1937">        l *= a;</span>
<span class="fc" id="L1938">        m *= a;</span>
<span class="fc" id="L1939">        m += (((d * f - l) + (d * g + e * f)) + e * g);</span>
<span class="fc" id="L1940">        d = l / y;</span>
<span class="fc" id="L1941">        e = SPLIT * d;</span>
<span class="fc" id="L1942">        e += d - e;</span>
<span class="fc" id="L1943">        f = d - e;</span>
<span class="fc" id="L1944">        g = SPLIT * y;</span>
<span class="fc" id="L1945">        g += y - g;</span>
<span class="fc" id="L1946">        h = y - g;</span>
<span class="fc" id="L1947">        i = d * y;</span>
<span class="fc" id="L1948">        j = l - i;</span>
<span class="fc" id="L1949">        k = l - j;</span>
<span class="fc" id="L1950">        m = (j + ((((l - (k + j)) + (k - i)) + m) - (((e * g - i) + (e * h + f * g)) + f * h))) / y;</span>
<span class="fc" id="L1951">        e = d + a;</span>
<span class="fc" id="L1952">        l = d - e;</span>
<span class="fc" id="L1953">        m += (d - (e + l)) + (a + l);</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">        if (isNeg) {</span>
<span class="fc" id="L1955">            e = -e;</span>
<span class="fc" id="L1956">            m = -m;</span>
        }
<span class="fc" id="L1958">        i = 1 / e;</span>
<span class="fc" id="L1959">        l = SPLIT * e;</span>
<span class="fc" id="L1960">        l += e - l;</span>
<span class="fc" id="L1961">        d = e - l;</span>
<span class="fc" id="L1962">        f = SPLIT * i;</span>
<span class="fc" id="L1963">        f += i - f;</span>
<span class="fc" id="L1964">        g = i - f;</span>
<span class="fc" id="L1965">        h = e * i;</span>
<span class="fc" id="L1966">        m = ((1 - h) - ((((l * f - h) + (l * g + d * f)) + d * g) + m * i)) / e;</span>
<span class="fc" id="L1967">        l = i + m;</span>
<span class="fc" id="L1968">        return new DoubleDouble(l, m + (i - l));</span>
    }
    
    
    

    
    // Devil's values:
    // 0.693147180559945309417232121458174
    // 1.03972077083991796412584818218727
    // 1.03972077083991796312584818218727

    /**
     *
     @return
     */
    public DoubleDouble exp() {
<span class="pc bpc" id="L1985" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L1986">            return NaN;</span>
        }
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">        if (hi &gt; 691.067739) {</span>
<span class="nc" id="L1989">            return new DoubleDouble(Double.POSITIVE_INFINITY);</span>
        }

<span class="fc" id="L1992">        double a, b, c, d, e, f, g = 0.5, h = 0, i, j, k, l, m, n, o, p, q = 2, r = 1;</span>
        int s;

<span class="fc" id="L1995">        a = SPLIT * hi;</span>
<span class="fc" id="L1996">        a += hi - a;</span>
<span class="fc" id="L1997">        b = a - hi;</span>
<span class="fc" id="L1998">        c = hi * 1.4426950408889634;</span>
<span class="fc" id="L1999">        b = (((a * 1.4426950514316559 - c) - (b * 1.4426950514316559 + a * 1.0542692496784412E-8)) + b * 1.0542692496784412E-8)</span>
                + (lo * 1.4426950408889634 + hi * 2.0355273740931033E-17);
<span class="fc" id="L2001">        s = (int) StrictMath.round(c);</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">        if (c == s) {</span>
<span class="fc" id="L2003">            s += (int) StrictMath.round(b);</span>
        } 
<span class="pc bpc" id="L2005" title="3 of 4 branches missed.">        else if (StrictMath.abs(s - c) == 0.5 &amp;&amp; b &lt; 0.0) {</span>
<span class="nc" id="L2006">            s--;</span>
        }
<span class="fc" id="L2008">        e = 0.6931471805599453 * s;</span>
<span class="fc" id="L2009">        c = ((s * 0.6931471824645996 - e) - (s * 1.904654323148236E-9)) + 2.3190468138462996E-17 * s;</span>
<span class="fc" id="L2010">        b = lo - c;</span>
<span class="fc" id="L2011">        d = lo - b;</span>
<span class="fc" id="L2012">        e = hi - e;</span>
<span class="fc" id="L2013">        a = e + b;</span>
<span class="fc" id="L2014">        b = ((lo - (d + b)) + (d - c)) + (b + (e - a));</span>
<span class="fc" id="L2015">        e = a + 1;</span>
<span class="fc" id="L2016">        c = a - e;</span>
<span class="fc" id="L2017">        d = ((a - (e + c)) + (1 + c)) + b;</span>
<span class="fc" id="L2018">        c = e + d;</span>
<span class="fc" id="L2019">        d += e - c;</span>
<span class="fc" id="L2020">        e = SPLIT * a;</span>
<span class="fc" id="L2021">        e += a - e;</span>
<span class="fc" id="L2022">        f = a - e;</span>
<span class="fc" id="L2023">        i = a * a;</span>
<span class="fc" id="L2024">        f = ((e * e - i) + e * f * 2) + f * f;</span>
<span class="fc" id="L2025">        f += a * b * 2;</span>
<span class="fc" id="L2026">        f += b * b;</span>
<span class="fc" id="L2027">        e = f + i;</span>
<span class="fc" id="L2028">        f += i - e;</span>
<span class="fc" id="L2029">        i = e * g;</span>
<span class="fc" id="L2030">        j = f * g;</span>
        do {
<span class="fc" id="L2032">            k = d + j;</span>
<span class="fc" id="L2033">            l = d - k;</span>
<span class="fc" id="L2034">            m = c + i;</span>
<span class="fc" id="L2035">            n = c - m;</span>
<span class="fc" id="L2036">            n = ((c - (n + m)) + (n + i)) + k;</span>
<span class="fc" id="L2037">            o = m + n;</span>
<span class="fc" id="L2038">            d = (n + (m - o)) + ((d - (l + k)) + (l + j));</span>
<span class="fc" id="L2039">            c = o + d;</span>
<span class="fc" id="L2040">            d += o - c;</span>
<span class="fc" id="L2041">            k = SPLIT * e;</span>
<span class="fc" id="L2042">            k += e - k;</span>
<span class="fc" id="L2043">            l = e - k;</span>
<span class="fc" id="L2044">            m = SPLIT * a;</span>
<span class="fc" id="L2045">            m += a - m;</span>
<span class="fc" id="L2046">            n = a - m;</span>
<span class="fc" id="L2047">            o = e * a;</span>
<span class="fc" id="L2048">            f = (((k * m - o) + (k * n + l * m)) + l * n) + (f * a + e * b);</span>
<span class="fc" id="L2049">            e = o + f;</span>
<span class="fc" id="L2050">            f += o - e;</span>
<span class="fc" id="L2051">            n = g / ++q;</span>
<span class="fc" id="L2052">            k = SPLIT * n;</span>
<span class="fc" id="L2053">            k += n - k;</span>
<span class="fc" id="L2054">            l = n - k;</span>
<span class="fc" id="L2055">            m = n * q;</span>
<span class="fc" id="L2056">            o = g - m;</span>
<span class="fc" id="L2057">            p = g - o;</span>
<span class="fc" id="L2058">            h = (o + ((((g - (p + o)) + (p - m)) + h) - (((k * q - m) + l * q)))) / q;</span>
<span class="fc" id="L2059">            g = n;</span>
<span class="fc" id="L2060">            i = SPLIT * e;</span>
<span class="fc" id="L2061">            i += e - i;</span>
<span class="fc" id="L2062">            k = e - i;</span>
<span class="fc" id="L2063">            j = SPLIT * g;</span>
<span class="fc" id="L2064">            j += g - j;</span>
<span class="fc" id="L2065">            l = g - j;</span>
<span class="fc" id="L2066">            m = e * g;</span>
<span class="fc" id="L2067">            j = (((i * j - m) + (i * l + k * j)) + k * l) + (f * g + e * h);</span>
<span class="fc" id="L2068">            i = m + j;</span>
<span class="fc" id="L2069">            j += m - i;</span>
        } 
<span class="fc bfc" id="L2071" title="All 4 branches covered.">        while (i &gt; 1e-40 || i &lt; -1e-40);</span>

<span class="pc bpc" id="L2073" title="1 of 2 branches missed.">        if (s &lt; 0) {</span>
<span class="nc" id="L2074">            s = -s;</span>
<span class="nc" id="L2075">            a = 0.5;</span>
        } 
        else {
<span class="fc" id="L2078">            a = 2;</span>
        }

<span class="fc bfc" id="L2081" title="All 2 branches covered.">        while (s &gt; 0) {</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">            if ((s &amp; 1) &gt; 0) {</span>
<span class="fc" id="L2083">                r *= a;</span>
            }
<span class="fc" id="L2085">            a *= a;</span>
<span class="fc" id="L2086">            s &gt;&gt;= 1;</span>
        }
<span class="fc" id="L2088">        a = d + j;</span>
<span class="fc" id="L2089">        b = d - a;</span>
<span class="fc" id="L2090">        e = c + i;</span>
<span class="fc" id="L2091">        f = c - e;</span>
<span class="fc" id="L2092">        f = ((c - (f + e)) + (f + i)) + a;</span>
<span class="fc" id="L2093">        c = e + f;</span>
<span class="fc" id="L2094">        d = (f + (e - c)) + ((d - (b + a)) + (b + j));</span>
<span class="fc" id="L2095">        return new DoubleDouble(c * r, d * r);</span>
    }
    
    /**
     *
     @return
     */
    public DoubleDouble log() {
<span class="pc bpc" id="L2103" title="2 of 4 branches missed.">        if (hi!=hi || hi &lt;= 0.0) {</span>
<span class="nc" id="L2104">            return NaN;</span>
        }

<span class="fc" id="L2107">        double a, b, c, d, e, f, g = 0.5, h = 0, i, j, k, l, m, n, o, p, q = 2, r = 1, s;</span>
        int t;

<span class="fc" id="L2110">        s = StrictMath.log(hi);</span>

<span class="fc" id="L2112">        a = SPLIT * s;</span>
<span class="fc" id="L2113">        a += s + a;</span>
<span class="fc" id="L2114">        b = s - a;</span>
<span class="fc" id="L2115">        c = s * -1.4426950408889634;</span>
<span class="fc" id="L2116">        b = (((a * -1.4426950514316559 - c) + (a * 1.0542692496784412E-8 - b * 1.4426950514316559)) + b * 1.0542692496784412E-8) - (s * 2.0355273740931033E-17);</span>
<span class="fc" id="L2117">        t = (int) StrictMath.round(c);</span>
<span class="fc bfc" id="L2118" title="All 2 branches covered.">        if (a == t) {</span>
<span class="fc" id="L2119">            t += (int) StrictMath.round(b);</span>
        } 
<span class="pc bpc" id="L2121" title="3 of 4 branches missed.">        else if (StrictMath.abs(t - a) == 0.5 &amp;&amp; b &lt; 0.0) {</span>
<span class="nc" id="L2122">            t--;</span>
        }
<span class="fc" id="L2124">        e = 0.6931471805599453 * t;</span>
<span class="fc" id="L2125">        c = ((t * 0.6931471824645996 - e) - (t * 1.904654323148236E-9)) + 2.3190468138462996E-17 * t;</span>
<span class="fc" id="L2126">        e += s;</span>
<span class="fc" id="L2127">        a = e + c;</span>
<span class="fc" id="L2128">        b = (a - e) - c;</span>
<span class="fc" id="L2129">        e = 1 - a;</span>
<span class="fc" id="L2130">        d = ((1 - e) - a) + b;</span>
<span class="fc" id="L2131">        c = e + d;</span>
<span class="fc" id="L2132">        d += e - c;</span>
<span class="fc" id="L2133">        e = SPLIT * -a;</span>
<span class="fc" id="L2134">        e -= a + e;</span>
<span class="fc" id="L2135">        f = a + e;</span>
<span class="fc" id="L2136">        i = a * a;</span>
<span class="fc" id="L2137">        f = ((e * e - i) - e * f * 2) + f * f;</span>
<span class="fc" id="L2138">        f += -a * b * 2;</span>
<span class="fc" id="L2139">        a = -a;</span>
<span class="fc" id="L2140">        f += b * b;</span>
<span class="fc" id="L2141">        e = f + i;</span>
<span class="fc" id="L2142">        f += i - e;</span>
<span class="fc" id="L2143">        l = SPLIT * e;</span>
<span class="fc" id="L2144">        l += e - l;</span>
        //k = e - l;
<span class="fc" id="L2146">        i = e * g;</span>
<span class="fc" id="L2147">        j = f * g;</span>
        do {
<span class="fc" id="L2149">            k = d + j;</span>
<span class="fc" id="L2150">            l = d - k;</span>
<span class="fc" id="L2151">            m = c + i;</span>
<span class="fc" id="L2152">            n = c - m;</span>
<span class="fc" id="L2153">            n = ((c - (n + m)) + (n + i)) + k;</span>
<span class="fc" id="L2154">            o = m + n;</span>
<span class="fc" id="L2155">            d = (n + (m - o)) + ((d - (l + k)) + (l + j));</span>
<span class="fc" id="L2156">            c = o + d;</span>
<span class="fc" id="L2157">            d += o - c;</span>
<span class="fc" id="L2158">            k = SPLIT * e;</span>
<span class="fc" id="L2159">            k += e - k;</span>
<span class="fc" id="L2160">            l = e - k;</span>
<span class="fc" id="L2161">            m = SPLIT * a;</span>
<span class="fc" id="L2162">            m += a - m;</span>
<span class="fc" id="L2163">            n = a - m;</span>
<span class="fc" id="L2164">            o = e * a;</span>
<span class="fc" id="L2165">            f = (((k * m - o) + (k * n + l * m)) + l * n) + (f * a + e * b);</span>
<span class="fc" id="L2166">            e = o + f;</span>
<span class="fc" id="L2167">            f += o - e;</span>
<span class="fc" id="L2168">            n = g / ++q;</span>
<span class="fc" id="L2169">            k = SPLIT * n;</span>
<span class="fc" id="L2170">            k += n - k;</span>
<span class="fc" id="L2171">            l = n - k;</span>
<span class="fc" id="L2172">            m = n * q;</span>
<span class="fc" id="L2173">            o = g - m;</span>
<span class="fc" id="L2174">            p = g - o;</span>
<span class="fc" id="L2175">            h = (o + ((((g - (p + o)) + (p - m)) + h) - (((k * q - m) + l * q)))) / q;</span>
<span class="fc" id="L2176">            g = n;</span>
<span class="fc" id="L2177">            i = SPLIT * e;</span>
<span class="fc" id="L2178">            i += e - i;</span>
<span class="fc" id="L2179">            k = e - i;</span>
<span class="fc" id="L2180">            j = SPLIT * g;</span>
<span class="fc" id="L2181">            j += g - j;</span>
<span class="fc" id="L2182">            l = g - j;</span>
<span class="fc" id="L2183">            m = e * g;</span>
<span class="fc" id="L2184">            j = (((i * j - m) + (i * l + k * j)) + k * l) + (f * g + e * h);</span>
<span class="fc" id="L2185">            i = m + j;</span>
<span class="fc" id="L2186">            j += m - i;</span>
        } 
<span class="fc bfc" id="L2188" title="All 4 branches covered.">        while (i &gt; 1e-40 || i &lt; -1e-40);</span>

<span class="fc bfc" id="L2190" title="All 2 branches covered.">        if (t &lt; 0) {</span>
<span class="fc" id="L2191">            t = -t;</span>
<span class="fc" id="L2192">            k = 0.5;</span>
        } 
        else {
<span class="fc" id="L2195">            k = 2;</span>
        }

<span class="fc bfc" id="L2198" title="All 2 branches covered.">        while (t &gt; 0) {</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">            if ((t &amp; 1) &gt; 0) {</span>
<span class="fc" id="L2200">                r *= k;</span>
            }
<span class="fc" id="L2202">            k *= k;</span>
<span class="fc" id="L2203">            t &gt;&gt;= 1;</span>
        }
<span class="fc" id="L2205">        a = d + j;</span>
<span class="fc" id="L2206">        b = d - a;</span>
<span class="fc" id="L2207">        e = c + i;</span>
<span class="fc" id="L2208">        f = c - e;</span>
<span class="fc" id="L2209">        f = ((c - (f + e)) + (f + i)) + a;</span>
<span class="fc" id="L2210">        g = e + f;</span>
<span class="fc" id="L2211">        h = ((f + (e - g)) + ((d - (b + a)) + (b + j))) * r;</span>
<span class="fc" id="L2212">        g *= r;</span>
<span class="fc" id="L2213">        a = SPLIT * hi;</span>
<span class="fc" id="L2214">        a += hi - a;</span>
<span class="fc" id="L2215">        c = hi - a;</span>
<span class="fc" id="L2216">        b = SPLIT * g;</span>
<span class="fc" id="L2217">        b += g - b;</span>
<span class="fc" id="L2218">        d = g - b;</span>
<span class="fc" id="L2219">        e = hi * g;</span>
<span class="fc" id="L2220">        b = (((a * b - e) + (a * d + c * b)) + c * d) + (lo * g + hi * h);</span>
<span class="fc" id="L2221">        a = --e + b;</span>
<span class="fc" id="L2222">        b += e - a;</span>
<span class="fc" id="L2223">        c = a + s;</span>
<span class="fc" id="L2224">        d = a - c;</span>
<span class="fc" id="L2225">        b += ((a - (c + d)) + (s + d));</span>
<span class="fc" id="L2226">        a = c + b;</span>
<span class="fc" id="L2227">        return new DoubleDouble(a, b + (c - a));</span>
    }

    
    
    
    /*------------------------------------------------------------
     *   Conversion Functions
     *------------------------------------------------------------
     */
    /**
     * Converts this value to the nearest double-precision number.
     *
     @return the nearest double-precision number to this value
     */
    public double doubleValue() {
<span class="fc" id="L2243">        return hi + lo;</span>
    }

    
    
    
    /*------------------------------------------------------------
     *   Conversion Functions
     *------------------------------------------------------------
     */
    /**
     * Converts this value to the absolute value of the
     * nearest double-precision number.
     *
     @return the absolute value of the nearest double-precision 
     * number to this value
     */
    public double dabs() {
<span class="nc" id="L2261">        double a = hi + lo;</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">        return (a &gt;= 0) ? a : -a;</span>
    }

    
    
    
    /**
     * Converts this value to the nearest integer.
     *
     @return the nearest integer to this value
     */
    public int intValue() {
        double fhi;
<span class="nc bnc" id="L2275" title="All 6 branches missed.">        if (hi &gt; 0.0 || (hi == 0.0 &amp;&amp; lo &gt;= 0.0)) {</span>
            // Non-negative number, use the floor function.
<span class="nc" id="L2277">            fhi = StrictMath.floor(hi);</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">            if (fhi == hi) {</span>
<span class="nc" id="L2279">                fhi += StrictMath.floor(lo);  </span>
            }
        }
        else {
            // Negative number, use the ceil function.
<span class="nc" id="L2284">            fhi = StrictMath.ceil(hi);</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">            if (fhi == hi) {</span>
<span class="nc" id="L2286">                fhi += StrictMath.ceil(lo);  </span>
            }
        }
<span class="nc bnc" id="L2289" title="All 4 branches missed.">        return (fhi &lt; MININT.hi) ? Integer.MIN_VALUE : (fhi &gt; MAXINT.hi ? Integer.MAX_VALUE : (int)fhi);</span>
    }

    
    
    
    /**
     * Converts this value to the nearest integer.
     *
     @return the nearest integer to this value
     */
    public long longValue() {
<span class="nc" id="L2301">        double fhi, flo = 0.0;</span>
<span class="nc bnc" id="L2302" title="All 6 branches missed.">        if (hi &gt; 0.0 || (hi == 0.0 &amp;&amp; lo &gt;= 0.0)) {</span>
            // Non-negative number, use the floor function.
<span class="nc" id="L2304">            fhi = StrictMath.floor(hi);</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">            if (fhi == hi) {</span>
<span class="nc" id="L2306">                flo = StrictMath.floor(lo);</span>
<span class="nc" id="L2307">                double st = fhi + flo; flo = flo + (fhi - st); fhi = st;</span>
<span class="nc" id="L2308">            }</span>
        }
        else {
            // Negative number, use the ceil function.
<span class="nc" id="L2312">            fhi = StrictMath.ceil(hi);</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">            if (fhi == hi) {</span>
<span class="nc" id="L2314">                flo = StrictMath.ceil(lo);</span>
<span class="nc" id="L2315">                double st = fhi + flo; flo = flo + (fhi - st); fhi = st;  </span>
            }
        }
        
<span class="nc bnc" id="L2319" title="All 6 branches missed.">        if (fhi &gt; MAXLONG.hi || (fhi == MAXLONG.hi &amp;&amp; flo &gt;= MAXLONG.lo)) return Long.MAX_VALUE;</span>
<span class="nc bnc" id="L2320" title="All 6 branches missed.">        if (fhi &lt; MINLONG.hi || (fhi == MINLONG.hi &amp;&amp; flo &lt;= MINLONG.lo)) return Long.MIN_VALUE;</span>
        
<span class="nc" id="L2322">        return ((long)fhi) + ((long)flo);</span>
    }

    
    
    
    /*------------------------------------------------------------
     *   Predicates
     *------------------------------------------------------------
     */
    
    /**
     * Tests whether this value is equal to 0.
     *
     @return true if this value is equal to 0
     */
    public boolean isZero() {
<span class="pc bpc" id="L2339" title="1 of 4 branches missed.">        return hi == 0.0 &amp;&amp; lo == 0.0;</span>
    }

    
    
    
    /**
     * Tests whether this value is equal to 1.
     *
     @return true if this value is equal to 1
     */
    public boolean isOne() {
<span class="nc bnc" id="L2351" title="All 4 branches missed.">        return hi == 1.0 &amp;&amp; lo == 0.0;</span>
    }

    
    
    
    /**
     * Tests whether this value is less than 0.
     *
     @return true if this value is less than 0
     */
    public boolean isNegative() {
<span class="pc bpc" id="L2363" title="3 of 6 branches missed.">        return hi &lt; 0.0 || (hi == 0.0 &amp;&amp; lo &lt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than 0.
     *
     @return true if this value is greater than 0
     */
    public boolean isPositive() {
<span class="nc bnc" id="L2375" title="All 6 branches missed.">        return hi &gt; 0.0 || (hi == 0.0 &amp;&amp; lo &gt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is NaN.
     *
     @return true if this value is NaN
     */
    public boolean isNaN() {
<span class="nc bnc" id="L2387" title="All 2 branches missed.">        return hi!=hi;</span>
    }

    
    
    
    /**
     * Tests whether this value is close to another value.
     *
     @param b a DoubleDouble value, to be compared with this
     @param eps a specification of the relatieve precision
     @return true if this value is close to the other value with relative
     * precision, given by eps.
     */
    public boolean isNear(DoubleDouble b, double eps) {
<span class="pc bpc" id="L2402" title="3 of 6 branches missed.">        if (hi!=hi || b.hi!=b.hi || eps!=eps) {</span>
<span class="nc" id="L2403">            return false;</span>
        }
<span class="fc" id="L2405">        double a = abs().doubleValue();</span>
<span class="fc" id="L2406">        double diff = sub(b).abs().doubleValue();</span>
<span class="pc bpc" id="L2407" title="1 of 2 branches missed.">        return diff &lt; a * eps;</span>
    }

    
    
    
    /**
     * Tests whether this value is equal to another &lt;tt&gt;DoubleDouble&lt;/tt&gt; value.
     *
     @param y a DoubleDouble value
     @return true if this value = y
     */
    public boolean equals(DoubleDouble y) {
<span class="nc bnc" id="L2420" title="All 4 branches missed.">        return hi == y.hi &amp;&amp; lo == y.lo;</span>
    }

    
    
    
    /**
     * Tests whether this value is equal to a given &lt;tt&gt;double&lt;/tt&gt; value.
     *
     @param y a double value
     @return true if this value = y
     */
    public boolean equals(double y) {
<span class="nc bnc" id="L2433" title="All 4 branches missed.">        return hi == y &amp;&amp; lo == 0;</span>
    }

    
    
    
    /**
     * Tests whether this value is equal to a given &lt;tt&gt;long&lt;/tt&gt; value.
     *
     @param y a long value
     @return true if this value = y
     */
    public boolean equals(long y) {
<span class="nc" id="L2446">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L2447">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L2448">        double s = yhi + ylo;</span>
<span class="nc" id="L2449">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L2450">        yhi = s;</span>
<span class="nc" id="L2451">        ylo = err;</span>
<span class="nc bnc" id="L2452" title="All 4 branches missed.">        return hi == yhi &amp;&amp; lo == ylo;</span>
    }

    
    
    
    /**
     * Tests whether this value is equal to a given &lt;tt&gt;int&lt;/tt&gt; value.
     *
     @param y an int value
     @return true if this value = y
     */
    public boolean equals(int y) {
<span class="nc bnc" id="L2465" title="All 4 branches missed.">        return hi == y &amp;&amp; lo == 0;</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than another &lt;tt&gt;DoubleDouble&lt;/tt&gt;
     * value.
     *
     @param y a DoubleDouble value
     @return true if this value &gt; y
     */
    public boolean gt(DoubleDouble y) {
<span class="nc bnc" id="L2479" title="All 6 branches missed.">        return (hi &gt; y.hi) || (hi == y.hi &amp;&amp; lo &gt; y.lo);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than a given &lt;tt&gt;double&lt;/tt&gt;
     * value.
     *
     @param y a double value
     @return true if this value &gt; y
     */
    public boolean gt(double y) {
<span class="pc bpc" id="L2493" title="3 of 6 branches missed.">        return (hi &gt; y) || (hi == y &amp;&amp; lo &gt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than a given
     * &lt;tt&gt;long&lt;/tt&gt; value.
     *
     @param y a long value
     @return true if this value &gt;= y
     */
    public boolean gt(long y) {
<span class="nc" id="L2507">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L2508">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L2509">        double s = yhi + ylo;</span>
<span class="nc" id="L2510">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L2511">        yhi = s;</span>
<span class="nc" id="L2512">        ylo = err;</span>
<span class="nc bnc" id="L2513" title="All 6 branches missed.">        return (hi &gt; yhi) || (hi == yhi &amp;&amp; lo &gt; ylo);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than a given &lt;tt&gt;int&lt;/tt&gt;
     * value.
     *
     @param y an int value
     @return true if this value &gt; y
     */
    public boolean gt(int y) {
<span class="nc bnc" id="L2527" title="All 6 branches missed.">        return (hi &gt; y) || (hi == y &amp;&amp; lo &gt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than or equals to another
     * &lt;tt&gt;DoubleDouble&lt;/tt&gt; value.
     *
     @param y a DoubleDouble value
     @return true if this value &gt;= y
     */
    public boolean ge(DoubleDouble y) {
<span class="nc bnc" id="L2541" title="All 6 branches missed.">        return (hi &gt; y.hi) || (hi == y.hi &amp;&amp; lo &gt;= y.lo);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than or equals to a given
     * &lt;tt&gt;double&lt;/tt&gt; value.
     *
     @param y a double value
     @return true if this value &gt;= y
     */
    public boolean ge(double y) {
<span class="nc bnc" id="L2555" title="All 6 branches missed.">        return (hi &gt; y) || (hi == y &amp;&amp; lo &gt;= 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than or equals to a given
     * &lt;tt&gt;long&lt;/tt&gt; value.
     *
     @param y a long value
     @return true if this value &gt;= y
     */
    public boolean ge(long y) {
<span class="nc" id="L2569">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L2570">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L2571">        double s = yhi + ylo;</span>
<span class="nc" id="L2572">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L2573">        yhi = s;</span>
<span class="nc" id="L2574">        ylo = err;</span>
<span class="nc bnc" id="L2575" title="All 6 branches missed.">        return (hi &gt; yhi) || (hi == yhi &amp;&amp; lo &gt;= ylo);</span>
    }

    
    
    
    /**
     * Tests whether this value is greater than or equals to a given
     * &lt;tt&gt;int&lt;/tt&gt; value.
     *
     @param y an int value
     @return true if this value &gt;= y
     */
    public boolean ge(int y) {
<span class="pc bpc" id="L2589" title="2 of 6 branches missed.">        return (hi &gt; y) || (hi == y &amp;&amp; lo &gt;= 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than another &lt;tt&gt;DoubleDouble&lt;/tt&gt;
     * value.
     *
     @param y a DoubleDouble value
     @return true if this value &lt; y
     */
    public boolean lt(DoubleDouble y) {
<span class="nc bnc" id="L2603" title="All 6 branches missed.">        return (hi &lt; y.hi) || (hi == y.hi &amp;&amp; lo &lt; y.lo);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than a given &lt;tt&gt;double&lt;/tt&gt;
     * value.
     *
     @param y a double value
     @return true if this value &lt; y
     */
    public boolean lt(double y) {
<span class="fc bfc" id="L2617" title="All 6 branches covered.">        return (hi &lt; y) || (hi == y &amp;&amp; lo &lt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than a given
     * &lt;tt&gt;long&lt;/tt&gt; value.
     *
     @param y a long value
     @return true if this value &lt;= y
     */
    public boolean lt(long y) { 
<span class="nc" id="L2631">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L2632">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L2633">        double s = yhi + ylo;</span>
<span class="nc" id="L2634">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L2635">        yhi = s;</span>
<span class="nc" id="L2636">        ylo = err;</span>
<span class="nc bnc" id="L2637" title="All 6 branches missed.">        return (hi &lt; yhi) || (hi == yhi &amp;&amp; lo &lt; ylo);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than a given &lt;tt&gt;int&lt;/tt&gt;
     * value.
     *
     @param y an int value
     @return true if this value &lt; y
     */
    public boolean lt(int y) {
<span class="nc bnc" id="L2651" title="All 6 branches missed.">        return (hi &lt; y) || (hi == y &amp;&amp; lo &lt; 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than or equal to another
     * &lt;tt&gt;DoubleDouble&lt;/tt&gt; value.
     *
     @param y a DoubleDouble value
     @return true if this value &lt;= y
     */
    public boolean le(DoubleDouble y) {
<span class="nc bnc" id="L2665" title="All 6 branches missed.">        return (hi &lt; y.hi) || (hi == y.hi &amp;&amp; lo &lt;= y.lo);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than or equal to a given
     * &lt;tt&gt;double&lt;/tt&gt; value.
     *
     @param y a double value
     @return true if this value &lt;= y
     */
    public boolean le(double y) {
<span class="nc bnc" id="L2679" title="All 6 branches missed.">        return (hi &lt; y) || (hi == y &amp;&amp; lo &lt;= 0.0);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than or equal to a given
     * &lt;tt&gt;long&lt;/tt&gt; value.
     *
     @param y a long value
     @return true if this value &lt;= y
     */
    public boolean le(long y) { 
<span class="nc" id="L2693">        double yhi = y &amp; 0xfffffffffffff800l;</span>
<span class="nc" id="L2694">        double ylo = y &amp; 0x7ffl;</span>
<span class="nc" id="L2695">        double s = yhi + ylo;</span>
<span class="nc" id="L2696">        double err = ylo - (s - yhi);</span>
<span class="nc" id="L2697">        yhi = s;</span>
<span class="nc" id="L2698">        ylo = err;</span>
<span class="nc bnc" id="L2699" title="All 6 branches missed.">        return (hi &lt; yhi) || (hi == yhi &amp;&amp; lo &lt;= ylo);</span>
    }

    
    
    
    /**
     * Tests whether this value is less than or equal to a given
     * &lt;tt&gt;int&lt;/tt&gt; value.
     *
     @param y an int value
     @return true if this value &lt;= y
     */
    public boolean le(int y) {
<span class="nc bnc" id="L2713" title="All 6 branches missed.">        return (hi &lt; y) || (hi == y &amp;&amp; lo &lt;= 0.0);</span>
    }

    
    
    
    /**
     * Compares two DoubleDouble objects numerically.
     *
     @return -1,0 or 1 depending on whether this value is less than, equal to
     * or greater than the value of &lt;tt&gt;o&lt;/tt&gt;
     */
    @Override
    public int compareTo(Object o) {
<span class="pc bpc" id="L2727" title="1 of 2 branches missed.">        if (o instanceof DoubleDouble) {</span>
<span class="fc" id="L2728">            DoubleDouble other = (DoubleDouble)o;</span>
<span class="fc bfc" id="L2729" title="All 6 branches covered.">            if (hi &lt; other.hi || (hi == other.hi &amp;&amp; lo &lt; other.lo)) {return -1;}</span>
<span class="pc bpc" id="L2730" title="1 of 6 branches missed.">            if (hi &gt; other.hi || (hi == other.hi &amp;&amp; lo &gt; other.lo)) {return 1;}</span>
<span class="fc" id="L2731">            return 0;</span>
        }
        
<span class="nc bnc" id="L2734" title="All 2 branches missed.">        if (o instanceof Double) {</span>
<span class="nc" id="L2735">            double other = (Double)o;</span>
<span class="nc bnc" id="L2736" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2737" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2738">            return 0;</span>
        }
        
<span class="nc bnc" id="L2741" title="All 2 branches missed.">        if (o instanceof Long) {</span>
<span class="nc" id="L2742">            DoubleDouble other = new DoubleDouble((Long)o);</span>
<span class="nc bnc" id="L2743" title="All 6 branches missed.">            if (hi &lt; other.hi || (hi == other.hi &amp;&amp; lo &lt; other.lo)) {return -1;}</span>
<span class="nc bnc" id="L2744" title="All 6 branches missed.">            if (hi &gt; other.hi || (hi == other.hi &amp;&amp; lo &gt; other.lo)) {return 1;}</span>
<span class="nc" id="L2745">            return 0;</span>
        }
        
<span class="nc bnc" id="L2748" title="All 2 branches missed.">        if (o instanceof Integer) {</span>
<span class="nc" id="L2749">            double other = (Integer)o;</span>
<span class="nc bnc" id="L2750" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2751" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2752">            return 0;</span>
        }
        
<span class="nc bnc" id="L2755" title="All 2 branches missed.">        if (o instanceof Float) {</span>
<span class="nc" id="L2756">            double other = (Float)o;</span>
<span class="nc bnc" id="L2757" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2758" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2759">            return 0;</span>
        }
        
<span class="nc bnc" id="L2762" title="All 2 branches missed.">        if (o instanceof String) {</span>
<span class="nc" id="L2763">            DoubleDouble other = new DoubleDouble((String)o);</span>
<span class="nc bnc" id="L2764" title="All 6 branches missed.">            if (hi &lt; other.hi || (hi == other.hi &amp;&amp; lo &lt; other.lo)) {return -1;}</span>
<span class="nc bnc" id="L2765" title="All 6 branches missed.">            if (hi &gt; other.hi || (hi == other.hi &amp;&amp; lo &gt; other.lo)) {return 1;}</span>
<span class="nc" id="L2766">            return 0;</span>
        }
        
<span class="nc bnc" id="L2769" title="All 2 branches missed.">        if (o instanceof Short) {</span>
<span class="nc" id="L2770">            double other = (Short)o;</span>
<span class="nc bnc" id="L2771" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2772" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2773">            return 0;</span>
        }
        
<span class="nc bnc" id="L2776" title="All 2 branches missed.">        if (o instanceof Byte) {</span>
<span class="nc" id="L2777">            double other = (Byte)o;</span>
<span class="nc bnc" id="L2778" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2779" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2780">            return 0;</span>
        }
        
<span class="nc bnc" id="L2783" title="All 2 branches missed.">        if (o instanceof Character) {</span>
<span class="nc" id="L2784">            double other = (Character)o;</span>
<span class="nc bnc" id="L2785" title="All 6 branches missed.">            if (hi &lt; other || (hi == other &amp;&amp; lo &lt; 0)) {return -1;}</span>
<span class="nc bnc" id="L2786" title="All 6 branches missed.">            if (hi &gt; other || (hi == other &amp;&amp; lo &gt; 0)) {return 1;}</span>
<span class="nc" id="L2787">            return 0;</span>
        }
        
<span class="nc" id="L2790">        throw new RuntimeException(&quot;Cannot compare class &quot; + o.getClass().getName() + &quot; to DoubleDouble value.&quot;);</span>
    }

    
    
    
    
    /*------------------------------------------------------------
     *   Output
     *------------------------------------------------------------
     */
    
    /**
     * Dumps the components of this number to a string.
     *
     @return a string showing the components of the number
     */
    public String dump() {
<span class="nc" id="L2808">        return &quot;DD&lt;&quot; + hi + &quot;, &quot; + lo + &quot;&gt;&quot;;</span>
    }
    
        
    
<span class="fc" id="L2813">    private static final char[] BASE_36_TABLE = { //</span>
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', //
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', //
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', //
        'U', 'V', 'W', 'X', 'Y', 'Z'};
    
<span class="fc" id="L2819">    private static final char[] ZEROES = { //</span>
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', //
        '0', '0', '0', '0', '0'};
    
    
<span class="fc" id="L2833">    private static final double[] DIGITS_PER_BIT = new double[37];</span>
    static {
<span class="fc" id="L2835">        double log2 = StrictMath.log(2);</span>
<span class="fc bfc" id="L2836" title="All 2 branches covered.">        for (int base = 2; base &lt;= 36; base++) {</span>
<span class="fc" id="L2837">            DIGITS_PER_BIT[base] = log2 / StrictMath.log(base);</span>
        }
<span class="fc" id="L2839">    }</span>
    
    
    /**
     * Prints a DoubleDouble in the decimal number system to a String.
     * Normal notation is used for numbers in the range 0.001 to 1e10,
     * numbers outside of this range are printed in scientific notation.
     @return The String, representing the number.
     */
    @Override
    public String toString() {
<span class="fc" id="L2850">        return toString(10, 0, false);</span>
    }

    
    
    /**
     * Prints this DoubleDouble to a String. This method provides a lot
     * of flexibility on how to print the number.
     @param radix The radix of the number system in which this DoubleDouble
     * is printed. The exponent (if scientific notation is used) is always
     * printed in the decimal system. E.g. in the hexadecimal system, the
     * number A.BCDEFe20 stands for A.BCDEF*power, where power is 16^20 in
     * the decimal system.
     @param maxPrecision The maximum number of digits in the given radix to
     * be printed. If the value 0 is supplied, then the number of digits is
     * such that the entire precision of the number is used (for radix 10 this
     * means that 31 digits are printed, for radix 16, this means that 26 
     * digits are printed). If a value is supplied, which uses more than the
     * precision of a DoubleDouble, then the number of digits is limited as if
     * the value 0 were aupplied.
     @param sci A boolean, telling whether normal notation or scientific
     * notation with exponents needs to be used.
     @return 
     */
    public String toString(int radix, int maxPrecision, boolean sci) {
<span class="pc bpc" id="L2875" title="1 of 2 branches missed.">        if (hi!=hi) {</span>
<span class="nc" id="L2876">            return &quot;NaN&quot;;</span>
        }
        
        // Get the precision. (The number of significant digits required
        // for an accurate representation of this number). 
<span class="fc" id="L2881">        int precision = (int)(105 * DIGITS_PER_BIT[radix]);</span>
<span class="pc bpc" id="L2882" title="1 of 4 branches missed.">        if (maxPrecision &gt; 0 &amp;&amp; maxPrecision &lt; precision) {</span>
<span class="fc" id="L2883">            precision = maxPrecision;</span>
        }

        // Get the raw digit representation.
<span class="fc" id="L2887">        char[] chars = new char[precision + 1];</span>
<span class="fc" id="L2888">        int exp = to_digits(chars, precision, radix) + 1;</span>

        // Get some properties.
<span class="fc" id="L2891">        int left = StrictMath.max(0, -exp);</span>
<span class="fc" id="L2892">        int right = StrictMath.max(0, exp);</span>
<span class="pc bpc" id="L2893" title="1 of 2 branches missed.">        if (chars[precision - 1] == 0) {</span>
<span class="nc" id="L2894">            precision--;</span>
        }
<span class="pc bpc" id="L2896" title="3 of 8 branches missed.">        sci = sci || (exp&lt;-3 || exp&gt;10 || exp&gt;precision);</span>

        // Allocate exactly the right size string.
<span class="fc bfc" id="L2899" title="All 4 branches covered.">        StringBuilder out = new StringBuilder(precision + (sci ? 3 : left) + (exp &gt; 0 ? 1 : 2));</span>

        // Build the string.
<span class="fc bfc" id="L2902" title="All 2 branches covered.">        if (hi &lt; 0) {</span>
<span class="fc" id="L2903">            out.append('-');</span>
        }
<span class="fc bfc" id="L2905" title="All 2 branches covered.">        if (sci) {</span>
<span class="fc" id="L2906">            out.append(chars, 0, 1);</span>
<span class="fc" id="L2907">            out.append('.');</span>
<span class="fc" id="L2908">            out.append(chars, 1, precision - 1);</span>
<span class="fc" id="L2909">            out.append('e');</span>
<span class="fc" id="L2910">            out.append(exp - 1);</span>
        } else {
<span class="fc bfc" id="L2912" title="All 2 branches covered.">            if (exp &lt;= 0) {</span>
<span class="fc" id="L2913">                out.append('0');</span>
            }
<span class="fc bfc" id="L2915" title="All 2 branches covered.">            if (right &gt; 0) {</span>
<span class="fc" id="L2916">                out.append(chars, 0, right);</span>
            }
<span class="fc" id="L2918">            out.append('.');</span>
<span class="fc bfc" id="L2919" title="All 2 branches covered.">            if (left &gt; 0) {</span>
<span class="pc bpc" id="L2920" title="1 of 2 branches missed.">                if (DoubleDouble.ZEROES.length &lt; left) {</span>
<span class="nc" id="L2921">                    System.err.println(left);</span>
                } else {
<span class="fc" id="L2923">                    out.append(DoubleDouble.ZEROES, 0, left);</span>
                }
            }
<span class="fc" id="L2926">            out.append(chars, right, precision - right);</span>
        }

<span class="fc" id="L2929">        return out.toString();</span>
    }

    
    
    
    private int to_digits(char[] s, int precision, int base) {
<span class="fc" id="L2936">        int halfBase = (base + 1) &gt;&gt; 1;</span>

<span class="pc bpc" id="L2938" title="1 of 4 branches missed.">        if (hi == 0.0 &amp;&amp; lo == 0) {</span>
<span class="fc" id="L2939">            Arrays.fill(s, 0, precision, '0');</span>
<span class="fc" id="L2940">            return 0;</span>
        }

        // First determine the (approximate) exponent.
<span class="fc" id="L2944">        DoubleDouble temp = this.abs();</span>
<span class="fc" id="L2945">        int exp = (int) StrictMath.floor(StrictMath.log(temp.hi) / StrictMath.log(base));</span>

<span class="fc" id="L2947">        DoubleDouble p = new DoubleDouble(base);</span>
<span class="pc bpc" id="L2948" title="1 of 2 branches missed.">        if (exp &lt; -300) {</span>
<span class="nc" id="L2949">            temp = temp.mul(p.pow(150));</span>
<span class="nc" id="L2950">            p = p.pow(-exp - 150);</span>
<span class="nc" id="L2951">            temp = temp.mul(p);</span>
        } 
        else {
<span class="fc" id="L2954">            p = p.pow(-exp);</span>
<span class="fc" id="L2955">            temp = temp.mul(p);</span>
        }

        // Fix roundoff errors. (eg. floor(log10(1e9))=floor(8.9999~)=8)
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">        if (temp.ge(base)) {</span>
<span class="nc" id="L2960">            exp++;</span>
<span class="nc" id="L2961">            temp = temp.div(base);</span>
        } 
<span class="fc bfc" id="L2963" title="All 2 branches covered.">        else if (temp.lt(1.0)) {</span>
<span class="fc" id="L2964">            exp--;</span>
<span class="fc" id="L2965">            temp = temp.mul(base);</span>
        }

<span class="pc bpc" id="L2968" title="2 of 4 branches missed.">        if (temp.ge(base) || temp.lt(1.0)) {</span>
<span class="nc" id="L2969">            throw new RuntimeException(&quot;Can't compute exponent.&quot;);</span>
        }

        // Handle one digit more. Used afterwards for rounding.
<span class="fc" id="L2973">        int numDigits = precision + 1;</span>

        // Extract the digits.
<span class="fc bfc" id="L2976" title="All 2 branches covered.">        for (int i = 0; i &lt; numDigits; i++) {</span>
<span class="fc" id="L2977">            int val = (int) temp.hi;</span>
<span class="fc" id="L2978">            temp = temp.sub(val);</span>
<span class="fc" id="L2979">            temp = temp.mul(base);</span>
<span class="fc" id="L2980">            s[i] = (char) val;</span>
        }

<span class="pc bpc" id="L2983" title="1 of 2 branches missed.">        if (s[0] &lt;= 0) {</span>
<span class="nc" id="L2984">            throw new RuntimeException(&quot;Negative leading digit.&quot;);</span>
        }

        // Fix negative digits due to roundoff error in exponent.
<span class="fc bfc" id="L2988" title="All 2 branches covered.">        for (int i = numDigits - 1; i &gt; 0; i--) {</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">            if (s[i] &gt;= 32768) {</span>
<span class="fc" id="L2990">                s[i - 1]--;</span>
<span class="fc" id="L2991">                s[i] += base;</span>
            }
        }

        // Round, handle carry.
<span class="fc bfc" id="L2996" title="All 2 branches covered.">        if (s[precision] &gt;= halfBase) {</span>
<span class="fc" id="L2997">            s[precision - 1]++;</span>
<span class="fc" id="L2998">            int i = precision - 1;</span>
<span class="fc bfc" id="L2999" title="All 4 branches covered.">            while (i &gt; 0 &amp;&amp; s[i] &gt;= base) {</span>
<span class="fc" id="L3000">                s[i] -= base;</span>
<span class="fc" id="L3001">                s[--i]++;</span>
            }
        }
<span class="fc" id="L3004">        s[precision] = 0;</span>

        // If first digit became too high, shift right and
        // replace first digit by &quot;10&quot;.
<span class="fc bfc" id="L3008" title="All 2 branches covered.">        if (s[0] &gt;= base) {</span>
<span class="fc" id="L3009">            exp++;</span>
<span class="fc bfc" id="L3010" title="All 2 branches covered.">            for (int i = precision; i &gt;= 2; i--) {</span>
<span class="fc" id="L3011">                s[i] = s[i-1];</span>
            }
<span class="fc" id="L3013">            s[1] = (char)(s[0] - base);</span>
<span class="fc" id="L3014">            s[0] = 1;</span>
        }

        // If first digit became zero, shift left.
<span class="pc bpc" id="L3018" title="1 of 2 branches missed.">        if (s[0] == 0) {</span>
<span class="nc" id="L3019">            exp--;</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">            for (int i = 0; i &lt; precision; i++) {</span>
<span class="nc" id="L3021">                s[i] = s[i+1];</span>
            }
        }

        // Convert to ASCII.
<span class="fc bfc" id="L3026" title="All 2 branches covered.">        for (int i = 0; i &lt; precision; i++) {</span>
<span class="fc" id="L3027">            s[i] = DoubleDouble.BASE_36_TABLE[s[i]];</span>
        }

<span class="fc" id="L3030">        return exp;</span>
    }

    

    

    /*------------------------------------------------------------
     *   Input
     *------------------------------------------------------------
     */
    
    /**
     * Converts a string representation of a real number into a DoubleDouble
     * value. The format accepted is similar to the standard Java real number
     * syntax. It is defined by the following regular expression:
     * &lt;pre&gt;
     * [&lt;tt&gt;+&lt;/tt&gt;|&lt;tt&gt;-&lt;/tt&gt;] {&lt;i&gt;digit&lt;/i&gt;} [ &lt;tt&gt;.&lt;/tt&gt; {&lt;i&gt;digit&lt;/i&gt;} ] [ ( &lt;tt&gt;e&lt;/tt&gt; | &lt;tt&gt;E&lt;/tt&gt; ) [&lt;tt&gt;+&lt;/tt&gt;|&lt;tt&gt;-&lt;/tt&gt;] {&lt;i&gt;digit&lt;/i&gt;}+
     * &lt;pre&gt;
     *
     @param str the string to parse
     @return the value of the parsed number
     * @throws NumberFormatException if &lt;tt&gt;str&lt;/tt&gt; is not a valid
     * representation of a number
     */
    private static DoubleDouble parse(String str) throws NumberFormatException {
<span class="fc" id="L3056">        int i = 0;</span>
<span class="fc" id="L3057">        int strlen = str.length();</span>

        // skip leading whitespace
<span class="pc bpc" id="L3060" title="1 of 2 branches missed.">        while (Character.isWhitespace(str.charAt(i))) {</span>
<span class="nc" id="L3061">            i++;</span>
        }
<span class="pc bpc" id="L3063" title="1 of 2 branches missed.">        if (str.substring(i).equals(&quot;NaN&quot;)) {</span>
<span class="nc" id="L3064">            return NaN;</span>
        }

        // check for sign
<span class="fc" id="L3068">        boolean isNegative = false;</span>
<span class="pc bpc" id="L3069" title="1 of 2 branches missed.">        if (i &lt; strlen) {</span>
<span class="fc" id="L3070">            char signCh = str.charAt(i);</span>
<span class="pc bpc" id="L3071" title="1 of 4 branches missed.">            if (signCh == '-' || signCh == '+') {</span>
<span class="fc" id="L3072">                i++;</span>
<span class="pc bpc" id="L3073" title="1 of 2 branches missed.">                if (signCh == '-') {</span>
<span class="fc" id="L3074">                    isNegative = true;</span>
                }
            }
        }

        // scan all digits and accumulate into an integral value
        // Keep track of the location of the decimal point (if any)
        // to allow scaling later.
<span class="fc" id="L3082">        DoubleDouble val = new DoubleDouble();</span>

<span class="fc" id="L3084">        int numDigits = 0;</span>
<span class="fc" id="L3085">        int numBeforeDec = -1;</span>
<span class="fc" id="L3086">        int exp = 0;</span>
        while (true) {
<span class="fc bfc" id="L3088" title="All 2 branches covered.">            if (i &gt;= strlen) {</span>
<span class="fc" id="L3089">                break;</span>
            }
<span class="fc" id="L3091">            char ch = str.charAt(i);</span>
<span class="fc" id="L3092">            i++;</span>
<span class="fc bfc" id="L3093" title="All 2 branches covered.">            if (Character.isDigit(ch)) {</span>
<span class="fc" id="L3094">                int d = ch - '0';</span>
<span class="fc" id="L3095">                val = val.mul(10);</span>
<span class="fc" id="L3096">                val = val.add(d);</span>
<span class="fc" id="L3097">                numDigits++;</span>
<span class="fc" id="L3098">                continue;</span>
            }
<span class="fc bfc" id="L3100" title="All 2 branches covered.">            if (ch == '.') {</span>
<span class="pc bpc" id="L3101" title="1 of 2 branches missed.">                if (numBeforeDec != -1) {</span>
<span class="nc" id="L3102">                    throw new NumberFormatException(&quot;Multiple decimal dots in number string &quot; + str);</span>
                }
<span class="fc" id="L3104">                numBeforeDec = numDigits;</span>
<span class="fc" id="L3105">                continue;</span>
            }
<span class="pc bpc" id="L3107" title="3 of 4 branches missed.">            if (ch == 'e' || ch == 'E') {</span>
<span class="fc" id="L3108">                String expStr = str.substring(i);</span>
                // this should catch any format problems with the exponent
                try {
<span class="fc" id="L3111">                    exp = Integer.parseInt(expStr);</span>
<span class="nc" id="L3112">                } catch (NumberFormatException ex) {</span>
<span class="nc" id="L3113">                    throw new NumberFormatException(&quot;Invalid exponent &quot; + expStr + &quot; in string &quot; + str);</span>
<span class="fc" id="L3114">                }</span>
                break;
            }
<span class="nc" id="L3117">            throw new NumberFormatException(&quot;Unexpected character '&quot; + ch</span>
                    + &quot;' at position &quot; + i
                    + &quot; in string &quot; + str);
        }
<span class="fc" id="L3121">        DoubleDouble val2 = val;</span>
        
        // If there was no decimal dot, then set the number of digits before
        // the decimal dot to the number of digits.
<span class="fc bfc" id="L3125" title="All 2 branches covered.">        if (numBeforeDec == -1) {</span>
<span class="fc" id="L3126">            numBeforeDec = numDigits;</span>
        }

        // scale the number correctly
<span class="fc" id="L3130">        int numDecPlaces = numDigits - numBeforeDec - exp;</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">        if (numDecPlaces == 0) {</span>
<span class="fc" id="L3132">            val2 = val;</span>
        } 
<span class="fc bfc" id="L3134" title="All 2 branches covered.">        else if (numDecPlaces &gt; 0) {</span>
<span class="fc" id="L3135">            DoubleDouble scale = TEN.pow(numDecPlaces);</span>
<span class="fc" id="L3136">            val2 = val.div(scale);</span>
<span class="fc" id="L3137">        } </span>
<span class="pc bpc" id="L3138" title="1 of 2 branches missed.">        else if (numDecPlaces &lt; 0) {</span>
<span class="fc" id="L3139">            DoubleDouble scale = TEN.pow(-numDecPlaces);</span>
<span class="fc" id="L3140">            val2 = val.mul(scale);</span>
        }
        
        // apply leading sign, if any
<span class="fc bfc" id="L3144" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L3145">            return val2.neg();</span>
        }
<span class="fc" id="L3147">        return val2;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>