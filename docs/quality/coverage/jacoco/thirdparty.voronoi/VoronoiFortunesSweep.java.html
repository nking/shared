<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VoronoiFortunesSweep.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.voronoi</a> &gt; <span class="el_source">VoronoiFortunesSweep.java</span></div><h1>VoronoiFortunesSweep.java</h1><pre class="source lang-java linenums">package thirdparty.voronoi;

import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PolygonAndPointPlotter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;

/**
 * A voronoi diagram is a partitioning of points
 * into cells defined by seed centers.  The cells
 * edges are defined as perpendicular bisectors
 * between 2 seeds, which results in the cells 
 * being regions which are closer to the seed
 * point than to any other seed point.
 * 
 * The sweep line algorithm runtime complexity
 * is  O(n log n).
 * 
  adapted from the following codes:
 
   a port to java of the C++ port of
 * Steven Fortune's original c code.
 * The C++ port by Shane O' Sullivan is at 
 * http://skynet.ie/~sos/mapviewer/voronoi.php
 * and uses a liberal AT&amp;T license.
 * Then 2 ports to java.  
 * https://sourceforge.net/projects/simplevoronoi/postdownload?source=dlp
 * All have liberal licenses listed here:
 
 * The author of this software is Steven Fortune.  Copyright (c) 1994 by AT&amp;T
 * Bell Laboratories.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 
 * This code was originally written by Stephan Fortune in C code.  I, Shane O'Sullivan,
 * have since modified it, encapsulating it in a C++ class and, fixing memory leaks and
 * adding accessors to the Voronoi Edges.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  
 * Java Version by Zhenyu Pan
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 * 
 * in this project:
 * changes to the above java port are essentially 
 * to the comparator and sorting, and an extra check for
 * zero length edges at the end of the method clipLine.
 * Format changes such as camel case are present 
 * here.  Also moved the data classes to inner classes
 * here, and am using specialized classes that already
 * existed in this project such as the PairFloat for 
 * coordinates.
 * 
 * first adapted in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

 */
public class VoronoiFortunesSweep {
    
    private static final int LE = 0;
    private static final int RE = 1;

<span class="fc" id="L91">    private HalfEdge ELleftend = null;</span>
<span class="fc" id="L92">    private HalfEdge ELrightend = null;</span>
    private int ELhashsize;
    private float xmin, xmax, ymin, ymax, deltax, deltay;

<span class="fc" id="L96">    private Site[] sites = null;</span>
<span class="fc" id="L97">    private int nSites = 0;</span>
<span class="fc" id="L98">    private int siteIdx = 0;</span>
    private int sqrtNSites;
<span class="fc" id="L100">    private int nVertices = 0;</span>
<span class="fc" id="L101">    private int nEdges = 0;</span>
    
    private Site bottomsite;
	
    private int	PQcount;
    private int	PQmin;
    private int PQhashsize;
    private HalfEdge[] PQhash;

    private float borderMinX, borderMaxX, borderMinY, borderMaxY;

<span class="fc" id="L112">    private LinkedList&lt;GraphEdge&gt; allEdges = null;</span>

<span class="fc" id="L114">    private float minDistanceBetweenSites = 0;</span>
    
<span class="fc" id="L116">    private HalfEdge[] ELhash = null;</span>
    
    /**
     *
     */
<span class="fc" id="L121">    public VoronoiFortunesSweep() {</span>
<span class="fc" id="L122">        allEdges = new LinkedList&lt;GraphEdge&gt;();</span>
<span class="fc" id="L123">    }</span>
    
    /**
     *
     @return
     */
    public LinkedList&lt;GraphEdge&gt; getAllEdges() {
<span class="fc" id="L130">        return allEdges;</span>
    }
    
    /**
     *
     @param xValues
     @param yValues
     @param minX
     @param maxX
     @param minY
     @param maxY
     @param minDist
     @return
     */
    public boolean generateVoronoi(float[] xValues, float[] yValues, float minX, 
        float maxX, float minY, float maxY, float minDist) {
        
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (xValues.length != yValues.length) {</span>
<span class="nc" id="L148">            throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must be same length&quot;);
        }
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (xValues.length == 0) {</span>
<span class="nc" id="L152">             throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must not be empty&quot;);
        }

<span class="fc" id="L156">        minDistanceBetweenSites = minDist;</span>
    
<span class="fc" id="L158">        siteIdx = 0;</span>
<span class="fc" id="L159">        nSites = xValues.length;</span>
<span class="fc" id="L160">        nVertices = 0;</span>
<span class="fc" id="L161">        nEdges = 0;</span>
<span class="fc" id="L162">        double sn = (double) nSites + 4;</span>
<span class="fc" id="L163">        sqrtNSites = (int) Math.sqrt(sn);</span>

<span class="fc" id="L165">        sites = new Site[nSites];</span>

<span class="fc" id="L167">        xmin = Float.MAX_VALUE;</span>
<span class="fc" id="L168">        ymin = Float.MAX_VALUE;</span>
<span class="fc" id="L169">        xmax = Float.MIN_VALUE;</span>
<span class="fc" id="L170">        ymax = Float.MIN_VALUE;</span>
        
        int i;
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for(i = 0; i &lt; nSites; i++) {</span>
<span class="fc" id="L174">            sites[i] = new Site();</span>
<span class="fc" id="L175">            sites[i].coord = new PairFloat(xValues[i], yValues[i]);</span>
            // this gets reset after sort:
<span class="fc" id="L177">            sites[i].sitenbr = i;</span>
<span class="fc" id="L178">            sites[i].refcnt = 0;</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (xValues[i] &lt; xmin) {</span>
<span class="fc" id="L181">                xmin = xValues[i];</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            } else if (xValues[i] &gt; xmax) {</span>
<span class="fc" id="L183">                xmax = xValues[i];</span>
            }
            
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (yValues[i] &lt; ymin) {</span>
<span class="fc" id="L187">                ymin = yValues[i];</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            } else if (yValues[i] &gt; ymax) {</span>
<span class="fc" id="L189">                ymax = yValues[i];</span>
            }
            
            //printf(&quot;\n%f %f\n&quot;,xValues[i],yValues[i]);
        }
        
        // N log_2 N
<span class="fc" id="L196">        qsort(sites);</span>
        
        // renumber site numbers
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (int ii = 0; ii &lt; sites.length; ++ii) {</span>
<span class="fc" id="L200">            sites[ii].sitenbr = ii;</span>
        }
        
<span class="fc" id="L203">        float temp = 0;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (minX &gt; maxX) {</span>
<span class="nc" id="L205">            temp = minX;</span>
<span class="nc" id="L206">            minX = maxX;</span>
<span class="nc" id="L207">            maxX = temp;</span>
        }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (minY &gt; maxY) {</span>
<span class="nc" id="L210">            temp = minY;</span>
<span class="nc" id="L211">            minY = maxY;</span>
<span class="nc" id="L212">            maxY = temp;</span>
        }
<span class="fc" id="L214">        borderMinX = minX;</span>
<span class="fc" id="L215">        borderMinY = minY;</span>
<span class="fc" id="L216">        borderMaxX = maxX;</span>
<span class="fc" id="L217">        borderMaxY = maxY;</span>
        
<span class="fc" id="L219">        deltay = ymax - ymin;</span>
<span class="fc" id="L220">        deltax = xmax - xmin;</span>
        
<span class="fc" id="L222">        return voronoi();        </span>
    }
    
    /*
       implicit parameters: nsites, sqrt_nsites, 
       xmin, xmax, ymin, ymax, deltax,
       deltay (can all be estimates). 
       Performance suffers if they are wrong;
       better to make nsites, deltax, 
       and deltay too big than too small. (?)
     */
    private boolean voronoi() {
        
        Site newsite, bot, top, temp, p;
        Site v;
<span class="fc" id="L237">        PairFloat newintstar = null;</span>
        int pm;
        HalfEdge lbnd, rbnd, llbnd, rrbnd, bisector;
        Edge e;

<span class="fc" id="L242">        PQInitialize();</span>
<span class="fc" id="L243">        ELInitialize();</span>

<span class="fc" id="L245">        bottomsite = nextOne();</span>
<span class="fc" id="L246">        newsite = nextOne();</span>
        
        while (true) {
            
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (!PQEmpty()) {</span>
<span class="fc" id="L251">                newintstar = PQMin();</span>
            }
            
            // if the lowest site has a smaller y value than 
            // the lowest vector intersection,
            // process the site otherwise process the vector 
            // intersection

<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (newsite != null</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            &amp;&amp; (PQEmpty() || </span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                newsite.coord.getY() &lt; newintstar.getY() || </span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                (newsite.coord.getY() == newintstar.getY() &amp;&amp; </span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                newsite.coord.getX() &lt; newintstar.getX()))) {</span>
                
                // new site is smallest -this is a site event
                         
                // get the first HalfEdge to the LEFT of the new site
<span class="fc" id="L268">                lbnd = ELLeftBnd((newsite.coord));</span>
                
                // get the first HalfEdge to the RIGHT of the new site
<span class="fc" id="L271">                rbnd = lbnd.ELright;</span>
                
                // if this halfedge has no edge,bot =bottom site 
<span class="fc" id="L274">                bot = rightReg(lbnd);</span>
                
                // create a new edge that bisects
<span class="fc" id="L277">                e = bisect(bot, newsite);</span>

                // create a new HalfEdge, setting its ELpm field to 0
<span class="fc" id="L280">                bisector = HECreate(e, LE);</span>
                
                // insert this new bisector edge between the left 
                // and right vectors in a linked list
<span class="fc" id="L284">                ELInsert(lbnd, bisector);</span>

                // if the new bisector intersects with the left edge,
                // remove the left edge's vertex, and put in the new one
<span class="fc bfc" id="L288" title="All 2 branches covered.">                if ((p = intersect(lbnd, bisector)) != null) {</span>
<span class="fc" id="L289">                    PQDelete(lbnd);</span>
<span class="fc" id="L290">                    PQInsert(lbnd, p, dist(p, newsite));</span>
                }
<span class="fc" id="L292">                lbnd = bisector;</span>
                
                // create a new HalfEdge, setting its ELpm field to 1
<span class="fc" id="L295">                bisector = HECreate(e, RE);</span>
                 
                // insert the new HE to the right of the original bisector
                // earlier in the IF stmt
<span class="fc" id="L299">                ELInsert(lbnd, bisector);</span>
                
                // if this new bisector intersects with the new HalfEdge
<span class="fc bfc" id="L302" title="All 2 branches covered.">                if ((p = intersect(bisector, rbnd)) != null) {</span>
                    // push the HE into the ordered linked list of vertices
<span class="fc" id="L304">                    PQInsert(bisector, p, dist(p, newsite));</span>
                }
                
                /*System.out.println(
                &quot;  &quot; + bot.sitenbr + &quot; bot=&quot; 
                + sites[bot.sitenbr].coord
                + &quot;  &quot; + newsite.sitenbr + &quot; top=&quot; 
                + sites[newsite.sitenbr].coord);
                */
                
<span class="fc" id="L314">                newsite = nextOne();</span>
                
<span class="fc bfc" id="L316" title="All 2 branches covered.">            } else if (!PQEmpty()) {</span>
            
                // intersection is smallest - this is a vector event
            
                // pop the HalfEdge with the lowest vector off the ordered list
                // of vectors
<span class="fc" id="L322">                lbnd = PQExtractMin();</span>
                
                // get the HalfEdge to the left of the above HE
<span class="fc" id="L325">                llbnd = lbnd.ELleft;</span>
                
                // get the HalfEdge to the right of the above HE
<span class="fc" id="L328">                rbnd = lbnd.ELright;</span>
                
                // get the HalfEdge to the right of the HE to the right of the
                // lowest HE
<span class="fc" id="L332">                rrbnd = rbnd.ELright;</span>
                
                // get the Site to the left of the left HE which it bisects
<span class="fc" id="L335">                bot = leftReg(lbnd);</span>
                
                // get the Site to the right of the right HE which it bisects
<span class="fc" id="L338">                top = rightReg(rbnd);</span>

                // get the vertex that caused this event
<span class="fc" id="L341">                v = lbnd.vertex;</span>
                
                // set the vertex number - couldn't do this
<span class="fc" id="L344">                makeVertex(v);</span>
                
                // earlier since we didn't know when it would be processed
<span class="fc" id="L347">                endPoint(lbnd.ELedge, lbnd.ELpm, v);</span>
                
                // set the endpoint of
                // the left HalfEdge to be this vector
<span class="fc" id="L351">                endPoint(rbnd.ELedge, rbnd.ELpm, v);</span>
                
                // set the endpoint of the right HalfEdge to
                // be this vector
<span class="fc" id="L355">                ELDelete(lbnd); // mark the lowest HE for</span>
                
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
<span class="fc" id="L359">                PQDelete(rbnd);</span>
                
                // remove all vertex events to do with the right HE
<span class="fc" id="L362">                ELDelete(rbnd); </span>
                
                // mark the right HE for
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
                
                // set the pm variable to zero
<span class="fc" id="L369">                pm = LE;</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">                if (bot.coord.getY() &gt; top.coord.getY()) {</span>
                    // if the site to the left of the event is 
                    // higher than the Site
                    // to the right of it, then swap them and 
                    // set the 'pm' variable to 1
<span class="fc" id="L376">                    temp = bot;</span>
<span class="fc" id="L377">                    bot = top;</span>
<span class="fc" id="L378">                    top = temp;</span>
<span class="fc" id="L379">                    pm = RE;</span>
                }
                
                // create an Edge (or line)
                // that is between the two Sites. This creates the formula of
                // the line, and assigns a line number to it
<span class="fc" id="L385">                e = bisect(bot, top); </span>
                
                // create a HE from the Edge 'e',
                // and make it point to that edge
                // with its ELedge field
<span class="fc" id="L390">                bisector = HECreate(e, pm); </span>
                
                // insert the new bisector to the
                // right of the left HE
<span class="fc" id="L394">                ELInsert(llbnd, bisector);               </span>
                
                // set one endpoint to the new edge
                // to be the vector point 'v'.
                // If the site to the left of this bisector is higher than the
                // right Site, then this endpoint
                // is put in position 0; otherwise in pos 1
<span class="fc" id="L401">                endPoint(e, RE - pm, v);</span>
                
                // if left HE and the new bisector intersect, then delete
                // the left HE, and reinsert it
<span class="fc bfc" id="L405" title="All 2 branches covered.">                if ((p = intersect(llbnd, bisector)) != null) {</span>
<span class="fc" id="L406">                    PQDelete(llbnd);</span>
<span class="fc" id="L407">                    PQInsert(llbnd, p, dist(p, bot));</span>
                }

                // if right HE and the new bisector intersect, then
                // reinsert it
<span class="fc bfc" id="L412" title="All 2 branches covered.">                if ((p = intersect(bisector, rrbnd)) != null) {</span>
<span class="fc" id="L413">                    PQInsert(bisector, p, dist(p, bot));</span>
                }
            } else {
                break;
            }
        }

<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (lbnd = ELleftend.ELright; lbnd != ELrightend; </span>
<span class="fc" id="L421">            lbnd = lbnd.ELright) {</span>
            
<span class="fc" id="L423">            e = lbnd.ELedge;</span>
<span class="fc" id="L424">            clipLine(e);</span>
        }

<span class="fc" id="L427">        return true;</span>
    }

    /**
     *
     @param fileNumber
     */
    public void plot(int fileNumber) {
        
        try {
            
<span class="nc" id="L438">            PolygonAndPointPlotter plotter =</span>
                new PolygonAndPointPlotter(xmin - 1, xmax + 1,
                    ymin - 1, ymax + 1);
        
<span class="nc" id="L442">            LinkedList&lt;GraphEdge&gt; edges = getAllEdges();</span>
<span class="nc" id="L443">            int n = 2*edges.size();</span>
<span class="nc" id="L444">            float[] xPolygon = new float[n];</span>
<span class="nc" id="L445">            float[] yPolygon = new float[n];</span>

<span class="nc" id="L447">            int count = 0;                </span>
        
<span class="nc bnc" id="L449" title="All 2 branches missed.">            for (GraphEdge edge : edges) {</span>
<span class="nc" id="L450">                int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L451">                int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L452">                int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L453">                int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L455">                PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L456">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (p1.equals(p2)) {</span>
<span class="nc" id="L458">                    continue;</span>
                }

<span class="nc" id="L461">                float xp = p1.getX();</span>
<span class="nc" id="L462">                float yp = p1.getY();</span>
<span class="nc" id="L463">                xPolygon[count] = xp;</span>
<span class="nc" id="L464">                yPolygon[count] = yp;</span>
<span class="nc" id="L465">                count++;</span>
                
<span class="nc" id="L467">                xp = p2.getX();</span>
<span class="nc" id="L468">                yp = p2.getY();</span>
<span class="nc" id="L469">                xPolygon[count] = xp;</span>
<span class="nc" id="L470">                yPolygon[count] = yp;</span>
<span class="nc" id="L471">                count++;</span>
<span class="nc" id="L472">            }</span>
            
<span class="nc" id="L474">            xPolygon = Arrays.copyOf(xPolygon, count);</span>
<span class="nc" id="L475">            yPolygon = Arrays.copyOf(yPolygon, count);</span>
            
<span class="nc" id="L477">            n = sites.length;</span>
<span class="nc" id="L478">            float[] x = new float[n];</span>
<span class="nc" id="L479">            float[] y = new float[n];</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L481">                Site site = sites[i];</span>
<span class="nc" id="L482">                x[i] = site.coord.getX();</span>
<span class="nc" id="L483">                y[i] = site.coord.getY();</span>
            }
            
<span class="nc" id="L486">            plotter.addPlotWithLines(x, y, xPolygon, yPolygon,</span>
                &quot;edges&quot;);
            
<span class="nc" id="L489">            plotter.writeFile(fileNumber);</span>
            
<span class="nc" id="L491">        } catch(IOException e) {</span>
<span class="nc" id="L492">            System.err.println(e.getMessage());</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">    }</span>

    private static class SiteComp implements Comparator&lt;Site&gt; {
        @Override
        public int compare(Site o1, Site o2) {
            if (o1.coord.getY() &lt; o2.coord.getY()) {
                return -1;
            } else if (o1.coord.getY() &gt; o2.coord.getY()) {
                return 1;
            } else if (o1.coord.getX() &lt; o2.coord.getX()) {
                return -1;
            } else if (o1.coord.getX() &gt; o2.coord.getX()) {
                return 1;
            }
            return 0;
        }
    }

    private void qsort(Site[] sites) {
<span class="fc" id="L513">        SiteComp comp = new SiteComp();</span>
<span class="fc" id="L514">        Arrays.sort(sites, comp);</span>
<span class="fc" id="L515">    }</span>
    
    /**
     *
     */
    public class Site {
        PairFloat coord;
        int	sitenbr;
	    int	refcnt;

        /**
         *
         @return
         */
        public PairFloat getCoord() {
            return coord;
        }
    }

    private static class Edge {
        float a = 0;
        float b = 0;
        float c = 0;
	    Site[] ep = new Site[2];
	    Site[] reg = new Site[2];
	    int edgenbr;
    }
    
    /**
     *
     */
    public class GraphEdge {

        /**
         *
         */
        public float x1,

        /**
         *
         */
        y1,

        /**
         *
         */
        x2,

        /**
         *
         */
        y2;

        /**
         *
         */
        public int site1;

        /**
         *
         */
        public int site2;
    }
     
    private static class HalfEdge {
	    HalfEdge ELleft = null; 
        HalfEdge ELright = null;
	    Edge ELedge = null;
        boolean deleted;
	    int ELpm;
	    Site vertex = null;
	    float ystar;
	    HalfEdge PQnext = null;
    }

    // return a single in-storage site
    private Site nextOne() {
        Site s;
<span class="fc bfc" id="L593" title="All 2 branches covered.">        if (siteIdx &lt; nSites) {</span>
<span class="fc" id="L594">            s = sites[siteIdx];</span>
<span class="fc" id="L595">            siteIdx += 1;</span>
<span class="fc" id="L596">            return s;</span>
        } else {
<span class="fc" id="L598">            return null;</span>
        }
    }

    private Edge bisect(Site s1, Site s2) {
        float dx, dy, adx, ady;
        Edge newEdge;

<span class="fc" id="L606">        newEdge = new Edge();</span>

        // store the sites that this edge is bisecting
<span class="fc" id="L609">        newEdge.reg[0] = s1;</span>
<span class="fc" id="L610">        newEdge.reg[1] = s2;</span>
        // to begin with, there are no endpoints on the bisector - it goes to
        // infinity
<span class="fc" id="L613">        newEdge.ep[0] = null;</span>
<span class="fc" id="L614">        newEdge.ep[1] = null;</span>

        // get the difference in x dist between the sites
<span class="fc" id="L617">        dx = s2.coord.getX() - s1.coord.getX();</span>
<span class="fc" id="L618">        dy = s2.coord.getY() - s1.coord.getY();</span>
    
        // make sure that the difference in positive
<span class="fc bfc" id="L621" title="All 2 branches covered.">        adx = dx &gt; 0 ? dx : -dx;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        ady = dy &gt; 0 ? dy : -dy;</span>
        
        // get the slope of the line
<span class="fc" id="L625">        newEdge.c = </span>
<span class="fc" id="L626">            (s1.coord.getX() * dx + s1.coord.getY() </span>
                * dy + (dx * dx + dy
                * dy) * 0.5f);

<span class="fc bfc" id="L630" title="All 2 branches covered.">        if (adx &gt; ady) {</span>
            // set formula of line, with x fixed to 1
<span class="fc" id="L632">            newEdge.a = 1.0f;</span>
<span class="fc" id="L633">            newEdge.b = dy / dx;</span>
<span class="fc" id="L634">            newEdge.c /= dx;</span>
        } else {
            // set formula of line, with y fixed to 1
<span class="fc" id="L637">            newEdge.b = 1.0f;</span>
<span class="fc" id="L638">            newEdge.a = dx / dy;</span>
<span class="fc" id="L639">            newEdge.c /= dy;</span>
        }

<span class="fc" id="L642">        newEdge.edgenbr = nEdges;</span>

<span class="fc" id="L644">        nEdges += 1;</span>
        
<span class="fc" id="L646">        return newEdge;</span>
    }
    
    /**
     *
     @return
     */
    public Site[] getSites() {
<span class="fc" id="L654">        return sites;</span>
    }

    private void makeVertex(Site v) {
<span class="fc" id="L658">        v.sitenbr = nVertices;</span>
<span class="fc" id="L659">        nVertices += 1;</span>
<span class="fc" id="L660">    }</span>

    private void PQInitialize() {
<span class="fc" id="L663">        PQcount = 0;</span>
<span class="fc" id="L664">        PQmin = 0;</span>
<span class="fc" id="L665">        PQhashsize = 4 * sqrtNSites;</span>
<span class="fc" id="L666">        PQhash = new HalfEdge[PQhashsize];</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (int i = 0; i &lt; PQhashsize; i += 1) {</span>
<span class="fc" id="L669">            PQhash[i] = new HalfEdge();</span>
        }
<span class="fc" id="L671">    }</span>

    private int PQBucket(HalfEdge he) {
        int bucket;

<span class="fc" id="L676">        bucket = (int) ((he.ystar - ymin) / deltay * PQhashsize);</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L678">            bucket = 0;</span>
        }
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (bucket &gt;= PQhashsize) {</span>
<span class="fc" id="L681">            bucket = PQhashsize - 1;</span>
        }
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (bucket &lt; PQmin) {</span>
<span class="fc" id="L684">            PQmin = bucket;</span>
        }
<span class="fc" id="L686">        return bucket;</span>
    }

    // push the HalfEdge into the ordered linked list of vertices
    private void PQInsert(HalfEdge he, Site v, float offset) {
        
        HalfEdge last;
        HalfEdge next;

<span class="fc" id="L695">        he.vertex = v;</span>
<span class="fc" id="L696">        he.ystar = (v.coord.getY() + offset);</span>
<span class="fc" id="L697">        last = PQhash[PQBucket(he)];</span>
  
        // TODO: for the cases where the number
        //  of items in the linked list is getting
        //  large enough that this is not approx O(1),
        //  could initialize a specialized comparator
        //  with v.coord.getX()
        //  and store the nodes in a java LinkedList in this bin
        //  instead of a linked list
        //  and use Collections.binarySearch and the comparator with
        //  a small scan to find the last node matching
        // the criteria.
<span class="fc bfc" id="L709" title="All 6 branches covered.">        while ((next = last.PQnext) != null</span>
            &amp;&amp; (he.ystar &gt; next.ystar
               || (he.ystar == next.ystar
<span class="fc bfc" id="L712" title="All 2 branches covered.">               &amp;&amp; v.coord.getX() &gt; next.vertex.coord.getX()))) {</span>
<span class="fc" id="L713">            last = next;</span>
        }
<span class="fc" id="L715">        he.PQnext = last.PQnext;</span>
<span class="fc" id="L716">        last.PQnext = he;</span>
<span class="fc" id="L717">        PQcount += 1;</span>
<span class="fc" id="L718">    }</span>

    // remove the HalfEdge from the list of vertices
    private void PQDelete(HalfEdge he) {
        
        HalfEdge last;

<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (he.vertex != null) {</span>
<span class="fc" id="L726">            last = PQhash[PQBucket(he)];</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            while (last.PQnext != he) {</span>
<span class="fc" id="L728">                last = last.PQnext;</span>
            }

<span class="fc" id="L731">            last.PQnext = he.PQnext;</span>
<span class="fc" id="L732">            PQcount -= 1;</span>
<span class="fc" id="L733">            he.vertex = null;</span>
        }
<span class="fc" id="L735">    }</span>

    private boolean PQEmpty() {
<span class="fc bfc" id="L738" title="All 2 branches covered.">        return (PQcount == 0);</span>
    }

    private PairFloat PQMin() {
        
<span class="fc bfc" id="L743" title="All 2 branches covered.">        while (PQhash[PQmin].PQnext == null) {</span>
<span class="fc" id="L744">            PQmin += 1;</span>
        }
        
<span class="fc" id="L747">        PairFloat answer = new PairFloat(</span>
<span class="fc" id="L748">            PQhash[PQmin].PQnext.vertex.coord.getX(),</span>
            PQhash[PQmin].PQnext.ystar);
        
<span class="fc" id="L751">        return answer;</span>
    }

    private HalfEdge PQExtractMin() {
        HalfEdge curr;

<span class="fc" id="L757">        curr = PQhash[PQmin].PQnext;</span>
<span class="fc" id="L758">        PQhash[PQmin].PQnext = curr.PQnext;</span>
<span class="fc" id="L759">        PQcount -= 1;</span>
<span class="fc" id="L760">        return curr;</span>
    }

    private HalfEdge HECreate(Edge e, int pm) {
        HalfEdge answer;
<span class="fc" id="L765">        answer = new HalfEdge();</span>
<span class="fc" id="L766">        answer.ELedge = e;</span>
<span class="fc" id="L767">        answer.ELpm = pm;</span>
<span class="fc" id="L768">        answer.PQnext = null;</span>
<span class="fc" id="L769">        answer.vertex = null;</span>
<span class="fc" id="L770">        return answer;</span>
    }

    private void ELInitialize() {
        
<span class="fc" id="L775">        ELhashsize = 2 * sqrtNSites;</span>
<span class="fc" id="L776">        ELhash = new HalfEdge[ELhashsize];</span>

<span class="fc" id="L778">        ELleftend = HECreate(null, 0);</span>
<span class="fc" id="L779">        ELrightend = HECreate(null, 0);</span>
        
<span class="fc" id="L781">        ELleftend.ELleft = null;</span>
<span class="fc" id="L782">        ELleftend.ELright = ELrightend;</span>
<span class="fc" id="L783">        ELrightend.ELleft = ELleftend;</span>
<span class="fc" id="L784">        ELrightend.ELright = null;</span>
        
<span class="fc" id="L786">        ELhash[0] = ELleftend;</span>
<span class="fc" id="L787">        ELhash[ELhashsize - 1] = ELrightend;</span>
<span class="fc" id="L788">    }</span>

    private Site leftReg(HalfEdge he) {
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        if (he.ELedge == null) {</span>
<span class="nc" id="L792">            return bottomsite;</span>
        }
<span class="fc bfc" id="L794" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[LE] : </span>
<span class="fc" id="L795">            he.ELedge.reg[RE];</span>
    }

    private void ELInsert(HalfEdge lb, HalfEdge newHe) {
<span class="fc" id="L799">        newHe.ELleft = lb;</span>
<span class="fc" id="L800">        newHe.ELright = lb.ELright;</span>
<span class="fc" id="L801">        (lb.ELright).ELleft = newHe;</span>
<span class="fc" id="L802">        lb.ELright = newHe;</span>
<span class="fc" id="L803">    }</span>

    /*
     * This delete routine can't reclaim node, since pointers from hash table
     * may be present.
     */
    private void ELDelete(HalfEdge he) {
<span class="fc" id="L810">        (he.ELleft).ELright = he.ELright;</span>
<span class="fc" id="L811">        (he.ELright).ELleft = he.ELleft;</span>
<span class="fc" id="L812">        he.deleted = true;</span>
<span class="fc" id="L813">    }</span>

    // Get entry from hash table, pruning any deleted nodes
    private HalfEdge ELGetHash(int b) {
        HalfEdge he;

<span class="pc bpc" id="L819" title="2 of 4 branches missed.">        if (b &lt; 0 || b &gt;= ELhashsize) {</span>
<span class="nc" id="L820">            return null;</span>
        }
<span class="fc" id="L822">        he = ELhash[b];</span>
<span class="fc bfc" id="L823" title="All 4 branches covered.">        if (he == null || !he.deleted) {</span>
<span class="fc" id="L824">            return he;</span>
        }

        // Hash table points to deleted half edge. Patch 
        // as necessary.
<span class="fc" id="L829">        ELhash[b] = null;</span>
        
<span class="fc" id="L831">        return null;</span>
    }

    private HalfEdge ELLeftBnd(PairFloat p) {
        int i, bucket;
        HalfEdge he;

        // Use hash table to get close to desired halfedge
        // use the hash function to find the place in the hash map that this
        // HalfEdge should be
<span class="fc" id="L841">        bucket = (int) ((p.getX() - xmin) / deltax * ELhashsize);</span>

        // make sure that the bucket position in within the range of the hash
        // array
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L846">            bucket = 0;</span>
        }
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (bucket &gt;= ELhashsize) {</span>
<span class="fc" id="L849">            bucket = ELhashsize - 1;</span>
        }

<span class="fc" id="L852">        he = ELGetHash(bucket);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (he == null) {</span>
            
            //TODO: could improve this with a datastructure
            // that has predecessor and successor
            
            // if the HE isn't found, search backwards and forwards in the hash map
            // for the first non-null entry
       
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">            for (i = 1; i &lt; ELhashsize; i += 1) {</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                if ((he = ELGetHash(bucket - i)) != null) {</span>
<span class="fc" id="L863">                    break;</span>
                }
<span class="fc bfc" id="L865" title="All 2 branches covered.">                if ((he = ELGetHash(bucket + i)) != null) {</span>
<span class="fc" id="L866">                    break;</span>
                }
            }
            
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">            if (he == null) {</span>
<span class="nc" id="L871">                throw new IllegalStateException(&quot;no left half edges.&quot; </span>
                  + &quot;check input data float[] xValues, float[] yValues&quot;);
            }
        }
        
        // Now search linear list of halfedges for the correct one
<span class="fc bfc" id="L877" title="All 4 branches covered.">        if (he == ELleftend || </span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        (he != ELrightend &amp;&amp; rightOf(he, p))) {</span>
            // keep going right on the list until either the end is reached, or
            // you find the 1st edge which the point isn't to the right of
            do {
<span class="fc" id="L882">                he = he.ELright;</span>
<span class="fc bfc" id="L883" title="All 4 branches covered.">            } while (he != ELrightend &amp;&amp; rightOf(he, p));</span>
<span class="fc" id="L884">            he = he.ELleft;</span>
        } else {
            // if the point is to the left of the HalfEdge, then search left for
            // the HE just to the left of the point
        
            do {
<span class="fc" id="L890">                he = he.ELleft;</span>
<span class="fc bfc" id="L891" title="All 4 branches covered.">            } while (he != ELleftend &amp;&amp; !rightOf(he, p));</span>
        }

        // Update hash table and reference counts
<span class="fc bfc" id="L895" title="All 4 branches covered.">        if (bucket &gt; 0 &amp;&amp; bucket &lt; ELhashsize - 1) {</span>
<span class="fc" id="L896">            ELhash[bucket] = he;</span>
        }
<span class="fc" id="L898">        return he;</span>
    }

    private void pushGraphEdge(Site leftSite, Site rightSite, 
        float x1, float y1, float x2, float y2) {
      
<span class="fc" id="L904">        GraphEdge newEdge = new GraphEdge();</span>
<span class="fc" id="L905">        allEdges.add(newEdge);</span>
<span class="fc" id="L906">        newEdge.x1 = x1;</span>
<span class="fc" id="L907">        newEdge.y1 = y1;</span>
<span class="fc" id="L908">        newEdge.x2 = x2;</span>
<span class="fc" id="L909">        newEdge.y2 = y2;</span>

<span class="fc" id="L911">        newEdge.site1 = leftSite.sitenbr;</span>
<span class="fc" id="L912">        newEdge.site2 = rightSite.sitenbr;</span>
<span class="fc" id="L913">    }</span>

    private void clipLine(Edge e) {
        float pxmin, pxmax, pymin, pymax;
        Site s1, s2;
<span class="fc" id="L918">        float x1 = 0, x2 = 0, y1 = 0, y2 = 0;</span>

<span class="fc" id="L920">        x1 = e.reg[0].coord.getX();</span>
<span class="fc" id="L921">        x2 = e.reg[1].coord.getX();</span>
<span class="fc" id="L922">        y1 = e.reg[0].coord.getY();</span>
<span class="fc" id="L923">        y2 = e.reg[1].coord.getY();</span>

        // if the distance between the two points this line 
        // was created from is
        // less than the square root of 2, then ignore it
<span class="fc bfc" id="L928" title="All 2 branches covered.">        if (Math.sqrt(((x2 - x1) * (x2 - x1)) </span>
            + ((y2 - y1) * (y2 - y1))) &lt; minDistanceBetweenSites) {
<span class="fc" id="L930">            return;</span>
        }
<span class="fc" id="L932">        pxmin = borderMinX;</span>
<span class="fc" id="L933">        pxmax = borderMaxX;</span>
<span class="fc" id="L934">        pymin = borderMinY;</span>
<span class="fc" id="L935">        pymax = borderMaxY;</span>

<span class="fc bfc" id="L937" title="All 4 branches covered.">        if (e.a == 1.0 &amp;&amp; e.b &gt;= 0.0) {</span>
<span class="fc" id="L938">            s1 = e.ep[1];</span>
<span class="fc" id="L939">            s2 = e.ep[0];</span>
        } else {
<span class="fc" id="L941">            s1 = e.ep[0];</span>
<span class="fc" id="L942">            s2 = e.ep[1];</span>
        }

<span class="fc bfc" id="L945" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L946">            y1 = pymin;</span>
<span class="fc bfc" id="L947" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getY() &gt; pymin) {</span>
<span class="fc" id="L948">                y1 = s1.coord.getY();</span>
            }
<span class="fc bfc" id="L950" title="All 2 branches covered.">            if (y1 &gt; pymax) {</span>
<span class="fc" id="L951">                y1 = pymax;</span>
            }
<span class="fc" id="L953">            x1 = e.c - e.b * y1;</span>
<span class="fc" id="L954">            y2 = pymax;</span>
<span class="fc bfc" id="L955" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getY() &lt; pymax) {</span>
<span class="fc" id="L956">                y2 = s2.coord.getY();</span>
            }

<span class="fc bfc" id="L959" title="All 2 branches covered.">            if (y2 &lt; pymin) {</span>
<span class="fc" id="L960">                y2 = pymin;</span>
            }
<span class="fc" id="L962">            x2 = (e.c) - (e.b) * y2;</span>
<span class="pc bpc" id="L963" title="1 of 10 branches missed.">            if (((x1 &gt; pxmax) &amp; (x2 &gt; pxmax)) | ((x1 &lt; pxmin) &amp; (x2 &lt; pxmin))) {</span>
<span class="nc" id="L964">                return;</span>
            }
<span class="fc bfc" id="L966" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L967">                x1 = pxmax;</span>
<span class="fc" id="L968">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L970" title="All 2 branches covered.">            if (x1 &lt; pxmin) {</span>
<span class="fc" id="L971">                x1 = pxmin;</span>
<span class="fc" id="L972">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L974" title="All 2 branches covered.">            if (x2 &gt; pxmax) {</span>
<span class="fc" id="L975">                x2 = pxmax;</span>
<span class="fc" id="L976">                y2 = (e.c - x2) / e.b;</span>
            }
<span class="fc bfc" id="L978" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L979">                x2 = pxmin;</span>
<span class="fc" id="L980">                y2 = (e.c - x2) / e.b;</span>
            }
        } else {
<span class="fc" id="L983">            x1 = pxmin;</span>
<span class="fc bfc" id="L984" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getX() &gt; pxmin) {</span>
<span class="fc" id="L985">                x1 = s1.coord.getX();</span>
            }
<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L988">                x1 = pxmax;</span>
            }
<span class="fc" id="L990">            y1 = e.c - e.a * x1;</span>
<span class="fc" id="L991">            x2 = pxmax;</span>
<span class="fc bfc" id="L992" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getX() &lt; pxmax) {</span>
<span class="fc" id="L993">                x2 = s2.coord.getX();</span>
            }
<span class="fc bfc" id="L995" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L996">                x2 = pxmin;</span>
            }
<span class="fc" id="L998">            y2 = e.c - e.a * x2;</span>
<span class="pc bpc" id="L999" title="4 of 10 branches missed.">            if (((y1 &gt; pymax) &amp; (y2 &gt; pymax)) | ((y1 &lt; pymin) &amp; (y2 &lt; pymin))) {</span>
<span class="nc" id="L1000">                return;</span>
            }
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">            if (y1 &gt; pymax) {</span>
<span class="nc" id="L1003">                y1 = pymax;</span>
<span class="nc" id="L1004">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">            if (y1 &lt; pymin) {</span>
<span class="nc" id="L1007">                y1 = pymin;</span>
<span class="nc" id="L1008">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            if (y2 &gt; pymax) {</span>
<span class="fc" id="L1011">                y2 = pymax;</span>
<span class="fc" id="L1012">                x2 = (e.c - y2) / e.a;</span>
            }
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">            if (y2 &lt; pymin) {</span>
<span class="nc" id="L1015">                y2 = pymin;</span>
<span class="nc" id="L1016">                x2 = (e.c - y2) / e.a;</span>
            }
        }
        
<span class="fc" id="L1020">        float diffX = x2 - x1;</span>
<span class="fc" id="L1021">        float diffY = y2 - y1;</span>
        //this, unfortunately, removes possible edges for
        // points composed of only a straight line
        //if (diffX == 0.f &amp;&amp; diffY == 0.f) {
        //    return;
        //}
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        if (Math.sqrt((diffX * diffX) + (diffY * diffY)) </span>
            &lt; minDistanceBetweenSites) {
<span class="fc" id="L1029">            return;</span>
        }
        
<span class="fc" id="L1032">        pushGraphEdge(e.reg[0], e.reg[1], x1, y1, x2, y2);</span>
<span class="fc" id="L1033">    }</span>

    private void endPoint(Edge e, int lr, Site s) {
<span class="fc" id="L1036">        e.ep[lr] = s;</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">        if (e.ep[RE - lr] == null) {</span>
<span class="fc" id="L1038">            return;</span>
        }
<span class="fc" id="L1040">        clipLine(e);</span>
<span class="fc" id="L1041">    }</span>

    // returns 1 if p is to right of halfedge e
    private boolean rightOf(HalfEdge el, PairFloat p) {
        Edge e;
        Site topsite;
        boolean rightOfSite;
        boolean above, fast;
        float dxp, dyp, dxs, t1, t2, t3, yl;

<span class="fc" id="L1051">        e = el.ELedge;</span>
<span class="fc" id="L1052">        topsite = e.reg[1];</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">        if (p.getX() &gt; topsite.coord.getX()) {</span>
<span class="fc" id="L1054">            rightOfSite = true;</span>
        } else {
<span class="fc" id="L1056">            rightOfSite = false;</span>
        }
<span class="fc bfc" id="L1058" title="All 4 branches covered.">        if (rightOfSite &amp;&amp; el.ELpm == LE) {</span>
<span class="fc" id="L1059">            return true;</span>
        }
<span class="fc bfc" id="L1061" title="All 4 branches covered.">        if (!rightOfSite &amp;&amp; el.ELpm == RE) {</span>
<span class="fc" id="L1062">            return false;</span>
        }

<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L1066">            dyp = p.getY() - topsite.coord.getY();</span>
<span class="fc" id="L1067">            dxp = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L1068">            fast = false;</span>
<span class="fc bfc" id="L1069" title="All 8 branches covered.">            if ((!rightOfSite &amp; (e.b &lt; 0.0)) | (rightOfSite &amp; (e.b &gt;= 0.0))) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">                above = dyp &gt;= e.b * dxp;</span>
<span class="fc" id="L1071">                fast = above;</span>
            } else {
<span class="fc bfc" id="L1073" title="All 2 branches covered.">                above = p.getX() + p.getY() * e.b &gt; e.c;</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                    above = !above;</span>
                }
<span class="fc bfc" id="L1077" title="All 2 branches covered.">                if (!above) {</span>
<span class="fc" id="L1078">                    fast = true;</span>
                }
            }
<span class="fc bfc" id="L1081" title="All 2 branches covered.">            if (!fast) {</span>
<span class="fc" id="L1082">                dxs = topsite.coord.getX() - (e.reg[0]).coord.getX();</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                above = e.b * (dxp * dxp - dyp * dyp) &lt; dxs * dyp</span>
                    * (1.0 + 2.0 * dxp / dxs + e.b * e.b);
<span class="fc bfc" id="L1085" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                    above = !above;</span>
                }
            }
        } else /* e.b==1.0 */ {
<span class="fc" id="L1090">            yl = e.c - e.a * p.getX();</span>
<span class="fc" id="L1091">            t1 = p.getY() - yl;</span>
<span class="fc" id="L1092">            t2 = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L1093">            t3 = yl - topsite.coord.getY();</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">            above = t1 * t1 &gt; t2 * t2 + t3 * t3;</span>
        }
<span class="fc bfc" id="L1096" title="All 4 branches covered.">        return el.ELpm == LE ? above : !above;</span>
    }

    private Site rightReg(HalfEdge he) {
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (he.ELedge == (Edge) null) {</span>
            // if this halfedge has no edge, return the bottom site (whatever
            // that is)
        
<span class="fc" id="L1104">            return bottomsite;</span>
        }

        // if the ELpm field is zero, return the site 0 that this edge bisects,
        // otherwise return site number 1
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[RE] : </span>
<span class="fc" id="L1110">            he.ELedge.reg[LE];</span>
    }

    private float dist(Site s, Site t) {
        float dx, dy;
<span class="fc" id="L1115">        dx = s.coord.getX() - t.coord.getX();</span>
<span class="fc" id="L1116">        dy = s.coord.getY() - t.coord.getY();</span>
<span class="fc" id="L1117">        return (float) (Math.sqrt(dx * dx + dy * dy));</span>
    }

    // create a new site where the HalfEdges el1 and el2 intersect - note that
    // the Point in the argument list is not used, don't know why it's there
    private Site intersect(HalfEdge el1, HalfEdge el2) {
        Edge e1, e2, e;
        HalfEdge el;
        float d, xint, yint;
        boolean rightOfSite;
        Site v;

<span class="fc" id="L1129">        e1 = el1.ELedge;</span>
<span class="fc" id="L1130">        e2 = el2.ELedge;</span>
<span class="fc bfc" id="L1131" title="All 4 branches covered.">        if (e1 == null || e2 == null) {</span>
<span class="fc" id="L1132">            return null;</span>
        }

        // if the two edges bisect the same parent, return null
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        if (e1.reg[1].equals(e2.reg[1])) {</span>
<span class="fc" id="L1137">            return null;</span>
        }

<span class="fc" id="L1140">        d = e1.a * e2.b - e1.b * e2.a;</span>
<span class="fc bfc" id="L1141" title="All 4 branches covered.">        if (-1.0e-10 &lt; d &amp;&amp; d &lt; 1.0e-10) {</span>
<span class="fc" id="L1142">            return null;</span>
        }

<span class="fc" id="L1145">        xint = (e1.c * e2.b - e2.c * e1.b) / d;</span>
<span class="fc" id="L1146">        yint = (e2.c * e1.a - e1.c * e2.a) / d;</span>

<span class="fc bfc" id="L1148" title="All 2 branches covered.">        if ((e1.reg[1].coord.getY() &lt; e2.reg[1].coord.getY())</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            || (e1.reg[1].coord.getY() == e2.reg[1].coord.getY() </span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">            &amp;&amp; e1.reg[1].coord.getX() &lt; e2.reg[1].coord.getX())) {</span>
<span class="fc" id="L1151">            el = el1;</span>
<span class="fc" id="L1152">            e = e1;</span>
        } else {
<span class="fc" id="L1154">            el = el2;</span>
<span class="fc" id="L1155">            e = e2;</span>
        }

<span class="fc bfc" id="L1158" title="All 2 branches covered.">        rightOfSite = xint &gt;= e.reg[1].coord.getX();</span>
<span class="fc bfc" id="L1159" title="All 8 branches covered.">        if ((rightOfSite &amp;&amp; el.ELpm == LE)</span>
            || (!rightOfSite &amp;&amp; el.ELpm == RE)) {
<span class="fc" id="L1161">            return null;</span>
        }

        // create a new site at the point of intersection - this is a new vector
        // event waiting to happen
<span class="fc" id="L1166">        v = new Site();</span>
<span class="fc" id="L1167">        v.coord = new PairFloat(xint, yint);</span>
<span class="fc" id="L1168">        return v;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>