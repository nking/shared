<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NodeMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.util</a> &gt; <span class="el_source">NodeMap.java</span></div><h1>NodeMap.java</h1><pre class="source lang-java linenums">/**
// This is an extension of and edits to TLongLongHashMap from the trove4j library
// downloaded from https://bitbucket.org/trove4j/trove/overview
// 
//   extended to add arrays to hold more values for the same key, specifically
     for nodes having parent, left, right, value, color and size.
// 
// The original copyright is:
// Copyright (c) 2001, Eric D. Friedman All Rights Reserved.
// Copyright (c) 2009, Rob Eden All Rights Reserved.
// Copyright (c) 2009, Jeff Randall All Rights Reserved.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// @author Eric D. Friedman
// @author Rob Eden
// @author Jeff Randall
// @version $Id: _K__V_HashMap.template,v 1.1.2.16 2010/03/02 04:09:50 robeden Exp $
*/
package algorithms.util;

import gnu.trove.map.TLongLongMap;
import gnu.trove.set.*;
import gnu.trove.iterator.*;
import gnu.trove.impl.hash.*;
import gnu.trove.impl.HashFunctions;
import gnu.trove.set.hash.TLongHashSet;

import java.io.*;
import java.util.*;

/**
 * An open addressed Map implementation for long keys and 
 *    long, long, long, int, int, int values.
 * 
 * Note that the structure was built specifically to hold fields for a tree node,
 * so there are special rules used to help define that a value has not been
 * set.
 * 
 * The key is the unique key for an entry.
 *    parent is LONG.MIN_VALUE when not used.
 *    left is LONG.MIN_VALUE when not used.
 *    right is LONG.MIN_VALUE when not used.
 *    value, as soon as the entry exists, always has a used value.
 *    color, as soon as the entry exists, always has a used value.
 *    size, as soon as the entry exists, always has a used value.
 *
 * Note that equals and hashcode use key and value only.
 * 
 */
public class NodeMap extends TLongIntHash implements 
    Externalizable {
    
    static final long serialVersionUID = 12325L;

    /** the values of the map */
    protected transient long[] _parents;

    /**
     *
     */
    protected transient long[] _lefts;

    /**
     *
     */
    protected transient long[] _rights;

    /**
     *
     */
    protected transient int[] _values;

    /**
     *
     */
    protected transient int[] _colors;

    /**
     *
     */
    protected transient int[] _sizes;
    
    /**
     *
     */
<span class="pc" id="L98">    protected final long noLinkValue = Long.MIN_VALUE;</span>

    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance with the default
     * capacity and load factor.
     */
    public NodeMap() {
<span class="fc" id="L105">        super();</span>
<span class="fc" id="L106">        no_entry_key = 0;</span>
<span class="fc" id="L107">    }</span>


    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance with a prime
     * capacity equal to or greater than &lt;em&gt;initialCapacity&lt;/em&gt; and
     * with the default load factor.
     *
     @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     */
    public NodeMap( int initialCapacity ) {
<span class="fc" id="L118">        super( initialCapacity );</span>
<span class="fc" id="L119">        no_entry_key = 0;</span>
<span class="fc" id="L120">    }</span>


    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance with a prime
     * capacity equal to or greater than &lt;em&gt;initialCapacity&lt;/em&gt; and
     * with the specified load factor.
     *
     @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     @param loadFactor a &lt;code&gt;float&lt;/code&gt; value
     */
    public NodeMap( int initialCapacity, float loadFactor ) {
<span class="nc" id="L132">        super( initialCapacity, loadFactor );</span>
<span class="nc" id="L133">        no_entry_key = 0;</span>
<span class="nc" id="L134">    }</span>


    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance with a prime
     * capacity equal to or greater than &lt;em&gt;initialCapacity&lt;/em&gt; and
     * with the specified load factor.
     * 
     * Note that the &quot;no link value&quot; is fixed to Long.MIN_VALUE.
     *
     @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     @param loadFactor a &lt;code&gt;float&lt;/code&gt; value
     @param noEntryKey a &lt;code&gt;long&lt;/code&gt; value that represents
     *                   &lt;em&gt;null&lt;/em&gt; for the Key set.
     @param noEntryValue a &lt;code&gt;int&lt;/code&gt; value that represents
     *                   &lt;em&gt;null&lt;/em&gt; for the Value set.
     */
    public NodeMap( int initialCapacity, float loadFactor,
        long noEntryKey, int noEntryValue) {
<span class="nc" id="L153">        super( initialCapacity, loadFactor, noEntryKey, noEntryValue);</span>
<span class="nc" id="L154">        no_entry_key = 0;</span>
<span class="nc" id="L155">    }</span>


    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance containing
     * all of the entries in the map passed in.
     *      *
     @param keys a &lt;em&gt;long&lt;/em&gt; array containing the keys for the matching values.
     *  
     @param parents is &lt;em&gt;long&lt;/em&gt; array containing the first entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;parent&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param lefts is &lt;code&gt;long&lt;/code&gt; array containing the second entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;left&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param rights is &lt;code&gt;long&lt;/code&gt; array containing the third entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;right&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param values is &lt;code&gt;int&lt;/code&gt; array containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;standard value&lt;/em&gt; field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param colors is &lt;code&gt;int&lt;/code&gt; array containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;color&lt;/em&gt; value field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param sizes &lt;code&gt;int&lt;/code&gt; array containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;size&lt;/em&gt; value field
           holding the size of the subtree of this node.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
     */
    public NodeMap( long[] keys, 
        long[] parents, long[] lefts, long[] rights, 
        int[] values, int[] colors, int[] sizes) {
        
<span class="fc" id="L197">        super(Math.max(keys.length, parents.length ) );</span>
        
<span class="fc" id="L199">        no_entry_key = 0;</span>
        
<span class="pc bpc" id="L201" title="6 of 12 branches missed.">        if (keys.length != parents.length ||</span>
            keys.length != lefts.length ||
            keys.length != rights.length ||
            keys.length != values.length ||
            keys.length != colors.length ||
            keys.length != sizes.length) {
<span class="nc" id="L207">            throw new IllegalArgumentException(&quot;all arrays must be same length&quot;);</span>
        }

<span class="fc" id="L210">        int size = Math.min(keys.length, parents.length );</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for ( int i = 0; i &lt; size; i++ ) {</span>
<span class="fc" id="L212">            this.put(keys[i], </span>
                parents[i], lefts[i], rights[i],
                values[i], colors[i], sizes[i]);
        }
<span class="fc" id="L216">    }</span>
    
    /**
     * from THash, a fast ceiling 
     @param v
     @return 
     */
    protected static long fastCeil( double v ) {
<span class="fc" id="L224">        long possible_result = ( long ) v;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if ( v - possible_result &gt; 0 ) possible_result++;</span>
<span class="fc" id="L226">        return possible_result;</span>
    }

    /* precondition: v &gt; 0 */

    /**
     *
     @param v
     @return
     */

    protected static int saturatedCast(long v) {
<span class="fc" id="L238">        int r = (int) (v &amp; 0x7fffffff); // removing sign bit</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (r != v) {</span>
<span class="nc" id="L240">            return Integer.MAX_VALUE;</span>
        }
<span class="fc" id="L242">        return r;</span>
    }

    /**
     * Creates a new &lt;code&gt;TLongLongHashMap&lt;/code&gt; instance containing
     * all of the entries in the map passed in.
     *
     @param map a &lt;code&gt;TLongLongMap&lt;/code&gt; that will be duplicated.
     */
    public NodeMap( 
        NodeMap map ) {
        
<span class="fc" id="L254">        super( map.size() );</span>
        
<span class="fc" id="L256">        NodeMap hashmap </span>
            = ( NodeMap ) map;
<span class="fc" id="L258">        this._loadFactor = Math.abs( hashmap._loadFactor );</span>
<span class="fc" id="L259">        this.no_entry_key = hashmap.no_entry_key;</span>
<span class="fc" id="L260">        this.no_entry_value = hashmap.no_entry_value;</span>
        
        //noinspection RedundantCast
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if ( this.no_entry_key != ( long ) 0 ) {</span>
<span class="nc" id="L264">            Arrays.fill( _set, this.no_entry_key );</span>
        }
                
<span class="fc" id="L267">        setUp( saturatedCast( </span>
<span class="fc" id="L268">            fastCeil( DEFAULT_CAPACITY / (double) _loadFactor ) ) );</span>
         
<span class="fc" id="L270">        Arrays.fill(_parents, this.noLinkValue );</span>
<span class="fc" id="L271">        Arrays.fill(_lefts, this.noLinkValue );</span>
<span class="fc" id="L272">        Arrays.fill(_rights, this.noLinkValue );</span>
<span class="fc" id="L273">        Arrays.fill(_values, this.no_entry_value );</span>
<span class="fc" id="L274">        Arrays.fill(_colors, this.no_entry_value );</span>
<span class="fc" id="L275">        Arrays.fill(_sizes, this.no_entry_value );</span>
       
<span class="fc" id="L277">        putAll( map );</span>
<span class="fc" id="L278">    }</span>


    /**
     * initializes the hashtable to a prime capacity which is at least
     * &lt;code&gt;initialCapacity + 1&lt;/code&gt;.
     *
     @param initialCapacity an &lt;code&gt;int&lt;/code&gt; value
     @return the actual capacity chosen
     */
    protected int setUp( int initialCapacity ) {
        int capacity;

<span class="fc" id="L291">        capacity = super.setUp( initialCapacity );</span>
<span class="fc" id="L292">        _parents = new long[capacity];</span>
<span class="fc" id="L293">        _lefts = new long[capacity];</span>
<span class="fc" id="L294">        _rights = new long[capacity];</span>
<span class="fc" id="L295">        _values = new int[capacity];</span>
<span class="fc" id="L296">        _colors = new int[capacity];</span>
<span class="fc" id="L297">        _sizes = new int[capacity];</span>
<span class="fc" id="L298">        return capacity;</span>
    }


    /**
     * rehashes the map to the new capacity.
     *
     @param newCapacity an &lt;code&gt;int&lt;/code&gt; value
     */
     /** {@inheritDoc} */
    protected void rehash( int newCapacity ) {
        
<span class="fc" id="L310">        int oldCapacity = _set.length;</span>
        
<span class="fc" id="L312">        long oldKeys[] = _set;</span>
<span class="fc" id="L313">        long oldVals0[] = _parents;</span>
<span class="fc" id="L314">        long oldVals1[] = _lefts;</span>
<span class="fc" id="L315">        long oldVals2[] = _rights;</span>
<span class="fc" id="L316">        int oldVals3[] = _values;</span>
<span class="fc" id="L317">        int oldVals4[] = _colors;</span>
<span class="fc" id="L318">        int oldVals5[] = _sizes;</span>
<span class="fc" id="L319">        byte oldStates[] = _states;</span>

<span class="fc" id="L321">        _set = new long[newCapacity];</span>
<span class="fc" id="L322">        _parents = new long[newCapacity];</span>
<span class="fc" id="L323">        _lefts = new long[newCapacity];</span>
<span class="fc" id="L324">        _rights = new long[newCapacity];</span>
<span class="fc" id="L325">        _values = new int[newCapacity];</span>
<span class="fc" id="L326">        _colors = new int[newCapacity];</span>
<span class="fc" id="L327">        _sizes = new int[newCapacity];</span>
<span class="fc" id="L328">        _states = new byte[newCapacity];</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        for ( int i = oldCapacity; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if( oldStates[i] == FULL ) {</span>
<span class="fc" id="L332">                long o = oldKeys[i];</span>
<span class="fc" id="L333">                int index = insertKey( o );</span>
<span class="fc" id="L334">                _parents[index] = oldVals0[i];</span>
<span class="fc" id="L335">                _lefts[index] = oldVals1[i];</span>
<span class="fc" id="L336">                _rights[index] = oldVals2[i];</span>
<span class="fc" id="L337">                _values[index] = oldVals3[i];</span>
<span class="fc" id="L338">                _colors[index] = oldVals4[i];</span>
<span class="fc" id="L339">                _sizes[index] = oldVals5[i];</span>
<span class="fc" id="L340">            }</span>
        }
<span class="fc" id="L342">    }</span>

    /**
     * insert key and values.
     * 
     @param key a &lt;code&gt;long&lt;/code&gt; containing the key for the associated values.
     *  
     @param parent is &lt;code&gt;long&lt;/code&gt; containing the first entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;parent&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param left is &lt;code&gt;long&lt;/code&gt; containing the second entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;left&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param right is &lt;code&gt;long&lt;/code&gt; containing the third entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;right&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param nodeValue is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;standard value&lt;/em&gt; field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeColor is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;color&lt;/em&gt; value field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeSize &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;size&lt;/em&gt; value field
           holding the size of the subtree of this node.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
     */
    public void put( long key, long parent, long left, long right,
        int nodeValue, int nodeColor, int nodeSize) {
<span class="fc" id="L380">        int index = insertKey( key );</span>
<span class="fc" id="L381">        doPut(key, parent, left, right, nodeValue, nodeColor, nodeSize, index );</span>
<span class="fc" id="L382">    }</span>
    
    /**
     insert key and values.  Note that the missing value0, value1, and value2
     are inserted with the sentinel for long null values, Long.MIN_VALUE.
     * 
     @param key a &lt;code&gt;long&lt;/code&gt; containing the key for the associated values.
     *  
       @param nodeValue is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;standard value&lt;/em&gt; field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeColor is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;color&lt;/em&gt; value field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeSize &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;size&lt;/em&gt; value field
           holding the size of the subtree of this node.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields. 
     */
    public void put( long key, int nodeValue, int nodeColor, int nodeSize) {
<span class="fc" id="L408">        int index = insertKey( key );</span>
<span class="fc" id="L409">        doPut(key, noLinkValue, noLinkValue, noLinkValue, nodeValue, nodeColor, </span>
            nodeSize, index );
<span class="fc" id="L411">    }</span>

    /** insert into map if there is not already an existing key.
     * Note that if there is an existing key, false is returned,
     * else true for successful insert.
     @param key a &lt;code&gt;long&lt;/code&gt; containing the key for the associated values.
     *  
     @param parent is &lt;code&gt;long&lt;/code&gt; containing the first entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;parent&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param left is &lt;code&gt;long&lt;/code&gt; containing the second entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;left&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param right is &lt;code&gt;long&lt;/code&gt; containing the third entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;right&lt;/em&gt; field.
     *     Note that the backing array has a LONG.MIN_VALUE when the key has
           no parent.
       @param nodeValue is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;standard value&lt;/em&gt; field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeColor is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;color&lt;/em&gt; value field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeSize &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;size&lt;/em&gt; value field
           holding the size of the subtree of this node.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
     @return 
     */
    public boolean putIfAbsent( long key, long parent, long left, long right,
        int nodeValue, int nodeColor, int nodeSize ) {
<span class="fc" id="L450">        int index = insertKey( key );</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        if (index &lt; 0)</span>
<span class="nc" id="L452">            return false;</span>
<span class="fc" id="L453">        doPut(key, parent, left, right, nodeValue, nodeColor, nodeSize, index );</span>
<span class="fc" id="L454">        return true;</span>
    }
    
    /** insert into map if there is not already an existing key.
     * Note that if there is an existing key, false is returned,
     * else true for successful insert.
     * 
     * Note that the missing value0, value1, and value2
     are inserted with the sentinel for long null values, Long.MIN_VALUE.
     * 
     @param key a &lt;code&gt;long&lt;/code&gt; containing the key for the associated values.
     *  
       @param nodeValue is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;standard value&lt;/em&gt; field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeColor is &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;color&lt;/em&gt; value field.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields.
       @param nodeSize &lt;code&gt;int&lt;/code&gt; containing the fourth entry of values.
     *     &lt;em&gt;For trees using this class&lt;/em&gt;, this is the &lt;em&gt;size&lt;/em&gt; value field
           holding the size of the subtree of this node.
     *     Note that the backing array should always have a valid value for this
           field, that is, if containsKey(key) is true, this value will be fetched
           and not checked for a null entry like the long fields. 
     @return  
     */
    public boolean putIfAbsent( long key, int nodeValue, int nodeColor, int nodeSize ) {
<span class="fc" id="L485">        int index = insertKey( key );</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (index &lt; 0)</span>
<span class="fc" id="L487">            return false;</span>
<span class="fc" id="L488">        doPut(key, noLinkValue, noLinkValue, noLinkValue, nodeValue, nodeColor, nodeSize, index );</span>
<span class="fc" id="L489">        return true;</span>
    }

    private void doPut( long key, long parent, long left, long right,
        int value, int nodeColor, int nodeSize, int index ) {
        
<span class="fc" id="L495">        boolean isNewMapping = true;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L497">            index = -index -1;</span>
<span class="fc" id="L498">            isNewMapping = false;</span>
        }
<span class="fc" id="L500">        _parents[index] = parent;</span>
<span class="fc" id="L501">        _lefts[index] = left;</span>
<span class="fc" id="L502">        _rights[index] = right;</span>
<span class="fc" id="L503">        _values[index] = value;</span>
<span class="fc" id="L504">        _colors[index] = nodeColor;</span>
<span class="fc" id="L505">        _sizes[index] = nodeSize;</span>

<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (isNewMapping) {</span>
            // a method in THash to expand and rehash if needed
<span class="fc" id="L509">            postInsertHook( consumeFreeSlot );</span>
        }
<span class="fc" id="L511">    }</span>
    
    /**
     * unset parent if it exists, else return false because there is
     * not an entry already for the given key.
     @param key
     @return 
     */
    public boolean unsetParent( long key) {
        //for existing entries, index returned by insertKey is negative
<span class="fc" id="L521">        int index = insertKey( key );</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (index &gt;= 0)</span>
<span class="nc" id="L523">            return false;</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L525">            index = -index -1;</span>
        }
<span class="fc" id="L527">        _parents[index] = noLinkValue;</span>
<span class="fc" id="L528">        return true;</span>
    }
    /**
     * unset left if it exists, else return false because there is
     * not an entry already for the given key.
     @param key
     @return 
     */
    public boolean unsetLeft( long key) {
        //for existing entries, index is positive
<span class="fc" id="L538">        int index = index( key );</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L540">            return false;</span>
        }
<span class="fc" id="L542">        _lefts[index] = noLinkValue;</span>
<span class="fc" id="L543">        return true;</span>
    }
    /**
     * unset right if it exists, else return false because there is
     * not an entry already for the given key.
     @param key
     @return 
     */
    public boolean unsetRight( long key ) {
        //for existing entries, index is positive
<span class="fc" id="L553">        int index = index( key );</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L555">            return false;</span>
        }
<span class="fc" id="L557">        _rights[index] = noLinkValue;</span>
<span class="fc" id="L558">        return true;</span>
    }
    
    /**
     * update parent if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param parent
     @return 
     */
    public boolean updateParent( long key, long parent ) {
        //for existing entries, index returned by insertKey is negative
<span class="fc" id="L570">        int index = insertKey( key );</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (index &gt;= 0)</span>
<span class="nc" id="L572">            return false;</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L574">            index = -index -1;</span>
        }
<span class="fc" id="L576">        _parents[index] = parent;</span>
<span class="fc" id="L577">        return true;</span>
    }
    /**
     * update left if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param left
     @return 
     */
    public boolean updateLeft( long key, long left ) {
        //for existing entries, index is positive
<span class="fc" id="L588">        int index = index( key );</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L590">            return false;</span>
        }
<span class="fc" id="L592">        _lefts[index] = left;</span>
<span class="fc" id="L593">        return true;</span>
    }
    /**
     * update right if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param right
     @return 
     */
    public boolean updateRight( long key, long right ) {
        //for existing entries, index is positive
<span class="fc" id="L604">        int index = index( key );</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L606">            return false;</span>
        }
<span class="fc" id="L608">        _rights[index] = right;</span>
<span class="fc" id="L609">        return true;</span>
    }
    /**
     * update nodeValue if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param nodeValue
     @return 
     */
    public boolean updateNodeValue( long key, int nodeValue ) {
        //for existing entries, index is positive
<span class="fc" id="L620">        int index = index( key );</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L622">            return false;</span>
        }
<span class="fc" id="L624">        _values[index] = nodeValue;</span>
<span class="fc" id="L625">        return true;</span>
    }
    /**
     * update nodeColor if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param nodeColor
     @return 
     */
    public boolean updateNodeColor( long key, int nodeColor ) {
        //for existing entries, index is positive
<span class="fc" id="L636">        int index = index( key );</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L638">            return false;</span>
        }
<span class="fc" id="L640">        _colors[index] = nodeColor;</span>
<span class="fc" id="L641">        return true;</span>
    }
    /**
     * update nodeSize if if doesn't exist, else return false because there is
     * not an entry already for the given key.
     @param key
     @param nodeSize the size of the subtree underneath and including the node
     @return 
     */
    public boolean updateNodeSize( long key, int nodeSize ) {
        //for existing entries, index is positive
<span class="fc" id="L652">        int index = index( key );</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L654">            return false;</span>
        }
<span class="fc" id="L656">        _sizes[index] = nodeSize;</span>
<span class="fc" id="L657">        return true;</span>
    }
    /** {@inheritDoc} */
    public void putAll( NodeMap map ) {
<span class="fc" id="L661">        ensureCapacity( map.size() );</span>
<span class="fc" id="L662">        TLong_LongLongLongIntIntIntHashIterator iter </span>
<span class="fc" id="L663">            = map.iterator();</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        while ( iter.hasNext() ) {</span>
<span class="fc" id="L665">            iter.advance();</span>
<span class="fc" id="L666">            this.put( iter.key(), </span>
<span class="fc" id="L667">                iter.parent(), iter.left(), iter.right(),</span>
<span class="fc" id="L668">                iter.nodeValue(), iter.nodeColor(), iter.nodeSize());</span>
        }
<span class="fc" id="L670">    }</span>

    /**
     *
     @param key
     @return
     */
    public boolean parentIsSet(long key) {
<span class="fc" id="L678">        int index = index(key);</span>
<span class="pc bpc" id="L679" title="1 of 4 branches missed.">        if (index &lt; 0 || _parents[index] == noLinkValue) {</span>
<span class="fc" id="L680">            return false;</span>
        }
<span class="fc" id="L682">        return true;</span>
    }

    /**
     *
     @param key
     @return
     */
    public boolean leftIsSet(long key) {
<span class="fc" id="L691">        int index = index(key);</span>
<span class="pc bpc" id="L692" title="1 of 4 branches missed.">        if (index &lt; 0 || _lefts[index] == noLinkValue) {</span>
<span class="fc" id="L693">            return false;</span>
        }
<span class="fc" id="L695">        return true;</span>
    }

    /**
     *
     @param key
     @return
     */
    public boolean rightIsSet(long key) {
<span class="fc" id="L704">        int index = index(key);</span>
<span class="pc bpc" id="L705" title="1 of 4 branches missed.">        if (index &lt; 0 || _rights[index] == noLinkValue) {</span>
<span class="fc" id="L706">            return false;</span>
        }
<span class="fc" id="L708">        return true;</span>
    }
    /** {@inheritDoc} */
    public long getParent( long key ) {
<span class="fc" id="L712">        int index = index( key );</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        return index &lt; 0 ? noLinkValue : _parents[index];</span>
    }

    /**
     *
     @param key
     @return
     */
    public long getLeft( long key ) {
<span class="fc" id="L722">        int index = index( key );</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        return index &lt; 0 ? noLinkValue : _lefts[index];</span>
    }

    /**
     *
     @param key
     @return
     */
    public long getRight( long key ) {
<span class="fc" id="L732">        int index = index( key );</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        return index &lt; 0 ? noLinkValue : _rights[index];</span>
    }

    /**
     *
     @param key
     @return
     */
    public int getNodeValue( long key ) {
<span class="fc" id="L742">        int index = index( key );</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">        return index &lt; 0 ? no_entry_value : _values[index];</span>
    }

    /**
     *
     @param key
     @return
     */
    public int getNodeColor( long key ) {
<span class="fc" id="L752">        int index = index( key );</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        return index &lt; 0 ? no_entry_value : _colors[index];</span>
    }

    /**
     *
     @param key
     @return
     */
    public int getNodeSize( long key ) {
<span class="fc" id="L762">        int index = index( key );</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        return index &lt; 0 ? no_entry_value : _sizes[index];</span>
    }


    /** {@inheritDoc} */
    @Override
    public void clear() {
<span class="fc" id="L770">        super.clear();</span>
<span class="fc" id="L771">        int n = _parents.length;</span>
<span class="fc" id="L772">        Arrays.fill( _set, 0, _set.length, no_entry_key );</span>
<span class="fc" id="L773">        Arrays.fill(_parents, 0, n, noLinkValue );</span>
<span class="fc" id="L774">        Arrays.fill(_lefts, 0, n, noLinkValue );</span>
<span class="fc" id="L775">        Arrays.fill(_rights, 0, n, noLinkValue );</span>
<span class="fc" id="L776">        Arrays.fill(_values, 0, n, no_entry_value );</span>
<span class="fc" id="L777">        Arrays.fill(_colors, 0, n, no_entry_value );</span>
<span class="fc" id="L778">        Arrays.fill(_sizes, 0, n, no_entry_value );</span>
<span class="fc" id="L779">        Arrays.fill( _states, 0, _states.length, FREE );</span>
<span class="fc" id="L780">    }</span>


    /** {@inheritDoc} */
    public boolean isEmpty() {
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        return 0 == _size;</span>
    }


    /** remove the entry for key and return true if succeeded, else false if
     * entry with key was not in map.
     @param key
     @return 
     */
    public boolean remove( long key ) {
<span class="fc" id="L795">        int index = index( key );</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        if ( index &gt;= 0 ) {</span>
<span class="fc" id="L797">            removeAt( index );    // clear key,state; adjust size</span>
<span class="fc" id="L798">            return true;</span>
        }
<span class="nc" id="L800">        return false;</span>
    }


    /** {@inheritDoc} */
    protected void removeAt( int index ) {
<span class="fc" id="L806">        _parents[index] = noLinkValue;</span>
<span class="fc" id="L807">        _lefts[index] = noLinkValue;</span>
<span class="fc" id="L808">        _rights[index] = noLinkValue;</span>
<span class="fc" id="L809">        _values[index] = no_entry_value;</span>
<span class="fc" id="L810">        _colors[index] = no_entry_value;</span>
<span class="fc" id="L811">        _sizes[index] = no_entry_value;</span>
<span class="fc" id="L812">        super.removeAt( index );  // clear key, state; adjust size</span>
<span class="fc" id="L813">    }</span>


    /** {@inheritDoc} */
    public TLongSet keySet() {
        
<span class="fc" id="L819">        TLongSet keys = new TLongHashSet();</span>
        
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (size() == 0) {</span>
<span class="nc" id="L822">            return keys;</span>
        }
        
<span class="fc" id="L825">        long[] k = _set;</span>
<span class="fc" id="L826">        byte[] states = _states;</span>

<span class="fc bfc" id="L828" title="All 2 branches covered.">        for (int i = k.length, j = 0; i-- &gt; 0;) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (states[i] == FULL) {</span>
<span class="fc" id="L830">                keys.add(k[i]);</span>
            }
        }
        
<span class="fc" id="L834">        return keys;</span>
    }


    /** {@inheritDoc} */
    public long[] keys() {
<span class="fc" id="L840">        long[] keys = new long[size()];</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if ( keys.length == 0 ) {</span>
<span class="nc" id="L842">            return keys;        // nothing to copy</span>
        }
<span class="fc" id="L844">        long[] k = _set;</span>
<span class="fc" id="L845">        byte[] states = _states;</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">        for ( int i = k.length, j = 0; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">          if ( states[i] == FULL ) {</span>
<span class="fc" id="L849">            keys[j++] = k[i];</span>
          }
        }
<span class="fc" id="L852">        return keys;</span>
    }


    /** {@inheritDoc} */
    public long[] keys( long[] array ) {
<span class="fc" id="L858">        int size = size();</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if ( size == 0 ) {</span>
<span class="nc" id="L860">            return array;       // nothing to copy</span>
        }
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if ( array.length &lt; size ) {</span>
<span class="nc" id="L863">            array = new long[size];</span>
        }

<span class="fc" id="L866">        long[] keys = _set;</span>
<span class="fc" id="L867">        byte[] states = _states;</span>

<span class="fc bfc" id="L869" title="All 2 branches covered.">        for ( int i = keys.length, j = 0; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">          if ( states[i] == FULL ) {</span>
<span class="fc" id="L871">            array[j++] = keys[i];</span>
          }
        }
<span class="fc" id="L874">        return array;</span>
    }

    /**
     * same as contains key
     @param val
     @return 
     */
    @Override
    public boolean contains(long val) {
<span class="fc" id="L884">        return super.contains(val); </span>
    }
    
    /** {@inheritDoc} */
    public boolean containsKey( long key ) {
<span class="fc" id="L889">        return contains( key );</span>
    }

    /**
     *
     @return
     */
    public TLong_LongLongLongIntIntIntHashIterator iterator() {
<span class="fc" id="L897">        return new TLong_LongLongLongIntIntIntHashIterator(this );</span>
    }

    class TLong_LongLongLongIntIntIntHashKeyIterator 
        extends THashPrimitiveIterator implements TLongIterator {

        /**
         * Creates an iterator over the specified map
         *
         @param hash the &lt;code&gt;TPrimitiveHash&lt;/code&gt; we will be iterating over.
         */
        TLong_LongLongLongIntIntIntHashKeyIterator( TPrimitiveHash hash ) {
            super( hash );
        }

        /** {@inheritDoc} */
        public long next() {
            moveToNextIndex();
            return _set[_index];
        }

        @Override
        public void remove() {
            if ( _expectedSize != _hash.size() ) {
                throw new ConcurrentModificationException();
            }

            // Disable auto compaction during the remove. This is a workaround for bug 1642768.
            try {
                _hash.tempDisableAutoCompaction();
                NodeMap.this.removeAt( _index );
            }
            finally {
                _hash.reenableAutoCompaction( false );
            }

            _expectedSize--;
        }
    }

    class TLong_LongLongLongIntIntIntHashIterator 
        extends THashPrimitiveIterator {

        /**
         * Creates an iterator over the specified map
         *
         @param map the &lt;code&gt;TLongLongHashMap&lt;/code&gt; we will be iterating over.
         */
        TLong_LongLongLongIntIntIntHashIterator( 
            NodeMap map ) {
            super( map );
        }

        /** {@inheritDoc} */
        public void advance() {
            moveToNextIndex();
        }

        /** {@inheritDoc} */
        public long key() {
            return _set[_index];
        }

        /** {@inheritDoc} */
        public long parent() {
            return _parents[_index];
        }
        public long left() {
            return _lefts[_index];
        }
        public long right() {
            return _rights[_index];
        }
        public int nodeValue() {
            return _values[_index];
        }
        public int nodeColor() {
            return _colors[_index];
        }
        public int nodeSize() {
            return _sizes[_index];
        }

        /** {@inheritDoc} */
        public long setParent( long val ) {
            long old = parent();
            _parents[_index] = val;
            return old;
        }
        public long setLeft( long val ) {
            long old = left();
            _lefts[_index] = val;
            return old;
        }
        public long setRight( long val ) {
            long old = right();
            _rights[_index] = val;
            return old;
        }
        
        public int setValue( int val ) {
            int old = nodeValue();
            _values[_index] = val;
            return old;
        }
        public int setNodeColor( int val ) {
            int old = nodeColor();
            _colors[_index] = val;
            return old;
        }
        public int setNodeSize( int val ) {
            int old = nodeSize();
            _sizes[_index] = val;
            return old;
        }

        @Override
        public void remove() {
            if ( _expectedSize != _hash.size() ) {
                throw new ConcurrentModificationException();
            }
            // Disable auto compaction during the remove. This is a workaround for bug 1642768.
            try {
                _hash.tempDisableAutoCompaction();
                NodeMap.this.removeAt( _index );
            }
            finally {
                _hash.reenableAutoCompaction( false );
            }
            _expectedSize--;
        }
    }


    /** {@inheritDoc}
     * NOTE: this uses just the key and value3 for equals operation.
     */
    @Override
    public boolean equals( Object other ) {
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        if ( ! ( other instanceof NodeMap ) ) {</span>
<span class="nc" id="L1037">            return false;</span>
        }
<span class="fc" id="L1039">        NodeMap that = ( NodeMap ) other;</span>
        
        //System.out.println(&quot;in equals.  sizes=&quot; + 
        //    that.size() + &quot;, &quot; + this.size());
        
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if ( that.size() != this.size() ) {</span>
<span class="nc" id="L1045">            return false;</span>
        }
<span class="fc" id="L1047">        int[] values3 = _values;</span>
<span class="fc" id="L1048">        byte[] states = _states;</span>
      
<span class="fc" id="L1050">        long this_no_entry_value = getNoEntryValue();</span>
<span class="fc" id="L1051">        long that_no_entry_value = that.getNoEntryValue();</span>
        
        //System.out.println(&quot;this_no_entry_value=&quot; + this_no_entry_value);
        //System.out.println(&quot;that_no_entry_value=&quot; + that_no_entry_value);
        
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        for ( int i = values3.length; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">            if ( states[i] == FULL ) {</span>
<span class="fc" id="L1058">                long key = _set[i];</span>

                //System.out.println(&quot;that.containsKey( key )=&quot;
                //    + that.containsKey(key));
                
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">                if ( !that.containsKey( key ) ) {</span>
<span class="nc" id="L1064">                    return false;</span>
                }

<span class="fc" id="L1067">                long that_value = that.getNodeValue(key);</span>
<span class="fc" id="L1068">                long this_value = values3[i];</span>
                
                //System.out.println(&quot;values=&quot; + that_value + &quot;, &quot; + this_value);
                
<span class="pc bpc" id="L1072" title="5 of 6 branches missed.">                if (</span>
                    (this_value != that_value) &amp;&amp; ( (this_value != this_no_entry_value)
                    || (that_value != that_no_entry_value))
                    ) {

<span class="nc" id="L1077">                    return false;</span>
                }
<span class="fc" id="L1079">            }</span>
        }
<span class="fc" id="L1081">        return true;</span>
    }


    /** {@inheritDoc} 
     * NOTE: this uses the key and values3 for hash code and no other fields.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L1090">        int hashcode = 0;</span>
<span class="nc" id="L1091">        byte[] states = _states;</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for ( int i = _parents.length; i-- &gt; 0; ) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if ( states[i] == FULL ) {</span>
<span class="nc" id="L1094">                hashcode += HashFunctions.hash( _set[i] ) ^</span>
<span class="nc" id="L1095">                            HashFunctions.hash(_values[i] );</span>
            }
        }
<span class="nc" id="L1098">        return hashcode;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {

<span class="fc" id="L1105">        final StringBuilder buf = new StringBuilder( &quot;{&quot; );</span>
        
<span class="fc" id="L1107">        int[] values3 = _values;</span>
<span class="fc" id="L1108">        byte[] states = _states;</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        for ( int i = values3.length; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">            if ( states[i] == FULL ) {</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">                if (buf.length() &gt; 0) {</span>
<span class="fc" id="L1112">                    buf.append( &quot;, &quot; );</span>
                }
<span class="fc" id="L1114">                long key = _set[i];</span>
<span class="fc" id="L1115">                buf.append(key);</span>
<span class="fc" id="L1116">                buf.append(&quot;=&quot;);</span>
<span class="fc" id="L1117">                buf.append(_parents[i]);</span>
<span class="fc" id="L1118">                buf.append(_lefts[i]);</span>
<span class="fc" id="L1119">                buf.append(_rights[i]);</span>
<span class="fc" id="L1120">                buf.append(_values[i]);</span>
<span class="fc" id="L1121">                buf.append(_colors[i]);</span>
<span class="fc" id="L1122">                buf.append(_sizes[i]);</span>
<span class="fc" id="L1123">            }</span>
        }
<span class="fc" id="L1125">        buf.append( &quot;}&quot; );</span>
<span class="fc" id="L1126">        return buf.toString();</span>
    }

    /** {@inheritDoc} */
    public void writeExternal(ObjectOutput out) throws IOException {
        // VERSION
<span class="fc" id="L1132">    	out.writeByte( 0 );</span>

        // SUPER
<span class="fc" id="L1135">    	super.writeExternal( out );</span>

    	// NUMBER OF ENTRIES
<span class="fc" id="L1138">    	out.writeInt( _size );</span>

    	// ENTRIES
<span class="fc bfc" id="L1141" title="All 2 branches covered.">    	for ( int i = _states.length; i-- &gt; 0; ) {</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">            if ( _states[i] == FULL ) {</span>
<span class="fc" id="L1143">                out.writeLong( _set[i] );</span>
<span class="fc" id="L1144">                out.writeLong(_parents[i] );</span>
<span class="fc" id="L1145">                out.writeLong(_lefts[i] );</span>
<span class="fc" id="L1146">                out.writeLong(_rights[i] );</span>
<span class="fc" id="L1147">                out.writeInt(_values[i] );</span>
<span class="fc" id="L1148">                out.writeInt(_colors[i] );</span>
<span class="fc" id="L1149">                out.writeInt(_sizes[i] );</span>
            }
        }
        
<span class="fc" id="L1153">        out.flush();</span>
    
        //System.out.println(&quot;write map.  size=&quot; + size());
<span class="fc" id="L1156">    }</span>


    /** {@inheritDoc} */
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        
        // VERSION
<span class="fc" id="L1163">    	in.readByte();</span>

        // SUPER
<span class="fc" id="L1166">    	super.readExternal( in );</span>

    	// NUMBER OF ENTRIES
<span class="fc" id="L1169">    	int size = in.readInt();</span>
        
        //System.out.println(&quot;read size var=&quot; + size);
    	
<span class="fc" id="L1173">        setUp( size );</span>
        
    	// ENTRIES
<span class="fc bfc" id="L1176" title="All 2 branches covered.">        for (int i = 0; i &lt; size; ++i) {</span>
<span class="fc" id="L1177">            long key = in.readLong();</span>
<span class="fc" id="L1178">            long val0 = in.readLong();</span>
<span class="fc" id="L1179">            long val1 = in.readLong();</span>
<span class="fc" id="L1180">            long val2 = in.readLong();</span>
<span class="fc" id="L1181">            int val3 = in.readInt();</span>
<span class="fc" id="L1182">            int val4 = in.readInt();</span>
<span class="fc" id="L1183">            int val5 = in.readInt();</span>
            
<span class="fc" id="L1185">            put(key, val0, val1, val2, val3, val4, val5);</span>
        }
        
        //System.out.println(&quot;read in map.  size=&quot; + size);
<span class="fc" id="L1189">    }</span>
    
    /**
     *
     @param numberOfEntries
     @return
     */
    public static long estimateSizeOnHeap(int numberOfEntries) {
        
        /*
        super class:
           long serialVersionUID = 1L;
           long[] _set;
           long no_entry_key;
           int no_entry_value;
           boolean consumeFreeSlot;
         this class:
           long serialVersionUID = 12325L;
           long[] _parents;
           long[] _lefts;
           long[] _rights;
           int[] _values;
           int[] _colors;
           int[] _sizes;
           long noLinkValue = Long.MIN_VALUE;
        */
        
<span class="fc" id="L1216">        ObjectSpaceEstimator est0 = new ObjectSpaceEstimator();</span>
<span class="fc" id="L1217">        est0.setNLongFields(2 + numberOfEntries);</span>
<span class="fc" id="L1218">        est0.setNIntFields(1);</span>
<span class="fc" id="L1219">        est0.setNArrayRefsFields(1);</span>
<span class="fc" id="L1220">        est0.setNBooleanFields(1);</span>
        
<span class="fc" id="L1222">        ObjectSpaceEstimator est = new ObjectSpaceEstimator();</span>
<span class="fc" id="L1223">        est.setNLongFields(2 + 3*numberOfEntries);</span>
<span class="fc" id="L1224">        est.setNIntFields(1 + 3*numberOfEntries);</span>
<span class="fc" id="L1225">        est.setNArrayRefsFields(6);</span>
        
<span class="fc" id="L1227">        return est0.estimateSizeOnHeap() + est.estimateSizeOnHeap();</span>
        
     }
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>