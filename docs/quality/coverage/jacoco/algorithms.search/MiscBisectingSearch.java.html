<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscBisectingSearch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.search</a> &gt; <span class="el_source">MiscBisectingSearch.java</span></div><h1>MiscBisectingSearch.java</h1><pre class="source lang-java linenums">package algorithms.search;

import java.util.Arrays;
import java.util.List;

/**
 * useful methods for bisecting search, a.k.a. binary search
 */
<span class="nc" id="L9">public class MiscBisectingSearch {</span>

    /**
     * finds where srch would be inserted such that all keys at indexes &lt; resulting index
     * have smaller values than srch.   if srch is larger than all array elements,
     * this method returns an index larger than last array index.
     &lt;pre&gt;

     a = [2, 2]
     srch = 1,
     returns index 0

     a = [2, 2]
     srch = 2,
     returns index 2

     a = [2, 2]
     srch = 2,
     returns index 2
     &lt;/pre&gt;
     * @param a
     * @param srch
     * @return smallest index i such that a[i] is GT srch.
     * range of returned value is is [0, n] where n is a.length.
     */
    public static int successor(int[] a, int srch) {
<span class="fc" id="L35">        int lo = 0;</span>
<span class="fc" id="L36">        int hi = a.length - 1;</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L38">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">            if (a[mid] &lt;= srch) {</span>
<span class="fc" id="L40">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L42">                hi = mid - 1;</span>
            }
<span class="fc" id="L44">        }</span>
<span class="fc" id="L45">        return lo;</span>
    }

    /**
     * find the least index i whose value a]i] EQ srch, else finds the least index i
     * whose value a[i] is GT srch.
     * The method returns indexes in the range [-1, a.length], inclusive.
     * The return valye of a.length means that srch is larger than all values in the array.
     *
     * Note that one could instead use the java.util.Arrays.binarySearch(...) and if the index is
     * negative, you can convert it with mult by -1 and then subtract 1 (
     * i.e. idx = -(insertion point) - 1, so insertion point = -idx - 1).
     * @param a
     * @param srch
     * @return
     * range is [0, n] inclusive where n = a.length.
     */
    public static int findInsertIndex(int[] a, int srch) {
<span class="fc" id="L63">        int lo = 0;</span>
<span class="fc" id="L64">        int hi = a.length - 1;</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L66">            int mid = lo + (hi - lo) / 2;</span>
            // NOTE: the successor method uses &lt;= here:
<span class="fc bfc" id="L68" title="All 2 branches covered.">            if (a[mid] &lt; srch) {</span>
<span class="fc" id="L69">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L71">                hi = mid - 1;</span>
            }
<span class="fc" id="L73">        }</span>
<span class="fc" id="L74">        return lo;</span>
    }

    /**
     * find the least index i whose value a]i] EQ srch, else finds the least index i
     * whose value a[i] is GT srch.
     * The method returns indexes in the range [-1, a.length], inclusive.
     * The return valye of a.length means that srch is larger than all values in the array.
     *
     * Note that one could instead use the java.util.Arrays.binarySearch(...) and if the index is
     * negative, you can convert it with mult by -1 and then subtract 1 (
     * i.e. idx = -(insertion point) - 1, so insertion point = -idx - 1).
     * @param a
     * @param srch
     * @return
     * range is [0, n] inclusive where n = a.length.
     */
    public static int findInsertIndex(List&lt;Integer&gt; a, int srch) {
<span class="fc" id="L92">        int lo = 0;</span>
<span class="fc" id="L93">        int hi = a.size() - 1;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L95">            int mid = lo + (hi - lo) / 2;</span>
            // NOTE: the successor method uses &lt;= here:
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (a.get(mid) &lt; srch) {</span>
<span class="fc" id="L98">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L100">                hi = mid - 1;</span>
            }
<span class="fc" id="L102">        }</span>
<span class="fc" id="L103">        return lo;</span>
    }

    /**
     * finds where srch would be inserted such that all keys at indexes &lt; resulting index
     * have smaller values than srch.   if srch is larger than all array elements,
     * this method returns an index larger than last array index.
     &lt;pre&gt;

     a = [2, 2]
     srch = 1,
     returns index 0

     a = [2, 2]
     srch = 2,
     returns index 2

     a = [2, 2]
     srch = 2,
     returns index 2
     &lt;/pre&gt;
     * @param a
     * @param srch
     * @return smallest index i such that a[i] is GT srch.
     * range of returned value is is [0, n] where n is a.length.
     */
    public static int successor(List&lt;Integer&gt; a, int srch) {
<span class="fc" id="L130">        int lo = 0;</span>
<span class="fc" id="L131">        int hi = a.size() - 1;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L133">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (a.get(mid) &lt;= srch) {</span>
<span class="fc" id="L135">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L137">                hi = mid - 1;</span>
            }
<span class="fc" id="L139">        }</span>
<span class="fc" id="L140">        return lo;</span>
    }

    /**
     Finds the smallest index for which value == srch, or if doesn't exist,
     finds the largest index for which the value is LT srch.

     * This is a floor function.
     *
     * If the method returns -1, the srch is smaller than all elements in the
     * array.
     * if srch is larger than every element in list 'a', this method will return
     * the last index of a.
     &lt;pre&gt;
     e.g.

     a = [0,1,2,2,3]
     srch = 2
     returns  2

     a = [0,3,4,4,6};
     srch = 5;
     returns 3

     a = [2,3,4,4,6};
     srch = 0;
     returns -1

     a = [2,3,4,4,6};
     srch = 7;
     returs 4

     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @return the floor index, that is,
     * finds the smallest index for which value == srch, or if doesn't exist,
     *      finds the largest index for which the value is LT srch.
     *      range of values from floor is [-1, a.length-1] inclusive.
     */
    public static int floor(int[] a, int srch) {
<span class="fc" id="L181">        return floor(a, srch, 0, a.length - 1);</span>
    }

    /**
     Finds the smallest index for which value == srch, or if doesn't exist,
     finds the largest index for which the value is LT srch.

     * This is a floor function.
     *
     * If the method returns -1, the srch is smaller than all elements in the
     * array.
     * if srch is larger than every element in list 'a', this method will return
     * the last index of a.
     &lt;pre&gt;
     e.g.

     a = [0,1,2,2,3]
     srch = 2
     returns  2

     a = [0,3,4,4,6};
     srch = 5;
     returns 3

     a = [2,3,4,4,6};
     srch = 0;
     returns -1

     a = [2,3,4,4,6};
     srch = 7;
     returs 4

     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index for search range
     * @param hi largets index for search range, inclusive.
     * @return the floor index, that is,
     * finds the smallest index for which value == srch, or if doesn't exist,
     *      finds the largest index for which the value is LT srch.
     *      range of values from floor is [-1, a.length-1] inclusive.
     */
    protected static int _floor(int[] a, int srch, int lo, int hi) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (srch &lt; a[lo]) {</span>
<span class="nc" id="L225">            return -1;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        } else if (srch &gt; a[hi]) {</span>
<span class="nc" id="L227">            return hi;</span>
        }
<span class="nc bnc" id="L229" title="All 2 branches missed.">        while (lo &lt;= hi) {</span>
<span class="nc" id="L230">            int mid = lo + (hi - lo) / 2;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (a[mid] == srch) {</span>
                //we want the smallest index whose value == srch, so search further in lower half of array
<span class="nc bnc" id="L233" title="All 2 branches missed.">                if (mid == lo) {</span>
<span class="nc" id="L234">                    return mid;</span>
                }
<span class="nc" id="L236">                int idx = _floor(a, srch, lo, mid - 1);</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">                if (idx == -1 || a[idx] &lt; srch) {</span>
<span class="nc" id="L238">                    return mid;</span>
                }
<span class="nc" id="L240">                return idx;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            } else if (a[mid] &lt; srch) {</span>
<span class="nc" id="L242">                lo = mid + 1;</span>
            } else {
<span class="nc" id="L244">                hi = mid - 1;</span>
            }
<span class="nc" id="L246">        }</span>
<span class="nc" id="L247">        return Math.min(lo, hi);</span>
    }

    /**
     Finds the smallest index for which value == srch, or if doesn't exist,
     finds the largest index for which the value is LT srch.

     * This is a floor function.
     *
     * If the method returns -1, the srch is smaller than all elements in the
     * array.
     * if srch is larger than every element in list 'a', this method will return
     * the last index of a.
     &lt;pre&gt;
     e.g.

     a = [0,1,2,2,3]
     srch = 2
     returns  2

     a = [0,3,4,4,6};
     srch = 5;
     returns 3

     a = [2,3,4,4,6};
     srch = 0;
     returns -1

     a = [2,3,4,4,6};
     srch = 7;
     returs 4

     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index for search range
     * @param hi largets index for search range, inclusive.
     * @return the floor index, that is,
     * finds the smallest index for which value == srch, or if doesn't exist,
     *      finds the largest index for which the value is LT srch.
     *      range of values from floor is [-1, a.length-1] inclusive.
     */
    public static int floor(int[] a, int srch, int lo, int hi) {
<span class="fc" id="L290">        boolean found = false;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L292">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (a[mid] == srch) {</span>
<span class="fc" id="L294">                found = true;</span>
<span class="fc" id="L295">                hi = mid - 1;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            } else if (a[mid] &lt; srch) {</span>
<span class="fc" id="L297">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L299">                hi = mid - 1;</span>
            }
<span class="fc" id="L301">        }</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        return found ? lo : Math.min(lo, hi);</span>
    }

    /**
     Finds the smallest index for which value == srch, or if doesn't exist,
     finds the largest index for which the value is LT srch.

     * This is a floor function.
     *
     * If the method returns -1, the srch is smaller than all elements in the
     * array.
     * if srch is larger than every element in list 'a', this method will return
     * the last index of a.
     &lt;pre&gt;
     e.g.

     a = [0,1,2,2,3]
     srch = 2
     returns  2

     a = [0,3,4,4,6};
     srch = 5;
     returns 3

     a = [2,3,4,4,6};
     srch = 0;
     returns -1

     a = [2,3,4,4,6};
     srch = 7;
     returs 4

     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @return the floor index, that is,
     * finds the smallest index for which value == srch, or if doesn't exist,
     *      finds the largest index for which the value is LT srch.
     */
    public static int floor(List&lt;Integer&gt; a, int srch) {
<span class="fc" id="L342">        return floor(a, srch, 0, a.size() - 1);</span>
    }
    /**
     Finds the smallest index for which value == srch, or if doesn't exist,
     finds the largest index for which the value is LT srch.

     * This is a floor function.
     *
     * If the method returns -1, the srch is smaller than all elements in the
     * array.
     * if srch is larger than every element in list 'a', this method will return
     * the last index of a.
     &lt;pre&gt;
     e.g.

     a = [0,1,2,2,3]
     srch = 2
     returns  2

     a = [0,3,4,4,6};
     srch = 5;
     returns 3

     a = [2,3,4,4,6};
     srch = 0;
     returns -1

     a = [2,3,4,4,6};
     srch = 7;
     returs 4

     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index for search range
     * @param hi largets index for search range, inclusive.
     * @return the floor index, that is,
     * finds the smallest index for which value == srch, or if doesn't exist,
     *      finds the largest index for which the value is LT srch.
     *      range of values from floor is [-1, a.length-1] inclusive.
     */
    public static int floor(List&lt;Integer&gt; a, int srch, int lo, int hi) {
<span class="fc" id="L384">        boolean found = false;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L386">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (a.get(mid) == srch) {</span>
<span class="fc" id="L388">                found = true;</span>
<span class="fc" id="L389">                hi = mid - 1;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            } else if (a.get(mid) &lt; srch) {</span>
<span class="fc" id="L391">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L393">                hi = mid - 1;</span>
            }
<span class="fc" id="L395">        }</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        return found ? lo : Math.min(lo, hi);</span>
    }

    public static int _floor(List&lt;Integer&gt; a, int srch, int lo, int hi) {
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (srch &lt; a.get(lo)) {</span>
<span class="nc" id="L401">            return -1;</span>
        }
<span class="nc bnc" id="L403" title="All 2 branches missed.">        while (lo &lt;= hi) {</span>
<span class="nc" id="L404">            int mid = lo + (hi - lo) / 2;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (a.get(mid) == srch) {</span>
                //we want the smallest index whose value == srch, so search further in lower half of array
<span class="nc" id="L407">                int idx = floor(a, srch, lo, mid - 1);</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">                if (idx == -1 || a.get(idx) &lt; srch) return mid;</span>
<span class="nc" id="L409">                return idx;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            } else if (a.get(mid) &lt; srch) {</span>
<span class="nc" id="L411">                lo = mid + 1;</span>
            } else {
<span class="nc" id="L413">                hi = mid - 1;</span>
            }
<span class="nc" id="L415">        }</span>
<span class="nc" id="L416">        return Math.min(lo, hi);</span>
    }

    /**
     * find the largest index i whose value a[i] EQ srch,
     * else if no value exists this method returns the smallest index whose
     * value is GT srch.  if all values in the array are less than srch, the
     * method returns index == array size which is beyond bounds of array.
     &lt;pre&gt;
     for example:
     a       = [1, 2, 3, 3, 4]
     indexes =  0  1  2  3  4

     ceil of srch=3 is index 3
     ceil of srch=4 is index 4
     ceil of srch=9 is index 5
     ceil of srch=0 is index 0
     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @return
    the greatest index i for which a[i] == srch, else if no such value exists,
    the index for the smallest value GT srch.
    range is [0, n] inclusive where n = a.length.
     */
    public static int ceiling(List&lt;Integer&gt; a, int srch) {
<span class="fc" id="L442">        return ceiling(a, srch, 0, a.size() - 1);</span>
    }

    /**
     * find the largest index i whose value a[i] EQ srch,
     * else if no value exists this method returns the smallest index whose
     * value is GT srch.  if all values in the array are less than srch, the
     * method returns index == array size which is beyond bounds of array.
     &lt;pre&gt;
     for example:
         a       = [1, 2, 3, 3, 4]
         indexes =  0  1  2  3  4

         ceil of srch=3 is index 3
         ceil of srch=4 is index 4
         ceil of srch=9 is index 5
         ceil of srch=0 is index 0
     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index of search range
     * @param hi largest index of search range
     * @return
    the greatest index i for which a[i] == srch, else if no such value exists,
    the index for the smallest value GT srch.
    range is [0, n] inclusive where n = a.length.
     */
    public static int ceiling(List&lt;Integer&gt; a, int srch, int lo, int hi) {
<span class="fc" id="L470">        boolean found = false;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L472">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (a.get(mid) == srch) {</span>
                //we want the largest index whose value == srch, so search further in higher half of arra
<span class="fc" id="L475">                lo = mid + 1;</span>
<span class="fc" id="L476">                found = true;</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">            } else if (a.get(mid) &lt; srch) {</span>
<span class="fc" id="L478">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L480">                hi = mid - 1;</span>
            }
<span class="fc" id="L482">        }</span>
        //return found ? hi : Math.max(lo, hi);// works too and easier to remember as complement of floor return
<span class="fc bfc" id="L484" title="All 2 branches covered.">        return found ? hi : lo;</span>
    }

    /**
     find the largest index i whose value a[i] EQ srch,
     * else if no value exists this method returns the smallest index whose
     * value is GT srch.  if all values in the array are less than srch, the
     * method returns index == array size which is beyond bounds of array.
     &lt;pre&gt;
     for example:
     a       = [1, 2, 3, 3, 4]
     indexes =  0  1  2  3  4

     ceil of srch=3 is index 3
     ceil of srch=4 is index 4
     ceil of srch=9 is index 5
     ceil of srch=0 is index 0
     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index of search range
     * @param hi largest index of search range
     * @return
     the greatest index i for which a[i] == srch, else if no such value exists,
     the index for the smallest value GT srch.
     range is [0, n] inclusive where n = a.length.
     */
    public static int ceiling(int[] a, int srch) {
<span class="fc" id="L512">        return ceiling(a, srch, 0, a.length - 1);</span>
    }

    /**
     * find the largest index i whose value a[i] EQ srch,
     * else if no value exists this method returns the smallest index whose
     * value is GT srch.  if all values in the array are less than srch, the
     * method returns index == array size which is beyond bounds of array.
     &lt;pre&gt;
     for example:
     a       = [1, 2, 3, 3, 4]
     indexes =  0  1  2  3  4

     ceil of srch=3 is index 3
     ceil of srch=4 is index 4
     ceil of srch=9 is index 5
     ceil of srch=0 is index 0
     &lt;/pre&gt;
     * @param a an ascending ordered list (non-decreasing, adjacent values can be ==).
     * @param srch the value to search for in a
     * @param lo smallest index of search range
     * @param hi largest index of search range
     * @return the greatest index i for which a[i] == srch, else if no such value exists,
     * the index for the smallest value GT srch.
     * range is [0, n] inclusive where n = a.length.
     */
    public static int ceiling(int[] a, int srch, int lo, int hi) {
<span class="fc" id="L539">        boolean found = false;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L541">            int mid = lo + (hi - lo) / 2;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (a[mid] == srch) {</span>
                //we want the largest index whose value == srch, so search further in higher half of arra
<span class="fc" id="L544">                lo = mid + 1;</span>
<span class="fc" id="L545">                found = true;</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">            } else if (a[mid] &lt; srch) {</span>
<span class="fc" id="L547">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L549">                hi = mid - 1;</span>
            }
<span class="fc" id="L551">        }</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        return found ? hi : lo;</span>
    }

    /**
     * find the greatest index i whose value a[i] is LT srch.
     * @param a list sorted by ascending values
     * @param srch value to srch for predecessor of.
     * @return the greatest index i whose value a[i] is LT srch.
     * range is [-1, n-1] where n = a.length.
     */
    public static int predecessor(int[] a, int srch) {

        // range of values from floor is [-1, a.length-1]
<span class="fc" id="L565">        int floorIdx = MiscBisectingSearch.floor(a, srch);</span>

<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (floorIdx == -1) {</span>
<span class="fc" id="L568">            return floorIdx;</span>
        }
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (a[floorIdx] == srch) {</span>
<span class="fc" id="L571">            return floorIdx - 1;</span>
        }
<span class="fc" id="L573">        return floorIdx;</span>
    }

    /**
     * find the greatest index i whose value a[i] is LT srch.
     * @param a list sorted by ascending values
     * @param srch value to srch for predecessor of.
     * @return the greatest index i whose value a[i] is LT srch.
     * range is [-1, n-1] where n = a.length.
     */
    public static int predecessor(List&lt;Integer&gt; a, int srch) {

        // range of values from floor is [-1, a.length-1]
<span class="fc" id="L586">        int floorIdx = MiscBisectingSearch.floor(a, srch);</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (floorIdx == -1) return floorIdx;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (a.get(floorIdx) == srch) return floorIdx - 1;</span>
<span class="fc" id="L590">        return floorIdx;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>