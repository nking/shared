<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NearestNeighbor2DLong.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.search</a> &gt; <span class="el_source">NearestNeighbor2DLong.java</span></div><h1>NearestNeighbor2DLong.java</h1><pre class="source lang-java linenums">package algorithms.search;

import algorithms.heapsAndPQs.YFastTrieLong;
import algorithms.util.ObjectSpaceEstimator;
import algorithms.util.PairInt;
import gnu.trove.iterator.TLongIterator;
import gnu.trove.map.TLongLongMap;
import gnu.trove.map.hash.TLongLongHashMap;
import gnu.trove.set.TLongSet;
import gnu.trove.set.hash.TLongHashSet;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

/**
 * a nearest neighbor's algorithm using XFastTrie
 * for predecessor and successor queries
 * on spatially indexed numbers.
 * 
 * The algorithm performs better on dense data
 * (that is because the base of the prefix tree
 * is filled, leaving smaller number of nodes to
 * create in linear time).
 * The queries depend upon the maximum of x and
 * maximum of y to be entered.
 * 
 * At this time, all entries must be non-negative numbers and
 * so must inquiries.
 * 
 * A worst case query would be when column 0 is
 * filled with points and no others filled elsewhere, 
 * and the last point in the last row and last 
 * column is the query point.
 * In this worst case, the query time would scale
 * roughly as maxY * O(log_2(w))
 
  The algorithm starts with a predecessor and successor 
  call on the query point.  The minimum distance among
  those 2 becomes the goal to search to for completeness
  as rows above and below the query in the same column.
  The search continues to higher rows making predecessor and
  successor calls until the goal is reached.  The next higher
  row is one less than the predecessor result.
  The goal to the complete search is reduced by smaller distance
  answers.  The same is repeated for lower rows.
  &lt;pre&gt;
  an example would be:
  
     0   1   2   3   4

     5   6   7   8   9

     10  11 *12  13  14     q='18'.  pred='15', succ='null' to goals(3, 23)
                                     13.pred='12'
    *15  16  17 *18  19              goals change to (13,23)
                                     13.succ='15', not closer than 12.
     20  21  22  23  24              23.pred and 23.succ not closer than 12
                             ans='12'.  queries: 3 pred, 3 succ queries.
                                     at O(log_2(w)) each
                                     complexity was 
                                           6 * O(log_2(w))
                                     for max index = 24, have w = 6 
 &lt;/pre&gt;

   first implemented in project
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright

   TODO: consider for the y-axis, adding locality based hashing or similar
 
 * @author nichole
 */
public class NearestNeighbor2DLong {
    
    private final YFastTrieLong xbt;
            
    private final int width;
    
    private final int height;
    
    private final long maxIndex;
    
<span class="fc" id="L87">    private boolean useCache = true;</span>
    
    //TODO: consider replacing these with weak reference key hash maps.
    //  even though the later take more space, they can evict keys no longer
    //  used elsewhere.  the google guava library has several structures 
    //  could use for a cache and there are a couple libraries such as cache 2k.
<span class="fc" id="L93">    private TLongLongMap pCache = new TLongLongHashMap();</span>
<span class="fc" id="L94">    private TLongLongMap sCache = new TLongLongHashMap();</span>
    
<span class="fc" id="L96">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    /**
     * 
     @param points non-negative coordinates
     @param imgWidth maximum x value of any data point + 1 including
     *    those to be queries
     @param imgHeight maximum y value of any data point + 1 including
     *    those to be queries
     */
    public NearestNeighbor2DLong(Set&lt;PairInt&gt; points,
<span class="fc" id="L107">        int imgWidth, int imgHeight) {</span>
        
<span class="fc" id="L109">        this.width = imgWidth;</span>
<span class="fc" id="L110">        this.height = imgHeight ;</span>
                
<span class="fc" id="L112">        maxIndex = (long)width * height;</span>
        
<span class="fc" id="L114">        int maxW = 1 + (int)Math.ceil(Math.log(maxIndex)/Math.log(2));</span>
        
<span class="fc" id="L116">        xbt = new YFastTrieLong(maxW);</span>
        
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (PairInt p : points) {</span>
            
<span class="fc" id="L120">            int x = p.getX();</span>
<span class="fc" id="L121">            int y = p.getY();</span>
                        
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">            if (x &gt; width || x &lt; 0) {</span>
<span class="nc" id="L124">                throw new IllegalArgumentException(</span>
                    &quot;x cannot be larger than &quot;
                    + &quot; maxX given in constructor &quot; + width
                    + &quot;. x=&quot; + x);
            }

<span class="pc bpc" id="L130" title="2 of 4 branches missed.">            if (y &gt; height || y &lt; 0) {</span>
<span class="nc" id="L131">                throw new IllegalArgumentException(</span>
                    &quot;y cannot be larger than &quot;
                    + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
            }
            
<span class="fc" id="L136">            long index = getInternalIndex(x, y);</span>
            
            //System.out.format(&quot;add %d  (%d, %d)\n&quot;, index, x, y);
            
<span class="fc" id="L140">            xbt.add(index);</span>
<span class="fc" id="L141">        }</span>
<span class="fc" id="L142">    }</span>
    
    /**
     * 
     @param pointIdxs pixel indexes formed from relationship
     *   pixIdx = (row * width) + col
     @param imgWidth maximum x value of any data point  + 1including
     *    those to be queries
     @param imgHeight maximum y value of any data point  + 1including
     *    those to be queries
     */
    public NearestNeighbor2DLong(TLongSet pointIdxs, 
<span class="fc" id="L154">        int imgWidth, int imgHeight) {</span>
        
<span class="fc" id="L156">        this.width = imgWidth;</span>
<span class="fc" id="L157">        this.height = imgHeight;</span>
                
<span class="fc" id="L159">        maxIndex = (long)width * height;</span>
        
<span class="fc" id="L161">        int maxW = 1 + (int)Math.ceil(Math.log(maxIndex)/Math.log(2));</span>
        
<span class="fc" id="L163">        xbt = new YFastTrieLong(maxW);</span>
        
<span class="fc" id="L165">        TLongIterator iter = pointIdxs.iterator();</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
            
<span class="fc" id="L168">            long pixIdx = iter.next();</span>
            
<span class="fc" id="L170">            int x = getCol(pixIdx);</span>
<span class="fc" id="L171">            int y = getRow(pixIdx);</span>
            
<span class="pc bpc" id="L173" title="2 of 4 branches missed.">            if (x &gt; width || x &lt; 0) {</span>
<span class="nc" id="L174">                throw new IllegalArgumentException(</span>
                    &quot;x cannot be larger than &quot;
                    + &quot; maxX given in constructor &quot; + width
                    + &quot;. x=&quot; + x);
            }

<span class="pc bpc" id="L180" title="2 of 4 branches missed.">            if (y &gt; height || y &lt; 0) {</span>
<span class="nc" id="L181">                throw new IllegalArgumentException(</span>
                    &quot;y cannot be larger than &quot;
                    + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
            }
            
<span class="fc" id="L186">            xbt.add(pixIdx);</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">    }</span>
    
    /**
     *
     */
    public void doNotUseCache() {
<span class="fc" id="L194">        useCache = false;</span>
<span class="fc" id="L195">    }</span>
    
    /**
     *
     @param col
     @param row
     @return
     */
    protected long getInternalIndex(int col, int row) {
<span class="fc" id="L204">        long t = ((long)width * row) + col;</span>
        
<span class="fc" id="L206">        return t;</span>
    }
    
    /**
     *
     @param internalIndex
     @return
     */
    protected int getRow(long internalIndex) {
<span class="fc" id="L215">        int row = (int)(internalIndex/width);        </span>
<span class="fc" id="L216">        return row;</span>
    }
    
    /**
     *
     @param internalIndex
     @return
     */
    protected int getCol(long internalIndex) {
        //int row = (int)(internalIndex/width);
        //int col = (int)(internalIndex - ((long)row * width));
<span class="fc" id="L227">        return (int)(internalIndex % width);</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.
            
         worst case: 
         
         Note, worst case is: first column
         filled with points and all else is empty and
         the number of rows is same or larger than 
         number of columns and the
         query is for the point in the last column and
         last row... a predecessor call is necessary for
         each row in the worst case.
          
     Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));            
     &lt;/pre&gt;
    
     @param x non-negative x coord to query for
     @param y non-negative y coord to query for
     @return 
     */
    public Set&lt;PairInt&gt; findClosest(final int x, final int y) {
        
<span class="fc" id="L256">        return findClosestWithinTolerance(x, y, 0);</span>
    }
    
    /**
     * NOTE: NOT READY FOR USE
     * method to return only the nearest point and any
     * that are at the same distance within a tolerance.
     * This is meant to be a nearest neighbor method
     * with ability to return more than one at same distance within a tolerance
     * of that distance.  
     * TODO: calculate the runtime complexity bounds....
     @param x non-negative x coord to query for
     @param y non-negative y coord to query for
     @param tolerance
     @return 
     */
    public Set&lt;PairInt&gt; findClosestWithinTolerance(int x, int y,
        double tolerance) {
        
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (xbt.size() == 0) {</span>
<span class="nc" id="L276">            log.warning(&quot;xbt is empty&quot;);</span>
<span class="nc" id="L277">            return new HashSet&lt;PairInt&gt;();</span>
        }
        
<span class="pc bpc" id="L280" title="2 of 4 branches missed.">        if (x &gt;= width || x &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L282">            log.fine(</span>
            &quot;x cannot be larger than &quot;
                + &quot; maxX given in constructor &quot; + width
                + &quot;. x=&quot; + x);
<span class="nc" id="L286">            return null;</span>
        }
        
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">        if (y &gt;= height || y &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L291">            log.fine(</span>
                &quot;y cannot be larger than &quot;
                + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
<span class="nc" id="L294">            return null;</span>
        }
        
<span class="fc" id="L297">        double closestDist = Double.MAX_VALUE;</span>
<span class="fc" id="L298">        double closestDistPlusTol = Double.MAX_VALUE;</span>
        
<span class="fc" id="L300">        TLongSet closestIndexes = new TLongHashSet();</span>
        
<span class="fc" id="L302">        long idx = getInternalIndex(x, y);</span>
        
        //System.out.format(&quot;find  %d  (=%d, %d)\n&quot;, idx, x, y);
        
        //O(1)
<span class="fc" id="L307">        long q = xbt.find(idx);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (q != -1) {</span>
            // have found nearest, but still need to search
            // within tolerance distance for others.
<span class="fc" id="L311">            closestDist = 0;</span>
<span class="fc" id="L312">            closestDistPlusTol = tolerance;</span>
<span class="fc" id="L313">            closestIndexes.add(idx);</span>
        }
                
<span class="fc" id="L316">        long predecessor = -1;</span>
<span class="fc" id="L317">        long successor = -1;</span>
        
<span class="pc bpc" id="L319" title="1 of 4 branches missed.">        if (useCache &amp;&amp; pCache.containsKey(idx)) {</span>
<span class="nc" id="L320">            predecessor = pCache.get(idx);</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L323">            predecessor = xbt.predecessor(idx);</span>
<span class="pc bpc" id="L324" title="1 of 4 branches missed.">            if (useCache &amp;&amp; predecessor != -1) {</span>
<span class="fc" id="L325">                pCache.put(idx, predecessor);</span>
            }
        }
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">        if (useCache &amp;&amp; sCache.containsKey(idx)) {</span>
<span class="nc" id="L329">            successor = sCache.get(idx);</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L332">            successor = xbt.successor(idx);</span>
<span class="pc bpc" id="L333" title="1 of 4 branches missed.">            if (useCache &amp;&amp; successor != -1){</span>
<span class="fc" id="L334">                sCache.put(idx, successor);</span>
            }
        }
        
<span class="fc" id="L338">        double dp2 = dist(x, y, predecessor);</span>
<span class="fc" id="L339">        double ds2 = dist(x, y, successor);</span>
<span class="fc" id="L340">        double dMin = Math.min(dp2, ds2);</span>
        
        //System.out.println(&quot;p=&quot; + predecessor + &quot; s=&quot; + successor);
 
        /*
        if smallest is smaller than closest 
           if the new closest diff with current is greater 
               than tol, clear the indexes and reset closest 
               vars and add smallest to indexes
               also add the other if within tolerance
           else if closer is within tolerance,
              update closest vars and add whichever or both 
              s2 and p2 to indexes (delaying detailed checks 
              of indexes until end of method)
        else if smallest is &lt;= closestPlusTol
            add s2 and/or p2 to indexes
        */
        
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (dMin &lt;= closestDist) {</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="fc" id="L360">                closestIndexes.clear();</span>
<span class="fc" id="L361">                closestDist = dMin;</span>
<span class="fc" id="L362">                closestDistPlusTol = closestDist + tolerance;</span>
            }
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">            if ((predecessor != -1) &amp;&amp; </span>
                (dp2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L366">                closestIndexes.add(predecessor);</span>
            }
<span class="fc bfc" id="L368" title="All 4 branches covered.">            if ((successor != -1) &amp;&amp;</span>
                (ds2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L370">                closestIndexes.add(successor);</span>
            }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L373" title="1 of 4 branches missed.">            if ((predecessor != -1) &amp;&amp; </span>
                (dp2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L375">                closestIndexes.add(predecessor);</span>
            }
<span class="pc bpc" id="L377" title="1 of 4 branches missed.">            if ((successor != -1) &amp;&amp;</span>
                (ds2 &lt;= closestDistPlusTol)) {
<span class="fc" id="L379">                closestIndexes.add(successor);</span>
            }
        }
        
        //add tolerance to goal
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        int goal = (closestDist != Double.MAX_VALUE) ?</span>
<span class="pc" id="L385">            (int)Math.ceil(closestDistPlusTol) : 0;</span>
        
<span class="fc" id="L387">        int yLow = estimateLowBound(y, goal);</span>
       
        int yCurrent;
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (predecessor == -1) {</span>
<span class="nc" id="L391">            yCurrent = Integer.MIN_VALUE;</span>
        } else {
<span class="fc" id="L393">            int pRow = getRow(predecessor);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            if (pRow &lt; y) {</span>
<span class="fc" id="L395">                yCurrent = pRow;</span>
            } else {
<span class="fc" id="L397">                yCurrent = pRow - 1;</span>
            }
        }
        
        //System.out.println(&quot;yCurrent=&quot; + yCurrent + &quot; yLow=&quot; + yLow);
        
        // predecessor searches until reach yLow, adjusting goal by
        //   min distances
<span class="fc" id="L405">        long p2 = -1; </span>
<span class="fc" id="L406">        long s2 = -1;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        while (yCurrent &gt;= yLow) {</span>
<span class="fc" id="L408">            long cIdx = getInternalIndex(x, yCurrent);</span>

            //O(1)
<span class="fc" id="L411">            q = xbt.find(cIdx);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (q != -1) {</span>
<span class="fc" id="L413">                p2 = q;</span>
<span class="fc" id="L414">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L415">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L417" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="nc" id="L418">                    p2 = pCache.get(cIdx);</span>
                } else {
<span class="fc" id="L420">                    p2 = xbt.predecessor(cIdx);</span>
<span class="pc bpc" id="L421" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != -1) {</span>
<span class="fc" id="L422">                        pCache.put(cIdx, p2);</span>
                    }
                }
<span class="pc bpc" id="L425" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="nc" id="L426">                    s2 = sCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L429">                    s2 = xbt.successor(cIdx);</span>
<span class="pc bpc" id="L430" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != -1) {</span>
<span class="fc" id="L431">                        sCache.put(cIdx, s2);</span>
                    }
                }
                
<span class="fc" id="L435">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L436">                ds2 = dist(x, y, s2);</span>
            }
        
<span class="fc" id="L439">            dMin = Math.min(dp2, ds2);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (dMin &lt;= closestDist) {</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="fc" id="L442">                    closestIndexes.clear();</span>
<span class="fc" id="L443">                    closestDist = dMin;</span>
<span class="fc" id="L444">                    closestDistPlusTol = closestDist + tolerance;</span>
<span class="fc" id="L445">                    goal = (int)Math.ceil(closestDistPlusTol);</span>
<span class="fc" id="L446">                    yLow = estimateLowBound(y, goal); </span>
                }
<span class="fc bfc" id="L448" title="All 4 branches covered.">                if ((p2 != -1) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L449">                    closestIndexes.add(p2);</span>
                }
<span class="fc bfc" id="L451" title="All 4 branches covered.">                if ((s2 != -1) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L452">                    closestIndexes.add(s2);</span>
                }
<span class="fc bfc" id="L454" title="All 2 branches covered.">            } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">                if ((p2 != -1) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L456">                    closestIndexes.add(p2);</span>
                }
<span class="fc bfc" id="L458" title="All 4 branches covered.">                if ((s2 != -1) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L459">                    closestIndexes.add(s2);</span>
                }
            }    
            
<span class="fc bfc" id="L463" title="All 2 branches covered.">            if (p2 != -1) {</span>
<span class="fc" id="L464">                long expectedNext = getInternalIndex(x, yCurrent - 1);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                if (p2 &gt; expectedNext) {</span>
<span class="fc" id="L466">                    yCurrent -= 1;</span>
                } else {
<span class="nc" id="L468">                    yCurrent = getRow(p2) - 1;</span>
                }
<span class="fc" id="L470">            } else {</span>
<span class="fc" id="L471">                yCurrent = Integer.MIN_VALUE;</span>
            }
<span class="fc" id="L473">        }</span>
       
        //System.out.println(&quot;yCurrent=&quot; + yCurrent + &quot; yLow=&quot; + yLow);
        //System.out.println(&quot;p=&quot; + p2 + &quot; s=&quot; + s2);
        
        // successor searches to higher bounds
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (successor == -1) {</span>
<span class="fc" id="L480">            yCurrent = Integer.MAX_VALUE;</span>
        } else {
<span class="fc" id="L482">            int sr = getRow(successor);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (sr &gt; y) {</span>
<span class="fc" id="L484">                yCurrent = sr;</span>
            } else {
<span class="fc" id="L486">                yCurrent = sr + 1;</span>
            }
        }
<span class="fc" id="L489">        int yHigh = estimateHighBound(y, goal);</span>
        
        //System.out.println(&quot;yCurrent=&quot; + yCurrent + &quot; yHigh=&quot; + yHigh);
        
<span class="fc bfc" id="L493" title="All 2 branches covered.">        while (yCurrent &lt;= yHigh) {</span>
<span class="fc" id="L494">            long cIdx = getInternalIndex(x, yCurrent);</span>
            
            //O(1)
<span class="fc" id="L497">            q = xbt.find(cIdx);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            if (q != -1) {</span>
<span class="fc" id="L499">                p2 = q;</span>
<span class="fc" id="L500">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L501">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="pc bpc" id="L503" title="1 of 4 branches missed.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="nc" id="L504">                    p2 = pCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L507">                    p2 = xbt.predecessor(cIdx);</span>
<span class="pc bpc" id="L508" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != -1) {</span>
<span class="fc" id="L509">                        pCache.put(cIdx, p2);</span>
                    }
                }
<span class="pc bpc" id="L512" title="1 of 4 branches missed.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="nc" id="L513">                    s2 = sCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L516">                    s2 = xbt.successor(cIdx);</span>
<span class="pc bpc" id="L517" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != -1) {</span>
<span class="fc" id="L518">                        sCache.put(cIdx, s2);</span>
                    }
                }
<span class="fc" id="L521">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L522">                ds2 = dist(x, y, s2);</span>
            }
            
<span class="fc" id="L525">            dMin = Math.min(dp2, ds2);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (dMin &lt;= closestDist) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                if (Math.abs(closestDist - dMin) &gt; tolerance) {</span>
<span class="fc" id="L528">                    closestIndexes.clear();</span>
<span class="fc" id="L529">                    closestDist = dMin;</span>
<span class="fc" id="L530">                    closestDistPlusTol = closestDist + tolerance;</span>
<span class="fc" id="L531">                    goal = (int)Math.ceil(closestDistPlusTol);</span>
<span class="fc" id="L532">                    yHigh = estimateHighBound(y, goal); </span>
                }
<span class="pc bpc" id="L534" title="1 of 4 branches missed.">                if ((p2 != -1) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L535">                    closestIndexes.add(p2);</span>
                }
<span class="fc bfc" id="L537" title="All 4 branches covered.">                if ((s2 != -1) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L538">                    closestIndexes.add(s2);</span>
                }
<span class="fc bfc" id="L540" title="All 2 branches covered.">            } else if (dMin &lt;= closestDistPlusTol) {</span>
<span class="pc bpc" id="L541" title="1 of 4 branches missed.">                if ((p2 != -1) &amp;&amp; dp2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L542">                    closestIndexes.add(p2);</span>
                }
<span class="fc bfc" id="L544" title="All 4 branches covered.">                if ((s2 != -1) &amp;&amp; ds2 &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L545">                    closestIndexes.add(s2);</span>
                }
            }    
            
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (s2 != -1) {</span>
<span class="fc" id="L550">                long expectedNext = getInternalIndex(x, yCurrent + 1);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (s2 &lt; expectedNext) {</span>
<span class="fc" id="L552">                    yCurrent += 1;</span>
                } else {
<span class="nc" id="L554">                    yCurrent = getRow(s2) + 1;</span>
                }
<span class="fc" id="L556">            } else {</span>
<span class="fc" id="L557">                yCurrent = Integer.MAX_VALUE;</span>
            }
            
            //System.out.println(&quot;yCurrent=&quot; + yCurrent + &quot; yHigh=&quot; + yHigh);
<span class="fc" id="L561">        }</span>
        
        //filter results for closest and tolerance
<span class="fc" id="L564">        Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L565">        TLongIterator iter = closestIndexes.iterator();</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L567">            long index2 = iter.next();</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">            if (dist(x, y, index2) &lt;= closestDistPlusTol) {</span>
<span class="fc" id="L569">                int x2 = getCol(index2);</span>
<span class="fc" id="L570">                int y2 = getRow(index2);</span>
<span class="fc" id="L571">                PairInt p3 = new PairInt(x2, y2);</span>
<span class="fc" id="L572">                results.add(p3);</span>
            }
<span class="fc" id="L574">        }</span>
 
<span class="fc" id="L576">        return results;</span>
    }
       
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 2 * O(log_2(maxW)).
            Note that caching leads to an O(1) term
            over time instead of the logarithmic term.
            
         worst case: nRows * 2 * O(log_2(maxW))
         
         Note, worst case is: first column
         filled with points and all else is empty and
         the number of rows is same or larger than 
         number of columns and the
         query is for the point in the last column and
         last row... a predecessor call is necessary for
         each row in the worst case.
          
     Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));            
     &lt;/pre&gt;
    
     @param x non-negative x coord to query for
     @param y non-negative y coord to query for
     @return 
     */
    public Set&lt;PairInt&gt; findClosestNotEqual(final int x, final int y) {
        
<span class="fc" id="L605">        return findClosest(x, y, Integer.MAX_VALUE, false);</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.
            
         worst case: 
         
      Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));
     &lt;/pre&gt;
    
     @param x
     @param y
     @param dMax
     @return a set of points within dMax that are the 
     * closest points, else returns an empty set
     */
    public Set&lt;PairInt&gt; findClosest(int x, int y, int dMax) {
<span class="fc" id="L627">        return findClosest(x, y, dMax, true);</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: 
            Note that caching leads to an O(1) term
            over time.
            
         worst case: 
         
      Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));
     &lt;/pre&gt;
    
     @param x
     @param y
     @param dMax
     @param includeEquals
     @return a set of points within dMax that are the 
     * closest points, else returns an empty set
     */
    private Set&lt;PairInt&gt; findClosest(int x, int y, int dMax, boolean includeEquals) {
        
<span class="pc bpc" id="L651" title="2 of 4 branches missed.">        if (x &gt;= width || x &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L653">            log.fine(</span>
            &quot;x cannot be larger than &quot;
                + &quot; maxX given in constructor &quot; + width
                + &quot;. x=&quot; + x);
<span class="nc" id="L657">            return null;</span>
        }
        
<span class="pc bpc" id="L660" title="2 of 4 branches missed.">        if (y &gt;= height || y &lt; 0) {</span>
            //throw new IllegalArgumentException(
<span class="nc" id="L662">            log.fine(</span>
                &quot;y cannot be larger than &quot;
                + &quot; maxY given in constructor &quot; + height + &quot;. y=&quot; + y);
<span class="nc" id="L665">            return null;</span>
        }
        
<span class="fc" id="L668">        long idx = getInternalIndex(x, y);</span>
        
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (includeEquals) {</span>
<span class="fc" id="L671">            long q = xbt.find(idx);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">            if (q != -1) {</span>
<span class="fc" id="L673">                Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L674">                results.add(new PairInt(x, y));</span>
<span class="fc" id="L675">                return results;</span>
            }
        }
                
<span class="fc" id="L679">        TLongSet closestIndexes = new TLongHashSet();</span>
        
<span class="fc" id="L681">        double closestDist = Double.MAX_VALUE;</span>
        
<span class="fc" id="L683">        long predecessor = -1;</span>
<span class="fc" id="L684">        long successor = -1;</span>
        
<span class="fc bfc" id="L686" title="All 4 branches covered.">        if (useCache &amp;&amp; pCache.containsKey(idx)) {</span>
<span class="fc" id="L687">            predecessor = pCache.get(idx);</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L690">            predecessor = xbt.predecessor(idx);</span>
<span class="pc bpc" id="L691" title="1 of 4 branches missed.">            if (useCache &amp;&amp; predecessor != -1) {</span>
<span class="fc" id="L692">                pCache.put(idx, predecessor);</span>
            }
        }
<span class="fc bfc" id="L695" title="All 4 branches covered.">        if (useCache &amp;&amp; sCache.containsKey(idx)) {</span>
<span class="fc" id="L696">            successor = sCache.get(idx);</span>
        } else {
            //O(log_2(maxW))
<span class="fc" id="L699">            successor = xbt.successor(idx);</span>
<span class="pc bpc" id="L700" title="1 of 4 branches missed.">            if (useCache &amp;&amp; successor != -1) {</span>
<span class="fc" id="L701">                sCache.put(idx, successor);</span>
            }
        }
        
<span class="fc" id="L705">        double dp2 = dist(x, y, predecessor);</span>
<span class="fc" id="L706">        double ds2 = dist(x, y, successor);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (!includeEquals) {</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">            if (dp2 == 0) {</span>
<span class="nc" id="L709">                ds2 = Double.MAX_VALUE;</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">            } else if (ds2 == 0) {</span>
<span class="nc" id="L711">                ds2 = Double.MAX_VALUE;</span>
            }
        }
<span class="fc bfc" id="L714" title="All 4 branches covered.">        if (dp2 &lt;= ds2 &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="fc" id="L715">            closestDist = dp2;</span>
<span class="fc" id="L716">            closestIndexes.add(predecessor);</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            if (dp2 == ds2) {</span>
<span class="fc" id="L718">                closestIndexes.add(successor);</span>
            }
<span class="fc bfc" id="L720" title="All 4 branches covered.">        } else if (ds2 &lt; dp2 &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="fc" id="L721">            closestDist = ds2;</span>
<span class="fc" id="L722">            closestIndexes.add(successor);</span>
        }
        
<span class="fc bfc" id="L725" title="All 2 branches covered.">        int goal = (closestDist != Double.MAX_VALUE) ?</span>
<span class="fc" id="L726">            (int)Math.ceil(closestDist) : dMax;</span>
        
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (goal &gt; dMax) {</span>
<span class="nc" id="L729">            goal = dMax;</span>
        }
        
<span class="fc" id="L732">        int yLow = estimateLowBound(y, goal);</span>
       
        int yCurrent;
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        if (predecessor == -1) {</span>
<span class="nc" id="L736">            yCurrent = Integer.MIN_VALUE;</span>
        } else {
<span class="fc" id="L738">            int pRow = getRow(predecessor);</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">            if (pRow &lt; y) {</span>
<span class="fc" id="L740">                yCurrent = pRow;</span>
            } else {
<span class="fc" id="L742">                yCurrent = pRow - 1;</span>
            }
        }
        
        // predecessor searches until reach yLow, adjusting goal by
        //   min distances
<span class="fc" id="L748">        long p2 = -1; </span>
<span class="fc" id="L749">        long s2 = -1;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        while (yCurrent &gt;= yLow) {</span>
<span class="fc" id="L751">            long cIdx = getInternalIndex(x, yCurrent);</span>
            
<span class="fc" id="L753">            long q = xbt.find(cIdx);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (q != -1) {</span>
<span class="fc" id="L755">                p2 = q;</span>
<span class="fc" id="L756">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L757">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="fc bfc" id="L759" title="All 4 branches covered.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="fc" id="L760">                    p2 = pCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L763">                    p2 = xbt.predecessor(cIdx);</span>
<span class="pc bpc" id="L764" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != -1) {</span>
<span class="fc" id="L765">                        pCache.put(cIdx, p2);</span>
                    }
                }
<span class="fc bfc" id="L768" title="All 4 branches covered.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="fc" id="L769">                    s2 = sCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L772">                    s2 = xbt.successor(cIdx);</span>
<span class="pc bpc" id="L773" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != -1) {</span>
<span class="fc" id="L774">                        sCache.put(cIdx, s2);</span>
                    }
                }
<span class="fc" id="L777">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L778">                ds2 = dist(x, y, s2);</span>
            }
<span class="fc bfc" id="L780" title="All 2 branches covered.">            if (!includeEquals) {</span>
<span class="pc bpc" id="L781" title="1 of 4 branches missed.">                if (s2 != -1 &amp;&amp; s2 == idx) {</span>
<span class="nc" id="L782">                    ds2 = Double.MAX_VALUE;</span>
                }
            }
<span class="fc bfc" id="L785" title="All 6 branches covered.">            if ((dp2 &lt; ds2) &amp;&amp; (dp2 &lt; closestDist) &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="fc" id="L786">                closestIndexes.clear();</span>
<span class="fc" id="L787">                closestDist = dp2;</span>
<span class="fc" id="L788">                closestIndexes.add(p2);</span>
<span class="fc" id="L789">                goal = (int)Math.ceil(closestDist);</span>
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L791">                    goal = dMax;</span>
                }
<span class="fc" id="L793">                yLow = estimateLowBound(y, goal);                </span>
<span class="fc bfc" id="L794" title="All 6 branches covered.">            } else if ((ds2 &lt; dp2) &amp;&amp; (ds2 &lt; closestDist) &amp;&amp; (ds2 &lt;= dMax)) {</span>
                           
<span class="fc" id="L796">                closestIndexes.clear();</span>
<span class="fc" id="L797">                closestDist = ds2;</span>
<span class="fc" id="L798">                closestIndexes.add(s2);</span>
<span class="fc" id="L799">                goal = (int)Math.ceil(closestDist);</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L801">                    goal = dMax;</span>
                }
<span class="fc" id="L803">                yLow = estimateLowBound(y, goal);</span>
<span class="pc bpc" id="L804" title="2 of 6 branches missed.">            } else if (dp2 == closestDist &amp;&amp; (dp2 != Double.MAX_VALUE)</span>
                &amp;&amp; (dp2 &lt;= dMax)) {               
<span class="fc" id="L806">                closestIndexes.add(p2);</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">                if (dp2 == ds2) {</span>
<span class="nc" id="L808">                    closestIndexes.add(s2);</span>
                }
<span class="pc bpc" id="L810" title="2 of 6 branches missed.">            } else if (ds2 == closestDist &amp;&amp; (ds2 != Double.MAX_VALUE)</span>
                &amp;&amp; (ds2 &lt;= dMax)) {                
<span class="fc" id="L812">                closestIndexes.add(s2);</span>
            }
            
<span class="fc bfc" id="L815" title="All 2 branches covered.">            if (p2 != -1) {</span>
<span class="fc" id="L816">                long expectedNext = getInternalIndex(x, yCurrent - 1);</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                if (p2 &gt; expectedNext) {</span>
<span class="fc" id="L818">                    yCurrent -= 1;</span>
                } else {
<span class="nc" id="L820">                    yCurrent = getRow(p2) - 1;</span>
                }
<span class="fc" id="L822">            } else {</span>
<span class="fc" id="L823">                yCurrent = Integer.MIN_VALUE;</span>
            }
<span class="fc" id="L825">        }</span>
        
        // successor searches to higher bounds
<span class="fc bfc" id="L828" title="All 2 branches covered.">        if (successor == -1) {</span>
<span class="fc" id="L829">            yCurrent = Integer.MAX_VALUE;</span>
        } else {
<span class="fc" id="L831">            int sr = getRow(successor);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            if (sr &gt; y) {</span>
<span class="fc" id="L833">                yCurrent = sr;</span>
            } else {
<span class="fc" id="L835">                yCurrent = sr + 1;</span>
            }
        }
<span class="fc" id="L838">        int yHigh = estimateHighBound(y, goal);</span>
        
<span class="fc bfc" id="L840" title="All 2 branches covered.">        while (yCurrent &lt;= yHigh) {</span>
<span class="fc" id="L841">            long cIdx = getInternalIndex(x, yCurrent);</span>
<span class="fc" id="L842">            long q = xbt.find(cIdx);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            if (q != -1) {</span>
<span class="fc" id="L844">                p2 = q;</span>
<span class="fc" id="L845">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L846">                ds2 = Double.MAX_VALUE;</span>
            } else {
<span class="fc bfc" id="L848" title="All 4 branches covered.">                if (useCache &amp;&amp; pCache.containsKey(cIdx)) {</span>
<span class="fc" id="L849">                    p2 = pCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L852">                    p2 = xbt.predecessor(cIdx);</span>
<span class="pc bpc" id="L853" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; p2 != -1) {</span>
<span class="fc" id="L854">                        pCache.put(cIdx, p2);</span>
                    }
                }
<span class="fc bfc" id="L857" title="All 4 branches covered.">                if (useCache &amp;&amp; sCache.containsKey(cIdx)) {</span>
<span class="fc" id="L858">                    s2 = sCache.get(cIdx);</span>
                } else {
                    //O(log_2(maxW))
<span class="fc" id="L861">                    s2 = xbt.successor(cIdx);</span>
<span class="pc bpc" id="L862" title="1 of 4 branches missed.">                    if (useCache &amp;&amp; s2 != -1) {</span>
<span class="fc" id="L863">                        sCache.put(cIdx, s2);</span>
                    }
                }
<span class="fc" id="L866">                dp2 = dist(x, y, p2);</span>
<span class="fc" id="L867">                ds2 = dist(x, y, s2);</span>
            }
<span class="fc bfc" id="L869" title="All 2 branches covered.">            if (!includeEquals) {</span>
<span class="pc bpc" id="L870" title="2 of 4 branches missed.">                if (p2 != -1 &amp;&amp; p2 == idx) {</span>
<span class="nc" id="L871">                    dp2 = Double.MAX_VALUE;</span>
<span class="pc bpc" id="L872" title="1 of 4 branches missed.">                } else if (s2 != -1 &amp;&amp; s2 == idx) {</span>
<span class="nc" id="L873">                    ds2 = Double.MAX_VALUE;</span>
                }
            }
<span class="fc bfc" id="L876" title="All 6 branches covered.">            if ((dp2 &lt; ds2) &amp;&amp; (dp2 &lt; closestDist) &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="fc" id="L877">                closestIndexes.clear();</span>
<span class="fc" id="L878">                closestDist = dp2;                </span>
<span class="fc" id="L879">                closestIndexes.add(p2);</span>
<span class="fc" id="L880">                goal = (int)Math.ceil(closestDist);</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L882">                    goal = dMax;</span>
                }
<span class="fc" id="L884">                yHigh = estimateHighBound(y, goal);</span>
<span class="fc bfc" id="L885" title="All 6 branches covered.">            } else if ((ds2 &lt; dp2) &amp;&amp; (ds2 &lt; closestDist) &amp;&amp; (ds2 &lt;= dMax)) {                </span>
<span class="fc" id="L886">                closestIndexes.clear();</span>
<span class="fc" id="L887">                closestDist = ds2;</span>
<span class="fc" id="L888">                closestIndexes.add(s2);</span>
<span class="fc" id="L889">                goal = (int)Math.ceil(closestDist);</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">                if (goal &gt; dMax) {</span>
<span class="nc" id="L891">                    goal = dMax;</span>
                }
<span class="fc" id="L893">                yHigh = estimateHighBound(y, goal);</span>
<span class="pc bpc" id="L894" title="2 of 6 branches missed.">            } else if (dp2 == closestDist &amp;&amp; (dp2 != Double.MAX_VALUE)</span>
                &amp;&amp; (dp2 &lt;= dMax)) {                
<span class="fc" id="L896">                closestIndexes.add(p2);</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">                if (dp2 == ds2) {                    </span>
<span class="fc" id="L898">                    closestIndexes.add(s2);</span>
                }
<span class="pc bpc" id="L900" title="2 of 6 branches missed.">            } else if (ds2 == closestDist &amp;&amp; (ds2 != Double.MAX_VALUE)</span>
                &amp;&amp; (ds2 &lt;= dMax)) {                
<span class="fc" id="L902">                closestIndexes.add(s2);</span>
            } 
            
<span class="fc bfc" id="L905" title="All 2 branches covered.">            if (s2 != -1) {</span>
<span class="fc" id="L906">                long expectedNext = getInternalIndex(x, yCurrent + 1);</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">                if (s2 &lt; expectedNext) {</span>
<span class="fc" id="L908">                    yCurrent += 1;</span>
                } else {
<span class="nc" id="L910">                    yCurrent = getRow(s2) + 1;</span>
                }
<span class="fc" id="L912">            } else {</span>
<span class="fc" id="L913">                yCurrent = Integer.MAX_VALUE;</span>
            }
<span class="fc" id="L915">        }</span>
        
<span class="fc" id="L917">        Set&lt;PairInt&gt; results = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L918">        TLongIterator iter = closestIndexes.iterator();</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L920">            long index2 = iter.next();</span>
<span class="fc" id="L921">            int x2 = getCol(index2);</span>
<span class="fc" id="L922">            int y2 = getRow(index2);</span>
<span class="fc" id="L923">            results.add(new PairInt(x2, y2));</span>
<span class="fc" id="L924">        }</span>
        
<span class="fc" id="L926">        return results;</span>
    }

    private double dist(int x, int y, long p2) {
        
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (p2 == -1) {</span>
<span class="fc" id="L932">            return Double.MAX_VALUE;</span>
        }
        
<span class="fc" id="L935">        int x2 = getCol(p2);</span>
<span class="fc" id="L936">        int y2 = getRow(p2);</span>
        
<span class="fc" id="L938">        int diffX = x2 - x;</span>
<span class="fc" id="L939">        int diffY = y2 - y;</span>
<span class="fc" id="L940">        double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>
        
<span class="fc" id="L942">        return dist;</span>
    }

    private int estimateLowBound(int y, int goal) {

<span class="fc" id="L947">        int low = y - goal;</span>
        
<span class="fc bfc" id="L949" title="All 2 branches covered.">        if (low &lt; 0) {</span>
<span class="fc" id="L950">            low = 0;</span>
        }
        
<span class="fc" id="L953">        return low;</span>
    }
    
    private int estimateHighBound(int y, int goal) {

<span class="fc" id="L958">        int high = y + goal;</span>
        
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (high &gt; height) {</span>
<span class="fc" id="L961">            high = height;</span>
        }
        
<span class="fc" id="L964">        return high;</span>
    }
 
    /**
     *
     @param numberOfPoints
     @param maxBitLength
     @return
     */
    public static long estimateSizeOnHeap(int numberOfPoints,
        int maxBitLength) {
         
<span class="nc" id="L976">        long[] yTotals = YFastTrieLong.estimateSizeOnHeap(numberOfPoints, </span>
            maxBitLength);
        
        //System.out.println(&quot;yft estimates=&quot; + Arrays.toString(yTotals));
        
<span class="nc" id="L981">        ObjectSpaceEstimator est = new ObjectSpaceEstimator();</span>
<span class="nc" id="L982">        est.setNObjRefsFields(4);</span>
<span class="nc" id="L983">        est.setNIntFields(2);</span>
<span class="nc" id="L984">        est.setNLongFields(1);</span>
<span class="nc" id="L985">        est.setNBooleanFields(1);</span>
        
<span class="nc" id="L987">        long total = est.estimateSizeOnHeap();</span>
       
<span class="nc" id="L989">        total += yTotals[1];</span>
                
<span class="nc" id="L991">        return total;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>