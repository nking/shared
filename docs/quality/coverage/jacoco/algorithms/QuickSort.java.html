<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.sort.MiscSorter;
import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="nc" id="L15">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     @param a items to sort
     */
    public static void sort(float[] a) {
<span class="fc" id="L22">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L23">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L33">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L36">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L39">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L42">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L43">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L54">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L56" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L57">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L60">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L63">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L64">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L74">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L77">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L80">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L83">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L84">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L94">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L103">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L104">    }</span>
    
    /**
     *
     @param a
     */
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L113">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L116">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L117">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L127">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L130">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L133">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L136">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L137">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, int[] b) {
<span class="nc" id="L145">        MiscSorter.sortBy1stArg(a, b);    </span>
<span class="nc" id="L146">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TFloatList a, int[] b) {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (b.length != a.size()) {</span>
<span class="nc" id="L155">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="fc" id="L157">        sortBy1stArg(a, b, 0, a.size() - 1);    </span>
<span class="fc" id="L158">    }</span>
    
    /**
    ascending sort of abc
    @param abc array to sort
    */
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L167">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L170">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L171">    }</span>
    
    /**
    ascending sort of a
    @param a array to sort
    @param b array to sort using order of a
    @param &lt;T&gt; paramter type of objects in list b
    */
    public static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b) {
    
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L191">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L192">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     @param a items to sort
     @param b items to be sorted by same order as a
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L202">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L205">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L208">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L211">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L212">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L225">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L228">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L231">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L232">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L242">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L251">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L252">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L262">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L268">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L271">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L272">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L285">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L288">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L291">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L292">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b) {

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L303">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L306">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L309">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L312">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L313">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L324">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L327">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L330">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L333">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L336">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L337">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L349">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L355">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L358">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L361">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L364">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L365">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L375">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L378">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L381">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L384">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L385">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param &lt;S&gt;
     @param a
     @param b
     @param c
     */
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
<span class="fc" id="L396">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L397">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param &lt;S&gt;
     @param a
     @param b
     @param c
     @param idxLo
     @param idxHi
     */
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L413">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L416">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L419">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L429">            return;</span>
        }
        
<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L434">            int x = a[idxLo];</span>
<span class="fc" id="L435">            int store = idxLo;</span>
<span class="fc" id="L436">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L440">                    store++;     </span>
<span class="fc bfc" id="L441" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L443">                    idxMid--;</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L446">                    break;</span>
                }
<span class="fc" id="L448">                int swap = a[store];</span>
<span class="fc" id="L449">                a[store] = a[idxMid];</span>
<span class="fc" id="L450">                a[idxMid] = swap;</span>
                
<span class="fc" id="L452">                T swap2 = b.get(store);</span>
<span class="fc" id="L453">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L454">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L456">                S swap3 = c.get(store);</span>
<span class="fc" id="L457">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L458">                c.set(idxMid, swap3);</span>
                
<span class="fc" id="L460">            }</span>
            
<span class="fc" id="L462">            int swap = a[idxLo];</span>
<span class="fc" id="L463">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L464">            a[idxMid] = swap;</span>

<span class="fc" id="L466">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L467">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L468">            b.set(idxMid, swap2);</span>

<span class="fc" id="L470">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L471">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L472">            c.set(idxMid, swap3);</span>
         
<span class="fc" id="L474">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L476">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L478">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param c items to be sorted by same order as a
     @param idxLo low index of a
     @param idxHi high index of a
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L493">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L496">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L499">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L502">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L505">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L509">            return;</span>
        }
        
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L514">            int x = a.get(idxLo);</span>
<span class="fc" id="L515">            int store = idxLo;</span>
<span class="fc" id="L516">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L520">                    store++;     </span>
<span class="fc bfc" id="L521" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L523">                    idxMid--;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L526">                    break;</span>
                }
<span class="nc" id="L528">                int swap = a.get(store);</span>
<span class="nc" id="L529">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L530">                a.set(idxMid, swap);</span>
<span class="nc" id="L531">                swap = c.get(store);</span>
<span class="nc" id="L532">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L533">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L535">                double bSwap = b.get(store);</span>
<span class="nc" id="L536">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L537">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L538">            }</span>
<span class="fc" id="L539">            int swap = a.get(idxLo);</span>
<span class="fc" id="L540">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L541">            a.set(idxMid, swap);</span>
<span class="fc" id="L542">            swap = c.get(idxLo);</span>
<span class="fc" id="L543">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L544">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L546">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L547">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L548">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L550">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L552">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L554">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param c items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L569">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L572">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L575">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L578">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L581">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L585">            return;</span>
        }
        
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L590">            float x = a.get(idxLo);</span>
<span class="fc" id="L591">            int store = idxLo;</span>
<span class="fc" id="L592">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L596">                    store++;     </span>
<span class="fc bfc" id="L597" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L599">                    idxMid--;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L602">                    break;</span>
                }
<span class="nc" id="L604">                float swap = a.get(store);</span>
<span class="nc" id="L605">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L606">                a.set(idxMid, swap);</span>
<span class="nc" id="L607">                int swap2 = c.get(store);</span>
<span class="nc" id="L608">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L609">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L611">                swap2 = b.get(store);</span>
<span class="nc" id="L612">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L613">                b.set(idxMid, swap2);</span>
<span class="nc" id="L614">            }</span>
<span class="fc" id="L615">            float swap = a.get(idxLo);</span>
<span class="fc" id="L616">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L617">            a.set(idxMid, swap);</span>
<span class="fc" id="L618">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L619">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L620">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L622">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L623">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L624">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L626">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L628">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L630">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L643">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L646">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L649">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L653">            return;</span>
        }
        
        float swap;
        int swap2;
<span class="fc bfc" id="L658" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L660">            float x = a.get(idxLo);</span>
<span class="fc" id="L661">            int store = idxLo;</span>
<span class="fc" id="L662">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L666">                    store++;     </span>
<span class="fc bfc" id="L667" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L669">                    idxMid--;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L672">                    break;</span>
                }
<span class="nc" id="L674">                swap = a.get(store);</span>
<span class="nc" id="L675">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L676">                a.set(idxMid, swap);</span>
                
<span class="nc" id="L678">                swap2 = b[store];</span>
<span class="nc" id="L679">                b[store] = b[idxMid];</span>
<span class="nc" id="L680">                b[idxMid] = swap2;</span>
            }
<span class="fc" id="L682">            swap = a.get(idxLo);</span>
<span class="fc" id="L683">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L684">            a.set(idxMid, swap);</span>
            
<span class="fc" id="L686">            swap2 = b[idxLo];</span>
<span class="fc" id="L687">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L688">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L690">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L692">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L694">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
      @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L708">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L711">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L714">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L718">            return;</span>
        }
        
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L723">            float x = a.get(idxLo);</span>
<span class="nc" id="L724">            int store = idxLo;</span>
<span class="nc" id="L725">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L729">                    store++;     </span>
<span class="nc bnc" id="L730" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L732">                    idxMid--;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L735">                    break;</span>
                }
<span class="nc" id="L737">                float swap = a.get(store);</span>
<span class="nc" id="L738">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L739">                a.set(idxMid, swap);</span>
<span class="nc" id="L740">                int swap2 = b.get(store);</span>
<span class="nc" id="L741">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L742">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L744">            }</span>
<span class="nc" id="L745">            float swap = a.get(idxLo);</span>
<span class="nc" id="L746">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L747">            a.set(idxMid, swap);</span>
<span class="nc" id="L748">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L749">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L750">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L752">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L754">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L756">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; parameter type of objects in b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L771">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L774">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L777">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L781">            return;</span>
        }
        
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L786">            float x = a.get(idxLo);</span>
<span class="fc" id="L787">            int store = idxLo;</span>
<span class="fc" id="L788">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L792">                    store++;     </span>
<span class="fc bfc" id="L793" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L795">                    idxMid--;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L798">                    break;</span>
                }
<span class="fc" id="L800">                float swap = a.get(store);</span>
<span class="fc" id="L801">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L802">                a.set(idxMid, swap);</span>
<span class="fc" id="L803">                T swap2 = b.get(store);</span>
<span class="fc" id="L804">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L805">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L807">            }</span>
<span class="fc" id="L808">            float swap = a.get(idxLo);</span>
<span class="fc" id="L809">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L810">            a.set(idxMid, swap);</span>
<span class="fc" id="L811">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L812">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L813">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L815">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L817">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L819">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
      @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L832">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L835">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L838">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L842">            return;</span>
        }
        
<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L847">            int x = a.get(idxLo);</span>
<span class="fc" id="L848">            int store = idxLo;</span>
<span class="fc" id="L849">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L853">                    store++;     </span>
<span class="fc bfc" id="L854" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L856">                    idxMid--;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L859">                    break;</span>
                }
<span class="nc" id="L861">                int swap = a.get(store);</span>
<span class="nc" id="L862">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L863">                a.set(idxMid, swap);</span>
<span class="nc" id="L864">                swap = b.get(store);</span>
<span class="nc" id="L865">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L866">                b.set(idxMid, swap);</span>
<span class="nc" id="L867">            }</span>
<span class="fc" id="L868">            int swap = a.get(idxLo);</span>
<span class="fc" id="L869">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L870">            a.set(idxMid, swap);</span>
<span class="fc" id="L871">            swap = b.get(idxLo);</span>
<span class="fc" id="L872">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L873">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L875">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L877">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L879">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param abc items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L892">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L896">            return;</span>
        }
        
<span class="fc bfc" id="L899" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L901">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L902">            int store = idxLo;</span>
<span class="fc" id="L903">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L907">                    store++;     </span>
<span class="fc bfc" id="L908" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L910">                    idxMid--;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L913">                    break;</span>
                }
<span class="nc" id="L915">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L916">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L917">                abc[idxMid] = swap;</span>
<span class="nc" id="L918">            }</span>
<span class="fc" id="L919">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L920">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L921">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L923">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L925">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L927">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L939">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L942">            return;</span>
        }
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L946">            float x = a[idxLo];</span>
<span class="fc" id="L947">            int store = idxLo;</span>
<span class="fc" id="L948">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L952">                    store++;     </span>
<span class="fc bfc" id="L953" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L955">                    idxMid--;</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L958">                    break;</span>
                }
<span class="fc" id="L960">                float swap = a[store];</span>
<span class="fc" id="L961">                a[store] = a[idxMid];</span>
<span class="fc" id="L962">                a[idxMid] = swap;</span>
<span class="fc" id="L963">            }</span>
<span class="fc" id="L964">            float swap = a[idxLo];</span>
<span class="fc" id="L965">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L966">            a[idxMid] = swap;</span>
         
<span class="fc" id="L968">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L970">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L972">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;T&gt;
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L987">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L990">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L992" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L993">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L996">            return;</span>
        }
        
<span class="nc bnc" id="L999" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1001">            int x = a[idxLo];</span>
<span class="nc" id="L1002">            int store = idxLo;</span>
<span class="nc" id="L1003">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1007">                    store++;     </span>
<span class="nc bnc" id="L1008" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L1010">                    idxMid--;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1014">                    break;</span>
                }
<span class="nc" id="L1016">                int swap = a[store];</span>
<span class="nc" id="L1017">                a[store] = a[idxMid];</span>
<span class="nc" id="L1018">                a[idxMid] = swap;</span>
<span class="nc" id="L1019">                T swap2 = b[store];</span>
<span class="nc" id="L1020">                b[store] = b[idxMid];</span>
<span class="nc" id="L1021">                b[idxMid] = swap2;</span>
<span class="nc" id="L1022">            }</span>
<span class="nc" id="L1023">            int swap = a[idxLo];</span>
<span class="nc" id="L1024">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1025">            a[idxMid] = swap;</span>
<span class="nc" id="L1026">            T swap2 = b[idxLo];</span>
<span class="nc" id="L1027">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1028">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L1030">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1032">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1034">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1048">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1051">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1054">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1057">            return;</span>
        }
        
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1062">            int x = a[idxLo];</span>
<span class="fc" id="L1063">            int store = idxLo;</span>
<span class="fc" id="L1064">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1068">                    store++;     </span>
<span class="pc bpc" id="L1069" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1071">                    idxMid--;</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1074" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1075">                    break;</span>
                }
<span class="fc" id="L1077">                int swap = a[store];</span>
<span class="fc" id="L1078">                a[store] = a[idxMid];</span>
<span class="fc" id="L1079">                a[idxMid] = swap;</span>
<span class="fc" id="L1080">                swap = b[store];</span>
<span class="fc" id="L1081">                b[store] = b[idxMid];</span>
<span class="fc" id="L1082">                b[idxMid] = swap;</span>
<span class="fc" id="L1083">            }</span>
<span class="fc" id="L1084">            int swap = a[idxLo];</span>
<span class="fc" id="L1085">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1086">            a[idxMid] = swap;</span>
<span class="fc" id="L1087">            swap = b[idxLo];</span>
<span class="fc" id="L1088">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1089">            b[idxMid] = swap;</span>
         
<span class="fc" id="L1091">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1093">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1095">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;T&gt; type of items in list b
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1111">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1114">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1117">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1120">            return;</span>
        }
        
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1125">            int x = a.get(idxLo);</span>
<span class="fc" id="L1126">            int store = idxLo;</span>
<span class="fc" id="L1127">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1131">                    store++;     </span>
<span class="pc bpc" id="L1132" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L1134">                    idxMid--;</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L1137" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1138">                    break;</span>
                }
<span class="fc" id="L1140">                int swap = a.get(store);</span>
<span class="fc" id="L1141">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1142">                a.set(idxMid, swap);</span>
<span class="fc" id="L1143">                T swap2 = b.get(store);</span>
<span class="fc" id="L1144">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1145">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1146">            }</span>
<span class="fc" id="L1147">            int swap = a.get(idxLo);</span>
<span class="fc" id="L1148">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1149">            a.set(idxMid, swap);</span>
<span class="fc" id="L1150">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1151">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1152">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1154">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1156">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1158">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;S&gt;
     @param a items to sort
     @param b items to sort by order of a
     @param &lt;T&gt; type of items in list b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1175">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1178">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1181">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1184">            return;</span>
        }
        
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1189">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1190">            int store = idxLo;</span>
<span class="fc" id="L1191">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1195">                    store++;     </span>
<span class="pc bpc" id="L1196" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1198">                    idxMid--;</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1202">                    break;</span>
                }
<span class="fc" id="L1204">                S swap = a.get(store);</span>
<span class="fc" id="L1205">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1206">                a.set(idxMid, swap);</span>
<span class="fc" id="L1207">                T swap2 = b.get(store);</span>
<span class="fc" id="L1208">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1209">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1210">            }</span>
<span class="fc" id="L1211">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1212">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1213">            a.set(idxMid, swap);</span>
<span class="fc" id="L1214">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1215">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1216">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1218">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1220">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1222">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1235">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1238">            return;</span>
        }
        
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1243">            double x = a[idxLo];</span>
<span class="fc" id="L1244">            int store = idxLo;</span>
<span class="fc" id="L1245">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1249">                    store++;     </span>
<span class="fc bfc" id="L1250" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1252">                    idxMid--;</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1255" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1256">                    break;</span>
                }
<span class="fc" id="L1258">                double swap = a[store];</span>
<span class="fc" id="L1259">                a[store] = a[idxMid];</span>
<span class="fc" id="L1260">                a[idxMid] = swap;</span>
<span class="fc" id="L1261">            }</span>
<span class="fc" id="L1262">            double swap = a[idxLo];</span>
<span class="fc" id="L1263">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1264">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1266">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1268">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1270">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1284">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1287">            return;</span>
        }
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1291">            float x = a[idxLo];</span>
<span class="fc" id="L1292">            int store = idxLo;</span>
<span class="fc" id="L1293">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1297">                    store++;     </span>
<span class="fc bfc" id="L1298" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1300">                    idxMid--;</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1303">                    break;</span>
                }
<span class="fc" id="L1305">                float swap = a[store];</span>
<span class="fc" id="L1306">                a[store] = a[idxMid];</span>
<span class="fc" id="L1307">                a[idxMid] = swap;</span>
<span class="fc" id="L1308">                int swap2 = b[store];</span>
<span class="fc" id="L1309">                b[store] = b[idxMid];</span>
<span class="fc" id="L1310">                b[idxMid] = swap2;</span>
<span class="fc" id="L1311">            }</span>
<span class="fc" id="L1312">            float swap = a[idxLo];</span>
<span class="fc" id="L1313">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1314">            a[idxMid] = swap;</span>
<span class="fc" id="L1315">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1316">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1317">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1319">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1321">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1323">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1337">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1340">            return;</span>
        }
<span class="fc bfc" id="L1342" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1344">            double x = a.get(idxLo);</span>
<span class="fc" id="L1345">            int store = idxLo;</span>
<span class="fc" id="L1346">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1350">                    store++;     </span>
<span class="fc bfc" id="L1351" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1353">                    idxMid--;</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1356">                    break;</span>
                }
<span class="fc" id="L1358">                double swap = a.get(store);</span>
<span class="fc" id="L1359">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1360">                a.set(idxMid, swap);</span>
<span class="fc" id="L1361">                int swap2 = b[store];</span>
<span class="fc" id="L1362">                b[store] = b[idxMid];</span>
<span class="fc" id="L1363">                b[idxMid] = swap2;</span>
<span class="fc" id="L1364">            }</span>
<span class="fc" id="L1365">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1366">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1367">            a.set(idxMid, swap);</span>
<span class="fc" id="L1368">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1369">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1370">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1372">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1374">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1376">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
<span class="nc" id="L1388">        MiscSorter.sortBy1stArg(a, b, idxLo, idxHi); </span>
<span class="nc" id="L1389">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1402">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1405">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1408">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1412">            return;</span>
        }
        
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1417">            int x = a[idxLo];</span>
<span class="nc" id="L1418">            int store = idxLo;</span>
<span class="nc" id="L1419">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1423">                    store++;     </span>
<span class="nc bnc" id="L1424" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1426">                    idxMid--;</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1429">                    break;</span>
                }
<span class="nc" id="L1431">                int swap = a[store];</span>
<span class="nc" id="L1432">                a[store] = a[idxMid];</span>
<span class="nc" id="L1433">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1435">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1436">                b[store] = b[idxMid];</span>
<span class="nc" id="L1437">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1438">            }</span>
<span class="nc" id="L1439">            int swap = a[idxLo];</span>
<span class="nc" id="L1440">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1441">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1443">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1444">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1445">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1447">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1449">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1451">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param &lt;S&gt; type of items in list c
     @param c
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
        
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1465">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1468">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1470" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1471">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1474">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1477">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1478">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param &lt;S&gt; type of items in list c
     @param c
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1493" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1494">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1497">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1500">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1503">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1507">            return;</span>
        }
        
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1512">            float x = a[idxLo];</span>
<span class="fc" id="L1513">            int store = idxLo;</span>
<span class="fc" id="L1514">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1518">                    store++;     </span>
<span class="fc bfc" id="L1519" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1521">                    idxMid--;</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1524">                    break;</span>
                }
<span class="fc" id="L1526">                float swap = a[store];</span>
<span class="fc" id="L1527">                a[store] = a[idxMid];</span>
<span class="fc" id="L1528">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1530">                T swap2 = b.get(store);</span>
<span class="fc" id="L1531">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1532">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1534">                S swap3 = c.get(store);</span>
<span class="fc" id="L1535">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1536">                c.set(idxMid, swap3);</span>
<span class="fc" id="L1537">            }</span>
<span class="fc" id="L1538">            float swap = a[idxLo];</span>
<span class="fc" id="L1539">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1540">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1542">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1543">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1544">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1546">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L1547">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1548">            c.set(idxMid, swap3);</span>
            
<span class="fc" id="L1550">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1552">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1554">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1567">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1570">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1573">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1577">            return;</span>
        }
        
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1582">            int x = a[idxLo];</span>
<span class="fc" id="L1583">            int store = idxLo;</span>
<span class="fc" id="L1584">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1588">                    store++;     </span>
<span class="fc bfc" id="L1589" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1591">                    idxMid--;</span>
<span class="fc bfc" id="L1592" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1594">                    break;</span>
                }
<span class="fc" id="L1596">                int swap = a[store];</span>
<span class="fc" id="L1597">                a[store] = a[idxMid];</span>
<span class="fc" id="L1598">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1600">                Object bSwap = b[store];</span>
<span class="fc" id="L1601">                b[store] = b[idxMid];</span>
<span class="fc" id="L1602">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1603">            }</span>
<span class="fc" id="L1604">            int swap = a[idxLo];</span>
<span class="fc" id="L1605">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1606">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1608">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1609">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1610">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1612">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1614">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1616">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1630">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1633">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1635" title="All 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1636">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1640">            return;</span>
        }
        
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1645">            float x = a[idxLo];</span>
<span class="nc" id="L1646">            int store = idxLo;</span>
<span class="nc" id="L1647">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1651">                    store++;     </span>
<span class="nc bnc" id="L1652" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1654">                    idxMid--;</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1657">                    break;</span>
                }
<span class="nc" id="L1659">                float swap = a[store];</span>
<span class="nc" id="L1660">                a[store] = a[idxMid];</span>
<span class="nc" id="L1661">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1663">                T bSwap = b.get(store);</span>
<span class="nc" id="L1664">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L1665">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L1666">            }</span>
<span class="nc" id="L1667">            float swap = a[idxLo];</span>
<span class="nc" id="L1668">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1669">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1671">            T bSwap = b.get(idxLo);</span>
<span class="nc" id="L1672">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L1673">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L1675">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1677">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1679">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1692">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1695">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1698">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1702">            return;</span>
        }
        
<span class="fc bfc" id="L1705" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1707">            float x = a[idxLo];</span>
<span class="fc" id="L1708">            int store = idxLo;</span>
<span class="fc" id="L1709">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1713">                    store++;     </span>
<span class="fc bfc" id="L1714" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1716">                    idxMid--;</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1719">                    break;</span>
                }
<span class="fc" id="L1721">                float swap = a[store];</span>
<span class="fc" id="L1722">                a[store] = a[idxMid];</span>
<span class="fc" id="L1723">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1725">                Object bSwap = b[store];</span>
<span class="fc" id="L1726">                b[store] = b[idxMid];</span>
<span class="fc" id="L1727">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1728">            }</span>
<span class="fc" id="L1729">            float swap = a[idxLo];</span>
<span class="fc" id="L1730">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1731">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1733">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1734">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1735">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1737">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1739">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1741">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b an array that will receive the same swap operations as are 
     performed on a
     @param c an array that will receive the same swap operations as are 
     performed on a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1758">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1761">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1764">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1766" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1767">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1772">            float x = a[idxLo];</span>
<span class="fc" id="L1773">            int store = idxLo;</span>
<span class="fc" id="L1774">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1778">                    store++;     </span>
<span class="fc bfc" id="L1779" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1781">                    idxMid--;</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1784">                    break;</span>
                }
<span class="fc" id="L1786">                float swap = a[store];</span>
<span class="fc" id="L1787">                a[store] = a[idxMid];</span>
<span class="fc" id="L1788">                a[idxMid] = swap;</span>
<span class="fc" id="L1789">                int swap2 = b[store];</span>
<span class="fc" id="L1790">                b[store] = b[idxMid];</span>
<span class="fc" id="L1791">                b[idxMid] = swap2;</span>
<span class="fc" id="L1792">                swap2 = c[store];</span>
<span class="fc" id="L1793">                c[store] = c[idxMid];</span>
<span class="fc" id="L1794">                c[idxMid] = swap2;</span>
<span class="fc" id="L1795">            }</span>
<span class="fc" id="L1796">            float swap = a[idxLo];</span>
<span class="fc" id="L1797">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1798">            a[idxMid] = swap;</span>
<span class="fc" id="L1799">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1800">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1801">            b[idxMid] = swap2;</span>
<span class="fc" id="L1802">            swap2 = c[idxLo];</span>
<span class="fc" id="L1803">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1804">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1806">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1808">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1810">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1818" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1819">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1821" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1822">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1825">            return;</span>
        }
<span class="fc" id="L1827">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1828">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     @param idxLo the first index in [0][index] to sort
     @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1839">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1842">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1845">            return;</span>
        }
<span class="fc bfc" id="L1847" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1848">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1849">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1850">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1852">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1857">        int x = a[0][idxHi];</span>
<span class="fc" id="L1858">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1860" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1861">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1862" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1863">                doSwap = true;</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1865" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1866">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1869" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1870">                store++;</span>
<span class="fc" id="L1871">                int swap = a[0][store];</span>
<span class="fc" id="L1872">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1873">                a[0][i] = swap;</span>
                
<span class="fc" id="L1875">                swap = a[1][store];</span>
<span class="fc" id="L1876">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1877">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1880">        store++;</span>
<span class="fc" id="L1881">        int swap = a[0][store];</span>
<span class="fc" id="L1882">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1883">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1885">        swap = a[1][store];</span>
<span class="fc" id="L1886">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1887">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1888">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1898">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1901">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1904">            return;</span>
        }
<span class="fc" id="L1906">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1907">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     @param idxLo the first index in [0][index] to sort
     @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1917" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1918">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1920" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1921">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1924">            return;</span>
        }
<span class="fc bfc" id="L1926" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1927">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1928">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1929">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1931">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1936">        int x = a[0][idxHi];</span>
<span class="fc" id="L1937">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1939" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1940">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1941" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1942">                doSwap = true;</span>
<span class="fc bfc" id="L1943" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1944" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1945">                    doSwap = true;</span>
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1948">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1952" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1953">                store++;</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1955">                    int swap = a[k][store];</span>
<span class="fc" id="L1956">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L1957">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L1961">        store++;</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1963">            int swap = a[k][store];</span>
<span class="fc" id="L1964">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L1965">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L1967">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1975">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1978">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1981">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1983" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1984">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1987">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L1990" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1991">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1992">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1993">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1995">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     @param d
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L2007" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L2008">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2010" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L2012">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L2015">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L2016">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     @param d
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L2030" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L2031">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2033" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L2035">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L2037" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2038">            return;</span>
        }
<span class="fc bfc" id="L2040" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2041">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2042">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2043">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2045">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2050">        float x = a[idxHi];</span>
<span class="fc" id="L2051">        float x2 = b[idxHi];</span>
<span class="fc" id="L2052">        float x3 = c[idxHi];</span>
<span class="fc" id="L2053">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2055" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2056">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2057" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2058">                doSwap = true;</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2060" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L2061">                    doSwap = true;</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L2064">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2068" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2069">                store++;</span>
<span class="fc" id="L2070">                float swap = a[store];</span>
<span class="fc" id="L2071">                a[store] = a[i];</span>
<span class="fc" id="L2072">                a[i] = swap;</span>
<span class="fc" id="L2073">                swap = b[store];</span>
<span class="fc" id="L2074">                b[store] = b[i];</span>
<span class="fc" id="L2075">                b[i] = swap;</span>
<span class="fc" id="L2076">                swap = c[store];</span>
<span class="fc" id="L2077">                c[store] = c[i];</span>
<span class="fc" id="L2078">                c[i] = swap;</span>
<span class="fc" id="L2079">                int swap3 = d[store];</span>
<span class="fc" id="L2080">                d[store] = d[i];</span>
<span class="fc" id="L2081">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L2084">        store++;</span>
<span class="fc" id="L2085">        float swap = a[store];</span>
<span class="fc" id="L2086">        a[store] = a[idxHi];</span>
<span class="fc" id="L2087">        a[idxHi] = swap;</span>
<span class="fc" id="L2088">        swap = b[store];</span>
<span class="fc" id="L2089">        b[store] = b[idxHi];</span>
<span class="fc" id="L2090">        b[idxHi] = swap;</span>
<span class="fc" id="L2091">        swap = c[store];</span>
<span class="fc" id="L2092">        c[store] = c[idxHi];</span>
<span class="fc" id="L2093">        c[idxHi] = swap;</span>
<span class="fc" id="L2094">        int swap3 = d[store];</span>
<span class="fc" id="L2095">        d[store] = d[idxHi];</span>
<span class="fc" id="L2096">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L2098">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2104">        float x = a.get(idxHi);</span>
<span class="fc" id="L2105">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2107" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2108">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2109" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2110">                doSwap = true;</span>
<span class="fc bfc" id="L2111" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2112" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L2113">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2116" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2117">                store++;</span>
<span class="fc" id="L2118">                float swap = a.get(store);</span>
<span class="fc" id="L2119">                a.set(store, a.get(i));</span>
<span class="fc" id="L2120">                a.set(i, swap);</span>
<span class="fc" id="L2121">                swap = b.get(store);</span>
<span class="fc" id="L2122">                b.set(store, b.get(i));</span>
<span class="fc" id="L2123">                b.set(i, swap);</span>
<span class="fc" id="L2124">                int swap2 = c.get(store);</span>
<span class="fc" id="L2125">                c.set(store, c.get(i));</span>
<span class="fc" id="L2126">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2129">        store++;</span>
        
<span class="fc" id="L2131">        float swap = a.get(store);</span>
<span class="fc" id="L2132">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2133">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L2135">        swap = b.get(store);</span>
<span class="fc" id="L2136">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2137">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L2139">        int swap2 = c.get(store);</span>
<span class="fc" id="L2140">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2141">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L2143">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2158" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2159">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2161" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2162">            return;</span>
        }
<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2165">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2168">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2170" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2171">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2173" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2174">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2176" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2177">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2178">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2179">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2181">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L2193" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2194">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2197">            return;</span>
        }
<span class="pc bpc" id="L2199" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2200">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2203">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2206">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2209">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L2211">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2212">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2227" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2228">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2231">            return;</span>
        }
<span class="pc bpc" id="L2233" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2234">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2237">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2240">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2243">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2246" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2247">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2248">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2249">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2251">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2259" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2260">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2262" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2263">            return;</span>
        }
<span class="nc bnc" id="L2265" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2266">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2269">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2271">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2272">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2280" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2281">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2283" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2284">            return;</span>
        }
<span class="pc bpc" id="L2286" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2287">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2289" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2290">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2292">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2293">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     */
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2302">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2304" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2305">            return;</span>
        }
<span class="fc" id="L2307">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2308">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2320">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2322" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2323">            return;</span>
        }
<span class="nc bnc" id="L2325" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2326">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="nc" id="L2329">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2330">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2344">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2346" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2347">            return;</span>
        }
<span class="nc bnc" id="L2349" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2350">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="nc bnc" id="L2353" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>
<span class="nc" id="L2354">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="nc" id="L2355">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="nc" id="L2356">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L2358">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param idxLo
     @param idxHi
     */
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2369" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2370">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2372" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2373">            return;</span>
        }
        
<span class="fc bfc" id="L2376" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2377">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2378">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2379">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2381">    }</span>
    
    /**
     *
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2391" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2392">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2394" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2395">            return;</span>
        }
<span class="pc bpc" id="L2397" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2398">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2400" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2401">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2403" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2404">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2405">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2406">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2408">    }</span>
    
    /**
     *
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2419">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2422">            return;</span>
        }
<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2425">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2427" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2428">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2430" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2431">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2432">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2433">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2435">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2446" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2447">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2449" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2450">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2452" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2453">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2456">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2457">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param d items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2473" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2474">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2476" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2477">            return;</span>
        }
<span class="pc bpc" id="L2479" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2480">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2482" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2483">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2485" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2486">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2488" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2489">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2491" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2492">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2494" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2495">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2498">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2499">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2500">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2502">    }</span>

    private static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2506" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2507">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2508">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2509">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2511">    }</span>
    
    /**
     * sorts a, b, and c by the values of a only
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="nc bnc" id="L2524" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>
<span class="nc" id="L2525">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="nc" id="L2526">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="nc" id="L2527">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L2529">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="nc" id="L2534">        float x = a[idxHi];</span>
<span class="nc" id="L2535">        int store = idxLo - 1;</span>
        
<span class="nc bnc" id="L2537" title="All 2 branches missed.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">            if (a[i] &lt;= x) {</span>
<span class="nc" id="L2539">                store++;</span>
<span class="nc" id="L2540">                float swap = a[store];</span>
<span class="nc" id="L2541">                a[store] = a[i];</span>
<span class="nc" id="L2542">                a[i] = swap;</span>
<span class="nc" id="L2543">                float swap2 = b[store];</span>
<span class="nc" id="L2544">                b[store] = b[i];</span>
<span class="nc" id="L2545">                b[i] = swap2;</span>
<span class="nc" id="L2546">                swap2 = c[store];</span>
<span class="nc" id="L2547">                c[store] = c[i];</span>
<span class="nc" id="L2548">                c[i] = swap2;</span>
            }
        }
<span class="nc" id="L2551">        store++;</span>
<span class="nc" id="L2552">        float swap = a[store];</span>
<span class="nc" id="L2553">        a[store] = a[idxHi];</span>
<span class="nc" id="L2554">        a[idxHi] = swap;</span>
<span class="nc" id="L2555">        float swap2 = b[store];</span>
<span class="nc" id="L2556">        b[store] = b[idxHi];</span>
<span class="nc" id="L2557">        b[idxHi] = swap2;</span>
<span class="nc" id="L2558">        swap2 = c[store];</span>
<span class="nc" id="L2559">        c[store] = c[idxHi];</span>
<span class="nc" id="L2560">        c[idxHi] = swap2;</span>
<span class="nc" id="L2561">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2567">        float x = a[idxHi];</span>
<span class="fc" id="L2568">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2570" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2571">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2572" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2573">                doSwap = true;</span>
<span class="fc bfc" id="L2574" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2575" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2576">                    doSwap = true;</span>
<span class="pc bpc" id="L2577" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2579">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2583" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2584">                store++;</span>
<span class="fc" id="L2585">                float swap = a[store];</span>
<span class="fc" id="L2586">                a[store] = a[i];</span>
<span class="fc" id="L2587">                a[i] = swap;</span>
<span class="fc" id="L2588">                float swap2 = b[store];</span>
<span class="fc" id="L2589">                b[store] = b[i];</span>
<span class="fc" id="L2590">                b[i] = swap2;</span>
<span class="fc" id="L2591">                swap2 = c[store];</span>
<span class="fc" id="L2592">                c[store] = c[i];</span>
<span class="fc" id="L2593">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2596">        store++;</span>
<span class="fc" id="L2597">        float swap = a[store];</span>
<span class="fc" id="L2598">        a[store] = a[idxHi];</span>
<span class="fc" id="L2599">        a[idxHi] = swap;</span>
<span class="fc" id="L2600">        float swap2 = b[store];</span>
<span class="fc" id="L2601">        b[store] = b[idxHi];</span>
<span class="fc" id="L2602">        b[idxHi] = swap2;</span>
<span class="fc" id="L2603">        swap2 = c[store];</span>
<span class="fc" id="L2604">        c[store] = c[idxHi];</span>
<span class="fc" id="L2605">        c[idxHi] = swap2;</span>
<span class="fc" id="L2606">        return store;</span>
    }
    
    private static &lt;T&gt; int partitionBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="fc" id="L2611">        int x = a[idxHi];</span>
<span class="fc" id="L2612">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2614" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2615">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2616" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2617">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2619" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2620">                store++;</span>
<span class="fc" id="L2621">                int swap = a[store];</span>
<span class="fc" id="L2622">                a[store] = a[i];</span>
<span class="fc" id="L2623">                a[i] = swap;</span>
<span class="fc" id="L2624">                T swap2 = b.get(store);</span>
<span class="fc" id="L2625">                b.set(store, b.get(i));</span>
<span class="fc" id="L2626">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2629">        store++;</span>
<span class="fc" id="L2630">        int swap = a[store];</span>
<span class="fc" id="L2631">        a[store] = a[idxHi];</span>
<span class="fc" id="L2632">        a[idxHi] = swap;</span>
<span class="fc" id="L2633">        T swap2 = b.get(store);</span>
<span class="fc" id="L2634">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2635">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2637">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2644">        int x = a.get(idxHi);</span>
<span class="fc" id="L2645">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2647" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2648">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2649" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2650">                doSwap = true;</span>
<span class="fc bfc" id="L2651" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2652" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2653">                    doSwap = true;</span>
<span class="fc bfc" id="L2654" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2656">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2660" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2661">                store++;</span>
<span class="fc" id="L2662">                int swap = a.get(store);</span>
<span class="fc" id="L2663">                a.set(store, a.get(i));</span>
<span class="fc" id="L2664">                a.set(i, swap);</span>
<span class="fc" id="L2665">                int swap2 = b.get(store);</span>
<span class="fc" id="L2666">                b.set(store, b.get(i));</span>
<span class="fc" id="L2667">                b.set(i, swap2);</span>
<span class="fc" id="L2668">                swap2 = c.get(store);</span>
<span class="fc" id="L2669">                c.set(store, c.get(i));</span>
<span class="fc" id="L2670">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2673">        store++;</span>
<span class="fc" id="L2674">        int swap = a.get(store);</span>
<span class="fc" id="L2675">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2676">        a.set(idxHi, swap);</span>
<span class="fc" id="L2677">        int swap2 = b.get(store);</span>
<span class="fc" id="L2678">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2679">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2680">        swap2 = c.get(store);</span>
<span class="fc" id="L2681">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2682">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2683">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2689">        float x = a[idxHi];</span>
<span class="fc" id="L2690">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2692" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2693">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2695">                doSwap = true;</span>
<span class="fc bfc" id="L2696" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2697" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2698">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2701" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2702">                store++;</span>
<span class="fc" id="L2703">                float swap = a[store];</span>
<span class="fc" id="L2704">                a[store] = a[i];</span>
<span class="fc" id="L2705">                a[i] = swap;</span>
<span class="fc" id="L2706">                float swap2 = b[store];</span>
<span class="fc" id="L2707">                b[store] = b[i];</span>
<span class="fc" id="L2708">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2711">        store++;</span>
<span class="fc" id="L2712">        float swap = a[store];</span>
<span class="fc" id="L2713">        a[store] = a[idxHi];</span>
<span class="fc" id="L2714">        a[idxHi] = swap;</span>
<span class="fc" id="L2715">        float swap2 = b[store];</span>
<span class="fc" id="L2716">        b[store] = b[idxHi];</span>
<span class="fc" id="L2717">        b[idxHi] = swap2;</span>
<span class="fc" id="L2718">        return store;</span>
    }
    
    public static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2724">        int x = a[idxHi];</span>
<span class="fc" id="L2725">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2727" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2728">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2729" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2730">                doSwap = true;</span>
<span class="fc bfc" id="L2731" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2732" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2733">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2736" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2737">                store++;</span>
<span class="fc bfc" id="L2738" title="All 2 branches covered.">                if (store != i) {</span>
<span class="fc" id="L2739">                    int swap = a[store];</span>
<span class="fc" id="L2740">                    a[store] = a[i];</span>
<span class="fc" id="L2741">                    a[i] = swap;</span>
<span class="fc" id="L2742">                    int swap2 = b[store];</span>
<span class="fc" id="L2743">                    b[store] = b[i];</span>
<span class="fc" id="L2744">                    b[i] = swap2;</span>
                }
            }
        }
<span class="fc" id="L2748">        store++;</span>
<span class="fc" id="L2749">        int swap = a[store];</span>
<span class="fc" id="L2750">        a[store] = a[idxHi];</span>
<span class="fc" id="L2751">        a[idxHi] = swap;</span>
<span class="fc" id="L2752">        int swap2 = b[store];</span>
<span class="fc" id="L2753">        b[store] = b[idxHi];</span>
<span class="fc" id="L2754">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2756">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2762">        T x = a[idxHi];</span>
<span class="fc" id="L2763">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2765" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2766">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2767" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2768">                doSwap = true;</span>
<span class="fc bfc" id="L2769" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2770" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2771">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2774" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2775">                store++;</span>
<span class="fc" id="L2776">                T swap = a[store];</span>
<span class="fc" id="L2777">                a[store] = a[i];</span>
<span class="fc" id="L2778">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2781">        store++;</span>
<span class="fc" id="L2782">        T swap = a[store];</span>
<span class="fc" id="L2783">        a[store] = a[idxHi];</span>
<span class="fc" id="L2784">        a[idxHi] = swap;</span>
<span class="fc" id="L2785">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="nc" id="L2791">        T x = a[idxHi];</span>
<span class="nc" id="L2792">        int store = idxLo - 1;</span>
        
<span class="nc bnc" id="L2794" title="All 2 branches missed.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="nc" id="L2795">            boolean doSwap = false;</span>
<span class="nc bnc" id="L2796" title="All 2 branches missed.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="nc" id="L2797">                doSwap = true;</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2800">                    doSwap = true;</span>
                }
            }
<span class="nc bnc" id="L2803" title="All 2 branches missed.">            if (doSwap) {</span>
<span class="nc" id="L2804">                store++;</span>
<span class="nc" id="L2805">                T swap = a[store];</span>
<span class="nc" id="L2806">                a[store] = a[i];</span>
<span class="nc" id="L2807">                a[i] = swap;</span>
<span class="nc" id="L2808">                int swap2 = b[store];</span>
<span class="nc" id="L2809">                b[store] = b[i];</span>
<span class="nc" id="L2810">                b[i] = swap2;</span>
            }
        }
<span class="nc" id="L2813">        store++;</span>
<span class="nc" id="L2814">        T swap = a[store];</span>
<span class="nc" id="L2815">        a[store] = a[idxHi];</span>
<span class="nc" id="L2816">        a[idxHi] = swap;</span>
<span class="nc" id="L2817">        int swap2 = b[store];</span>
<span class="nc" id="L2818">        b[store] = b[idxHi];</span>
<span class="nc" id="L2819">        b[idxHi] = swap2;</span>
<span class="nc" id="L2820">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2826">        double x = a[idxHi];</span>
<span class="fc" id="L2827">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2829" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2830">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2831" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2832">                doSwap = true;</span>
<span class="fc bfc" id="L2833" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2834" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2835">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2838" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2839">                store++;</span>
<span class="fc" id="L2840">                double swap = a[store];</span>
<span class="fc" id="L2841">                a[store] = a[i];</span>
<span class="fc" id="L2842">                a[i] = swap;</span>
<span class="fc" id="L2843">                swap = b[store];</span>
<span class="fc" id="L2844">                b[store] = b[i];</span>
<span class="fc" id="L2845">                b[i] = swap;</span>
<span class="fc" id="L2846">                int swap2 = c[store];</span>
<span class="fc" id="L2847">                c[store] = c[i];</span>
<span class="fc" id="L2848">                c[i] = swap2;</span>
<span class="fc" id="L2849">                swap2 = d[store];</span>
<span class="fc" id="L2850">                d[store] = d[i];</span>
<span class="fc" id="L2851">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2854">        store++;</span>
<span class="fc" id="L2855">        double swap = a[store];</span>
<span class="fc" id="L2856">        a[store] = a[idxHi];</span>
<span class="fc" id="L2857">        a[idxHi] = swap;</span>
<span class="fc" id="L2858">        swap = b[store];</span>
<span class="fc" id="L2859">        b[store] = b[idxHi];</span>
<span class="fc" id="L2860">        b[idxHi] = swap;</span>
<span class="fc" id="L2861">        int swap2 = c[store];</span>
<span class="fc" id="L2862">        c[store] = c[idxHi];</span>
<span class="fc" id="L2863">        c[idxHi] = swap2;</span>
<span class="fc" id="L2864">        swap2 = d[store];</span>
<span class="fc" id="L2865">        d[store] = d[idxHi];</span>
<span class="fc" id="L2866">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2867">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>