<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.sort.MiscSorter;
import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="nc" id="L15">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     @param a items to sort
     */
    public static void sort(float[] a) {
<span class="fc" id="L22">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L23">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L33">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L36">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L39">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L42">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L43">    }</span>

    /**
     * partition array 'a' elements in range [lo, hi] inclusive
     * around the pivot value key=a[pivotIdx]
     * inclusive such that
     * all elements in range [lo, hi] that have values LT key
     * are at indexes lower than the re-positioned pivot key and all elements
     * in range [lo, hi] with values GT key are at indexes &gt; the re-positioned
     * pivot key.
     * This partition function when using pivotIdx=hi is the same as
     * the parition function without specifying the pivot index.
     * This method can be used in the quickselect algorithm.
     * @param a
     * @param lo
     * @param hi
     * @param pivotIdx
     * @return the index of the re-located pivotIdx.  note that the index is w.r.t. to 0.
     */
    public static int partition(int[] a, int lo, int hi, int pivotIdx) {
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (pivotIdx != hi) { // move pivot to end</span>
<span class="fc" id="L64">            a[pivotIdx] ^= a[hi];</span>
<span class="fc" id="L65">            a[hi] ^= a[pivotIdx];</span>
<span class="fc" id="L66">            a[pivotIdx] ^= a[hi];</span>
        }
        // the rest is the same as the quicksort partition
<span class="fc" id="L69">        int x = a[hi];</span>
<span class="fc" id="L70">        int i = lo;</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (int k = lo; k &lt; hi; ++k) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            if (a[k] &lt; x) {</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">                if (i != k) {</span>
<span class="fc" id="L74">                    a[i] ^= a[k];</span>
<span class="fc" id="L75">                    a[k] ^= a[i];</span>
<span class="fc" id="L76">                    a[i] ^= a[k];</span>
                }
<span class="fc" id="L78">                ++i;</span>
            }
        }
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (i != hi) {</span>
<span class="fc" id="L82">            a[i] ^= a[hi];</span>
<span class="fc" id="L83">            a[hi] ^= a[i];</span>
<span class="fc" id="L84">            a[i] ^= a[hi];</span>
        }
<span class="fc" id="L86">        return i;</span>
    }


    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L99">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L105">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L108">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L109">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L128">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L129">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L148">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L149">    }</span>
    
    /**
     *
     @param a
     */
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L161">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L162">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L172">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L181">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L182">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, int[] b) {
<span class="nc" id="L190">        MiscSorter.sortBy1stArg(a, b);    </span>
<span class="nc" id="L191">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TFloatList a, int[] b) {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (b.length != a.size()) {</span>
<span class="nc" id="L200">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="fc" id="L202">        sortBy1stArg(a, b, 0, a.size() - 1);    </span>
<span class="fc" id="L203">    }</span>
    
    /**
    ascending sort of abc
    @param abc array to sort
    */
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L212">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L215">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L216">    }</span>
    
    /**
    ascending sort of a
    @param a array to sort
    @param b array to sort using order of a
    @param &lt;T&gt; paramter type of objects in list b
    */
    public static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b) {
    
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L236">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L237">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     @param a items to sort
     @param b items to be sorted by same order as a
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L247">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L250">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L253">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L256">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L257">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L267">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L276">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L277">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L290">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L293">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L296">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L297">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L310">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L313">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L316">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L317">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L327">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L330">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L333">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L336">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L337">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b) {

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L348">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L351">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L354">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L357">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L358">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L369">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L372">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L375">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L377" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L378">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L381">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L382">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L394">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L397">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L400">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L403">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L406">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L409">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L410">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L420">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L423">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L426">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L429">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L430">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param &lt;S&gt;
     @param a
     @param b
     @param c
     */
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
<span class="fc" id="L441">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L442">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param &lt;S&gt;
     @param a
     @param b
     @param c
     @param idxLo
     @param idxHi
     */
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L458">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L461">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L464">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L467">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L470">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L474">            return;</span>
        }
        
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L479">            int x = a[idxLo];</span>
<span class="fc" id="L480">            int store = idxLo;</span>
<span class="fc" id="L481">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L485">                    store++;     </span>
<span class="fc bfc" id="L486" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L488">                    idxMid--;</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L491">                    break;</span>
                }
<span class="fc" id="L493">                int swap = a[store];</span>
<span class="fc" id="L494">                a[store] = a[idxMid];</span>
<span class="fc" id="L495">                a[idxMid] = swap;</span>
                
<span class="fc" id="L497">                T swap2 = b.get(store);</span>
<span class="fc" id="L498">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L499">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L501">                S swap3 = c.get(store);</span>
<span class="fc" id="L502">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L503">                c.set(idxMid, swap3);</span>
                
<span class="fc" id="L505">            }</span>
            
<span class="fc" id="L507">            int swap = a[idxLo];</span>
<span class="fc" id="L508">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L509">            a[idxMid] = swap;</span>

<span class="fc" id="L511">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L512">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L513">            b.set(idxMid, swap2);</span>

<span class="fc" id="L515">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L516">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L517">            c.set(idxMid, swap3);</span>
         
<span class="fc" id="L519">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L521">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L523">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param c items to be sorted by same order as a
     @param idxLo low index of a
     @param idxHi high index of a
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L538">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L541">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L544">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L547">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L550">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L554">            return;</span>
        }
        
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L559">            int x = a.get(idxLo);</span>
<span class="fc" id="L560">            int store = idxLo;</span>
<span class="fc" id="L561">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L565">                    store++;     </span>
<span class="fc bfc" id="L566" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L568">                    idxMid--;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L571">                    break;</span>
                }
<span class="nc" id="L573">                int swap = a.get(store);</span>
<span class="nc" id="L574">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L575">                a.set(idxMid, swap);</span>
<span class="nc" id="L576">                swap = c.get(store);</span>
<span class="nc" id="L577">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L578">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L580">                double bSwap = b.get(store);</span>
<span class="nc" id="L581">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L582">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L583">            }</span>
<span class="fc" id="L584">            int swap = a.get(idxLo);</span>
<span class="fc" id="L585">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L586">            a.set(idxMid, swap);</span>
<span class="fc" id="L587">            swap = c.get(idxLo);</span>
<span class="fc" id="L588">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L589">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L591">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L592">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L593">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L595">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L597">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L599">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param c items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L614">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L617">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L620">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L623">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L626">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L630">            return;</span>
        }
        
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L635">            float x = a.get(idxLo);</span>
<span class="fc" id="L636">            int store = idxLo;</span>
<span class="fc" id="L637">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L641">                    store++;     </span>
<span class="fc bfc" id="L642" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L644">                    idxMid--;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L647">                    break;</span>
                }
<span class="nc" id="L649">                float swap = a.get(store);</span>
<span class="nc" id="L650">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L651">                a.set(idxMid, swap);</span>
<span class="nc" id="L652">                int swap2 = c.get(store);</span>
<span class="nc" id="L653">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L654">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L656">                swap2 = b.get(store);</span>
<span class="nc" id="L657">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L658">                b.set(idxMid, swap2);</span>
<span class="nc" id="L659">            }</span>
<span class="fc" id="L660">            float swap = a.get(idxLo);</span>
<span class="fc" id="L661">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L662">            a.set(idxMid, swap);</span>
<span class="fc" id="L663">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L664">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L665">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L667">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L668">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L669">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L671">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L673">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L675">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L688">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L691">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L694">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L698">            return;</span>
        }
        
        float swap;
        int swap2;
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L705">            float x = a.get(idxLo);</span>
<span class="fc" id="L706">            int store = idxLo;</span>
<span class="fc" id="L707">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L711">                    store++;     </span>
<span class="fc bfc" id="L712" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L714">                    idxMid--;</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L717">                    break;</span>
                }
<span class="nc" id="L719">                swap = a.get(store);</span>
<span class="nc" id="L720">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L721">                a.set(idxMid, swap);</span>
                
<span class="nc" id="L723">                swap2 = b[store];</span>
<span class="nc" id="L724">                b[store] = b[idxMid];</span>
<span class="nc" id="L725">                b[idxMid] = swap2;</span>
            }
<span class="fc" id="L727">            swap = a.get(idxLo);</span>
<span class="fc" id="L728">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L729">            a.set(idxMid, swap);</span>
            
<span class="fc" id="L731">            swap2 = b[idxLo];</span>
<span class="fc" id="L732">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L733">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L735">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L737">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L739">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
      @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L753">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L756">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L759">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L763">            return;</span>
        }
        
<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L768">            float x = a.get(idxLo);</span>
<span class="nc" id="L769">            int store = idxLo;</span>
<span class="nc" id="L770">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L774">                    store++;     </span>
<span class="nc bnc" id="L775" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L777">                    idxMid--;</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L780">                    break;</span>
                }
<span class="nc" id="L782">                float swap = a.get(store);</span>
<span class="nc" id="L783">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L784">                a.set(idxMid, swap);</span>
<span class="nc" id="L785">                int swap2 = b.get(store);</span>
<span class="nc" id="L786">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L787">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L789">            }</span>
<span class="nc" id="L790">            float swap = a.get(idxLo);</span>
<span class="nc" id="L791">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L792">            a.set(idxMid, swap);</span>
<span class="nc" id="L793">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L794">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L795">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L797">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L799">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L801">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; parameter type of objects in b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L816">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L819">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L822">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L826">            return;</span>
        }
        
<span class="fc bfc" id="L829" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L831">            float x = a.get(idxLo);</span>
<span class="fc" id="L832">            int store = idxLo;</span>
<span class="fc" id="L833">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L837">                    store++;     </span>
<span class="fc bfc" id="L838" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L840">                    idxMid--;</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L843">                    break;</span>
                }
<span class="fc" id="L845">                float swap = a.get(store);</span>
<span class="fc" id="L846">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L847">                a.set(idxMid, swap);</span>
<span class="fc" id="L848">                T swap2 = b.get(store);</span>
<span class="fc" id="L849">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L850">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L852">            }</span>
<span class="fc" id="L853">            float swap = a.get(idxLo);</span>
<span class="fc" id="L854">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L855">            a.set(idxMid, swap);</span>
<span class="fc" id="L856">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L857">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L858">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L860">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L862">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L864">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
      @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L877">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L880">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L883">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L887">            return;</span>
        }
        
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L892">            int x = a.get(idxLo);</span>
<span class="fc" id="L893">            int store = idxLo;</span>
<span class="fc" id="L894">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L898">                    store++;     </span>
<span class="fc bfc" id="L899" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L901">                    idxMid--;</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L904">                    break;</span>
                }
<span class="nc" id="L906">                int swap = a.get(store);</span>
<span class="nc" id="L907">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L908">                a.set(idxMid, swap);</span>
<span class="nc" id="L909">                swap = b.get(store);</span>
<span class="nc" id="L910">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L911">                b.set(idxMid, swap);</span>
<span class="nc" id="L912">            }</span>
<span class="fc" id="L913">            int swap = a.get(idxLo);</span>
<span class="fc" id="L914">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L915">            a.set(idxMid, swap);</span>
<span class="fc" id="L916">            swap = b.get(idxLo);</span>
<span class="fc" id="L917">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L918">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L920">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L922">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L924">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param abc items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L937">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L941">            return;</span>
        }
        
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L946">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L947">            int store = idxLo;</span>
<span class="fc" id="L948">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L952">                    store++;     </span>
<span class="fc bfc" id="L953" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L955">                    idxMid--;</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L958">                    break;</span>
                }
<span class="nc" id="L960">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L961">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L962">                abc[idxMid] = swap;</span>
<span class="nc" id="L963">            }</span>
<span class="fc" id="L964">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L965">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L966">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L968">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L970">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L972">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L984">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L987">            return;</span>
        }
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L991">            float x = a[idxLo];</span>
<span class="fc" id="L992">            int store = idxLo;</span>
<span class="fc" id="L993">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L997">                    store++;     </span>
<span class="fc bfc" id="L998" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1000">                    idxMid--;</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1003">                    break;</span>
                }
<span class="fc" id="L1005">                float swap = a[store];</span>
<span class="fc" id="L1006">                a[store] = a[idxMid];</span>
<span class="fc" id="L1007">                a[idxMid] = swap;</span>
<span class="fc" id="L1008">            }</span>
<span class="fc" id="L1009">            float swap = a[idxLo];</span>
<span class="fc" id="L1010">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1011">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1013">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1015">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1017">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;T&gt;
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1032">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1035">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1038">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1041">            return;</span>
        }
        
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1046">            int x = a[idxLo];</span>
<span class="nc" id="L1047">            int store = idxLo;</span>
<span class="nc" id="L1048">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1052">                    store++;     </span>
<span class="nc bnc" id="L1053" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L1055">                    idxMid--;</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L1058" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1059">                    break;</span>
                }
<span class="nc" id="L1061">                int swap = a[store];</span>
<span class="nc" id="L1062">                a[store] = a[idxMid];</span>
<span class="nc" id="L1063">                a[idxMid] = swap;</span>
<span class="nc" id="L1064">                T swap2 = b[store];</span>
<span class="nc" id="L1065">                b[store] = b[idxMid];</span>
<span class="nc" id="L1066">                b[idxMid] = swap2;</span>
<span class="nc" id="L1067">            }</span>
<span class="nc" id="L1068">            int swap = a[idxLo];</span>
<span class="nc" id="L1069">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1070">            a[idxMid] = swap;</span>
<span class="nc" id="L1071">            T swap2 = b[idxLo];</span>
<span class="nc" id="L1072">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1073">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L1075">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1077">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1079">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1093">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1096">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1099">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1102">            return;</span>
        }
        
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1107">            int x = a[idxLo];</span>
<span class="fc" id="L1108">            int store = idxLo;</span>
<span class="fc" id="L1109">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1113">                    store++;     </span>
<span class="pc bpc" id="L1114" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1116">                    idxMid--;</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1119" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1120">                    break;</span>
                }
<span class="fc" id="L1122">                int swap = a[store];</span>
<span class="fc" id="L1123">                a[store] = a[idxMid];</span>
<span class="fc" id="L1124">                a[idxMid] = swap;</span>
<span class="fc" id="L1125">                swap = b[store];</span>
<span class="fc" id="L1126">                b[store] = b[idxMid];</span>
<span class="fc" id="L1127">                b[idxMid] = swap;</span>
<span class="fc" id="L1128">            }</span>
<span class="fc" id="L1129">            int swap = a[idxLo];</span>
<span class="fc" id="L1130">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1131">            a[idxMid] = swap;</span>
<span class="fc" id="L1132">            swap = b[idxLo];</span>
<span class="fc" id="L1133">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1134">            b[idxMid] = swap;</span>
         
<span class="fc" id="L1136">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1138">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1140">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;T&gt; type of items in list b
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1156">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1159">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1162">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1165">            return;</span>
        }
        
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1170">            int x = a.get(idxLo);</span>
<span class="fc" id="L1171">            int store = idxLo;</span>
<span class="fc" id="L1172">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1176">                    store++;     </span>
<span class="pc bpc" id="L1177" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L1179">                    idxMid--;</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L1182" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1183">                    break;</span>
                }
<span class="fc" id="L1185">                int swap = a.get(store);</span>
<span class="fc" id="L1186">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1187">                a.set(idxMid, swap);</span>
<span class="fc" id="L1188">                T swap2 = b.get(store);</span>
<span class="fc" id="L1189">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1190">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1191">            }</span>
<span class="fc" id="L1192">            int swap = a.get(idxLo);</span>
<span class="fc" id="L1193">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1194">            a.set(idxMid, swap);</span>
<span class="fc" id="L1195">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1196">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1197">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1199">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1201">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1203">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param &lt;S&gt;
     @param a items to sort
     @param b items to sort by order of a
     @param &lt;T&gt; type of items in list b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1220">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1223">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1226">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1229">            return;</span>
        }
        
<span class="fc bfc" id="L1232" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1234">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1235">            int store = idxLo;</span>
<span class="fc" id="L1236">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1240">                    store++;     </span>
<span class="pc bpc" id="L1241" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1243">                    idxMid--;</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1247">                    break;</span>
                }
<span class="fc" id="L1249">                S swap = a.get(store);</span>
<span class="fc" id="L1250">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1251">                a.set(idxMid, swap);</span>
<span class="fc" id="L1252">                T swap2 = b.get(store);</span>
<span class="fc" id="L1253">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1254">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1255">            }</span>
<span class="fc" id="L1256">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1257">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1258">            a.set(idxMid, swap);</span>
<span class="fc" id="L1259">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1260">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1261">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1263">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1265">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1267">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1280">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1283">            return;</span>
        }
        
<span class="fc bfc" id="L1286" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1288">            double x = a[idxLo];</span>
<span class="fc" id="L1289">            int store = idxLo;</span>
<span class="fc" id="L1290">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1294">                    store++;     </span>
<span class="fc bfc" id="L1295" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1297">                    idxMid--;</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1301">                    break;</span>
                }
<span class="fc" id="L1303">                double swap = a[store];</span>
<span class="fc" id="L1304">                a[store] = a[idxMid];</span>
<span class="fc" id="L1305">                a[idxMid] = swap;</span>
<span class="fc" id="L1306">            }</span>
<span class="fc" id="L1307">            double swap = a[idxLo];</span>
<span class="fc" id="L1308">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1309">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1311">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1313">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1315">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1329">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1332">            return;</span>
        }
<span class="fc bfc" id="L1334" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1336">            float x = a[idxLo];</span>
<span class="fc" id="L1337">            int store = idxLo;</span>
<span class="fc" id="L1338">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1342">                    store++;     </span>
<span class="fc bfc" id="L1343" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1345">                    idxMid--;</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1348">                    break;</span>
                }
<span class="fc" id="L1350">                float swap = a[store];</span>
<span class="fc" id="L1351">                a[store] = a[idxMid];</span>
<span class="fc" id="L1352">                a[idxMid] = swap;</span>
<span class="fc" id="L1353">                int swap2 = b[store];</span>
<span class="fc" id="L1354">                b[store] = b[idxMid];</span>
<span class="fc" id="L1355">                b[idxMid] = swap2;</span>
<span class="fc" id="L1356">            }</span>
<span class="fc" id="L1357">            float swap = a[idxLo];</span>
<span class="fc" id="L1358">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1359">            a[idxMid] = swap;</span>
<span class="fc" id="L1360">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1361">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1362">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1364">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1366">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1368">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1382">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1385">            return;</span>
        }
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1389">            double x = a.get(idxLo);</span>
<span class="fc" id="L1390">            int store = idxLo;</span>
<span class="fc" id="L1391">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1395">                    store++;     </span>
<span class="fc bfc" id="L1396" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1398">                    idxMid--;</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1401">                    break;</span>
                }
<span class="fc" id="L1403">                double swap = a.get(store);</span>
<span class="fc" id="L1404">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1405">                a.set(idxMid, swap);</span>
<span class="fc" id="L1406">                int swap2 = b[store];</span>
<span class="fc" id="L1407">                b[store] = b[idxMid];</span>
<span class="fc" id="L1408">                b[idxMid] = swap2;</span>
<span class="fc" id="L1409">            }</span>
<span class="fc" id="L1410">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1411">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1412">            a.set(idxMid, swap);</span>
<span class="fc" id="L1413">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1414">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1415">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1417">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1419">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1421">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
<span class="nc" id="L1433">        MiscSorter.sortBy1stArg(a, b, idxLo, idxHi); </span>
<span class="nc" id="L1434">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1447">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1450">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1452" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1453">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1457">            return;</span>
        }
        
<span class="nc bnc" id="L1460" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1462">            int x = a[idxLo];</span>
<span class="nc" id="L1463">            int store = idxLo;</span>
<span class="nc" id="L1464">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1468">                    store++;     </span>
<span class="nc bnc" id="L1469" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1471">                    idxMid--;</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1474">                    break;</span>
                }
<span class="nc" id="L1476">                int swap = a[store];</span>
<span class="nc" id="L1477">                a[store] = a[idxMid];</span>
<span class="nc" id="L1478">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1480">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1481">                b[store] = b[idxMid];</span>
<span class="nc" id="L1482">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1483">            }</span>
<span class="nc" id="L1484">            int swap = a[idxLo];</span>
<span class="nc" id="L1485">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1486">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1488">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1489">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1490">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1492">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1494">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1496">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param &lt;S&gt; type of items in list c
     @param c
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
        
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1510">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1513">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1516">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1519">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1522">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1523">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param &lt;S&gt; type of items in list c
     @param c
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1539">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1542">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1545">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1548">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1552">            return;</span>
        }
        
<span class="fc bfc" id="L1555" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1557">            float x = a[idxLo];</span>
<span class="fc" id="L1558">            int store = idxLo;</span>
<span class="fc" id="L1559">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1563">                    store++;     </span>
<span class="fc bfc" id="L1564" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1566">                    idxMid--;</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1568" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1569">                    break;</span>
                }
<span class="fc" id="L1571">                float swap = a[store];</span>
<span class="fc" id="L1572">                a[store] = a[idxMid];</span>
<span class="fc" id="L1573">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1575">                T swap2 = b.get(store);</span>
<span class="fc" id="L1576">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1577">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1579">                S swap3 = c.get(store);</span>
<span class="fc" id="L1580">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1581">                c.set(idxMid, swap3);</span>
<span class="fc" id="L1582">            }</span>
<span class="fc" id="L1583">            float swap = a[idxLo];</span>
<span class="fc" id="L1584">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1585">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1587">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1588">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1589">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1591">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L1592">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1593">            c.set(idxMid, swap3);</span>
            
<span class="fc" id="L1595">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1597">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1599">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1612">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1615">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1618">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1622">            return;</span>
        }
        
<span class="fc bfc" id="L1625" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1627">            int x = a[idxLo];</span>
<span class="fc" id="L1628">            int store = idxLo;</span>
<span class="fc" id="L1629">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1633">                    store++;     </span>
<span class="fc bfc" id="L1634" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1636">                    idxMid--;</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1639">                    break;</span>
                }
<span class="fc" id="L1641">                int swap = a[store];</span>
<span class="fc" id="L1642">                a[store] = a[idxMid];</span>
<span class="fc" id="L1643">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1645">                Object bSwap = b[store];</span>
<span class="fc" id="L1646">                b[store] = b[idxMid];</span>
<span class="fc" id="L1647">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1648">            }</span>
<span class="fc" id="L1649">            int swap = a[idxLo];</span>
<span class="fc" id="L1650">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1651">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1653">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1654">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1655">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1657">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1659">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1661">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param &lt;T&gt; type of items in list b
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static &lt;T&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1674" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1675">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1677" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1678">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1681">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1684" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1685">            return;</span>
        }
        
<span class="nc bnc" id="L1688" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1690">            float x = a[idxLo];</span>
<span class="nc" id="L1691">            int store = idxLo;</span>
<span class="nc" id="L1692">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1696">                    store++;     </span>
<span class="nc bnc" id="L1697" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1699">                    idxMid--;</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1702">                    break;</span>
                }
<span class="nc" id="L1704">                float swap = a[store];</span>
<span class="nc" id="L1705">                a[store] = a[idxMid];</span>
<span class="nc" id="L1706">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1708">                T bSwap = b.get(store);</span>
<span class="nc" id="L1709">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L1710">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L1711">            }</span>
<span class="nc" id="L1712">            float swap = a[idxLo];</span>
<span class="nc" id="L1713">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1714">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1716">            T bSwap = b.get(idxLo);</span>
<span class="nc" id="L1717">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L1718">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L1720">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1722">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1724">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b items to be sorted by same order as a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1737">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1740">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1743">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1747">            return;</span>
        }
        
<span class="fc bfc" id="L1750" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1752">            float x = a[idxLo];</span>
<span class="fc" id="L1753">            int store = idxLo;</span>
<span class="fc" id="L1754">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1758">                    store++;     </span>
<span class="fc bfc" id="L1759" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1761">                    idxMid--;</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1764">                    break;</span>
                }
<span class="fc" id="L1766">                float swap = a[store];</span>
<span class="fc" id="L1767">                a[store] = a[idxMid];</span>
<span class="fc" id="L1768">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1770">                Object bSwap = b[store];</span>
<span class="fc" id="L1771">                b[store] = b[idxMid];</span>
<span class="fc" id="L1772">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1773">            }</span>
<span class="fc" id="L1774">            float swap = a[idxLo];</span>
<span class="fc" id="L1775">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1776">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1778">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1779">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1780">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1782">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1784">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1786">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     @param a items to sort
     @param b an array that will receive the same swap operations as are 
     performed on a
     @param c an array that will receive the same swap operations as are 
     performed on a
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1802" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1803">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1805" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1806">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1809">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1811" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1812">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1815" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1817">            float x = a[idxLo];</span>
<span class="fc" id="L1818">            int store = idxLo;</span>
<span class="fc" id="L1819">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1823">                    store++;     </span>
<span class="fc bfc" id="L1824" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1826">                    idxMid--;</span>
<span class="fc bfc" id="L1827" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1828" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1829">                    break;</span>
                }
<span class="fc" id="L1831">                float swap = a[store];</span>
<span class="fc" id="L1832">                a[store] = a[idxMid];</span>
<span class="fc" id="L1833">                a[idxMid] = swap;</span>
<span class="fc" id="L1834">                int swap2 = b[store];</span>
<span class="fc" id="L1835">                b[store] = b[idxMid];</span>
<span class="fc" id="L1836">                b[idxMid] = swap2;</span>
<span class="fc" id="L1837">                swap2 = c[store];</span>
<span class="fc" id="L1838">                c[store] = c[idxMid];</span>
<span class="fc" id="L1839">                c[idxMid] = swap2;</span>
<span class="fc" id="L1840">            }</span>
<span class="fc" id="L1841">            float swap = a[idxLo];</span>
<span class="fc" id="L1842">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1843">            a[idxMid] = swap;</span>
<span class="fc" id="L1844">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1845">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1846">            b[idxMid] = swap2;</span>
<span class="fc" id="L1847">            swap2 = c[idxLo];</span>
<span class="fc" id="L1848">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1849">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1851">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1853">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1855">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1864">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1866" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1867">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1869" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1870">            return;</span>
        }
<span class="fc" id="L1872">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1873">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     @param idxLo the first index in [0][index] to sort
     @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1884">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1886" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1887">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1890">            return;</span>
        }
<span class="fc bfc" id="L1892" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1893">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1894">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1895">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1897">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1902">        int x = a[0][idxHi];</span>
<span class="fc" id="L1903">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1905" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1906">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1907" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1908">                doSwap = true;</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1910" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1911">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1914" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1915">                store++;</span>
<span class="fc" id="L1916">                int swap = a[0][store];</span>
<span class="fc" id="L1917">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1918">                a[0][i] = swap;</span>
                
<span class="fc" id="L1920">                swap = a[1][store];</span>
<span class="fc" id="L1921">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1922">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1925">        store++;</span>
<span class="fc" id="L1926">        int swap = a[0][store];</span>
<span class="fc" id="L1927">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1928">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1930">        swap = a[1][store];</span>
<span class="fc" id="L1931">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1932">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1933">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1943">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1946">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1949">            return;</span>
        }
<span class="fc" id="L1951">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1952">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     @param a items to sort
     @param idxLo the first index in [0][index] to sort
     @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1963">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1966">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1969">            return;</span>
        }
<span class="fc bfc" id="L1971" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1972">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1973">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1974">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1976">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1981">        int x = a[0][idxHi];</span>
<span class="fc" id="L1982">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1984" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1985">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1986" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1987">                doSwap = true;</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1989" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1990">                    doSwap = true;</span>
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1992" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1993">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1997" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1998">                store++;</span>
<span class="fc bfc" id="L1999" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L2000">                    int swap = a[k][store];</span>
<span class="fc" id="L2001">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L2002">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L2006">        store++;</span>
<span class="fc bfc" id="L2007" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L2008">            int swap = a[k][store];</span>
<span class="fc" id="L2009">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L2010">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L2012">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2020">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2023">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2025" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2026">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2029">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2032">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L2035" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2036">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2037">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2038">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2040">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     @param d
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L2052" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L2053">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2055" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L2057">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L2060">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L2061">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     @param d
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L2075" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L2076">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2078" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L2080">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2083">            return;</span>
        }
<span class="fc bfc" id="L2085" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2086">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2087">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2088">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2090">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2095">        float x = a[idxHi];</span>
<span class="fc" id="L2096">        float x2 = b[idxHi];</span>
<span class="fc" id="L2097">        float x3 = c[idxHi];</span>
<span class="fc" id="L2098">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2100" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2101">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2103">                doSwap = true;</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L2106">                    doSwap = true;</span>
<span class="fc bfc" id="L2107" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L2109">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2113" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2114">                store++;</span>
<span class="fc" id="L2115">                float swap = a[store];</span>
<span class="fc" id="L2116">                a[store] = a[i];</span>
<span class="fc" id="L2117">                a[i] = swap;</span>
<span class="fc" id="L2118">                swap = b[store];</span>
<span class="fc" id="L2119">                b[store] = b[i];</span>
<span class="fc" id="L2120">                b[i] = swap;</span>
<span class="fc" id="L2121">                swap = c[store];</span>
<span class="fc" id="L2122">                c[store] = c[i];</span>
<span class="fc" id="L2123">                c[i] = swap;</span>
<span class="fc" id="L2124">                int swap3 = d[store];</span>
<span class="fc" id="L2125">                d[store] = d[i];</span>
<span class="fc" id="L2126">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L2129">        store++;</span>
<span class="fc" id="L2130">        float swap = a[store];</span>
<span class="fc" id="L2131">        a[store] = a[idxHi];</span>
<span class="fc" id="L2132">        a[idxHi] = swap;</span>
<span class="fc" id="L2133">        swap = b[store];</span>
<span class="fc" id="L2134">        b[store] = b[idxHi];</span>
<span class="fc" id="L2135">        b[idxHi] = swap;</span>
<span class="fc" id="L2136">        swap = c[store];</span>
<span class="fc" id="L2137">        c[store] = c[idxHi];</span>
<span class="fc" id="L2138">        c[idxHi] = swap;</span>
<span class="fc" id="L2139">        int swap3 = d[store];</span>
<span class="fc" id="L2140">        d[store] = d[idxHi];</span>
<span class="fc" id="L2141">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L2143">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2149">        float x = a.get(idxHi);</span>
<span class="fc" id="L2150">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2152" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2153">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2154" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2155">                doSwap = true;</span>
<span class="fc bfc" id="L2156" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L2158">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2161" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2162">                store++;</span>
<span class="fc" id="L2163">                float swap = a.get(store);</span>
<span class="fc" id="L2164">                a.set(store, a.get(i));</span>
<span class="fc" id="L2165">                a.set(i, swap);</span>
<span class="fc" id="L2166">                swap = b.get(store);</span>
<span class="fc" id="L2167">                b.set(store, b.get(i));</span>
<span class="fc" id="L2168">                b.set(i, swap);</span>
<span class="fc" id="L2169">                int swap2 = c.get(store);</span>
<span class="fc" id="L2170">                c.set(store, c.get(i));</span>
<span class="fc" id="L2171">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2174">        store++;</span>
        
<span class="fc" id="L2176">        float swap = a.get(store);</span>
<span class="fc" id="L2177">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2178">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L2180">        swap = b.get(store);</span>
<span class="fc" id="L2181">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2182">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L2184">        int swap2 = c.get(store);</span>
<span class="fc" id="L2185">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2186">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L2188">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2204">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2207">            return;</span>
        }
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2210">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2213">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2216">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2219">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2221" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2222">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2223">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2224">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2226">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2239">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2242">            return;</span>
        }
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2245">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2248">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2251">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2253" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2254">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L2256">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2257">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2272" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2273">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2275" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2276">            return;</span>
        }
<span class="pc bpc" id="L2278" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2279">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2281" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2282">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2284" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2285">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2287" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2288">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2291" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2292">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2293">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2294">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2296">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2305">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2307" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2308">            return;</span>
        }
<span class="nc bnc" id="L2310" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2311">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2313" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2314">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2316">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2317">    }</span>
    
    /**
     *
     @param a
     @param b
     */
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2325" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2326">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2328" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2329">            return;</span>
        }
<span class="pc bpc" id="L2331" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2332">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2334" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2335">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2337">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2338">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     */
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2346" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2347">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2349" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2350">            return;</span>
        }
<span class="fc" id="L2352">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2353">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     */
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2365">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2367" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2368">            return;</span>
        }
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2371">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="nc" id="L2374">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2375">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L2388" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2389">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2391" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2392">            return;</span>
        }
<span class="nc bnc" id="L2394" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2395">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="nc bnc" id="L2398" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>
<span class="nc" id="L2399">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="nc" id="L2400">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="nc" id="L2401">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L2403">    }</span>
    
    /**
     *
     @param &lt;T&gt;
     @param a
     @param idxLo
     @param idxHi
     */
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2414" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2415">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2417" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2418">            return;</span>
        }
        
<span class="fc bfc" id="L2421" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2422">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2423">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2424">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2426">    }</span>
    
    /**
     *
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2437">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2439" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2440">            return;</span>
        }
<span class="pc bpc" id="L2442" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2443">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2445" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2446">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2448" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2449">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2450">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2451">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2453">    }</span>
    
    /**
     *
     @param a
     @param b
     @param idxLo
     @param idxHi
     */
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2463" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2464">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2466" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2467">            return;</span>
        }
<span class="pc bpc" id="L2469" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2470">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2472" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2473">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2475" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2476">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2477">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2478">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2480">    }</span>
    
    /**
     *
     @param a
     @param b
     @param c
     */
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2491" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2492">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2494" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2495">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2497" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2498">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2501">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2502">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param d items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2518" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2519">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2521" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2522">            return;</span>
        }
<span class="pc bpc" id="L2524" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2525">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2527" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2528">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2530" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2531">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2533" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2534">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2537">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2539" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2540">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2542" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2543">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2544">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2545">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2547">    }</span>

    private static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2551" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2552">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2553">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2554">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2556">    }</span>
    
    /**
     * sorts a, b, and c by the values of a only
     @param a items to sort
     @param b items to be sorted
     @param c items to be sorted
     @param idxLo low index of a sort range, inclusive
     @param idxHi high index of a sort range, inclusive
     */
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="nc bnc" id="L2569" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>
<span class="nc" id="L2570">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="nc" id="L2571">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="nc" id="L2572">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L2574">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="nc" id="L2579">        float x = a[idxHi];</span>
<span class="nc" id="L2580">        int store = idxLo - 1;</span>
        
<span class="nc bnc" id="L2582" title="All 2 branches missed.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">            if (a[i] &lt;= x) {</span>
<span class="nc" id="L2584">                store++;</span>
<span class="nc" id="L2585">                float swap = a[store];</span>
<span class="nc" id="L2586">                a[store] = a[i];</span>
<span class="nc" id="L2587">                a[i] = swap;</span>
<span class="nc" id="L2588">                float swap2 = b[store];</span>
<span class="nc" id="L2589">                b[store] = b[i];</span>
<span class="nc" id="L2590">                b[i] = swap2;</span>
<span class="nc" id="L2591">                swap2 = c[store];</span>
<span class="nc" id="L2592">                c[store] = c[i];</span>
<span class="nc" id="L2593">                c[i] = swap2;</span>
            }
        }
<span class="nc" id="L2596">        store++;</span>
<span class="nc" id="L2597">        float swap = a[store];</span>
<span class="nc" id="L2598">        a[store] = a[idxHi];</span>
<span class="nc" id="L2599">        a[idxHi] = swap;</span>
<span class="nc" id="L2600">        float swap2 = b[store];</span>
<span class="nc" id="L2601">        b[store] = b[idxHi];</span>
<span class="nc" id="L2602">        b[idxHi] = swap2;</span>
<span class="nc" id="L2603">        swap2 = c[store];</span>
<span class="nc" id="L2604">        c[store] = c[idxHi];</span>
<span class="nc" id="L2605">        c[idxHi] = swap2;</span>
<span class="nc" id="L2606">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2612">        float x = a[idxHi];</span>
<span class="fc" id="L2613">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2615" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2616">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2617" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2618">                doSwap = true;</span>
<span class="fc bfc" id="L2619" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2621">                    doSwap = true;</span>
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2624">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2628" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2629">                store++;</span>
<span class="fc" id="L2630">                float swap = a[store];</span>
<span class="fc" id="L2631">                a[store] = a[i];</span>
<span class="fc" id="L2632">                a[i] = swap;</span>
<span class="fc" id="L2633">                float swap2 = b[store];</span>
<span class="fc" id="L2634">                b[store] = b[i];</span>
<span class="fc" id="L2635">                b[i] = swap2;</span>
<span class="fc" id="L2636">                swap2 = c[store];</span>
<span class="fc" id="L2637">                c[store] = c[i];</span>
<span class="fc" id="L2638">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2641">        store++;</span>
<span class="fc" id="L2642">        float swap = a[store];</span>
<span class="fc" id="L2643">        a[store] = a[idxHi];</span>
<span class="fc" id="L2644">        a[idxHi] = swap;</span>
<span class="fc" id="L2645">        float swap2 = b[store];</span>
<span class="fc" id="L2646">        b[store] = b[idxHi];</span>
<span class="fc" id="L2647">        b[idxHi] = swap2;</span>
<span class="fc" id="L2648">        swap2 = c[store];</span>
<span class="fc" id="L2649">        c[store] = c[idxHi];</span>
<span class="fc" id="L2650">        c[idxHi] = swap2;</span>
<span class="fc" id="L2651">        return store;</span>
    }
    
    private static &lt;T&gt; int partitionBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="fc" id="L2656">        int x = a[idxHi];</span>
<span class="fc" id="L2657">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2659" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2660">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2661" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2662">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2664" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2665">                store++;</span>
<span class="fc" id="L2666">                int swap = a[store];</span>
<span class="fc" id="L2667">                a[store] = a[i];</span>
<span class="fc" id="L2668">                a[i] = swap;</span>
<span class="fc" id="L2669">                T swap2 = b.get(store);</span>
<span class="fc" id="L2670">                b.set(store, b.get(i));</span>
<span class="fc" id="L2671">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2674">        store++;</span>
<span class="fc" id="L2675">        int swap = a[store];</span>
<span class="fc" id="L2676">        a[store] = a[idxHi];</span>
<span class="fc" id="L2677">        a[idxHi] = swap;</span>
<span class="fc" id="L2678">        T swap2 = b.get(store);</span>
<span class="fc" id="L2679">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2680">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2682">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2689">        int x = a.get(idxHi);</span>
<span class="fc" id="L2690">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2692" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2693">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2695">                doSwap = true;</span>
<span class="fc bfc" id="L2696" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2697" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2698">                    doSwap = true;</span>
<span class="fc bfc" id="L2699" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2700" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2701">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2705" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2706">                store++;</span>
<span class="fc" id="L2707">                int swap = a.get(store);</span>
<span class="fc" id="L2708">                a.set(store, a.get(i));</span>
<span class="fc" id="L2709">                a.set(i, swap);</span>
<span class="fc" id="L2710">                int swap2 = b.get(store);</span>
<span class="fc" id="L2711">                b.set(store, b.get(i));</span>
<span class="fc" id="L2712">                b.set(i, swap2);</span>
<span class="fc" id="L2713">                swap2 = c.get(store);</span>
<span class="fc" id="L2714">                c.set(store, c.get(i));</span>
<span class="fc" id="L2715">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2718">        store++;</span>
<span class="fc" id="L2719">        int swap = a.get(store);</span>
<span class="fc" id="L2720">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2721">        a.set(idxHi, swap);</span>
<span class="fc" id="L2722">        int swap2 = b.get(store);</span>
<span class="fc" id="L2723">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2724">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2725">        swap2 = c.get(store);</span>
<span class="fc" id="L2726">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2727">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2728">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2734">        float x = a[idxHi];</span>
<span class="fc" id="L2735">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2737" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2738">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2739" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2740">                doSwap = true;</span>
<span class="fc bfc" id="L2741" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2742" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2743">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2746" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2747">                store++;</span>
<span class="fc" id="L2748">                float swap = a[store];</span>
<span class="fc" id="L2749">                a[store] = a[i];</span>
<span class="fc" id="L2750">                a[i] = swap;</span>
<span class="fc" id="L2751">                float swap2 = b[store];</span>
<span class="fc" id="L2752">                b[store] = b[i];</span>
<span class="fc" id="L2753">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2756">        store++;</span>
<span class="fc" id="L2757">        float swap = a[store];</span>
<span class="fc" id="L2758">        a[store] = a[idxHi];</span>
<span class="fc" id="L2759">        a[idxHi] = swap;</span>
<span class="fc" id="L2760">        float swap2 = b[store];</span>
<span class="fc" id="L2761">        b[store] = b[idxHi];</span>
<span class="fc" id="L2762">        b[idxHi] = swap2;</span>
<span class="fc" id="L2763">        return store;</span>
    }
    
    public static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2769">        int x = a[idxHi];</span>
<span class="fc" id="L2770">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2772" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2773">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2774" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2775">                doSwap = true;</span>
<span class="fc bfc" id="L2776" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2777" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2778">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2781" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2782">                store++;</span>
<span class="fc bfc" id="L2783" title="All 2 branches covered.">                if (store != i) {</span>
<span class="fc" id="L2784">                    int swap = a[store];</span>
<span class="fc" id="L2785">                    a[store] = a[i];</span>
<span class="fc" id="L2786">                    a[i] = swap;</span>
<span class="fc" id="L2787">                    int swap2 = b[store];</span>
<span class="fc" id="L2788">                    b[store] = b[i];</span>
<span class="fc" id="L2789">                    b[i] = swap2;</span>
                }
            }
        }
<span class="fc" id="L2793">        store++;</span>
<span class="fc" id="L2794">        int swap = a[store];</span>
<span class="fc" id="L2795">        a[store] = a[idxHi];</span>
<span class="fc" id="L2796">        a[idxHi] = swap;</span>
<span class="fc" id="L2797">        int swap2 = b[store];</span>
<span class="fc" id="L2798">        b[store] = b[idxHi];</span>
<span class="fc" id="L2799">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2801">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2807">        T x = a[idxHi];</span>
<span class="fc" id="L2808">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2810" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2811">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2812" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2813">                doSwap = true;</span>
<span class="fc bfc" id="L2814" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2815" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2816">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2819" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2820">                store++;</span>
<span class="fc" id="L2821">                T swap = a[store];</span>
<span class="fc" id="L2822">                a[store] = a[i];</span>
<span class="fc" id="L2823">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2826">        store++;</span>
<span class="fc" id="L2827">        T swap = a[store];</span>
<span class="fc" id="L2828">        a[store] = a[idxHi];</span>
<span class="fc" id="L2829">        a[idxHi] = swap;</span>
<span class="fc" id="L2830">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="nc" id="L2836">        T x = a[idxHi];</span>
<span class="nc" id="L2837">        int store = idxLo - 1;</span>
        
<span class="nc bnc" id="L2839" title="All 2 branches missed.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="nc" id="L2840">            boolean doSwap = false;</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="nc" id="L2842">                doSwap = true;</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2845">                    doSwap = true;</span>
                }
            }
<span class="nc bnc" id="L2848" title="All 2 branches missed.">            if (doSwap) {</span>
<span class="nc" id="L2849">                store++;</span>
<span class="nc" id="L2850">                T swap = a[store];</span>
<span class="nc" id="L2851">                a[store] = a[i];</span>
<span class="nc" id="L2852">                a[i] = swap;</span>
<span class="nc" id="L2853">                int swap2 = b[store];</span>
<span class="nc" id="L2854">                b[store] = b[i];</span>
<span class="nc" id="L2855">                b[i] = swap2;</span>
            }
        }
<span class="nc" id="L2858">        store++;</span>
<span class="nc" id="L2859">        T swap = a[store];</span>
<span class="nc" id="L2860">        a[store] = a[idxHi];</span>
<span class="nc" id="L2861">        a[idxHi] = swap;</span>
<span class="nc" id="L2862">        int swap2 = b[store];</span>
<span class="nc" id="L2863">        b[store] = b[idxHi];</span>
<span class="nc" id="L2864">        b[idxHi] = swap2;</span>
<span class="nc" id="L2865">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2871">        double x = a[idxHi];</span>
<span class="fc" id="L2872">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2874" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2875">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2876" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2877">                doSwap = true;</span>
<span class="fc bfc" id="L2878" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2879" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2880">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2883" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2884">                store++;</span>
<span class="fc" id="L2885">                double swap = a[store];</span>
<span class="fc" id="L2886">                a[store] = a[i];</span>
<span class="fc" id="L2887">                a[i] = swap;</span>
<span class="fc" id="L2888">                swap = b[store];</span>
<span class="fc" id="L2889">                b[store] = b[i];</span>
<span class="fc" id="L2890">                b[i] = swap;</span>
<span class="fc" id="L2891">                int swap2 = c[store];</span>
<span class="fc" id="L2892">                c[store] = c[i];</span>
<span class="fc" id="L2893">                c[i] = swap2;</span>
<span class="fc" id="L2894">                swap2 = d[store];</span>
<span class="fc" id="L2895">                d[store] = d[i];</span>
<span class="fc" id="L2896">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2899">        store++;</span>
<span class="fc" id="L2900">        double swap = a[store];</span>
<span class="fc" id="L2901">        a[store] = a[idxHi];</span>
<span class="fc" id="L2902">        a[idxHi] = swap;</span>
<span class="fc" id="L2903">        swap = b[store];</span>
<span class="fc" id="L2904">        b[store] = b[idxHi];</span>
<span class="fc" id="L2905">        b[idxHi] = swap;</span>
<span class="fc" id="L2906">        int swap2 = c[store];</span>
<span class="fc" id="L2907">        c[store] = c[idxHi];</span>
<span class="fc" id="L2908">        c[idxHi] = swap2;</span>
<span class="fc" id="L2909">        swap2 = d[store];</span>
<span class="fc" id="L2910">        d[store] = d[idxHi];</span>
<span class="fc" id="L2911">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2912">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>