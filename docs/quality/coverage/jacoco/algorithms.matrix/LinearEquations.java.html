<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinearEquations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.matrix</a> &gt; <span class="el_source">LinearEquations.java</span></div><h1>LinearEquations.java</h1><pre class="source lang-java linenums">package algorithms.matrix;

import java.util.Arrays;

import algorithms.util.FormatArray;
import no.uib.cipr.matrix.*;

/**
 a class of utility methods for linear algebra.
 &lt;pre&gt;
 note, for solving linear least squares problems, a good resource aside
 * from Strang, Golub &amp; van Loan, and Cormen et al. is:
 “Algorithms for Linear Least Squares Problems”, 
 Bj̈orck 1991, published in Computer Algorithms for Solving Linear Algebraic Equations;
 The State of the Art., Vol. 77 of NATO-ASI Series F: Computer and Systems Sciences, pages 57–92.
 &lt;/pre&gt;
   LUPSolve, __, and __ follow
   pseudocode from Cormen, Leiserson, Rivest, and Stein, &quot;Introduction to
   Computer Algorithms&quot;.
*/
<span class="pc" id="L21">public class LinearEquations {</span>

    /**
     solving for 'x' in equations:
       a_0_0*x_0   +  a_0_1*x_1   + ... a_0_n*x_n     = b_0
       a_1_0*x_0   +  a_1_1*x_1   + ... a_1_n*x_n     = b_1
          ...
       a_n-1_0*x_0 +  a_n-1_1*x_1 + ... a_{n-1}_n*x_{n-1} = b_{n-1}
     where a is a square matrix, that is, there are n equations and n
     unknowns.
     LUP decomposition is more numerically stable than x = A^-1*b.
         can find L, U, and P such that P*A=L*U
     where L is a lower triangular matrix, U is an upper triangular matrix,
     and P is a permutation matrix.
     (a permutation matrix is all 0's excepting a single 1 in each column, uniquely.
     multiplying a vector by a permutation rearranges the members of the vector.)
     Uses forward substitution then back substitution.
       L*U*x=P*b.
         let y=U*x.
       L*y=P*b  (uses forward substitution with these results).
       U*x=y    (uses back substitution with these results).
       A*x=b    (then solves x_i=(y_i - summation_j=i_to_{n-1}(u_i_j*x_j))/u_i_i).
     runtime complexity is O(n^2) for backward and forward substitutions.
     * The method follows Cormet et al. Chap 28.3.
     @param ell is an nxn lower triangular matrix using row major format.
     @param u is an nxn upper triangular matrix using row major format.
     @param p is an array of length n holding permutation vector columns. 
            e.g. p_0=0 states that column 0 contains a 1 for row=0.
            e.g. p_1=2 states that column 2 contains a 1 for row=1.
            full_permutation_matrix = zeros everywhere except the row, col pairs in p
     @param b is an array of length n.
     @return array of x
    */
    public static double[] LUPSolve(double[][] ell, double[][] u, int[] p, double[] b) {
<span class="fc" id="L55">        int n = ell.length;</span>
<span class="fc" id="L56">        assertSquareMatrix(ell, &quot;ell&quot;);</span>
<span class="fc" id="L57">        assertSquareMatrix(u, &quot;u&quot;);</span>
<span class="fc" id="L58">        assertArrayLength(n, p, &quot;p&quot;);</span>
<span class="fc" id="L59">        assertArrayLength(n, b, &quot;b&quot;);</span>

<span class="fc" id="L61">        double[] y = new double[n];</span>
<span class="fc" id="L62">        double[] x = new double[n];</span>
<span class="fc" id="L63">        double tempsum = 0;</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L65">            tempsum = 0;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L67">                tempsum += ell[i][j]*y[j];</span>
            }
<span class="fc" id="L69">            y[i] = b[p[i]] - tempsum;</span>
        }
<span class="fc" id="L71">        tempsum = 0;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        for (int i = n-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L73">            tempsum = 0;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">            if (i != (n-1)) {</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">                for (int j = i+1; j &lt; n; j++) {</span>
<span class="fc" id="L76">                    tempsum += u[i][j]*x[j];</span>
                }
            }
<span class="fc" id="L79">            x[i] = (y[i] - tempsum)/u[i][i];</span>
        }
<span class="fc" id="L81">        return x;</span>
    }
    
    /**
     * solve for x in A*x=b by LU decomposition
     * @param a
     * @param b
     * @return 
     */
    public static double[] solveXFromLUDecomposition(double[][] a, double[] b) {
        
<span class="fc" id="L92">        int n = a.length;</span>
        
<span class="fc" id="L94">        DenseVector x = new DenseVector(n);</span>
<span class="fc" id="L95">        DenseVector _b = new DenseVector(b);</span>
        
<span class="fc" id="L97">        DenseMatrix aa = new DenseMatrix(a);</span>
<span class="fc" id="L98">        x = (DenseVector)aa.solve(_b, x);</span>
                        
<span class="fc" id="L100">        return x.getData();</span>
    }

    /**
     * an efficient LUP decomposition for a being a square non-singular matrix and
     * P is the Identity matrix.   uses Gaussian elimination and the Schur
     * complement while making recursive subdivision subdivisions.
     * The runtime is O(n^3).
     * @param a square two dimensional array in row major format.  
     * a is a non-singular matrix(i.e. has exactly one solution).  the rank of
     * a is n (it's dimensions are m x n).
     * @return LU a wrapper holding the 2 two-dimensional row major output arrays.
     * L and U.  they are both size nXn where n=a.length.
     * L is a unit lower triangular matrix (has 1's on the diagonal) and U
     * is an upper triangular matrix whose diagonals are the matrix pivots.
     * Note that the determinant of A is the product of the U diagonals,
     * that is det(A) = u[0][0] * u[1][1]...*u[n-1][n-1].
     */
    public static LU LUDecomposition(double[][] a) {
<span class="fc" id="L119">        int n = a.length;</span>
<span class="fc" id="L120">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="fc" id="L122">        a = MatrixUtil.copy(a);</span>
        
        //nXn for both:
<span class="fc" id="L125">        double[][] ell = new double[n][];</span>
<span class="fc" id="L126">        double[][] u = new double[n][];</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L128">            ell[i] = new double[n];</span>
<span class="fc" id="L129">            u[i] = new double[n];</span>
<span class="fc" id="L130">            ell[i][i] = 1;</span>
<span class="fc" id="L131">            u[i][i] = 1;</span>
        }
        
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L135">            u[k][k] = a[k][k];</span>
            
<span class="fc bfc" id="L137" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc" id="L138">                ell[i][k] = a[i][k]/u[k][k];</span>
<span class="fc" id="L139">                u[k][i] = a[k][i];</span>
            }
            
<span class="fc bfc" id="L142" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                for (int j = k+1; j &lt; n; j++) {</span>
<span class="fc" id="L144">                    a[i][j] -= (ell[i][k] * u[k][j]); </span>
                }
            }
        }
                
<span class="fc" id="L149">        return new LU(ell, u);</span>
    }

    /**
     * create the reduced row echelon form of matrix a as the Upper right matrix from the LU decomposition,
     * further normalized and reduced.
     * @param a a rectangular matrix
     * @param tol tolerance for comparing to zero.  e.g. the machine precision.
     * @return
     */
    public static double[][] gaussianEliminationViaLU(double[][] a, double tol) throws NotConvergedException {
<span class="fc" id="L160">        a = MatrixUtil.copy(a);</span>
<span class="fc" id="L161">        int m = a.length;</span>
<span class="fc" id="L162">        int n = a[0].length;</span>

        /*
        //  following Algorithm 4.2-1 of &quot;Matrix Computations&quot;, Golub and van Loan
        // algorithm is written with &quot;1&quot; based indexes, so
        // subtract 1 when using them as matrix indices.
        int s = Math.min(m - 1, n);
        double[] wj = new double[n];
        double eta;
        for (int k = 1; k &lt;= s; ++k) {
            if (Math.abs(a[k-1][k-1]) &lt; tol) {
                System.err.println(&quot;0 in matrix a cause algorithm to terminate&quot;);
                break;
            }
            //j=k+1...n
            Arrays.fill(wj,0);
            for (j = k + 1; j &lt;= n; ++j) {
                wj[j-1] = a[k-1][j-1];
            }
            for (i = k + 1; i &lt;= m; ++i) {
                eta = a[i-1][k-1] / a[k-1][k-1];
                a[i-1][k-1] = eta;
                for (j = k + 1; j &lt;= n; ++j) {
                    a[i-1][j-1] -= eta * wj[j-1];
                }
            }
        }
        // the lower left is L, upper right is U.
        // A = L*U
        // and (L)^-1 * A = U where L^-1 is the gauss transformations.
        double[][] ell = MatrixUtil.zeros(m, n);
        double[][] u = MatrixUtil.zeros(m, n);
        for (i = 0; i &lt; m; ++i) {
            for (j = i; j &lt; n; ++j) {
                u[i][j] =  a[i][j];
            }
        }
        ell[0][0] = 1;
        for (i = 1; i &lt; m; ++i) {
            ell[i][i] = 1;
            for (j = 0; j &lt; i; ++j) {
                if (j &gt;= n) {
                    break;
                }
                if (i == j) {
                    continue;
                }
                ell[i][j] =  a[i][j];
            }
        }
        return u;
        */

        int j;
        int i;
<span class="fc" id="L217">        DenseMatrix aM = new DenseMatrix(a);</span>
<span class="fc" id="L218">        DenseLU luM = no.uib.cipr.matrix.DenseLU.factorize(aM);</span>
<span class="fc" id="L219">        UpperTriangDenseMatrix uM = luM.getU();</span>
<span class="fc" id="L220">        UnitLowerTriangDenseMatrix lM = luM.getL();</span>

<span class="fc" id="L222">        double[][] ell = Matrices.getArray(lM);</span>
<span class="fc" id="L223">        double[][] u = Matrices.getArray(uM);</span>

<span class="fc" id="L225">        double[][] ellInv = MatrixUtil.pseudoinverseFullColumnRank(ell);</span>

        // calculate U = L^-1 * A in full, not the nxn or mxm version
<span class="fc" id="L228">        u = MatrixUtil.multiply(ellInv, a);</span>

        int c;
        double[] t;
        // normalize all rows in u so that pivots are &quot;1&quot;
<span class="fc" id="L233">        makePivots1(u, tol);</span>

        // zero-out any repeated rows
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (i = u.length - 1; i &gt; 0; --i) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            for (j = i - 1; j &gt; -1; --j) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (identicalRows(u, j, i, tol)) {</span>
<span class="fc" id="L239">                    Arrays.fill(u[i], 0.);</span>
<span class="fc" id="L240">                    break;</span>
                }
            }
        }

        // subtract pivot columns from lower rows
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (i = u.length - 1; i &gt; 0; --i) {</span>
<span class="fc" id="L247">            c = 0;</span>
            // skip past zeroes
<span class="fc bfc" id="L249" title="All 4 branches covered.">            while (c &lt; n &amp;&amp; Math.abs(u[i][c]) &lt; tol) {</span>
<span class="fc" id="L250">                ++c;</span>
            }
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (c &lt; n) {</span>
                // this is the pivot column in row i.
                // search lower rows and subtract this pivot row from them if not already 0 in pivot column
<span class="fc bfc" id="L255" title="All 2 branches covered.">                for (j = i - 1; j &gt; -1; --j) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">                    if (Math.abs(u[j][c]) &gt; tol) {</span>
                        // subtract pivot row
                        // e.g.   1  3  1  0  &lt;== subtr 3*R1
                        //        0  1  1  1
<span class="fc" id="L260">                        t = Arrays.copyOf(u[i], n);</span>
<span class="fc" id="L261">                        MatrixUtil.multiply(t, u[j][c]);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                        for (int k = 0; k &lt; n; ++k) {</span>
<span class="fc" id="L263">                            u[j][k] -= t[k];</span>
                        }
                    }
                }
            }
        }

        // if wanted to return the L matrix also, L = U * A^-1
        // and return the pivot indexes
        // add to comments that the product of the pivots gives the determinant
        //     of U which is the determinant of A.
        // when A has less than n pivots, det A = 0.

<span class="fc" id="L276">        return u;</span>
    }

    static void makePivots1(double[][] u, double tol) {
<span class="fc" id="L280">        int m = u.length;</span>
<span class="fc" id="L281">        int n = u[0].length;</span>
        int c;
        int i;
        int j;
        double f;
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L287">            c = 0;</span>
            // skip past zeroes
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">            while (c &lt; n &amp;&amp; Math.abs(u[i][c]) &lt; tol) {</span>
<span class="fc" id="L290">                ++c;</span>
            }
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (c &lt; n) {</span>
                // this is the pivot column in row i.
<span class="fc" id="L294">                f = 1./u[i][c];</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                for (j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L296">                    u[i][j] *= f;</span>
                }
            }
        }
<span class="fc" id="L300">    }</span>

    private static boolean identicalRows(double[][] u, int r1, int r2, double tol) {
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int i = 0; i &lt; u[r1].length; ++i) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (Math.abs(u[r1][i] - u[r2][i]) &gt; tol) {</span>
<span class="fc" id="L305">                return false;</span>
            }
        }
<span class="fc" id="L308">        return true;</span>
    }

    /**
     * for a symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-M decomposition which is a 
     * variation of L-U decomposition.  If all leading principal sub-matrices of 
     * A are non-singular then there exist lower unit triangular matrices
     * L and M and a diagonal matrix D = diag(d1, d2, ...d_n) where d_i = u_i_i.
     * A = L*D*M^T.
     * Note that D is non-singular and that M^T = D^-1*U is unit upper triangular.
     * (A=L*U = L*D*(D^-1*U = L*D*M^T).
     * &lt;pre&gt;
     * Once A = L*D*M^T is decomposed, one can solve A*x = b:
     * L*y = b   (in (n^2)/2 flops
     * D*z= y    (in n flops)
     * M^T*x = z (in (n^2)/2 flops)
     * 
     * References:
     * Golub and va Loan, &quot;Matrix Computations&quot;, Section 5.1
     * &lt;/pre&gt;
     * 2n^3/3 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     */
    public static LDM LDMDecomposition(double[][] a) {
        
<span class="fc" id="L337">        int n = a.length;</span>
        
<span class="fc" id="L339">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
        // need to have a in row echelon reduced state for this:
        //assertSymmetrix(a);
        
<span class="fc" id="L344">        double[][] ell = MatrixUtil.zeros(n, n);</span>
<span class="fc" id="L345">        double[][] m = MatrixUtil.zeros(n, n);</span>
<span class="fc" id="L346">        double[] d = new double[n];</span>
        
        int k, i, p;
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for (k = 1; k &lt;= n; ++k) {</span>
<span class="fc" id="L350">            d[k-1] = a[k-1][k-1];</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L352">                d[k-1] -= (ell[k-1][p-1]*d[p-1]*m[k-1][p-1]);</span>
            }
            // error in the 1st edition of Matrix Computations; i=k to n, but they use i=k+1 to n
<span class="fc bfc" id="L355" title="All 2 branches covered.">            for (i = k/*k+1*/; i &lt;= n; ++i) {</span>
                
<span class="fc" id="L357">                ell[i-1][k-1] = a[i-1][k-1];</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L359">                    ell[i-1][k-1] -= (ell[i-1][p-1]*d[p-1]*m[k-1][p-1]);</span>
                }
<span class="fc" id="L361">                ell[i-1][k-1] /= d[k-1];</span>
                
<span class="fc" id="L363">                m[i-1][k-1] = a[k-1][i-1];</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L365">                    m[i-1][k-1] -= (ell[k-1][p-1]*d[p-1]*m[i-1][p-1]);</span>
                }
<span class="fc" id="L367">                m[i-1][k-1] /= d[k-1];</span>
            }
        }
        
<span class="fc" id="L371">        LDM ldm = new LDM(ell, d, m);</span>
        
<span class="fc" id="L373">        return ldm;</span>
    }
    
    /**
     * compute the cholesky decomposition for symmetric positive definite matrix
     * a using the MTJ library.
     * @param a symmetric positive definite matrix 
     * @return lower triangular matrix G  which G is a lower triangular matrix with positive
    * diagonal entries.  a = G*G^T.
    */
    public static double[][] choleskyDecompositionViaMTJ(double[][] a) {
<span class="nc" id="L384">        int n = a.length;</span>
        
<span class="nc" id="L386">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="nc" id="L388">        DenseCholesky chol = new DenseCholesky(n, false);</span>
<span class="nc" id="L389">        chol = chol.factor(new LowerSPDDenseMatrix(new DenseMatrix(a)));</span>
<span class="nc" id="L390">        LowerTriangDenseMatrix ell = chol.getL();</span>
<span class="nc" id="L391">        return Matrices.getArray(ell);</span>
    }
    
    /**
     * compute the cholesky decomposition for symmetric positive definite matrix
     * a.
     * reference:
     * golub &amp; van loan &quot;matrix computations, theorem 5.2-3.
     * This method uses LDL decomposition to compute G in 
     * a = G*G^T where G is a lower triangular matrix with positive
    * diagonal entries.
    * 
     * @param a symmetric positive definite matrix 
     * @param eps value for an error tolerance around zero used in the LDL decomposition.
     * @return lower triangular matrix G  which G is a lower triangular matrix with positive
    * diagonal entries.  a = G*G^T.
    */
    public static double[][] choleskyDecompositionViaLDL(double[][] a, double eps) {
        
<span class="fc" id="L410">        int n = a.length;</span>
        
<span class="fc" id="L412">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
        //assertPositiveDefinite(a, &quot;a&quot;);
        
<span class="fc" id="L416">        LDL ldl = LDLDecomposition(a, eps);</span>
        
<span class="fc" id="L418">        double[] d = Arrays.copyOf(ldl.getD(), ldl.getD().length);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (int i = 0; i &lt; d.length; ++i) {</span>
<span class="fc" id="L420">            d[i] = Math.sqrt(d[i]);</span>
        }
<span class="fc" id="L422">        double[][] g = MatrixUtil.multiplyByDiagonal(ldl.getL(), d);</span>
        
<span class="fc" id="L424">        return g;</span>
    }
       
    /**
     * for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-L decomposition which is a 
     * variation of L-U decomposition.  Computes a unit lower triangular matrix
     * L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
     * A = L*D*L^T.
     * &lt;pre&gt;
     * 
     * References:
     * Golub and van Loan, &quot;Matrix Computations&quot;, Algorithm 5.1.2
     * &lt;/pre&gt;
     * n^3/6 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     */
    public static LDL LDLDecomposition(double[][] a) {
<span class="fc" id="L445">        double eps = 1.e-7;</span>
<span class="fc" id="L446">        return LDLDecomposition(a, eps);</span>
    }
        
    /**
     * for a nonsingular symmetric matrix A (with real numbers in matrix of size nXn), 
     * perform and L-D-L decomposition which is a 
     * variation of L-U decomposition.  Computes a unit lower triangular matrix
     * L and a diagonal matrix D = diag(d1, d2, ...d_n) such that
     * A = L*D*L^T.
     * &lt;pre&gt;
     * 
     * References:
     * Golub and van Loan, &quot;Matrix Computations&quot;, Algorithm 5.1.2
     * &lt;/pre&gt;
     * n^3/6 flops.
     * @param a two dimensional array in row major format.  
     * a is a symmetric matrix with dimensions n x n.
     * @param eps value for a tolerance of an error around 0.
     * @return LDM a wrapper holding the 2 two-dimensional row major output arrays.
     * L and M and the diagonal matrix D as a an array of the diagonal.
     * Note that the method will return null when an intermediary calculation 
     * is smaller than eps.
     */
    public static LDL LDLDecomposition(double[][] a, double eps) {
        
<span class="fc" id="L471">        int m = a.length;</span>
<span class="fc" id="L472">        int n = a[0].length;</span>
        
<span class="fc" id="L474">        assertSquareMatrix(a, &quot;a&quot;);</span>
                
        // need to have a in row echelon reduced state for this:
        //assertSymmetrix(a);
        
        //NOTE: if need to conserve memory, can remove the copy statement,
        //    and add to javadoc comments that a is modified in place.
<span class="fc" id="L481">        a = MatrixUtil.copy(a);</span>
<span class="fc" id="L482">        double[] r = new double[m];</span>
<span class="fc" id="L483">        double[] d = new double[m];</span>
        
        int k, i, p;
<span class="fc bfc" id="L486" title="All 2 branches covered.">        for (k = 1; k &lt;= m; ++k) {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L488">                r[p-1] = d[p-1]*a[k-1][p-1];</span>
            }
<span class="fc" id="L490">            d[k-1] = a[k-1][k-1];</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L492">                d[k-1] -= a[k-1][p-1]*r[p-1];</span>
            }
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (Math.abs(d[k-1]) &lt; eps) {</span>
<span class="nc" id="L495">                System.err.printf(&quot;Error: number %.3e is smaller than %.3e\n&quot;, </span>
<span class="nc" id="L496">                    Math.abs(d[k-1]), eps);</span>
<span class="nc" id="L497">                return null;</span>
            }
<span class="fc bfc" id="L499" title="All 2 branches covered.">            for (i = k; i &lt;= m; ++i) {</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                for (p = 1; p &lt;= (k-1); ++p) {</span>
<span class="fc" id="L501">                    a[i-1][k-1] -= a[i-1][p-1]*r[p-1];</span>
                }
<span class="fc" id="L503">                a[i-1][k-1] /= d[k-1];</span>
            }
        }
        
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            for (k = i+1; k &lt; m; ++k) {</span>
<span class="fc" id="L509">                a[i][k] = 0;</span>
            }
        }
        
<span class="fc" id="L513">        LDL ld = new LDL(a, d);</span>
        
<span class="fc" id="L515">        return ld;</span>
    }
    
    
    
    /**
     * an LUP decomposition for a being a square non-singular matrix that tries 
     * to reduce errors due to division by small numbers.  
     * creates a permutation matrix to pivot rows so that the row reduction
     * divisions are by the largest numbers.
     * uses Gaussian elimination and the Schur
     * complement while making recursive subdivision subdivisions.
     * The runtime is O(n^3).
     * @param a square two dimensional array in row major format.  
     * a is a non-singular matrix (i.e. has exactly one solution).  the rank of
     * a is n (it's dimensions are m x n).
     * @return LUP a wrapper holding the 2 two-dimensional row major output arrays.
     * L and U and the condensed permutation array p, where P*A=L*U.
     */
    public static LUP LUPDecomposition(double[][] a) {
<span class="fc" id="L535">        int n = a.length;</span>
<span class="fc" id="L536">        assertSquareMatrix(a, &quot;a&quot;);</span>
        
<span class="fc" id="L538">        a = MatrixUtil.copy(a);</span>
        
<span class="fc" id="L540">        int[] pi = new int[n];</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {            </span>
<span class="fc" id="L542">            pi[i] = i;</span>
        }
        
        double p;
        double temp;
<span class="fc" id="L547">        int k2 = -1;</span>
        double swap;
        int swapI;
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L551">            p = 0;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            for (int i = k; i &lt; n; i++) {</span>
<span class="fc" id="L553">                temp = Math.abs(a[i][k]);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (temp &gt; p) {</span>
<span class="fc" id="L555">                    p = temp;</span>
<span class="fc" id="L556">                    k2 = i;</span>
                }
            }
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">            if (p == 0.) {</span>
<span class="nc" id="L560">                throw new IllegalStateException(&quot;Error: a is a singular matrix&quot;);</span>
            }
<span class="pc bnc" id="L562" title="All 2 branches missed.">            assert(k2 &gt;= 0);</span>
<span class="fc" id="L563">            swapI = pi[k2];</span>
<span class="fc" id="L564">            pi[k2] = pi[k];</span>
<span class="fc" id="L565">            pi[k] = swapI;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L567">                swap = a[k2][i];</span>
<span class="fc" id="L568">                a[k2][i] = a[k][i];</span>
<span class="fc" id="L569">                a[k][i] = swap;</span>
            }
<span class="fc bfc" id="L571" title="All 2 branches covered.">            for (int i = k+1; i &lt; n; i++) {</span>
<span class="fc" id="L572">                a[i][k] /= a[k][k];</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                for (int j = k+1; j &lt; n; j++) {</span>
<span class="fc" id="L574">                    a[i][j] -= (a[i][k] * a[k][j]);</span>
                }
            }
        }
       
        // setting the upper and lower triangles of a into ell and u to pass
        //   pack as arguments.
        //   the original pseudocode uses only a and modifies the original in place
        //     to conserve space.
<span class="fc" id="L583">        double[][] ell = new double[n][];</span>
<span class="fc" id="L584">        double[][] u = new double[n][];</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L586">            ell[i] = new double[n];</span>
<span class="fc" id="L587">            u[i] = new double[n];</span>
<span class="fc" id="L588">            u[i][i] = 1;</span>
<span class="fc" id="L589">            ell[i][i] = 1;</span>
        }
<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">                if (i &gt; j) {</span>
<span class="fc" id="L594">                    ell[i][j] = a[i][j];</span>
                } else {
<span class="fc" id="L596">                    u[i][j] = a[i][j];</span>
                }
            }
        }
        
<span class="fc" id="L601">        return new LUP(ell, u, pi);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @param solveForFullRank
     * when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
     * and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
     * (see Chap 4.3 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang and Chap 28 from the book &quot;Introductionvto 
     * Algorithms&quot; by Cormen, Leiserson, Rivest, and Stein.)
     * when solveForFullRank is set to 'False' this method uses the SVD to
     * create a pseudoinverse (see Chap 7 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang.)
     *  
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     * @throws no.uib.cipr.matrix.NotConvergedException
     */
    public static double[] leastSquaresPolynomial(double[][] xy, int polyOrder, boolean
        solveForFullRank) throws NotConvergedException {
<span class="fc" id="L632">        return _leastSquaresPolynomial(xy, polyOrder, solveForFullRank);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     */
    public static double[] leastSquaresPolynomial(double[][] xy, int polyOrder) throws NotConvergedException {
<span class="nc" id="L651">        return _leastSquaresPolynomial(xy, polyOrder, false);</span>
    }
    
    /**
     * given data points xy and the assumption that measurement errors are small,
     * fit a polynomial of order polyOrder to the data points, minimizing the
     * error, i.e. solve for coefficients c in y_i = summation(c_i*x^i) + error.
     * calculated by c = pseudo-inverse of A * y where A is the components of
     * x as polynomial factors.
     * NOTE that a regularized linear least squares algorithm called Elastic-Net
     * is implemented as thirdparty.scipy.optimization.ElastticNet.
     * This method follows pseudocode in chapter 28 of Cormen et al. Introduction
     * To Algorithms.
     * @param xy two dimensional array of format row0=[x0,y0], row1=[x1,y1], etc.
     * @param polyOrder the order of a polynomial to fit.  should be .lte. the
     * number of rows.
     * @param solveFullRank
     * when 'True' AX=b has no solution (e.g. xy.length is larger than xy[0].length)
     * and the algorithm uses (inverse(A^T*A) * A^T) for the pseudo-inverse
     * (see Chap 4.3 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang and Chap 28 from the book &quot;Introductionvto 
     * Algorithms&quot; by Cormen, Leiserson, Rivest, and Stein.)
     * when solveForFullRank is set to 'False' this method uses the SVD to
     * create a pseudoinverse (see Chap 7 from the book &quot;Introduction to Linear
     * Algebra&quot; by W Gilbert Strang.)
     * @return coefficients c where y_i = summation(c_i*x^i) + error
     */
    public static double[] _leastSquaresPolynomial(double[][] xy, int polyOrder,
        boolean solveFullRank) throws NotConvergedException {
        
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        if (polyOrder &lt; 0) {</span>
<span class="nc" id="L682">            throw new IllegalArgumentException(&quot;polyOrder must be 0 or larger&quot;);</span>
        }
<span class="fc" id="L684">        int nRows = xy.length;</span>
        
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (polyOrder &gt; nRows) {</span>
<span class="nc" id="L687">            throw new IllegalArgumentException(&quot;polyOrder should be smaller &quot;</span>
                    + &quot; than or equal to the number of data rows&quot;);
        }
        
        // create matrix A
<span class="fc" id="L692">        double[][] a = new double[nRows][];</span>
        double x;
<span class="fc bfc" id="L694" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L695">            a[i] = new double[polyOrder + 1];</span>
<span class="fc" id="L696">            a[i][0] = 1;</span>
        }
<span class="fc bfc" id="L698" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L699">            x = xy[i][0];</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">            for (int k = 0; k &lt; polyOrder; ++k) {</span>
<span class="fc" id="L701">                a[i][k + 1] = x * a[i][k];</span>
            }
        }
        
        double[][] aPInv;
<span class="fc bfc" id="L706" title="All 2 branches covered.">        if (solveFullRank) {</span>
            //AX=b has no solution
            //using A_pseudoinverse = inverse(A^T*A) * A^T
<span class="fc" id="L709">            aPInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
        } else {
            // uses SVD of a in pseudo-inverse
            // Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
            //inverse of A.
            // method is valid for  rows .lte. rank,
            // but for rows .gt. rank, the null-space needs to be solved instead.
<span class="fc" id="L716">            aPInv = MatrixUtil.pseudoinverseRankDeficient(a);</span>
        }
        
<span class="fc" id="L719">        double[] y = new double[nRows];</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L721">            y[i] = xy[i][1];</span>
        }
        
<span class="fc" id="L724">        double[] c = MatrixUtil.multiplyMatrixByColumnVector(aPInv, y);</span>
        
<span class="fc" id="L726">        return c;</span>
    }
    
    public static class LU {
        double[][] ell;
        double[][] u;
        public LU(double[][] ell, double[][] u) {
            this.ell = ell;
            this.u = u;
        }
    }
    
    public static class LUP {
        double[][] ell;
        double[][] u;
        int[] p;
        public LUP(double[][] ell, double[][] u, int[] p) {
            this.ell = ell;
            this.u = u;
            this.p = p;
        }
    }
    
    /**
     * lower triangular portion of A = L * D * M^T
     */
    public static class LDM {
        double[][] ell;
        double[] d;
        double[][] m;
        public LDM(double[][] ell, double[] d, double[][] m) {
            this.ell = ell;
            this.d = d;
            this.m = m;
        }
    }
    
    public static class LDL {
        private double[][] ell;
        private double[] d;
        public LDL(double[][] ell, double[] d) {
            this.ell = ell;
            this.d = d;
        }

        /**
         * @return the L
         */
        public double[][] getL() {
            return ell;
        }

        /**
         * @return the d
         */
        public double[] getD() {
            return d;
        }
    }
    
    private static void assertSquareMatrix(double[][] a, String name) {
<span class="fc" id="L787">        int n = a.length;</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">        if (a[0].length != n) {</span>
<span class="nc" id="L789">            throw new IllegalArgumentException(name + &quot; must be a square matrix&quot;);</span>
        }
<span class="fc" id="L791">    }</span>
    
    private static void assertPositiveDefinite(double[][] a, String name) {
<span class="nc" id="L794">        int n = a.length;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (!MatrixUtil.isPositiveDefinite(a)) {</span>
<span class="nc" id="L796">            throw new IllegalArgumentException(name + &quot; must be a positive definite matrix&quot;);</span>
        }
<span class="nc" id="L798">    }</span>

    private static void assertArrayLength(int n, double[] a, String name) {
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (a.length != n) {</span>
<span class="nc" id="L802">            throw new IllegalArgumentException(name + &quot; must be length &quot; + n);</span>
        }
<span class="fc" id="L804">    }</span>

    private static void assertArrayLength(int n, int[] a, String name) {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        if (a.length != n) {</span>
<span class="nc" id="L808">            throw new IllegalArgumentException(name + &quot; must be length &quot; + n);</span>
        }
<span class="fc" id="L810">    }</span>

} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>