<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatrixUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.matrix</a> &gt; <span class="el_source">MatrixUtil.java</span></div><h1>MatrixUtil.java</h1><pre class="source lang-java linenums">package algorithms.matrix;

import algorithms.matrix.LinearEquations.LU;
import algorithms.matrix.LinearEquations.LUP;
import algorithms.misc.Misc0;
import algorithms.misc.MiscMath0;
import algorithms.util.FormatArray;
import algorithms.util.PairInt;
import gnu.trove.list.array.TDoubleArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Random;

import no.uib.cipr.matrix.*;
import gnu.trove.iterator.TIntIntIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.iterator.TObjectDoubleIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.TObjectDoubleMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TObjectDoubleHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;

/**
 
 &lt;pre&gt;
   misc notes:
 
   The eigenvalues can be determined in a few ways depending upon the matrix:
       If A is a positive definite matrix, can use the power method to find 
       the largest eigenvalue.  
          Caveat is that it performs best when the spectral gap is large 
          (diff between largest and 2nd largest eigenvalues).
       If A is symmetric, can diagonalize A.
       If A is not symmetric, can either diagonalize A^T*A and use the square root 
          of those eigenvalues or can use Singular Value Decomposition on A 
          (the singular values are the eigenvalues of A).
   Note that the eigenvectors are the same for the diagonalization of A, the 
   diagonalization of A^T*A, the SVD(A), and the same operations performed 
   on the CUR-Decompositions of A (=C) or on C^T*C.
   NOTE: for large-scale eigenvalue problems,consider cur decomposition, power
   * method, qr decomposition (which for general matrices might include the 
   * schur decomposition followed by back substitution), or
   * for hermetician matrices can use divide and conquer eigenvalue algorithms and they
   * are parallelizable.
 &lt;/pre&gt;
 * 
 * TODO: implement Orthogonal Iteration from Morita and Kanade Sect 3.2.2
   &quot;A straightforward generalization of the power method can be used to compute 
   several dominant eigenvectors of a symmetric matrix.&quot;
   A useful alternative to the singular value decomposition in situations 
   where B is a large matrix and only a few of its largest eigenvalues are needed.
   * for p eigenvalues out of n, if lambda__(p_1)/lambda_p is very small,
   * the computation of the eigenvectors should proceed quickly.

 see https://netlib.org/lapack/explore-html/index.html for details of
 MTJ toolkit methods and LAPACK.getInstance() methods that might not be in MTJ

 Note that any rectangular matrix can be made into a square matrix by adding zero rows or columns,
 without changing the nonzero singular values.
 Bjorck 1991, &quot;Algorithms for Linear Least Squares Problems&quot;

 * @author nichole
 */
<span class="pc" id="L71">public class MatrixUtil {</span>
    
    /**
     * multiply the row vector v by matrix m.
     * @param v
     * @param m
     * @return result is size [1][m[0].length]
     */
    public static double[] multiplyRowVectorByMatrix(double[] v, double[][] m) {
        
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (m.length != v.length) {</span>
<span class="nc" id="L82">            throw new IllegalArgumentException(&quot;length of v and length of m must be the same&quot;);</span>
        }
        
<span class="fc" id="L85">        int mRows = m.length;</span>
<span class="fc" id="L86">        int mCols = m[0].length;</span>
        
<span class="fc" id="L88">        double[] out = new double[mCols];</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (int i = 0; i &lt; mCols; ++i) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            for (int j = 0; j &lt; mRows; ++j) {</span>
<span class="fc" id="L91">                out[i] += (v[j] * m[j][i]);</span>
            }
        }
<span class="fc" id="L94">        return out;</span>
    }
    
    /**
     * multiply matrix m by vector n
     * @param m two dimensional array in row major format
     * @param n one dimensional array
     * @return vector of length m.length
     */
    public static double[] multiplyMatrixByColumnVector(double[][] m, double[] n) {

<span class="pc bpc" id="L105" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L108" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L109">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L112">        int mcols = m[0].length;</span>

<span class="fc" id="L114">        int mrows = m.length;</span>

<span class="fc" id="L116">        int ncols = n.length;</span>
        
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (mcols != ncols) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the length of n&quot;);
        }
        
<span class="fc" id="L123">        double[] c = new double[mrows];</span>

<span class="fc" id="L125">        multiplyMatrixByColumnVector(m, n, c);</span>

<span class="fc" id="L127">        return c;</span>
    }
    
    /**
     * multiply matrix m by vector n
     * @param m two dimensional array in row major format
     * @param n one dimensional array
     * @return vector of length m.length
     */
    public static double[] multiplyMatrixByColumnVector(double[][] m, int[] n) {

<span class="nc bnc" id="L138" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L141" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L145">        int mcols = m[0].length;</span>

<span class="nc" id="L147">        int mrows = m.length;</span>

<span class="nc" id="L149">        int ncols = n.length;</span>
        
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (mcols != ncols) {</span>
<span class="nc" id="L152">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the length of n&quot;);
        }
        
<span class="nc" id="L156">        double[] c = new double[mrows];</span>

<span class="nc" id="L158">        multiplyMatrixByColumnVector(m, n, c);</span>

<span class="nc" id="L160">        return c;</span>
    }
    
    /**
     * multiply matrix m by vector n and return results in given vector out
     * @param m two dimensional array in row major format
     * @param n one dimensional array
     * @param out vector of length m.length to return results in
     */
    public static void multiplyMatrixByColumnVector(double[][] m, double[] n,
        double[] out) {

<span class="pc bpc" id="L172" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L175" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        // identity check
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (n.toString().equals(out.toString())) {</span>
<span class="nc" id="L180">            throw new IllegalArgumentException(&quot;n cannot be the same as out&quot;);</span>
        }
        
<span class="fc" id="L183">        int mcols = m[0].length;</span>

<span class="fc" id="L185">        int mrows = m.length;</span>

<span class="fc" id="L187">        int ncols = n.length;</span>
        
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (mcols != ncols) {</span>
<span class="nc" id="L190">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the length of n&quot;);
        }
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (mrows != out.length) {</span>
<span class="nc" id="L194">            throw new IllegalArgumentException(</span>
                &quot;out.length must equal m.length&quot;);
        }
        
<span class="fc" id="L198">        Arrays.fill(out, 0);</span>
        
<span class="fc" id="L200">        int cCol = 0;</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (int row = 0; row &lt; mrows; row++) {                        </span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            for (int col = 0; col &lt; mcols; col++) {</span>
<span class="fc" id="L204">                out[cCol] += (m[row][col] * n[col]);</span>
            }
<span class="fc" id="L206">            cCol++;        </span>
        }
<span class="fc" id="L208">    }</span>
    
    /**
     * multiply matrix m by vector n and return results in given vector out
     * @param m two dimensional array in row major format
     * @param n one dimensional array
     * @param out vector of length m.length to return results in
     */
    public static void multiplyMatrixByColumnVector(double[][] m, int[] n,
        double[] out) {

<span class="nc bnc" id="L219" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L220">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L222" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L223">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        // identity check
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (m.toString().equals(out.toString())) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(&quot;m cannot be the same as out&quot;);</span>
        }
        
<span class="nc" id="L230">        int mcols = m[0].length;</span>

<span class="nc" id="L232">        int mrows = m.length;</span>

<span class="nc" id="L234">        int ncols = n.length;</span>
        
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (mcols != ncols) {</span>
<span class="nc" id="L237">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the length of n&quot;);
        }
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (mrows != out.length) {</span>
<span class="nc" id="L241">            throw new IllegalArgumentException(</span>
                &quot;out.length must equal m.length&quot;);
        }
        
<span class="nc" id="L245">        Arrays.fill(out, 0);</span>
        
<span class="nc" id="L247">        int cCol = 0;</span>
        
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (int row = 0; row &lt; mrows; row++) {                        </span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (int col = 0; col &lt; mcols; col++) {</span>
<span class="nc" id="L251">                out[cCol] += (m[row][col] * n[col]);</span>
            }
<span class="nc" id="L253">            cCol++;        </span>
        }
<span class="nc" id="L255">    }</span>
    
    /**
     * multiply matrix m by vector n
     * @param m two dimensional array in row major format
     * @param n one dimensional array
     * @return 
     */
    public static float[] multiplyMatrixByColumnVector(float[][] m, float[] n) {

<span class="nc bnc" id="L265" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L266">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L268" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L269">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L272">        int mcols = m[0].length;</span>

<span class="nc" id="L274">        int mrows = m.length;</span>

<span class="nc" id="L276">        int ncols = n.length;</span>
        
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (mcols != ncols) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the number of rows in n&quot;);
        }
        
<span class="nc" id="L283">        float[] c = new float[mrows];</span>

<span class="nc" id="L285">        int cCol = 0;</span>
        
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int row = 0; row &lt; mrows; row++) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            for (int col = 0; col &lt; mcols; col++) {</span>
<span class="nc" id="L289">                c[cCol] += (m[row][col] * n[col]);</span>
            }            
<span class="nc" id="L291">            cCol++;        </span>
        }

<span class="nc" id="L294">        return c;</span>
    }
    
    public static double[] multiplyMatrixByColumnVector(Matrix a, double[] b) {
        
<span class="pc bpc" id="L299" title="2 of 4 branches missed.">        if (a == null || a.numRows() == 0) {</span>
<span class="nc" id="L300">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">        if (b == null || b.length == 0) {</span>
<span class="nc" id="L303">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L306">        int mrows = a.numRows();</span>

<span class="fc" id="L308">        int mcols = a.numColumns();</span>

<span class="fc" id="L310">        int nrows = b.length;</span>
        
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L313">            throw new IllegalArgumentException(</span>
                &quot;the number of cols in a must equal the length of b&quot;);
        }
        
<span class="fc" id="L317">        double[] c = new double[mrows];</span>

<span class="fc" id="L319">        int cCol = 0;</span>
        
        /*
        a0 1 2     0
                   1
                   2
        */
        
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int row = 0; row &lt; mrows; row++) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            for (int col = 0; col &lt; mcols; col++) {</span>
<span class="fc" id="L329">                c[cCol] += (a.get(row, col) * b[col]);</span>
            }
<span class="fc" id="L331">            cCol++;        </span>
        }

<span class="fc" id="L334">        return c;</span>
    }
    
    /**
     * multiply vector m by factor
     * @param m one dimensional array that is input and output for result
     * @param factor factor to multiply m by
     */
    public static void multiply(int[] m, int factor) {

<span class="nc bnc" id="L344" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L348">        int len = m.length;</span>
                
<span class="nc bnc" id="L350" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {                        </span>
<span class="nc" id="L351">            m[i] *= factor;</span>
        }
<span class="nc" id="L353">    }</span>
    
    /**
     * multiply matrix m by factor
     * @param a two dimensional array in that is input and output for result
     * @param m factor to multiply m by
     */
    public static void multiply(float[][] a, float m) {

<span class="nc bnc" id="L362" title="All 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L363">            throw new IllegalArgumentException(&quot;a cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L366">        int mcols = a.length;</span>

<span class="nc" id="L368">        int mrows = a[0].length;</span>
        
<span class="nc bnc" id="L370" title="All 2 branches missed.">        for (int col = 0; col &lt; mcols; col++) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            for (int row = 0; row &lt; mrows; row++) {</span>
<span class="nc" id="L372">                a[col][row] *= m;</span>
            }            
        }
<span class="nc" id="L375">    }</span>
    
    public static void multiply(int[] m, int[] n) {

<span class="nc bnc" id="L379" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L380">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="nc bnc" id="L383" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L384">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;m must be the same size as n&quot;);</span>
        }
        
<span class="nc" id="L391">        int len = m.length;</span>
                
<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {                        </span>
<span class="nc" id="L394">            m[i] *= n[i];</span>
        }
<span class="nc" id="L396">    }</span>
    
    /*
    public static double[][] fastMultiply(double[][] m, double[][] n) {
        
        consider using Native BLAS from the included Netlib package
        BLAS.getInstance().dgemm.
        
        Can see example in this repository's related project called
        https://github.com/nking/curvature-scale-space-corners-and-transformations.git
        in the test class tests//algorithms/NetlibTest.java
        
        or in MTJ source code
        https://github.com/fommil/matrix-toolkits-java/blob/master/src/main/java/no/uib/cipr/matrix/DenseMatrix.java#L299
        
    }*/
    
    /**
     * multiply matrix m by matrix n
     * @param m two dimensional array in row major format
     * @param n two dimensional array in row major format
     * @return multiplication of m by n.  resulting matrix is size mrows X ncols.
     */
    public static double[][] multiply(double[][] m, double[][] n) {

<span class="pc bpc" id="L421" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L424" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L428">        int mrows = m.length;</span>

<span class="fc" id="L430">        int mcols = m[0].length;</span>

<span class="fc" id="L432">        int nrows = n.length;</span>
        
<span class="fc" id="L434">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L437">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
        /*
        a b c      p0 p1 p2
        d e f      p3 p4 p5
                   p6 p7 p8        
        a*p0 + b*p3 + c*p6    a*p1 + b*p4 + c*p7    a*p2 + b*p5 + c*p8
        d*p0 + d*p3 + e*p6    d*p1 + d*p4 + e*p7    d*p2 + e*p5 + f*p8
        */
        
        // mrows X ncols
<span class="fc" id="L451">        double[][] c = MatrixUtil.zeros(mrows, ncols);</span>
        
<span class="fc" id="L453">        multiply(m, n, c);</span>

<span class="fc" id="L455">        return c;</span>
    }
    
    /**
     * multiply matrix m by matrix n
     * @param m two dimensional array in row major format
     * @param n two dimensional array in row major format
     * @return multiplication of m by n.  resulting matrix is size mrows X ncols.
     */
    public static double[][] multiply(double[][] m, int[][] n) {

<span class="pc bpc" id="L466" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L467">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L470">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L473">        int mrows = m.length;</span>

<span class="fc" id="L475">        int mcols = m[0].length;</span>

<span class="fc" id="L477">        int nrows = n.length;</span>
        
<span class="fc" id="L479">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L482">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
        // mrows X ncols
<span class="fc" id="L488">        double[][] c = MatrixUtil.zeros(mrows, ncols);</span>
        
<span class="fc" id="L490">        multiply(m, n, c);</span>

<span class="fc" id="L492">        return c;</span>
    }
    
     /**
     * multiply matrix m by matrix n
     * @param m two dimensional array in row major format
     * @param n two dimensional array in row major format
     * @return multiplication of m by n.  resulting matrix is size mrows X ncols.
     */
    public static double[][] multiply(int[][] m, double[][] n) {

<span class="pc bpc" id="L503" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L504">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L506" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L507">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L510">        int mrows = m.length;</span>

<span class="fc" id="L512">        int mcols = m[0].length;</span>

<span class="fc" id="L514">        int nrows = n.length;</span>
        
<span class="fc" id="L516">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L519">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
        // mrows X ncols
<span class="fc" id="L525">        double[][] c = MatrixUtil.zeros(mrows, ncols);</span>
        
<span class="fc" id="L527">        multiply(m, n, c);</span>

<span class="fc" id="L529">        return c;</span>
    }
    
    /**
     * multiply matrix m by matrix n
     * @param m tow dimensional array in row major format
     * @param n two dimensional array in row major format
     * @param out the results of multiplication of m by n.  the matrix should be size mrows X ncols.
     */
    public static void multiply(double[][] m, double[][] n, double[][] out) {

<span class="pc bpc" id="L540" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L541">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L543" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L544">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        // identity check:
<span class="pc bpc" id="L547" title="2 of 4 branches missed.">        if (out.toString().equals(m.toString()) || out.toString().equals(n.toString())) {</span>
<span class="nc" id="L548">            throw new IllegalArgumentException(&quot;out must be a different object than n and m&quot;);</span>
        }
        
<span class="fc" id="L551">        int mrows = m.length;</span>

<span class="fc" id="L553">        int mcols = m[0].length;</span>

<span class="fc" id="L555">        int nrows = n.length;</span>
        
<span class="fc" id="L557">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L560">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">        if (out.length != mrows || out[0].length != ncols) {</span>
<span class="nc" id="L566">            throw new IllegalArgumentException(&quot;out must be [m.length X n[0].length]&quot;);</span>
        }
        
        /*
        a b c      p0 p1 p2
        d e f      p3 p4 p5
                   p6 p7 p8        
        a*p0 + b*p3 + c*p6    a*p1 + b*p4 + c*p7    a*p2 + b*p5 + c*p8
        d*p0 + d*p3 + e*p6    d*p1 + d*p4 + e*p7    d*p2 + e*p5 + f*p8
        */
        
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (int mrow = 0; mrow &lt; mrows; mrow++) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (int ncol = 0; ncol &lt; ncols; ncol++) {</span>
<span class="fc" id="L579">                double sum = 0;                </span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">                for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L581">                    sum += (m[mrow][mcol] * n[mcol][ncol]);                    </span>
                }
<span class="fc" id="L583">                out[mrow][ncol] = sum;</span>
            }            
        }
<span class="fc" id="L586">    }</span>
    
    /**
     * multiply matrix m by matrix n
     * @param m tow dimensional array in row major format
     * @param n two dimensional array in row major format
     * @param out the results of multiplication of m by n.  the matrix should be size mrows X ncols.
     */
    public static void multiply(double[][] m, int[][] n, double[][] out) {

<span class="pc bpc" id="L596" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L597">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L599" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L600">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        // identity check:
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        if (out.toString().equals(m.toString())) {</span>
<span class="nc" id="L604">            throw new IllegalArgumentException(&quot;out must be a different object than n and m&quot;);</span>
        }
        
<span class="fc" id="L607">        int mrows = m.length;</span>

<span class="fc" id="L609">        int mcols = m[0].length;</span>

<span class="fc" id="L611">        int nrows = n.length;</span>
        
<span class="fc" id="L613">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L616">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
<span class="pc bpc" id="L621" title="2 of 4 branches missed.">        if (out.length != mrows || out[0].length != ncols) {</span>
<span class="nc" id="L622">            throw new IllegalArgumentException(&quot;out must be [m.length X n[0].length]&quot;);</span>
        }
        
        /*
        a b c      p0 p1 p2
        d e f      p3 p4 p5
                   p6 p7 p8        
        a*p0 + b*p3 + c*p6    a*p1 + b*p4 + c*p7    a*p2 + b*p5 + c*p8
        d*p0 + d*p3 + e*p6    d*p1 + d*p4 + e*p7    d*p2 + e*p5 + f*p8
        */
        
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int mrow = 0; mrow &lt; mrows; mrow++) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            for (int ncol = 0; ncol &lt; ncols; ncol++) {</span>
<span class="fc" id="L635">                double sum = 0;                </span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L637">                    sum += (m[mrow][mcol] * n[mcol][ncol]);                    </span>
                }
<span class="fc" id="L639">                out[mrow][ncol] = sum;</span>
            }            
        }
<span class="fc" id="L642">    }</span>
    
    /**
     * multiply matrix m by matrix n
     * @param m tow dimensional array in row major format
     * @param n two dimensional array in row major format
     * @param out the results of multiplication of m by n.  the matrix should be size mrows X ncols.
     */
    public static void multiply(int[][] m, double[][] n, double[][] out) {

<span class="pc bpc" id="L652" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L653">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L655" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L656">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        // identity check:
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (out.toString().equals(n.toString())) {</span>
<span class="nc" id="L660">            throw new IllegalArgumentException(&quot;out must be a different object than n and m&quot;);</span>
        }
        
<span class="fc" id="L663">        int mrows = m.length;</span>

<span class="fc" id="L665">        int mcols = m[0].length;</span>

<span class="fc" id="L667">        int nrows = n.length;</span>
        
<span class="fc" id="L669">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L672">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
<span class="pc bpc" id="L677" title="2 of 4 branches missed.">        if (out.length != mrows || out[0].length != ncols) {</span>
<span class="nc" id="L678">            throw new IllegalArgumentException(&quot;out must be [m.length X n[0].length]&quot;);</span>
        }
        
        /*
        a b c      p0 p1 p2
        d e f      p3 p4 p5
                   p6 p7 p8        
        a*p0 + b*p3 + c*p6    a*p1 + b*p4 + c*p7    a*p2 + b*p5 + c*p8
        d*p0 + d*p3 + e*p6    d*p1 + d*p4 + e*p7    d*p2 + e*p5 + f*p8
        */
        
<span class="fc bfc" id="L689" title="All 2 branches covered.">        for (int mrow = 0; mrow &lt; mrows; mrow++) {</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">            for (int ncol = 0; ncol &lt; ncols; ncol++) {</span>
<span class="fc" id="L691">                double sum = 0;                </span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">                for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L693">                    sum += (m[mrow][mcol] * n[mcol][ncol]);                    </span>
                }
<span class="fc" id="L695">                out[mrow][ncol] = sum;</span>
            }            
        }
<span class="fc" id="L698">    }</span>
    
    /**
     * multiply matrix m by matrix n
     * @param m tow dimensional array in row major format
     * @param n two dimensional array in row major format
     * @return out the results of multiplication of m by n.  the matrix should be size mrows X ncols.
     */
    public static int[][] multiply(int[][] m, int[][] n) {

<span class="pc bpc" id="L708" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L709">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L711" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L712">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L715">        int mrows = m.length;</span>

<span class="fc" id="L717">        int mcols = m[0].length;</span>

<span class="fc" id="L719">        int nrows = n.length;</span>
        
<span class="fc" id="L721">        int ncols = n[0].length;</span>
        
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L724">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m (=&quot; + mcols + &quot;) &quot;
                + &quot; must equal the number of rows in n (=&quot; + nrows + &quot;)&quot;);
        }
        
<span class="fc" id="L729">        int[][] out = new int[mrows][];</span>
        int mrow, ncol;
<span class="fc bfc" id="L731" title="All 2 branches covered.">        for (mrow = 0; mrow &lt; mrows; mrow++) {</span>
<span class="fc" id="L732">            out[mrow] = new int[ncols];</span>
        }
        
<span class="fc bfc" id="L735" title="All 2 branches covered.">        for (mrow = 0; mrow &lt; mrows; mrow++) {</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">            for (ncol = 0; ncol &lt; ncols; ncol++) {</span>
<span class="fc" id="L737">                int sum = 0;                </span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L739">                    sum += (m[mrow][mcol] * n[mcol][ncol]);                    </span>
                }
<span class="fc" id="L741">                out[mrow][ncol] = sum;</span>
            }            
        }
<span class="fc" id="L744">        return out;</span>
    }
    
    public static boolean isOrthogonal(int[][] a) {
        
<span class="fc" id="L749">        int[][] aT = MatrixUtil.transpose(a);</span>
        
        int[][] prod;
        int i, n;
<span class="fc bfc" id="L753" title="All 2 branches covered.">        for (int k = 0; k &lt; 2; ++k) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (k == 0) {</span>
<span class="fc" id="L755">                prod = MatrixUtil.multiply(a, aT);</span>
            } else {
<span class="fc" id="L757">                prod = MatrixUtil.multiply(aT, a);</span>
            }
<span class="fc" id="L759">            n = prod.length;</span>
<span class="pc bnc" id="L760" title="All 2 branches missed.">            assert(n == prod[0].length);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">                if (prod[i][i] != 1) {</span>
<span class="nc" id="L763">                    return false;</span>
                }
            }
        }
        
<span class="fc" id="L768">        return true;</span>
    }
    
    public static boolean isAPermutationMatrix(int[][] a) {
        
        int i, j;
<span class="fc" id="L774">        int sum = 0;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L776">            sum = 0;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            for (j = 0; j &lt; a[i].length; ++j) {</span>
<span class="fc" id="L778">                sum += a[i][j];</span>
            }
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (sum != 1) {</span>
<span class="nc" id="L781">                return false;</span>
            }
        }
<span class="fc bfc" id="L784" title="All 2 branches covered.">        for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc" id="L785">            sum = 0;</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">            for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L787">                sum += a[i][j];</span>
            }
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">            if (sum != 1) {</span>
<span class="nc" id="L790">                return false;</span>
            }
        }

<span class="fc" id="L794">        return true;</span>
    }
   
    public static double[][] createATransposedTimesA(double[][] a) {

<span class="pc bpc" id="L799" title="2 of 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L800">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L803">        int m = a.length;</span>
<span class="fc" id="L804">        int n = a[0].length;</span>
        
        /*
        a00  a01     a00  a01 
        a10  a11     a10  a11 
        a20  a21     a20  a21 
        
                         i:[0,n)
        a00  a10  a20    a00  a01
        a01  a11  a21    a10  a11
                         a20  a21 
        
        a00*a00 + a10*a10 + a20*a20   a00*a01 + a10*a11 + a20*a21   
        a01*a00 + a11*a10 + a21*a20   a01*a01 + a11*a11 + a21*a21 
        
        col0_ dot col0
        col1_ dot col0
        */
        
        int outCol, i, j;
<span class="fc" id="L824">        double[][] c = new double[n][n];</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L826">            c[i] = new double[n];</span>
        }
        double sum;
<span class="fc bfc" id="L829" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">            for (outCol = 0; outCol &lt; n; outCol++) {</span>
<span class="fc" id="L831">                sum = 0;</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                for (j = 0; j &lt; m; j++) {</span>
<span class="fc" id="L833">                    sum += (a[j][outCol] * a[j][i]);</span>
                }
<span class="fc" id="L835">                c[outCol][i] = sum;</span>
            }
        }

<span class="fc" id="L839">        return c;</span>
    }
    
    public static void multiply(double[] a, double f) {
<span class="fc bfc" id="L843" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L844">            a[i] *= f;</span>
        }
<span class="fc" id="L846">    }</span>
    
    public static void multiply(double[][] m, double factor) {

<span class="fc" id="L850">        int nrows = m.length;</span>
<span class="fc" id="L851">        int ncols = m[0].length;</span>

<span class="fc bfc" id="L853" title="All 2 branches covered.">        for (int i = 0; i &lt; nrows; i++) {</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            for (int j = 0; j &lt; ncols; j++) {</span>
<span class="fc" id="L855">                m[i][j] = factor*m[i][j];</span>
            }
        }
<span class="fc" id="L858">    }</span>
    
    /**
     * multiply matrices and return matrix of size mrows X ncols
     * @param m
     * @param n
     * @return 
     */
    public static DenseMatrix multiply(Matrix m, Matrix n) {

<span class="pc bpc" id="L868" title="3 of 6 branches missed.">        if (m == null || m.numRows() == 0 || m.numColumns() == 0) {</span>
<span class="nc" id="L869">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L871" title="3 of 6 branches missed.">        if (n == null || n.numRows() == 0 || n.numColumns() == 0) {</span>
<span class="nc" id="L872">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L875">        int mrows = m.numRows();</span>

<span class="fc" id="L877">        int mcols = m.numColumns();</span>

<span class="fc" id="L879">        int nrows = n.numRows();</span>
        
<span class="fc" id="L881">        int ncols = n.numColumns();</span>
        
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L884">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the number of rows in n&quot;);
        }
    
        /*
        a b c      p0 p1 p2
        d e f      p3 p4 p5
                   p6 p7 p8        
        a*p0+... a*p a*p
        d*p0+... d*p d*p
        */
        
<span class="fc" id="L896">        no.uib.cipr.matrix.DenseMatrix c = new DenseMatrix(mrows, ncols);        </span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">        for (int row = 0; row &lt; mrows; row++) {</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            for (int ncol = 0; ncol &lt; ncols; ncol++) {</span>
<span class="fc" id="L899">                double sum = 0;                </span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">                for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L901">                    sum += (m.get(row, mcol) * n.get(mcol, ncol));                    </span>
                }
<span class="fc" id="L903">                c.set(row, ncol, sum);</span>
            }            
        }

<span class="fc" id="L907">        return c;</span>
    }
    
    public static void multiply(TDoubleArrayList a, double f) {
<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (int i = 0; i &lt; a.size(); ++i) {</span>
<span class="nc" id="L912">            a.set(i, f * a.get(i));</span>
        }
<span class="nc" id="L914">    }</span>
    
    public static void multiply(Matrix a, double b) {
        
<span class="nc bnc" id="L918" title="All 4 branches missed.">        if (a == null || a.numRows() == 0) {</span>
<span class="nc" id="L919">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L922">        Iterator&lt;MatrixEntry&gt; iter = a.iterator();</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L924">            MatrixEntry entry = iter.next();</span>
<span class="nc" id="L925">            entry.set(entry.get() * b);</span>
<span class="nc" id="L926">        }</span>
        
<span class="nc" id="L928">    }</span>
    
    /**
     * perform dot product of m and a diagonalized matrix of diag,
     * and return matrix of size mrows X mcols
     * @param m
     * @param diag
     * @return 
     */
    public static double[][] multiplyByDiagonal(
        double[][] m, double[] diag) {

<span class="pc bpc" id="L940" title="3 of 6 branches missed.">        if (m == null || m.length == 0 || m[0].length == 0) {</span>
<span class="nc" id="L941">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L943" title="2 of 4 branches missed.">        if (diag == null || diag.length == 0) {</span>
<span class="nc" id="L944">            throw new IllegalArgumentException(&quot;diag cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L947">        int mrows = m.length;</span>

<span class="fc" id="L949">        int mcols = m[0].length;</span>

<span class="fc" id="L951">        int nrows = diag.length;</span>
                
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L954">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the number of rows in n&quot;);
        }
        
        /*
        a b c      p0 0  0
        d e f      0  p1 0
                   0  0  p2        
        */
        
<span class="fc" id="L964">        double[][] c = new double[mrows][mcols];</span>
        
<span class="fc bfc" id="L966" title="All 2 branches covered.">        for (int row = 0; row &lt; mrows; row++) {</span>
<span class="fc" id="L967">            c[row] = new double[mcols];</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">            for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="fc" id="L969">                c[row][mcol] = m[row][mcol] * diag[mcol];</span>
            }            
        }

<span class="fc" id="L973">        return c;</span>
    }
    
    /**
     * perform dot product of m and a diagonalized matrix of diag,
     * and return matrix of size mrows X mcols
     * @param m
     * @param diag
     */
    public static void multiplyByDiagonal(DenseMatrix m, double[] diag) {

<span class="nc bnc" id="L984" title="All 6 branches missed.">        if (m == null || m.numRows() == 0 || m.numColumns() == 0) {</span>
<span class="nc" id="L985">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L987" title="All 4 branches missed.">        if (diag == null || diag.length == 0) {</span>
<span class="nc" id="L988">            throw new IllegalArgumentException(&quot;diag cannot be null or empty&quot;);</span>
        }
        
<span class="nc" id="L991">        int mrows = m.numRows();</span>

<span class="nc" id="L993">        int mcols = m.numColumns();</span>

<span class="nc" id="L995">        int nrows = diag.length;</span>
                
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (mcols != nrows) {</span>
<span class="nc" id="L998">            throw new IllegalArgumentException(</span>
                &quot;the number of columns in m must equal the number of rows in n&quot;);
        }
        
        /*
        a b c      p0 0  0
        d e f      0  p1 0
                   0  0  p2        
        */
                
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        for (int row = 0; row &lt; mrows; row++) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            for (int mcol = 0; mcol &lt; mcols; mcol++) {</span>
<span class="nc" id="L1010">                m.set(row, mcol,  m.get(row, mcol) * diag[mcol]);</span>
            }            
        }
<span class="nc" id="L1013">    }</span>
    
    /**
     * calculates the inner product of a and b, which is a as a single row matrix
     * and b as a single column matrix, so is a^T * b.  it's also known as the
     * scalar product or dot product.
     * @param a
     * @param b
     * @return scale result of a^T * b
     */
    public static double innerProduct(TDoubleArrayList a, 
        TDoubleArrayList b) {
<span class="nc" id="L1025">        int sz0 = a.size();</span>
<span class="nc" id="L1026">        int sz1 = b.size();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (sz0 != sz1) {</span>
<span class="nc" id="L1028">            throw new IllegalArgumentException(</span>
                &quot;a and b must be same size&quot;);
        }
<span class="nc" id="L1031">        double s = 0;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        for (int i = 0; i &lt; a.size(); ++i) {</span>
<span class="nc" id="L1033">            s += a.get(i) * b.get(i);</span>
        }
<span class="nc" id="L1035">        return s;</span>
    }
    
    /**
     * calculates the inner product of a and b, which is a as a single row matrix
     * and b as a single column matrix, so is a^T * b.
     * @param a
     * @param b
     * @return scalar result of a^T * b
     */
    public static double innerProduct(double[] a, 
        double[] b) {
<span class="fc" id="L1047">        int sz0 = a.length;</span>
<span class="fc" id="L1048">        int sz1 = b.length;</span>
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">        if (sz0 != sz1) {</span>
<span class="nc" id="L1050">            throw new IllegalArgumentException(</span>
                &quot;a and b must be same size&quot;);
        }
<span class="fc" id="L1053">        double s = 0;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1055">            s += a[i] * b[i];</span>
        }
<span class="fc" id="L1057">        return s;</span>
    }
    
    public static double innerProduct(int[] a, double[] b) {

<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1063">            throw new IllegalArgumentException(&quot;a.length must == b.length&quot;);</span>
        }
        
<span class="fc" id="L1066">        double sum = 0;</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1068">            sum += (a[i] * b[i]);</span>
        }

<span class="fc" id="L1071">        return sum;</span>
    }
     
    public static TDoubleArrayList subtract(TDoubleArrayList a, TDoubleArrayList b) {
<span class="nc" id="L1075">        int sz0 = a.size();</span>
<span class="nc" id="L1076">        int sz1 = b.size();</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (sz0 != sz1) {</span>
<span class="nc" id="L1078">            throw new IllegalArgumentException(</span>
                &quot;a and b must be same size&quot;);
        }
<span class="nc" id="L1081">        TDoubleArrayList c = new TDoubleArrayList(sz0);</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        for (int i = 0; i &lt; a.size(); ++i) {</span>
<span class="nc" id="L1083">            c.add(a.get(i) - b.get(i));</span>
        }
<span class="nc" id="L1085">        return c;</span>
    }
    
    public static double[] subtract(double[] m, double[] n) {

<span class="fc" id="L1090">        int len = m.length;</span>

<span class="fc" id="L1092">        double[] c = new double[len];</span>

<span class="fc" id="L1094">        subtract(m, n, c);</span>

<span class="fc" id="L1096">        return c;</span>
    }
    
    /**
     * calculate m[i] - s for each i=[0, m.length).
     * @param m
     * @param s
     * @return 
     */
    public static double[] subtract(double[] m, double s) {

<span class="fc" id="L1107">        int len = m.length;</span>

<span class="fc" id="L1109">        double[] c = new double[len];</span>

<span class="fc bfc" id="L1111" title="All 2 branches covered.">        for (int i = 0; i &lt; len; ++i) {</span>
<span class="fc" id="L1112">            c[i] = m[i] - s;</span>
        }

<span class="fc" id="L1115">        return c;</span>
    }
    /**
     * calculate s - m[i] for each i=[0, m.length).
     * @param m
     * @param s
     * @return 
     */
    public static double[] subtract(double s, double[] m) {

<span class="nc" id="L1125">        int len = m.length;</span>

<span class="nc" id="L1127">        double[] c = new double[len];</span>

<span class="nc bnc" id="L1129" title="All 2 branches missed.">        for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1130">            c[i] = s - m[i];</span>
        }

<span class="nc" id="L1133">        return c;</span>
    }
    
    /**
     * calculate s + m[i] for each i=[0, m.length).
     * @param m
     * @param s
     * @return 
     */
    public static double[] add(double s, double[] m) {

<span class="nc" id="L1144">        int len = m.length;</span>

<span class="nc" id="L1146">        double[] c = new double[len];</span>

<span class="nc bnc" id="L1148" title="All 2 branches missed.">        for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1149">            c[i] = s + m[i];</span>
        }

<span class="nc" id="L1152">        return c;</span>
    }
    
    public static void subtract(double[] m, double[] n,
        double[] output) {

<span class="pc bpc" id="L1158" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1159">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1161" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1162">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1165">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }

<span class="fc" id="L1168">        int len = m.length;</span>

<span class="fc bfc" id="L1170" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1171">            output[i] = m[i] - n[i];</span>
        }
<span class="fc" id="L1173">    }</span>
    
        public static double[] add(double[] m, double[] n) {

<span class="pc bpc" id="L1177" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1178">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1180" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1181">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1184">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="fc" id="L1187">        int len = m.length;</span>
     
<span class="fc" id="L1189">        double[] c = new double[len];</span>
        
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1192">            c[i] = m[i] + n[i];</span>
        }

<span class="fc" id="L1195">        return c;</span>
    }
    
    public static float[] add(float[] m, float[] n) {

<span class="pc bpc" id="L1200" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1201">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1203" title="2 of 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1204">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1207">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="fc" id="L1210">        int len = m.length;</span>
     
<span class="fc" id="L1212">        float[] c = new float[len];</span>
        
<span class="fc bfc" id="L1214" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1215">            c[i] = m[i] + n[i];</span>
        }

<span class="fc" id="L1218">        return c;</span>
    }
    
    public static float[][] subtract(float[][] m, float[][] n) {

<span class="nc bnc" id="L1223" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1224">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1226" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1227">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1230">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (m[0].length != n[0].length) {</span>
<span class="nc" id="L1233">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="nc" id="L1236">        float[][] c = new float[m.length][];</span>

<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (int i = 0; i &lt; m.length; ++i) {</span>
<span class="nc" id="L1239">            c[i] = new float[m[0].length];</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            for (int j = 0; j &lt; m[0].length; ++j) {</span>
<span class="nc" id="L1241">                c[i][j] -= m[i][j] - n[i][j];</span>
            }
        }

<span class="nc" id="L1245">        return c;</span>
    }
    
    public static float[][] add(float[][] m, float[][] n) {

<span class="nc bnc" id="L1250" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1251">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1253" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1254">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1256" title="All 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1257">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (m[0].length != n[0].length) {</span>
<span class="nc" id="L1260">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="nc" id="L1263">        float[][] c = new float[m.length][];</span>

<span class="nc bnc" id="L1265" title="All 2 branches missed.">        for (int i = 0; i &lt; m.length; ++i) {</span>
<span class="nc" id="L1266">            c[i] = new float[m[0].length];</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">            for (int j = 0; j &lt; m[0].length; ++j) {</span>
<span class="nc" id="L1268">                c[i][j] = m[i][j] + n[i][j];</span>
            }
        }

<span class="nc" id="L1272">        return c;</span>
    }

    public static float[] subtract(float[] m, float[] n) {

<span class="nc bnc" id="L1277" title="All 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1278">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1280" title="All 4 branches missed.">        if (n == null || n.length == 0) {</span>
<span class="nc" id="L1281">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L1284">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="nc" id="L1287">        int len = m.length;</span>
     
<span class="nc" id="L1289">        float[] c = new float[len];</span>
        
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1292">            c[i] = m[i] - n[i];</span>
        }

<span class="nc" id="L1295">        return c;</span>
    }
    
    public static DenseMatrix subtract(DenseMatrix m, DenseMatrix n) {

<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (m == null) {</span>
<span class="nc" id="L1301">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (n == null) {</span>
<span class="nc" id="L1304">            throw new IllegalArgumentException(&quot;n cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L1306" title="All 4 branches missed.">        if (m.numRows() != n.numRows() || m.numColumns() != n.numColumns()) {</span>
<span class="nc" id="L1307">            throw new IllegalArgumentException(&quot;m and n must be same length&quot;);</span>
        }
        
<span class="nc" id="L1310">        DenseMatrix output = new DenseMatrix(m.numRows(), m.numColumns());</span>
        
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        for (int i = 0; i &lt; m.numRows(); ++i) {</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">            for (int j = 0; j &lt; m.numColumns(); ++j) {</span>
<span class="nc" id="L1314">                double v0 = m.get(i, j);</span>
<span class="nc" id="L1315">                double v1 = n.get(i, j);</span>
<span class="nc" id="L1316">                output.set(i, j, v0 - v1);</span>
            }
        }
        
<span class="nc" id="L1320">        return output;</span>
    }
    
    public static void add(int[] m, int n) {

<span class="pc bpc" id="L1325" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1326">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L1329">        int len = m.length;</span>
             
<span class="fc bfc" id="L1331" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1332">            m[i] += n;</span>
        }
<span class="fc" id="L1334">    }</span>
    
    public static float[][] transpose(float[][] m) {

<span class="pc bpc" id="L1338" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1339">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }

<span class="fc" id="L1342">        int mRows = m.length;</span>
<span class="fc" id="L1343">        int mCols = m[0].length;</span>

<span class="fc" id="L1345">        float[][] t = new float[mCols][];</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (int i = 0; i &lt; mCols; i++) {</span>
<span class="fc" id="L1347">            t[i] = new float[mRows];</span>
        }

<span class="fc bfc" id="L1350" title="All 2 branches covered.">        for (int i = 0; i &lt; mRows; i++) {</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">            for (int j = 0; j &lt; mCols; j++) {</span>
<span class="fc" id="L1352">                t[j][i] = m[i][j];</span>
            }
        }

<span class="fc" id="L1356">        return t;</span>
    }
    
    public static DenseMatrix transpose(DenseMatrix m) {
        
<span class="nc" id="L1361">        int mRows = m.numRows();</span>
<span class="nc" id="L1362">        int mCols = m.numColumns();</span>
        
<span class="nc" id="L1364">        double[][] t = new double[mRows][];</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        for (int i = 0; i &lt; mRows; i++) {</span>
<span class="nc" id="L1366">            t[i] = new double[mCols];</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">            for (int j = 0; j &lt; mCols; j++) {</span>
<span class="nc" id="L1368">                t[i][j] = m.get(i, j);</span>
            }
        } 
        
<span class="nc" id="L1372">        double[][] transposed = transpose(t);</span>
        
<span class="nc" id="L1374">        DenseMatrix mT = new DenseMatrix(transposed);</span>
        
<span class="nc" id="L1376">        return mT;</span>
    }
    
    public static double[][] transpose(double[][] m) {

<span class="pc bpc" id="L1381" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1382">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L1385">        int mRows = m.length;</span>
<span class="fc" id="L1386">        int mCols = m[0].length;</span>
        
<span class="fc" id="L1388">        double[][] t = new double[mCols][];</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">        for (int i = 0; i &lt; mCols; i++) {</span>
<span class="fc" id="L1390">            t[i] = new double[mRows];</span>
        }
        
<span class="fc bfc" id="L1393" title="All 2 branches covered.">        for (int i = 0; i &lt; mRows; i++) {</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">            for (int j = 0; j &lt; mCols; j++) {</span>
<span class="fc" id="L1395">                t[j][i] = m[i][j];</span>
            }
        }
        
<span class="fc" id="L1399">        return t;</span>
    }
    
    public static int[][] transpose(int[][] m) {

<span class="pc bpc" id="L1404" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1405">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L1408">        int mRows = m.length;</span>
<span class="fc" id="L1409">        int mCols = m[0].length;</span>
        
<span class="fc" id="L1411">        int[][] t = new int[mCols][];</span>
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        for (int i = 0; i &lt; mCols; i++) {</span>
<span class="fc" id="L1413">            t[i] = new int[mRows];</span>
        }
        int i, j;
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        for (i = 0; i &lt; mRows; i++) {</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">            for (j = 0; j &lt; mCols; j++) {</span>
<span class="fc" id="L1418">                t[j][i] = m[i][j];</span>
            }
        }
        
<span class="fc" id="L1422">        return t;</span>
    }
    
    /**
     * transpose matrix m into out matrix which must be size m[0].length X m.length.
     * @param m matrix to transpose
     * @param out output matrix to hold transposed m
     * @return 
     */
    public static void transpose(double[][] m, double[][] out) {

<span class="pc bpc" id="L1433" title="2 of 4 branches missed.">        if (m == null || m.length == 0) {</span>
<span class="nc" id="L1434">            throw new IllegalArgumentException(&quot;m cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L1437">        int mRows = m.length;</span>
<span class="fc" id="L1438">        int mCols = m[0].length;</span>
        
<span class="pc bpc" id="L1440" title="2 of 4 branches missed.">        if (out.length != mCols || out[0].length != mRows){</span>
<span class="nc" id="L1441">            throw new IllegalArgumentException(&quot;out size must be m[0].length X m.length&quot;);</span>
        }
        
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        for (int i = 0; i &lt; mRows; i++) {</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">            for (int j = 0; j &lt; mCols; j++) {</span>
<span class="fc" id="L1446">                out[j][i] = m[i][j];</span>
            }
        }        
<span class="fc" id="L1449">    }</span>
    
    public static double[][] convertToRowMajor(AbstractMatrix a) {
<span class="fc" id="L1452">        int nc = a.numColumns();</span>
<span class="fc" id="L1453">        int nr = a.numRows();</span>
<span class="fc" id="L1454">        double[][] out = new double[nr][];</span>
<span class="fc bfc" id="L1455" title="All 2 branches covered.">        for (int i = 0; i &lt; nr; ++i) {</span>
<span class="fc" id="L1456">            out[i] = new double[nc];</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">            for (int j = 0; j &lt; nc; ++j) {</span>
<span class="fc" id="L1458">                out[i][j] = a.get(i, j);</span>
            }
        }
<span class="fc" id="L1461">        return out;</span>
    }
    
    public static double[][] convertToRowMajor(UpperTriangDenseMatrix a) {
<span class="fc" id="L1465">        int nc = a.numColumns();</span>
<span class="fc" id="L1466">        int nr = a.numRows();</span>
        //TODO: read API to see if can make this more effient by only visiting upper right of matrix
<span class="fc" id="L1468">        double[][] out = new double[nr][];</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">        for (int i = 0; i &lt; nr; ++i) {</span>
<span class="fc" id="L1470">            out[i] = new double[nc];</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            for (int j = 0; j &lt; nc; ++j) {</span>
<span class="fc" id="L1472">                out[i][j] = a.get(i, j);</span>
            }
        }
<span class="fc" id="L1475">        return out;</span>
    }
    
    public static double[][] convertToRowMajor(LowerSymmDenseMatrix a) {
<span class="nc" id="L1479">        int nc = a.numColumns();</span>
<span class="nc" id="L1480">        int nr = a.numRows();</span>
<span class="nc" id="L1481">        double[][] out = new double[nr][];</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        for (int i = 0; i &lt; nr; ++i) {</span>
<span class="nc" id="L1483">            out[i] = new double[nc];</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            for (int j = 0; j &lt; nc; ++j) {</span>
<span class="nc" id="L1485">                out[i][j] = a.get(i, j);</span>
            }
        }
<span class="nc" id="L1488">        return out;</span>
    }
            
    /*
    columns of mxn matrix A are linearly independent only when rank r == n.
    there are n pivots and no free variables.  \in this case m is .geq. r).
    only x=0 is in the null space when n == r.
    
    the columns of A are independent if x=0 is the only solution to a*x=0.
    
    &lt;pre&gt;
    
      A is m x n matrix with rank r
    
                            r           n
        .                   .           .
        |                               |  row space is size        r   x  n
        |                               |  col space is size        m   x  r
    r ..|                               |  null space is size     (n-r) x  n
        |                               |  left null space is size  m   x  (m-r)
    m ..|                               |
    
    1) space r x n transformed    : C(A^T) is row space n x r           ==&gt; all A^T*y
    2) space (n-r) x r            : N(A) is null space n x (n-r)        ==&gt; A*x = 0
    3) space m x r                : C(A) is column space m x r          ==&gt; all A*x
    4) space m x (m-r) transformed: N(A^T) is left null space m x (m-r) ==&gt; A^T*y = 0
    
    &lt;/pre&gt;
   .
    */
    
    /**
     * calculate the pseudo-inverse of matrix a for cases when the rank of a
     * is less than the width of matrix a.
     * Note that the term rank can be deceptive for cases when the 
     * original matrix a was rank deficient and then is perturbed to become
     * a full rank matrix leading to possibility of larger errors when treated as full rank.
     * the term rank deficient can be replaced by the ter numerically rank deficient.
     * (see Bjork 1991 Section 2, &quot;Algorithms for linear least squares problems&quot;
     * and Chap 6 of Golub &amp; Van Loan).
     * This method uses the SVD of a,
     * specifically, V*R*U^T where R is 1/diagonal of S for cases where
     * rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
     * Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
     * inverse of A.
     * 
     * Following Gilbert Strang's &quot;Introduction to Linear Algebra&quot;.
     * 
     * TODO: read &quot;ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX&quot; by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length &gt;= a[0].length, the full rank pseudo-inverse
      * is calculated instead of the rank-deficient;
     * @param a and m X n matrix
     * @return pseudo-inverse of matrix a. dimensions are those of a^T.
     * @throws NotConvergedException 
     */
    public static double[][] pseudoinverseRankDeficient(double[][] a) throws NotConvergedException {
<span class="fc" id="L1548">        return pseudoinverseRankDeficient(a, true);</span>
    }
    
    /**
     * calculate the pseudo-inverse of matrix a for cases when the rank of a
     * is less than the width of matrix a.
     * Note that the term rank can be deceptive for cases when the 
     * original matrix a was rank deficient and then is perturbed to become
     * a full rank matrix leading to possibility of larger errors when treated as full rank.
     * the term rank deficient can be replaced by the term numerically rank deficient.
     * (see Bjork 1991 Section 2, &quot;Algorithms for linear least squares problems&quot;
     * and Chap 6 of Golub &amp; Van Loan).
     * This method uses the SVD of a,
     * specifically, V*R*U^T where R is 1/diagonal of S for cases where
     * rank .leq. m or rank .leq. n where mXn are the dimensions of matrix a.
     * Note that if A^-1 exists, then the pseudo-inverse of A is equal to the
     * inverse of A.
     * 
     * Following Gilbert Strang's &quot;Introduction to Linear Algebra&quot;.
     * 
     * TODO: read &quot;ALTERNATIVE METHODS OF CALCULATION OF THE PSEUDO INVERSE
       OF A NON FULL-RANK MATRIX&quot; by M. A. Murray-Lasso, 2008
       http://www.scielo.org.mx/pdf/jart/v6n3/v6n3a4.pdf
       
      NOTE: if the rank is found to be equal to a[0].length and 
      a.length &gt;= a[0].length, the full rank pseudo-inverse
      * is calculated instead of the rank-deficient;
     * @param a and m X n matrix
     * @param checkForFullRank if true, the method looks for a[0],length == rank
     * and if it is full-rank, the method returns the results form pseudoinverseFullRank(a)
     * instead.
     * @return pseudo-inverse of matrix a. dimensions are those of a^T.
     * @throws NotConvergedException 
     */
    static double[][] pseudoinverseRankDeficient(double[][] a,
        boolean checkForFullRank) throws NotConvergedException {
<span class="fc" id="L1584">        int m = a.length;</span>
<span class="fc" id="L1585">        int n = a[0].length;</span>
        
        // limit for a number to be significant above 0
<span class="fc" id="L1588">        double eps = 1e-16;</span>
        
        // from Gilbert Strang's &quot;Introduction to Linear Algebra&quot;, Chap 7:
        // uses SVD:
        //
        //   A_inverse = V * pseudoinverse(S) * U^T
        //        where pseudoinverse(S) is simply an empty matrix with the diagonal
        //        being the reciprocal of each singular value
        //      NOTE: compare number of ops w/ this factoring:
        //          V * (pseudoinverse(S) * U^T)
        //   A_inverse is n X m
        //
        //   V is n X n
        //   pseudoinverse(S) is n X m
        //   U^T is m X m
        
<span class="fc" id="L1604">        DenseMatrix aMatrix = new DenseMatrix(a);</span>
<span class="fc" id="L1605">        SVD svd = SVD.factorize(aMatrix);</span>
        
        //TODO: rewrite to use fewer data structures and multiply in place.
        
        // s is an array of size min(m,n)
<span class="fc" id="L1610">        double[] s = svd.getS();</span>
<span class="fc" id="L1611">        int rank = 0;</span>
<span class="fc bfc" id="L1612" title="All 2 branches covered.">        for (double sv : s) {</span>
<span class="fc bfc" id="L1613" title="All 2 branches covered.">            if (sv &gt; eps) {</span>
<span class="fc" id="L1614">                rank++;</span>
            }
        }
<span class="pc bpc" id="L1617" title="2 of 6 branches missed.">        if (checkForFullRank &amp;&amp; rank == n &amp;&amp; m &gt;= n) {</span>
            // use full rank solution:
<span class="fc" id="L1619">            return pseudoinverseFullColumnRank(a);</span>
        }
        
<span class="fc" id="L1622">        DenseMatrix vTM = svd.getVt();</span>
<span class="fc" id="L1623">        double[][] vT = MatrixUtil.convertToRowMajor(vTM);</span>
<span class="fc" id="L1624">        double[][] v = MatrixUtil.transpose(vT);</span>
<span class="fc" id="L1625">        double[][] uT = MatrixUtil.convertToRowMajor(svd.getU());</span>
        
        /*
        U is mxm orthonormal columns
        S is mxn with non-negative singular values.  rank is number of non-zero entries
        V is  nxn
        */
<span class="pc bnc" id="L1632" title="All 2 branches missed.">        assert(v.length == n);</span>
<span class="pc bnc" id="L1633" title="All 2 branches missed.">        assert(v[0].length == n);</span>
<span class="pc bnc" id="L1634" title="All 2 branches missed.">        assert(uT.length == m);</span>
<span class="pc bnc" id="L1635" title="All 2 branches missed.">        assert(uT[0].length == m);</span>
        
<span class="fc" id="L1637">        double[][] sInverse = zeros(n, m);</span>
        double sI;
<span class="fc bfc" id="L1639" title="All 2 branches covered.">        for (int i = 0; i &lt; s.length; ++i) {</span>
<span class="fc" id="L1640">            sI = s[i];</span>
<span class="fc bfc" id="L1641" title="All 2 branches covered.">            if (sI &gt; eps) {</span>
<span class="fc" id="L1642">                sInverse[i][i] = 1./sI;</span>
            }
        }
        
        /*
        U is mxn orthonormal columns
        S is nxn with non-negative singular values.  rank is number of non-zero entries
        V is  nxn
        pseudoinverse(S) is nxm
        */
        
        //A_inverse = V * pseudoinverse(S) * U^T
<span class="fc" id="L1654">        double[][] inv = MatrixUtil.multiply(v, sInverse);</span>
<span class="fc" id="L1655">        inv = MatrixUtil.multiply(inv, uT);</span>
        
<span class="fc" id="L1657">        return inv;</span>
    }
    
    /**
     * calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
     * column rank matrix or overdetermined, 
     * n &gt;= rank.
     * A_pseudoinverse for A being full column rank = inverse(A^T*A) * A^T.
     * This particular pseudoinverse constitutes a left inverse.
     * pseudoinv(A)*A = I.
     * 
     * If inverting A^T*A fails, the method returns results of pseudoinverseRankDeficient().
     * 
     * NOTE that (A^T*A) (or (A * A^T)) has to be invertible, that is, 
     * the reduced echelon form of A has linearly independent columns (rank==n).
     * following pseudocode from Cormen, Leiserson, Rivest, and Stein Introduction to Algorithms.
     * @param a two dimensional array in row major format with dimensions
     * m x n.  a is a full-rank matrix.
     * a is a non-singular matrix(i.e. has exactly one solution). 
     * 
     * @return matrix of size [a[0].length][a.length]
     * @throws NotConvergedException 
     */
    public static double[][] pseudoinverseFullColumnRank(double[][] a) throws NotConvergedException {
<span class="fc" id="L1681">        int m = a.length;</span>
<span class="fc" id="L1682">        int n = a[0].length;</span>
        
        // limit for a number to be significant above 0 (precision of computer)
<span class="fc" id="L1685">        double eps = 1e-16;</span>
        
        //from Cormen, Leiserson, Rivest, and Stein: A_pseudoinverse = inverse(A^T*A) * A^T
<span class="fc" id="L1688">        double[][] _aT = MatrixUtil.transpose(a);</span>
<span class="fc" id="L1689">        double[][] _aTA = MatrixUtil.multiply(_aT, a);</span>
<span class="fc" id="L1690">        DenseMatrix aTA = new DenseMatrix(_aTA);</span>
        
        //NOTE that (A^T*A) has to be invertible, that is, the reduced echelon form
        // of A has linearly independent columns (no free variables, only pivots.
        // which also means rank==n).
        //
        // could invert (A^T*A) using the cofactor matrix/determinant
        //   or a convenience method from MTJ Matrix.solve
        
<span class="fc" id="L1699">        DenseMatrix I = Matrices.identity(_aTA[0].length);</span>
<span class="fc" id="L1700">        DenseMatrix placeholder = I.copy();</span>
             
        // the pseudoinverse needs (A^T*A)^-1:
        //    in general: if an inverse exists for a matrix V then  V * V^-1 = I
        //    if an inverse exists for (A^T*A) then (A^T*A) * (A^T*A)^-1 = I
                
        // matlab and other matrix notation uses left division symbol in this way:
        //     x = A\B solves the system of linear equations A*x = B for x.
        //        can substitute A = A^T*A,   X = (A^T*A)^-1,   B = I
        //  X = A\B in MTJ is X = A.solve(B, X), that is, inputs are A and B.
        try {
<span class="fc" id="L1711">             DenseMatrix aTAI = (DenseMatrix)aTA.solve(I, placeholder);</span>
<span class="fc" id="L1712">             double[][] _aTAI = MatrixUtil.convertToRowMajor(aTAI);</span>
            // _pseudoinverse = inverse(A^T*A) * A^T
<span class="fc" id="L1714">            double[][] inv = MatrixUtil.multiply(_aTAI, _aT);</span>
<span class="fc" id="L1715">            return inv;</span>
<span class="nc" id="L1716">        } catch (no.uib.cipr.matrix.MatrixSingularException ex) {</span>
<span class="nc" id="L1717">            return pseudoinverseRankDeficient(a, false);</span>
        }
    }
    
    /**
     * calculate the pseudo-inverse of matrix a (dimensions mxn) which is a full
     * row rank matrix, m &gt;= rank.
     * A_pseudoinverse for A being full row rank = a^T*inverse(A*A^T).
     * This particular pseudoinverse constitutes a right inverse.
     * A*pseudoinv(A) = I.
     * 
     * @param a two dimensional array in row major format with dimensions
     * m x n.  a is a full-rank matrix.
     * a is a non-singular matrix(i.e. has exactly one solution). 
     * 
     * @return matrix of size [a[0].length][a.length]
     * @throws NotConvergedException 
     */
    public static double[][] pseudoinverseFullRowRank(double[][] a) throws NotConvergedException {
<span class="fc" id="L1736">        int m = a.length;</span>
<span class="fc" id="L1737">        int n = a[0].length;</span>
        
        // limit for a number to be significant above 0 (precision of computer)
<span class="fc" id="L1740">        double eps = 1e-16;</span>
        
        //A^T(AA^T)^-1
<span class="fc" id="L1743">        double[][] _aT = MatrixUtil.transpose(a);</span>
<span class="fc" id="L1744">        double[][] _aAT = MatrixUtil.multiply(a, _aT);</span>
<span class="fc" id="L1745">        DenseMatrix aAT = new DenseMatrix(_aAT);</span>
        
<span class="fc" id="L1747">        DenseMatrix I = Matrices.identity(_aAT[0].length);</span>
<span class="fc" id="L1748">        DenseMatrix placeholder = I.copy();</span>
             
        // the pseudoinverse needs (A*A^T)^-1:
                
        // matlab and other matrix notation uses left division symbol in this way:
        //     x = A\B solves the system of linear equations A*x = B for x.
        //        can substitute A = A^T*A,   X = (A^T*A)^-1,   B = I
        //  X = A\B in MTJ is X = A.solve(B, X), that is, inputs are A and B.
        try {
<span class="fc" id="L1757">             DenseMatrix aATI = (DenseMatrix)aAT.solve(I, placeholder);</span>
<span class="fc" id="L1758">             double[][] _aATI = MatrixUtil.convertToRowMajor(aATI);</span>
            // _pseudoinverse = inverse(A^T*A) * A^T
<span class="fc" id="L1760">            double[][] inv = MatrixUtil.multiply(_aT, _aATI);</span>
<span class="fc" id="L1761">            return inv;</span>
<span class="nc" id="L1762">        } catch (no.uib.cipr.matrix.MatrixSingularException ex) {</span>
<span class="nc" id="L1763">            return pseudoinverseRankDeficient(a, false);</span>
        }
        
    }
    
    /**
      from Strang &quot;Introduction to Linear Algebra&quot;:
      &lt;pre&gt;
       an inverse matrix may or may not exist.  
       (1) has to be a square matrix.
           A^-1 x A = I, where I is the identity matrix.
       (2) an inverse matrix has n pivots remaining after elimination,
                where pivot is the leftmost non-zero variable. i.e. the rank r
                is equal to the dimension of the square matrix which is n.
       (3) after elimination, next test is that the determinant is not zero

       if A is invertible, then A * x = b can be solved as x = A^-1 * b
       and (A * B)^-1 = B^-1 * A^-1
      &lt;/pre&gt;
     NOTE: because this uses decomposition, each application using it should decide whether
     * to perform the exterior operations at same time to avoid recomputing
     * any matrices.
     * @param a
     * @return true if is invertible
     */
    public static boolean isInvertible(double[][] a) {
        
<span class="nc" id="L1790">        int m = a.length;</span>
<span class="nc" id="L1791">        int n = a[0].length;</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (m != n) {</span>
<span class="nc" id="L1793">            throw new IllegalArgumentException(&quot;a is not a squae matrix&quot;);</span>
        }
        
        //rank:
        // -- could use Cholesky factorization followed by check for positive definiteness
        // -- could use LUP decomposition and count the L diagonal 1's
        // -- could use SVD and count the unique singular values in D
<span class="nc" id="L1800">        LUP lup = LinearEquations.LUPDecomposition(a);</span>
        
<span class="nc" id="L1802">        int rank = 0;</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">        for (int i = 0; i &lt; lup.ell.length; ++i) {</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">            if (Math.abs(lup.ell[i][i] - 1.0) &lt; 1.e-7) {</span>
<span class="nc" id="L1805">                rank++;</span>
            }
        }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">        if (rank != n) {</span>
<span class="nc" id="L1809">            return false;</span>
        }
        
        // determinant (-1)^n * det(U) where det(U) is product of diagonal
<span class="nc" id="L1813">        double det = 1;</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">        for (int i = 0; i &lt; lup.ell.length; ++i) {</span>
<span class="nc" id="L1815">            det *= lup.u[i][i];</span>
        }
<span class="nc bnc" id="L1817" title="All 2 branches missed.">        if ((n % 2) != 0) {</span>
<span class="nc" id="L1818">            det *= -1;</span>
        }
        
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        if (Math.abs(det) &gt; 1e-15) {</span>
            // determinant is not zero, so is invertible
<span class="nc" id="L1823">            return true;</span>
        }
        
<span class="nc" id="L1826">        return false;</span>
    }
    
    /**
      determine the rank of martix A
      &lt;pre&gt;
      If matrix A is a square matrix:
          uses LUP decomposition and counts the L diagonal 1's
      Else
          uses SVD and counts the non-zero diagonal singular values.
          
      NOTE: a positive tolerance level eps is used to find the number of singular values
      above eps instead of 0.
      &lt;/pre&gt;
     * @param a
     * @param eps a positive number for the tolerance above zero of the pivots or
     * singular values.
     * @return the rank of A
     */
    public static int rank(double[][] a, double eps) throws NotConvergedException {
       
<span class="fc" id="L1847">        int m = a.length;</span>
<span class="fc" id="L1848">        int n = a[0].length;</span>
<span class="fc" id="L1849">        int rank = 0;</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">        if (m == n) {</span>
<span class="fc" id="L1851">            int rU = 0;</span>
<span class="fc" id="L1852">            LU lu = LinearEquations.LUDecomposition(a);</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">            for (int i = 0; i &lt; lu.u.length; ++i) {</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">                if (Math.abs(lu.u[i][i] - 1.0) &lt; eps) {</span>
<span class="fc" id="L1855">                    rU++;</span>
                }
            }
<span class="fc" id="L1858">            int rL = 0;</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">            for (int i = 0; i &lt; lu.ell.length; ++i) {</span>
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">                if (Math.abs(lu.ell[i][i] - 1.0) &lt; eps) {</span>
<span class="fc" id="L1861">                    rL++;</span>
                }
            }
<span class="fc" id="L1864">            return Math.min(rU, rL);</span>
        }
        
        /* or
        QRP qrp = QRP.factorize(new DenseMatrix(a));
        final double EPS = 1e-12;
        int rank2 =  qrp.getRank();
        */
       
<span class="fc" id="L1873">        SVDProducts svd = performSVD(a);</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">        for (double sv : svd.s) {</span>
<span class="pc bpc" id="L1875" title="1 of 2 branches missed.">            if (sv &gt; eps) {</span>
<span class="fc" id="L1876">                rank++;</span>
            }
        }
<span class="fc" id="L1879">        return rank;</span>
    }

    /**
     * given a map called adj having keys and values for each key, 
     * create a map where the keys are adj.values and the
     * values are the keys of adj.values.
     * @param adj
     * @return 
     */
    public static TIntObjectMap&lt;TIntSet&gt; createReverseMap(TIntObjectMap&lt;TIntSet&gt; adj) {
<span class="fc" id="L1890">        TIntObjectMap&lt;TIntSet&gt; r = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
<span class="fc" id="L1892">        TIntObjectIterator&lt;TIntSet&gt; iter = adj.iterator();</span>
        TIntIterator iterV;
        TIntSet vSet, rVSet;
        int u, v;
<span class="fc bfc" id="L1896" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1897">            iter.advance();</span>
            
<span class="fc" id="L1899">            u = iter.key();</span>
<span class="fc" id="L1900">            vSet = iter.value();</span>
            
<span class="pc bpc" id="L1902" title="1 of 4 branches missed.">            if (vSet == null || vSet.isEmpty()) {</span>
<span class="fc" id="L1903">                continue;</span>
            }
            
<span class="fc" id="L1906">            iterV = vSet.iterator();</span>
<span class="fc bfc" id="L1907" title="All 2 branches covered.">            while (iterV.hasNext()) {</span>
<span class="fc" id="L1908">                v = iterV.next();</span>
                
<span class="fc" id="L1910">                rVSet = r.get(v);</span>
                
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                if (rVSet == null) {</span>
<span class="fc" id="L1913">                    rVSet = new TIntHashSet();</span>
<span class="fc" id="L1914">                    r.put(v, rVSet);</span>
                }
<span class="fc" id="L1916">                rVSet.add(u);</span>
            }
        }
        
<span class="fc" id="L1920">        return r;</span>
    }
    
    /**
     * class to hold the results of the Singular Value Decomposition
     */
    public static class SVDProducts {
        
        /**
         * the rank of the input matrix
         */
        public int rank;
        
        /**
         * given A as an mxn matrix, u is orthogonal column vectors in a matrix of size mxm.
         * These are eigenvectors of A as columns ordered by the eigenvalues s.
         */
        public double[][] u;
        
        /**
         * given A as an mxn matrix, v^T is orthogonal row vectors in a matrix of sizr nxn.
         * These are eigenvectors of A as rows ordered by the eigenvalues s.
         */
        public double[][] vT;
        
        /**
         * given a matrix A of size mxn, s holds the singular values, that is,
         * the eigenvalues of the SVD decomposition ordered from largest to smallest.
         * these are the diagonal of matrix sigma which may or may not be populated
         */
        public double[] s;
        
        /**
         * the diagonal matrix holding the eigenvalues.  this variable might not
         * be populated if s is.
         */
        public double[][] sigma = null;
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;u=\n&quot;);
            if (u != null) {
                sb.append(FormatArray.toString(u, &quot;%.4e&quot;));
            } 
            sb.append(&quot;\ns=\n&quot;);
            if (s != null) {
                sb.append(FormatArray.toString(s, &quot;%.4e&quot;));
            }
            sb.append(&quot;\nsigma=\n&quot;);
            if (sigma != null) {
                sb.append(FormatArray.toString(sigma, &quot;%.4e&quot;));
            }
            sb.append(&quot;\nvT=\n&quot;);
            if (vT != null) {
                sb.append(FormatArray.toString(vT, &quot;%.4e&quot;));
            }
            return sb.toString();
        }
        
    }
    
    /**
     * performs SVD on matrix a and if fails to converge, performs SVD on
     * a*a^T and a^T*a separately to get the factorization components for a.
     * &lt;pre&gt;
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            
          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U 
          
          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       &lt;/pre&gt;
     * @param a
     * @return 
     */
    public static SVDProducts performSVD(double[][] a) throws NotConvergedException {
<span class="fc" id="L1997">        return performSVD(new DenseMatrix(a));</span>
    }
    
    /**
     * performs SVD on matrix a and if fails to converge, performs SVD on
     * a*a^T and a^T*a separately to get the factorization components for a.
     * &lt;pre&gt;
          SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            
          SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U 
          
          SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
              and sqrt( SVD(A^TA) eigenvalues )
       &lt;/pre&gt;
     * @param a
     * @return 
     */
    public static SVDProducts performSVD(DenseMatrix a) throws NotConvergedException {
        SVD svd;
<span class="fc" id="L2016">        DenseMatrix u = null;</span>
<span class="fc" id="L2017">        DenseMatrix vT = null;</span>
<span class="fc" id="L2018">        double[] sDiag = null;</span>
        try {
<span class="fc" id="L2020">            svd = SVD.factorize(a);</span>
<span class="fc" id="L2021">            vT = svd.getVt();</span>
<span class="fc" id="L2022">            u = svd.getU();</span>
<span class="fc" id="L2023">            sDiag = svd.getS();</span>
<span class="nc" id="L2024">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L2025">            double[][] _a = MatrixUtil.convertToRowMajor(a);</span>
<span class="nc" id="L2026">            double[][] aTa = MatrixUtil.multiply(MatrixUtil.transpose(_a), _a);</span>
<span class="nc" id="L2027">            double[][] aaT = MatrixUtil.multiply(_a, MatrixUtil.transpose(_a));</span>
            //SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            //SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U 
            //SVD(A) eigenvalues are the same as sqrt( SVD(AA^T) eigenvalues )
            //    and sqrt( SVD(A^TA) eigenvalues )
<span class="nc" id="L2032">            svd = SVD.factorize(new DenseMatrix(aTa));</span>
<span class="nc" id="L2033">            vT = svd.getVt();</span>
<span class="nc" id="L2034">            sDiag = svd.getS();</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">            for (int i = 0; i &lt; sDiag.length; ++i) {</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                if (sDiag[i] &gt; 0) {</span>
<span class="nc" id="L2037">                    sDiag[i] = Math.sqrt(sDiag[i]);</span>
                }
            }

<span class="nc" id="L2041">            svd = SVD.factorize(new DenseMatrix(aaT));</span>
<span class="nc" id="L2042">            u = svd.getU();</span>
<span class="fc" id="L2043">        }</span>
<span class="fc" id="L2044">        int rank = 0;</span>
<span class="fc" id="L2045">        double eps = 1E-15;</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        for (double sv : svd.getS()) {</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">            if (sv &gt; eps) {</span>
<span class="fc" id="L2048">                rank++;</span>
            }
        }
<span class="fc" id="L2051">        SVDProducts out = new SVDProducts();</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">        out.u = (u != null) ? MatrixUtil.convertToRowMajor(u) : null;</span>
<span class="pc bpc" id="L2053" title="1 of 2 branches missed.">        out.vT = (vT != null) ? MatrixUtil.convertToRowMajor(vT) : null;</span>
<span class="fc" id="L2054">        out.s = sDiag;</span>
<span class="fc" id="L2055">        out.rank = rank;</span>
<span class="fc" id="L2056">        return out;</span>
    }
    
    /**
     * create matrix A^T*A then perform SVD on it.  NOTE that the singular values
     * returned in S will have the square of values of SVD(A).s.
     * @param a the matrix a (internally, a^T*a will be calculated and used)
     * @return
     * @throws NotConvergedException 
     */
    public static SVDProducts performSVDATransposeA(double[][] a) throws NotConvergedException {
<span class="fc" id="L2067">        double[][] aTa = MatrixUtil.createATransposedTimesA(a);</span>
<span class="fc" id="L2068">        return performSVDATransposeA(new DenseMatrix(aTa));</span>
    }
    
    public static SVDProducts performSVDATransposeA(DenseMatrix aTa) throws NotConvergedException {
        
        SVD svd;
<span class="fc" id="L2074">        DenseMatrix u = null;</span>
<span class="fc" id="L2075">        DenseMatrix vT = null;</span>
<span class="fc" id="L2076">        double[] sDiag = null;</span>
        
<span class="fc" id="L2078">        svd = SVD.factorize(aTa);</span>
<span class="fc" id="L2079">        vT = svd.getVt();</span>
<span class="fc" id="L2080">        u = svd.getU();</span>
<span class="fc" id="L2081">        sDiag = svd.getS();</span>
        
<span class="fc" id="L2083">        SVDProducts out = new SVDProducts();</span>
<span class="fc" id="L2084">        out.u = MatrixUtil.convertToRowMajor(u);</span>
<span class="fc" id="L2085">        out.vT = MatrixUtil.convertToRowMajor(vT);</span>
<span class="fc" id="L2086">        out.s = sDiag;</span>
<span class="fc" id="L2087">        return out;</span>
    }
    
    /**
     * perform QR decomposition (a.k.a. Francis algorithm, a.k.a. Francis QR step)
     * on matrix a using the MTJ library.
     * It's a sophisticated version of the &quot;power method&quot;.
     * A = Q*R of an orthonormal matrix Q and an upper triangular matrix R.
     * The columns of Q are the eigenvectors of A.
     * A*Q = Q * diag(eigenvalues of A).
     * 
     * &lt;pre&gt;
     * To calculate the product of eigenvalue or singular values using
     * QR, see section &quot;Connection to a determinant or a product of eigenvalues&quot;
     * in wikipedia:
     * https://en.wikipedia.org/wiki/QR_decomposition
     * &lt;/pre&gt;
     * 
     * @param a a square or rectangular matrix with independent columns.
     * @return 
     */
    public static QR performQRDecomposition(double[][] a) {
<span class="nc" id="L2109">        QR qr = QR.factorize(new DenseMatrix(a));</span>
<span class="nc" id="L2110">        return qr;</span>
    }
    
    /**
     * given data points xy, want to create a matrix usable to transform
     * the data points by scaling and translation so that:
        a) points are translated so that their centroid is at the origin.
        b) points are scaled so that the average distance from the
           origin is sqrt(2).
       Can use the transformation matrix with dot operator: Misc.multiply(xy, tMatrix).
     * @param xy
     * @return a matrix for use for canonical transformation of the points.
     * the format of the result is 
     * &lt;pre&gt;
     *  t[0] = new double[]{scale,       0,     -centroidX*scale};
        t[1] = new double[]{0,           scale, -centroidY*scale};
       &lt;/pre&gt;
     */
    public static double[][] calculateNormalizationMatrix2X3(double[][] xy) {
        
<span class="nc" id="L2130">        int nRows = xy.length;</span>
        
<span class="nc" id="L2132">        double cen0 = 0;</span>
<span class="nc" id="L2133">        double cen1 = 0;</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="nc" id="L2135">            cen0 += xy[i][0];</span>
<span class="nc" id="L2136">            cen1 += xy[i][1];</span>
        }
<span class="nc" id="L2138">        cen0 /= (double)nRows;</span>
<span class="nc" id="L2139">        cen1 /= (double)nRows;</span>
        
<span class="nc" id="L2141">        double mean = 0;</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="nc" id="L2143">            double diffX = xy[i][0] - cen0;</span>
<span class="nc" id="L2144">            double diffY = xy[i][1] - cen1;</span>
<span class="nc" id="L2145">            double dist = Math.sqrt((diffX * diffX) + (diffY * diffY));</span>
<span class="nc" id="L2146">            mean += dist;</span>
        }
<span class="nc" id="L2148">        mean /= (double)nRows;</span>
        
        /*
        mean * factor = sqrt(2)
        */
<span class="nc" id="L2153">        double scale = Math.sqrt(2)/mean;</span>
                
<span class="nc" id="L2155">        double[][] t = new double[2][];</span>
<span class="nc" id="L2156">        t[0] = new double[]{scale,       0,     -cen0*scale};</span>
<span class="nc" id="L2157">        t[1] = new double[]{0,           scale, -cen1*scale};</span>
        
<span class="nc" id="L2159">        return t;</span>
    }
    
     public static float[][] copy(float[][] a) {

<span class="nc" id="L2164">        float[][] c = new float[a.length][a[0].length];</span>

<span class="nc bnc" id="L2166" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L2167">            c[i] = new float[a[0].length];</span>
<span class="nc" id="L2168">            System.arraycopy(a[i], 0, c[i], 0, a[0].length);</span>
        }
        
<span class="nc" id="L2171">        return c;</span>
    }

    public static double[][] copy(double[][] a) {
        
<span class="fc" id="L2176">        double[][] m = new double[a.length][];</span>
        
<span class="fc bfc" id="L2178" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2179">            int n0 = a[i].length;</span>
<span class="fc" id="L2180">            m[i] = new double[n0];</span>
<span class="fc" id="L2181">            System.arraycopy(a[i], 0, m[i], 0, n0);</span>
        }
        
<span class="fc" id="L2184">        return m;</span>
    }
    
    public static void copy(double[][] source, double[][] destination) {
        
<span class="fc" id="L2189">        int m = source.length;</span>
<span class="fc" id="L2190">        int n = source[0].length;</span>
        
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">        if (destination.length != m) {</span>
<span class="nc" id="L2193">            throw new IllegalArgumentException(&quot;destination.length must equal source.length&quot;);</span>
        }
<span class="pc bpc" id="L2195" title="1 of 2 branches missed.">        if (destination[0].length != n) {</span>
<span class="nc" id="L2196">            throw new IllegalArgumentException(&quot;destination[0].length must equal source[0].length&quot;);</span>
        }
        
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        for (int i = 0; i &lt; source.length; ++i) {</span>
<span class="fc" id="L2200">            System.arraycopy(source[i], 0, destination[i], 0, n);</span>
        }        
<span class="fc" id="L2202">    }</span>
    
    /**
     * 
     * @param a
     * @param row0 beginning index, inclusive
     * @param row1 end index, inclusive
     * @param col0 beginning index, inclusive
     * @param col1 end index, inclusive
     * @return 
     */
    public static double[][] copySubMatrix(double[][] a, int row0, int row1, int col0, int col1) {
        
<span class="fc" id="L2215">        int nr2 = row1 - row0 + 1;</span>
<span class="fc" id="L2216">        int nc2 = col1 - col0 + 1;</span>
        
<span class="fc" id="L2218">        double[][] m = new double[nr2][];</span>
        int i, j;
<span class="fc bfc" id="L2220" title="All 2 branches covered.">        for (i = 0; i &lt; nr2; ++i) {</span>
<span class="fc" id="L2221">            m[i] = new double[nc2];</span>
<span class="fc" id="L2222">            System.arraycopy(a[row0 + i], col0, m[i], 0, nc2);</span>
        }
        
<span class="fc" id="L2225">        return m;</span>
    }
    
    /**
     * copy the section of matrix a from row0 to row1 (inclusive) and 
     * col0 to col1 (inclusive) into output matrix out which must
     * be size (row1-row0+1) X (col1-col0+1)
     * @param a
     * @param row0 beginning index, inclusive
     * @param row1 end index, inclusive
     * @param col0 beginning index, inclusive
     * @param col1 end index, inclusive
     * @param out output matrix to hold the copied section
     */
    public static void copySubMatrix(double[][] a, int row0, int row1, 
        int col0, int col1, double[][] out) {
        
<span class="fc" id="L2242">        int nr2 = row1 - row0 + 1;</span>
<span class="fc" id="L2243">        int nc2 = col1 - col0 + 1;</span>
        
<span class="pc bpc" id="L2245" title="2 of 4 branches missed.">        if (out.length != nr2 || out[0].length != nc2) {</span>
<span class="nc" id="L2246">            throw new IllegalArgumentException(&quot;out dimensions must be &quot;</span>
                    + &quot; row1 - row0 + 1 X col1 - col0 + 1&quot;);
        }
        
        int i, j;
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        for (i = 0; i &lt; nr2; ++i) {</span>
<span class="fc" id="L2252">            System.arraycopy(a[row0 + i], col0, out[i], 0, nc2);</span>
        }        
<span class="fc" id="L2254">    }</span>
    
    /**
     * 
     * @param a
     * @param col index of column to extract
     * @return one dimensional array holding the column col of a
     */
    public static double[] extractColumn(double[][] a, int col) {
                
<span class="fc" id="L2264">        double[] m = new double[a.length];</span>
<span class="fc" id="L2265">        extractColumn(a, col, m);</span>
<span class="fc" id="L2266">        return m;</span>
    }
    
    /**
     * 
     * @param a
     * @param col index of column to extract
     * @param out one dimensional array holding the column col of a
     */
    public static void  extractColumn(double[][] a, int col, double[] out) {
           
<span class="pc bpc" id="L2277" title="1 of 2 branches missed.">        if (out.length != a.length) {</span>
<span class="nc" id="L2278">            throw new IllegalArgumentException(&quot;out.length must equal a.length&quot;);</span>
        }
        
        int i;
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2283">            out[i] = a[i][col];</span>
        }        
<span class="fc" id="L2285">    }</span>
    
      /**
     * using cofactors and minors of the matrix, return the determinant.
     * in practice one can use any row as the primary set of cofactors or
     * any column.  this method may be optimized in the future, but for now,
     * uses the first column as the cofactors.
     *
     * e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
     *         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11
        + 135 + 2 = 148
     *         | 2   1  5 |
     * &lt;pre&gt;
     * Note that det(a) = 0 shows that matrix a is a singular matrix and is not
     * invertible.
     * &lt;/pre&gt;
     * @param a a square matrix
     * @return the determinant of matrix a
     */
    public static double determinant(Matrix a) {

<span class="fc" id="L2306">        double[][] ma = no.uib.cipr.matrix.Matrices.getArray(a);</span>

<span class="fc" id="L2308">        return determinant(ma);</span>
    }
    
    /**
     * using cofactors and minors of the matrix, return the determinant.
     * in practice one can use any row as the primary set of cofactors or
     * any column.  this method may be optimized in the future, but for now,
     * uses the first column as the cofactors.
     *
     * e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
     *         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11 + 135 + 2 = 148
     *         | 2   1  5 |
     * &lt;pre&gt;
     * Note that det(a) = 0 shows that matrix a is a singular matrix and is not
     * invertible.
     * &lt;/pre&gt;
     * @param a a square matrix
     * @return 
     */
    public static double determinant(double[][] a) {

<span class="pc bpc" id="L2329" title="2 of 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L2330">            throw new IllegalArgumentException(&quot;matrix a cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L2332" title="1 of 2 branches missed.">        if (a.length != a[0].length) {</span>
<span class="nc" id="L2333">            throw new IllegalArgumentException(&quot;matrix a must be square&quot;);</span>
        }
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        if (a.length == 1) {</span>
<span class="fc" id="L2336">            return a[0][0];</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">        } else if (a.length == 2) {</span>
<span class="fc" id="L2338">            double s = ( a[0][0]*a[1][1] ) - ( a[0][1]*a[1][0] );</span>
<span class="fc" id="L2339">            return s;</span>
        } else {
<span class="fc" id="L2341">            double s = 0.0;</span>
            // use 1st row as cofactors and minors
<span class="fc bfc" id="L2343" title="All 2 branches covered.">            for (int i = 0; i &lt; a.length; i++) {</span>

<span class="fc" id="L2345">                double[][] n = copyExcept(a, i, 0);</span>
                
<span class="fc" id="L2347">                double tmp = a[i][0] * determinant(n);</span>
                                
<span class="fc bfc" id="L2349" title="All 2 branches covered.">                if ((i &amp; 1) == 0) {</span>
<span class="fc" id="L2350">                    s +=  tmp;</span>
                } else {
<span class="fc" id="L2352">                    s -=  tmp;</span>
                }
            }
<span class="fc" id="L2355">            return s;</span>
        }
    }
    
    /**
     * calculate the determinant of a using the diagonal of U from the
     * LU decomposition.
     * 
     * @param a a square matrix
     * @return 
     */
    public static double determinantFromLU(double[][] a) {

<span class="pc bpc" id="L2368" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L2369">            throw new IllegalArgumentException(&quot;matrix a must be square&quot;);</span>
        }
<span class="pc bpc" id="L2371" title="3 of 4 branches missed.">        switch (a.length) {</span>
            case 0:
<span class="nc" id="L2373">                throw new IllegalArgumentException(&quot;matrix a length must be larger than 0&quot;);</span>
            case 1:
<span class="nc" id="L2375">                return a[0][0];</span>
            case 2: {
<span class="nc" id="L2377">                double s = ( a[0][0]*a[1][1] ) - ( a[0][1]*a[1][0] );</span>
<span class="nc" id="L2378">                return s;</span>
            }
            default: {
<span class="fc" id="L2381">                LU lu = LinearEquations.LUDecomposition(a);</span>
<span class="fc" id="L2382">                double d = 1;</span>
                int i;
<span class="fc bfc" id="L2384" title="All 2 branches covered.">                for (i = 0; i &lt; lu.u.length; ++i) {</span>
<span class="fc" id="L2385">                    d *= lu.u[i][i];</span>
                }
<span class="fc" id="L2387">                return d;</span>
            }
        }
    }
    
    /**
     * create copy of matrix m except row and col
     * @param m
     * @param col
     * @param row
     * @return
     */
    private static double[][] copyExcept(double[][] m, int col, int row) {

<span class="fc" id="L2401">        double[][] n = new double[m.length - 1][m.length - 1];</span>

<span class="fc" id="L2403">        int nr = 0;</span>
<span class="fc" id="L2404">        int nc = 0;</span>

<span class="fc bfc" id="L2406" title="All 2 branches covered.">        for (int mCol = 0; mCol &lt; m.length; mCol++) {</span>
<span class="fc bfc" id="L2407" title="All 2 branches covered.">            if (mCol == col) {</span>
<span class="fc" id="L2408">                continue;</span>
            }

<span class="fc" id="L2411">            n[nc] = new double[m.length - 1];</span>
            
<span class="fc" id="L2413">            nr = 0;</span>
<span class="fc bfc" id="L2414" title="All 2 branches covered.">            for (int mRow = 0; mRow &lt; m[0].length; mRow++) {</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">                if (mRow == row) {</span>
<span class="fc" id="L2416">                    continue;</span>
                }

<span class="fc" id="L2419">                n[nc][nr] = m[mCol][mRow];</span>
<span class="fc" id="L2420">                nr++;</span>
            }
<span class="fc" id="L2422">            nc++;</span>
        }

<span class="fc" id="L2425">        return n;</span>
    }
    
    /**
     * constructs the 3x3 skew-symmetric matrices for use in cross products,
     * notation is [v]_x.
     * the operator is also called &quot;hat operator&quot;.
     * v cross product with w is v X w = [v]_x * w.
     * Its individual terms are a_j_i = -a_i_j.
       &lt;pre&gt;
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |
       
       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       &lt;/pre&gt;
     * @param v
     * @return 
     */
    public static double[][] skewSymmetric(double[] v) {
<span class="pc bpc" id="L2445" title="1 of 2 branches missed.">        if (v.length != 3) { </span>
<span class="nc" id="L2446">            throw new IllegalArgumentException(&quot;v.length must be 3&quot;);</span>
        }
        
<span class="fc" id="L2449">        double[][] out = new double[3][3];</span>
<span class="fc" id="L2450">        skewSymmetric(v, out);</span>
<span class="fc" id="L2451">        return out;</span>
    }
    
    /**
     * constructs the 3x3 skew-symmetric matrices for use in cross products,
     * notation is [v]_x.
     * v cross product with w is v X w = [v]_x * w.
     * Its individual terms are a_j_i = -a_i_j.
       &lt;pre&gt;
       |    0   -v[2]   v[1] |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]      0  |
       
       Note that the skew symmetric matrix equals its own negative, i.e. A^T = -A.
       &lt;/pre&gt;
     * the operator is also called &quot;hat operator&quot;.
     * @param v
     * @param out 
     */
    public static void skewSymmetric(double[] v, double[][] out) {
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">        if (v.length != 3) { </span>
<span class="nc" id="L2472">            throw new IllegalArgumentException(&quot;v.length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L2474" title="2 of 4 branches missed.">        if (out.length != 3 || out[0].length != 3) { </span>
<span class="nc" id="L2475">            throw new IllegalArgumentException(&quot;out must be 3X3&quot;);</span>
        }
        
        /*
        out[0] = new double[]{0,     -v[2],  v[1]};
        out[1] = new double[]{v[2],     0,  -v[0]};
        out[2] = new double[]{-v[1], v[0],    0};
        */
        
<span class="fc" id="L2484">        out[0][0] = 0;</span>
<span class="fc" id="L2485">        out[0][1] = -v[2];</span>
<span class="fc" id="L2486">        out[0][2] = v[1];</span>
<span class="fc" id="L2487">        out[1][0] = v[2];</span>
<span class="fc" id="L2488">        out[1][1] = 0;</span>
<span class="fc" id="L2489">        out[1][2] = -v[0];</span>
<span class="fc" id="L2490">        out[2][0] = -v[1];</span>
<span class="fc" id="L2491">        out[2][1] = v[0];</span>
<span class="fc" id="L2492">        out[2][2] = 0;</span>
        
<span class="fc" id="L2494">    }</span>

    /**
     * extract the vector from a skew-symmetric matrix.  the operation is called vee operator.
     * @param vHat
     * @return
     */
    public static double[] extractVectorFromSkewSymmetric(double[][] vHat) {
<span class="nc" id="L2502">        double[] out = new double[3];</span>
<span class="nc" id="L2503">        out[0] = 0.5*(vHat[2][1] - vHat[1][2]);</span>
<span class="nc" id="L2504">        out[1] = 0.5*(vHat[0][2] - vHat[2][0]);</span>
<span class="nc" id="L2505">        out[2] = 0.5*(vHat[1][0] - vHat[0][1]);</span>
<span class="nc" id="L2506">        return out;</span>
    }
    
    public static double[] crossProduct(double[] p0, double[] p1) {
<span class="pc bpc" id="L2510" title="2 of 4 branches missed.">        if (p0.length != 3 || p1.length != 3) {</span>
<span class="nc" id="L2511">            throw new IllegalArgumentException(&quot;expecting p0 and p1 lengths to be 3&quot;);</span>
        }
<span class="fc" id="L2513">        double[] out = new double[3];</span>
<span class="fc" id="L2514">        out[0] = p0[1]*p1[2] - p0[2]*p1[1];</span>
<span class="fc" id="L2515">        out[1] = p0[2]*p1[0] - p0[0]*p1[2];</span>
<span class="fc" id="L2516">        out[2] = p0[0]*p1[1] - p0[1]*p1[0];</span>
<span class="fc" id="L2517">        return out;</span>
    }
    
    public static boolean areColinear(double[] p0, double[] p1, double eps) {
<span class="pc bpc" id="L2521" title="2 of 4 branches missed.">        if (p0.length != 3 || p1.length != 3) {</span>
<span class="nc" id="L2522">            throw new IllegalArgumentException(&quot;expecting p0 and p1 lengths to be 3&quot;);</span>
        }
<span class="fc" id="L2524">        double[] cp = crossProduct(p0, p1);</span>
<span class="fc" id="L2525">        double norm = lPSum(cp, 2);</span>
<span class="fc bfc" id="L2526" title="All 2 branches covered.">        return Math.abs(norm) &lt; eps;</span>
    }
    
    public static boolean areColinear(double[] p0, double[] p1, double[] p2, double eps) {
<span class="nc bnc" id="L2530" title="All 6 branches missed.">        if (p0.length != 3 || p1.length != 3 || p2.length != 3) {</span>
<span class="nc" id="L2531">            throw new IllegalArgumentException(&quot;expecting p0, p1 and p2 lengths to be 3&quot;);</span>
        }
        //adapted from code by Peter Kovesis for function 
        // iscolinear.m.  r =  norm(cross(p2-p1, p3-p1)) &lt; eps
        // https://www.peterkovesi.com/matlabfns/
<span class="nc" id="L2536">        double[] p21 = MatrixUtil.subtract(p1, p0);</span>
<span class="nc" id="L2537">        double[] p31 = MatrixUtil.subtract(p2, p0);</span>
<span class="nc" id="L2538">        double[] cp = crossProduct(p21, p31);</span>
<span class="nc" id="L2539">        double norm = lPSum(cp, 2);</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">        return Math.abs(norm) &lt; eps;</span>
    }
    
    /**
     * normalize vector v by euclidean, that is the square root of the sum of 
     * its squared components.  notation is sometimes ||v||_2.
     * @param v
     * @return 
     */
    public static double[] normalizeL2(double[] v) {
<span class="fc" id="L2550">        return normalizeLP(v, 2);</span>
    }
    
    /**
     * normalize each column of matrix a by the square root of the sum of 
     * its squared components. ||v||_2 for each column...
     * @param a matrix
     */
    public static void normalizeColumnsL2(double[][] a) {
        double sum;
        int j;
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        for (int i = 0; i &lt; a[0].length; ++i) {</span>
<span class="fc" id="L2562">            sum = 0;</span>
<span class="fc bfc" id="L2563" title="All 2 branches covered.">            for (j = 0; j &lt; a.length; ++j) {</span>
<span class="fc" id="L2564">                sum += (a[j][i]*a[j][i]);</span>
            }
<span class="fc" id="L2566">            sum = Math.sqrt(sum);</span>
<span class="fc bfc" id="L2567" title="All 2 branches covered.">            for (j = 0; j &lt; a.length; ++j) {</span>
<span class="fc" id="L2568">                a[j][i] /= sum;</span>
            }
        }
<span class="fc" id="L2571">    }</span>
    
    /**
     * normalize each row of matrix a by the square root of the sum of 
     * its squared components. ||v||_2 for each row...
     * @param a matrix
     */
    public static void normalizeRowsL2(double[][] a) {
        double sum;
        int j;
<span class="fc bfc" id="L2581" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2582">            sum = 0;</span>
<span class="fc bfc" id="L2583" title="All 2 branches covered.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc" id="L2584">                sum += (a[i][j]*a[i][j]);</span>
            }
<span class="fc" id="L2586">            sum = Math.sqrt(sum);</span>
<span class="fc bfc" id="L2587" title="All 2 branches covered.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc" id="L2588">                a[i][j] /= sum;</span>
            }
        }
<span class="fc" id="L2591">    }</span>
    
    /**
     * calculate the condition number as the largest singular value divided
     * by the singular value for i==(rank-1) of A where the singular values are
     * found using the SVD.
     &lt;pre&gt;
     from https://blogs.mathworks.com/cleve/2017/07/17/what-is-the-condition-number-of-a-matrix/
     A condition number for a matrix and computational task measures how
     sensitive the answer is to perturbations in the input data and to roundoff
     errors made during the solution process....If a matrix is singular,
     then its condition number is infinite.
     ...(A large condition number means that the matrix is close to being singular).

     also see Section 9.2 of Strang's &quot;Introduction to Linear Algebra&quot;.
     &lt;/pre&gt;
     * 
     * @param a
     * @return 
     */
    public static double conditionNumber(double[][] a) throws NotConvergedException {
        
<span class="nc" id="L2613">        SVDProducts svd = performSVD(a);</span>
<span class="nc" id="L2614">        int rm1 = -1;</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">        for (int i = 0; i &lt; svd.s.length; ++i) {</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">            if (svd.s[i] &gt; 0) {</span>
<span class="nc" id="L2617">                rm1 = i;</span>
            }
        }
<span class="nc bnc" id="L2620" title="All 2 branches missed.">        if (rm1 == -1) {</span>
<span class="nc" id="L2621">            throw new IllegalStateException(&quot;all singular values of a are 0&quot;);</span>
        }
<span class="nc" id="L2623">        double c = svd.s[0]/svd.s[rm1];</span>
        
<span class="nc" id="L2625">        return c;</span>
    }
    
    /**
     * summation = the (1/p) power of sum of 
     * its (components)^p.
     * @param v
     * @return 
     */
    public static double lPSum(double[] v, double p) {
<span class="fc" id="L2635">        double sum = 0;</span>
<span class="fc bfc" id="L2636" title="All 2 branches covered.">        for (double a : v) {</span>
<span class="fc" id="L2637">            sum += Math.pow(a, p);</span>
        }
<span class="fc" id="L2639">        sum = Math.pow(sum, 1./p);</span>
<span class="fc" id="L2640">        return sum;</span>
    }
    
    /**
    following the convention used by Matlab
    &lt;pre&gt;
    https://www.mathworks.com/help/matlab/ref/norm.html#bvhji30-3

    For p-norm = 1, the L1-norm is the maximum absolute column sum of the matrix.
    ||X||_1 = max sum for an arg j where (0.lte.j.lte.n-1) sum_(i=0 to n-1) ( |a[i][j] )
    &lt;/pre&gt;
    @param a
    @return the maximum absolute column sum of the matrix
    */
    public static int lp1Norm(int[][] a) {
<span class="fc" id="L2655">        int maxSum = Integer.MIN_VALUE;</span>
        int i, j, sum;
<span class="fc bfc" id="L2657" title="All 2 branches covered.">        for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc" id="L2658">            sum = 0;</span>
<span class="fc bfc" id="L2659" title="All 2 branches covered.">            for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2660">                sum += Math.abs(a[i][j]);</span>
            }
<span class="fc bfc" id="L2662" title="All 2 branches covered.">            if (sum &gt; maxSum) {</span>
<span class="fc" id="L2663">                maxSum = sum;</span>
            }
        }
<span class="fc" id="L2666">        return maxSum;</span>
    }
    
    /**
     * calculate the Frobenius Norm of matrix a.
     * It's the square root of the sum of squares of each element.
     * It can also be calculated as the square root of the
     * trace of a_conjugate*a, or as
     * the square root of the sums of the squares of the singular
     * values of a.
     * (The later can be compared to the spectral norm which is the largest singular value of a.)
     * @param a
     * @return 
     */
    public static double frobeniusNorm(double[][] a) {
<span class="fc" id="L2681">        double sum = 0;</span>
        int i, j;
<span class="fc bfc" id="L2683" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc bfc" id="L2684" title="All 2 branches covered.">            for (j = 0; j &lt; a[i].length; ++j) {</span>
<span class="fc" id="L2685">                sum += (a[i][j]*a[i][j]);</span>
            }
        }
<span class="fc" id="L2688">        return Math.sqrt(sum);</span>
    }

    /**
     * calculate the value of the largest singular value of matrix r.  this is the induced norm
     * which measures what is the maximum of  for any 0 (or, equivalently, the maximum of  for =1).
     * Note that the frobenius norm can be defined as the square root of the sums of the squares of the singular
     * values of and therefore can be different than the spectral norm.
     * &lt;pre&gt;
     *     reference for documentation:
     *     https://math.stackexchange.com/questions/33083/what-is-the-difference-between-the-frobenius-norm-and-the-2-norm-of-a-matrix
     * &lt;/pre&gt;
     * @param r
     * @return
     * @throws NotConvergedException
     */
    public static double spectralNorm(double[][] r) throws NotConvergedException {
<span class="fc" id="L2705">        SVDProducts svd = performSVDATransposeA(r);</span>
<span class="fc" id="L2706">        double norm = Math.sqrt(svd.s[0]);</span>
<span class="fc" id="L2707">        return norm;</span>
    }
    
    /**
     * Given a symmetric matrix and a nonnegative number eps, find the
     * nearest symmetric positive semidefinite matrices with eigenvalues at least eps.
     * &lt;pre&gt;
     * References:
     * https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
     * Cheng and Higham, 1998
     * 
     * &lt;/pre&gt;
     * @param a a symmetric matrix
     * @param eps a tolerance or error above 0 such as machine precision.  must
     * be greater than or equal to 0.  If it is above 0, this method attempts
     * to return a symmetric positive definite matrix.
     * @return 
     */
    public static double[][] nearestPositiveSemidefiniteToASymmetric(double[][] a,
        double eps) throws NotConvergedException {

<span class="pc bpc" id="L2728" title="1 of 2 branches missed.">        if (eps &lt; 0) {</span>
<span class="nc" id="L2729">            throw new IllegalArgumentException(&quot;eps must be .gte. 0&quot;);</span>
        }

<span class="fc bfc" id="L2732" title="All 2 branches covered.">        if (!isSymmetric(a, eps)) {</span>
<span class="fc" id="L2733">            System.err.println(&quot;matrix is not symmetric in current form&quot;);</span>
        }

        // uses the Frobenius norm as a distance.  notation: ||A||_F
        
        // spectral decomposition 
        //  X = Q * diag(tau_i) * Q^T
        //    where tau_i = {    lambda_i for lambda_i &gt;= eps
        //                  { or eps_i    for lambda_i &lt;  eps
        //        where lambda_i are the eigenvalues of A
        
<span class="fc" id="L2744">        EVD evd = EVD.factorize(new DenseMatrix(a));</span>
<span class="fc" id="L2745">        double[][] leftEV = MatrixUtil.convertToRowMajor(evd.getLeftEigenvectors());</span>
        
<span class="fc" id="L2747">        double[] tau = Arrays.copyOf(evd.getRealEigenvalues(), </span>
<span class="fc" id="L2748">            evd.getRealEigenvalues().length);</span>
        
        int i;
<span class="fc bfc" id="L2751" title="All 2 branches covered.">        for (i = 0; i &lt; tau.length; ++i) {</span>
<span class="fc bfc" id="L2752" title="All 2 branches covered.">            if (tau[i] &lt; eps) {</span>
<span class="fc" id="L2753">                tau[i] = eps;</span>
            }
        }
        
<span class="fc" id="L2757">        double[][] aPSD = MatrixUtil.multiplyByDiagonal(leftEV, tau);</span>
<span class="fc" id="L2758">        aPSD = MatrixUtil.multiply(aPSD, MatrixUtil.transpose(leftEV));</span>
        
        /*
        // another solution for X uses polar decomposition B = UH, 
        //     where U is orthogonal (U*U^T=I)
        //     and H is symmetric positive definite (H = H^T &gt;= 0)
        //         (with H = Q * diag(lambda_i) * Q^T.
        //         (where Q is svd.v)
        //
        //   since A is symmetric): 
        //   answer is X_F = (A + H)/2
        
        // can use polar decompositon on square matrices:
        double[][] b = MatrixUtil.pointwiseAdd(a, MatrixUtil.transpose(a));
        MatrixUtil.multiply(b, 0.5);
        
        QH qh = performPolarDecomposition(b);
        
        //X_F:
        double[][] aPSD2 = MatrixUtil.pointwiseAdd(a, qh.h);
        MatrixUtil.multiply(aPSD2, 0.5);
        */
        
<span class="fc" id="L2781">        return aPSD;</span>
    }

    /**
     * Given a matrix A that is not necessarily symmetric, find the
     * nearest symmetric matrix to A.
     * &lt;pre&gt;
     * References:
     * https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
     *
     * &lt;/pre&gt;
     * @param a a square matrix which can be non-symmetric.
     * @return
     */
    public static double[][] nearestSymmetricToA(double[][] a) {
<span class="pc bpc" id="L2796" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L2797">            throw new IllegalArgumentException(&quot;a must be square&quot;);</span>
        }
        //0.5 * (A + A^T)
<span class="fc" id="L2800">        int n = a.length;</span>
<span class="fc" id="L2801">        double[][] out = new double[n][];</span>
        int i, j;
<span class="fc bfc" id="L2803" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2804">            out[i] = new double[n];</span>
<span class="fc bfc" id="L2805" title="All 2 branches covered.">            for (j = 0; j &lt; a[i].length; ++j) {</span>
<span class="fc" id="L2806">                out[i][j] = 0.5 * (a[i][j] + a[j][i]);</span>
            }
        }
<span class="fc" id="L2809">        return out;</span>
    }
    
    /**
     * Given a matrix a that is not necessarily symmetric,
     * and a nonnegative number eps, find the
     * nearest symmetric positive definite matrices with eigenvalues at least eps.
     * Note that this method attempts to make it symmetric positive definite by
     * adding a small perturbation of size smallest eigenvalue to the diagonal
     * of the resulting matrix.  The result satisfies the broader, non-negative
     * definition of positive semi-definite matrix.
     * &lt;pre&gt;
     * References:
     * https://nhigham.com/2021/01/26/what-is-the-nearest-positive-semidefinite-matrix/
     * 
     * &lt;/pre&gt;
     * @param a a square matrix which can be non-symmetric.
     * @param eps a tolerance or error above 0 such as machine precision.  must
     * be greater than or equal to 0.  If it is above 0, this method attempts
     * to return a symmetric positive definite matrix.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static double[][] nearestPositiveSemidefiniteToA(double[][] a,
        double eps) throws NotConvergedException {

<span class="pc bpc" id="L2835" title="1 of 2 branches missed.">        if (eps &lt; 0) {</span>
<span class="nc" id="L2836">            throw new IllegalArgumentException(&quot;eps must be .gte. 0&quot;);</span>
        }
        // uses the Frobenius norm as a distance

<span class="pc bpc" id="L2840" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L2841">            System.err.println(&quot;matrix must be square for nearestPositiveSemidefiniteToA()&quot;);</span>
        }

        // uses the Frobenius norm as a distance.  notation: ||A||_F
        
        //     the symmetric part of A is matrix B = 0.5*(A + A^T)
        //     the skew-symmetric part of A is matrix C = 0.5*(A - A^T)
        //                          note that C = -C^T.
        
        // another solution for X uses polar decomposition B = UH, 
        //     where U is orthogonal (U*U^T=I)
        //     and H is symmetric positive definite (H = H^T &gt;= 0)
        //         (with H = Q * diag(lambda_i) * Q^T.
        //
        //   since A is symmetric): 
        //   answer is X_F = (A + H)/2
        
        // can use polar decomposition on square matrices:

<span class="fc" id="L2860">        double[][] b = nearestSymmetricToA(a);</span>

        /* another to method to solve for X_F = PSD
        // [Q,d] = eig(B,'vector'); X_F = Q*(max(d,0).*Q'); X_F = (X_F + X_F')/2;
        // where Q are the right eigenvectors, and D is a vector of corresponding eigenvalues
        EVD evdB = EVD.factorize(new DenseMatrix(b));
        double[][] q = MatrixUtil.convertToRowMajor(evdB.getRightEigenvectors());
        double[] d = evdB.getRealEigenvalues();
        double dMax = MiscMath0.findMax(d);
        double[][] xF = MatrixUtil.transpose(q);
        MatrixUtil.multiply(xF, dMax);
        xF = MatrixUtil.multiply(q, xF);
        xF = MatrixUtil.pointwiseAdd(xF, MatrixUtil.transpose(xF));
        MatrixUtil.multiply(xF, 0.5);
        EVD evdXF = EVD.factorize(new DenseMatrix(xF));
        double[] eigXF = evdXF.getRealEigenvalues();
        // no perturbations needed for xF
         */

        // H is formed from V, S, and V^T of SVD(B)
<span class="fc" id="L2880">        QH qh = performPolarDecomposition(b);</span>
<span class="fc" id="L2881">        double[][] h = qh.h;</span>
        
        //X = (B + H)/2.
<span class="fc" id="L2884">        double[][] aPSD = MatrixUtil.pointwiseAdd(b, h);</span>
<span class="fc" id="L2885">        MatrixUtil.multiply(aPSD, 0.5);</span>
        
        // check that all eigenvalues are &gt;= eps
<span class="fc" id="L2888">        EVD evd = EVD.factorize(new DenseMatrix(aPSD));</span>
        int i;
<span class="fc" id="L2890">        double[] eig = evd.getRealEigenvalues();</span>
<span class="fc" id="L2891">        boolean ok = true;</span>
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">        for (i = 0; i &lt; eig.length; ++i) {</span>
<span class="pc bpc" id="L2893" title="1 of 2 branches missed.">            if (eig[i] &lt; eps) {</span>
<span class="fc" id="L2894">                ok = false;</span>
<span class="fc" id="L2895">                break;</span>
            }
        }
<span class="pc bpc" id="L2898" title="1 of 2 branches missed.">        if (!ok) {</span>
            //System.out.printf(&quot;before: evd eigenvalues=%s\n&quot;, FormatArray.toString(evd.getRealEigenvalues(), &quot;%.5e&quot;));

            //still needs a small perturbation to make the eigenvalues all &gt;= eps
            // see https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/
        
<span class="fc" id="L2904">            double[] e = Arrays.copyOf(eig, eig.length);</span>
<span class="fc" id="L2905">            Arrays.sort(e);</span>
<span class="fc" id="L2906">            double eigMin = Math.max(-e[0], eps);</span>
<span class="fc" id="L2907">            double[][] D = MatrixUtil.zeros(a.length, a.length);</span>
<span class="fc bfc" id="L2908" title="All 2 branches covered.">            for (i = 0; i &lt; D.length; ++i) {</span>
<span class="fc" id="L2909">                D[i][i] = eigMin;</span>
            }
<span class="fc" id="L2911">            aPSD = MatrixUtil.pointwiseAdd(aPSD, D);</span>
            //evd = EVD.factorize(new DenseMatrix(aPSD));
            //System.out.printf(&quot;after:  evd eigenvalues=%s\n&quot;, FormatArray.toString(evd.getRealEigenvalues(), &quot;%.5e&quot;));
        }
        
<span class="fc" id="L2916">        return aPSD; </span>
    }
    
    /**
     * normalize vector v by power p, that is the (1/p) power of sum of 
     * its (components)^p.  notation is sometimes ||v||_p.
     * when p = 0, this is the manhattan normalization or taxi-cab normalization,
     * when p = 2, this is the euclidean normalization.
     * @param v
     * @return 
     */
    public static double[] normalizeLP(double[] v, double p) {
<span class="fc" id="L2928">        double sum = 0;</span>
<span class="fc bfc" id="L2929" title="All 2 branches covered.">        for (double a : v) {</span>
<span class="fc" id="L2930">            sum += Math.pow(a, p);</span>
        }
<span class="fc" id="L2932">        sum = Math.pow(sum, 1./p);</span>
<span class="fc" id="L2933">        double[] out = Arrays.copyOf(v, v.length);</span>
<span class="fc bfc" id="L2934" title="All 2 branches covered.">        for (int i = 0; i &lt; v.length; ++i) {</span>
<span class="fc" id="L2935">            out[i] /= sum;</span>
        }
<span class="fc" id="L2937">        return out;</span>
    }
    
    /**
     * the outer product of vectors v1 and v2, which is v1 as a single row matrix
     * and v2 as a single column matrix, so is v1 * v2^T.
     * @param v1
     * @param v2
     * @return the outer product of v1 and v2 as double array of 
     * size v1.length X v2.length.
     */
    public static double[][] outerProduct(double[] v1, double[] v2) {
<span class="fc" id="L2949">        int n = v1.length;</span>
<span class="fc" id="L2950">        int m = v2.length;</span>
<span class="fc" id="L2951">        double[][] out = new double[n][m];</span>
<span class="fc bfc" id="L2952" title="All 2 branches covered.">        for (int row = 0; row &lt; n; ++row) {</span>
<span class="fc bfc" id="L2953" title="All 2 branches covered.">            for (int col = 0; col &lt; m; ++col) {</span>
<span class="fc" id="L2954">                out[row][col] = v1[row] * v2[col];</span>
            }
        }
<span class="fc" id="L2957">        return out;</span>
    }
    
    /**
     * determine the largest eigenvalue using the power method.  note that
     * matrix A must be diagonalizable, that is, a positive definite matrix.
     * for best results, perform standard normalization on matrix A first
     * because the first initial guess of an eigenvector of a is composed
     * of random values between [0 and 1).
     * The method is implemented from pseudocode in Golub and van Loan 
     * &quot;Matrix Computations&quot;.
     * 
     * calculates lambda in lambda * v = M * v for some constant eigenvalue lambda.
     * 
     * NOTE that the number of necessary iterations is dependent upon
     * how close the largest and second largest eigenvalues are and that ratio
     * tends to be near &quot;1&quot; for large matrices and in that case, the power
     * method isn't the right method (consider QR or SVD).
     * TODO:consider implementing the inverse power method also to determine the
     * smallest eigenvalue and its eigenvector
     * @param a a positive definite matrix
     * @param nIterations
     * @return 
     */
    public static double powerMethod(double[][] a, int nIterations) {

        // is diagonalizable.   From wikipedia: &quot;Real symmetric matrices are diagonalizable by orthogonal matrices; i.e.,
        // given a real symmetric matrix A, Q^T * A * Q is diagonal for some orthogonal matrix Q
<span class="pc bpc" id="L2985" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L2986">            throw new IllegalArgumentException(&quot;a must be a square matrix&quot;);</span>
        }
        
        // v_k = A^k * v_0  = (c_1*(lambda_1)^k * x_1) + ... (c_n*(lambda_n)^k * x_n)

<span class="fc" id="L2991">        int nR = a.length;</span>
<span class="fc" id="L2992">        double[] v = new double[nR];</span>
        double[] z;
        double norm;
<span class="fc" id="L2995">        double eig = 0;</span>
        int row;
        
<span class="fc" id="L2998">        Random rand = Misc0.getSecureRandom();</span>
<span class="fc" id="L2999">        long seed = System.nanoTime();</span>
        //System.out.println(&quot;SEED=&quot; + seed);
<span class="fc" id="L3001">        rand.setSeed(seed);</span>
        //avoid orthogonal first guess at v using randomization.
<span class="fc bfc" id="L3003" title="All 2 branches covered.">        for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3004">            v[row] = rand.nextDouble();</span>
        }
            
<span class="fc bfc" id="L3007" title="All 2 branches covered.">        for (int i = 0; i &lt; nIterations; ++i) {</span>
            
<span class="fc" id="L3009">            z = MatrixUtil.multiplyMatrixByColumnVector(a, v);</span>
<span class="fc" id="L3010">            norm = 0;</span>
<span class="fc bfc" id="L3011" title="All 2 branches covered.">            for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3012">                norm += (z[row]*z[row]);</span>
            }
<span class="fc" id="L3014">            norm = Math.sqrt(norm);</span>
<span class="fc" id="L3015">            eig = norm;</span>
<span class="fc bfc" id="L3016" title="All 2 branches covered.">            for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3017">                v[row] = z[row] / eig;</span>
            }
            //System.out.printf(&quot;eig=%.3f\n  v=%s\n  z=%s\n&quot;, eig, Arrays.toString(v),
            //    Arrays.toString(z));
        }
<span class="fc" id="L3022">        return eig;</span>
    }
    
    /**
     * determine the largest eigenvalue using the power method.  note that
     * matrix A must be diagonalizable, that is, a positive definite matrix.
     * for best results, perform standard normalization on matrix A first
     * because the first initial guess of an eigenvector of a is composed
     * of random values between [0 and 1).
     * The method is implemented from pseudocode in Golub and van Loan 
     * &quot;Matrix Computations&quot;.
     * NOTE that the number of necessary iterations is dependent upon
     * how close the largest and second largest eigenvalues are and that ratio
     * tends to be near &quot;1&quot; for large matrices and in that case, the power
     * method isn't the right method (consider QR or SVD).
     * @param a a positive definite matrix
     * @param tolerance iterations are stopped when the current multiplication vector
     * difference from previous is smaller than tolerance for each item.
     * @param x an initialized vector of size a.length that will be filled by
     * this method to hold the vector used to calculate eig = x^T * a * x
     * @return 
     */
    public static double powerMethod(double[][] a, double tolerance, double[] x) {
<span class="fc" id="L3045">        int nR = a.length;</span>
<span class="fc" id="L3046">        double[] v = new double[nR];</span>
        double[] z;
        double norm, t;
<span class="fc" id="L3049">        double eig = 0;</span>
        int row, stop;
        
<span class="fc" id="L3052">        Random rand = Misc0.getSecureRandom();</span>
<span class="fc" id="L3053">        long seed = System.nanoTime();</span>
        //System.out.println(&quot;SEED=&quot; + seed);
<span class="fc" id="L3055">        rand.setSeed(seed);</span>
        //avoid orthogonal first guess at v using randomization.
<span class="fc bfc" id="L3057" title="All 2 branches covered.">        for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3058">            v[row] = rand.nextDouble();</span>
        }
        
<span class="fc" id="L3061">        int nIter = 0;</span>
        
        while (true) {
                        
<span class="fc" id="L3065">            z = MatrixUtil.multiplyMatrixByColumnVector(a, v);</span>
<span class="fc" id="L3066">            norm = 0;</span>
<span class="fc bfc" id="L3067" title="All 2 branches covered.">            for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3068">                norm += (z[row]*z[row]);</span>
            }
<span class="fc" id="L3070">            norm = Math.sqrt(norm);</span>
<span class="fc" id="L3071">            eig = norm;</span>
<span class="fc" id="L3072">            stop = 1;</span>
<span class="fc bfc" id="L3073" title="All 2 branches covered.">            for (row = 0; row &lt; nR; ++row) {</span>
<span class="fc" id="L3074">                t = z[row]/eig;</span>
<span class="fc bfc" id="L3075" title="All 2 branches covered.">                if (Math.abs(v[row] - t) &gt; tolerance) {</span>
<span class="fc" id="L3076">                    stop = 0;</span>
                }
<span class="fc" id="L3078">                v[row] = t;</span>
            }
<span class="fc bfc" id="L3080" title="All 2 branches covered.">            if (stop == 1) {</span>
<span class="fc" id="L3081">                break;</span>
            }
            //System.out.printf(&quot;nIter=%d eig=%.3f\n  v=%s\n  z=%s\n&quot;, nIter, 
            //    eig, Arrays.toString(v), Arrays.toString(z));
<span class="fc" id="L3085">            nIter++;</span>
        }
<span class="fc" id="L3087">        System.arraycopy(v, 0, x, 0, v.length);</span>
<span class="fc" id="L3088">        return eig;</span>
    }
    
     /**
     * determine the largest eigenvalue using the power method.  note that
     * array a must be diagonalizable, that is, a positive definite matrix.
     * for best results, perform standard normalization on matrix a first
     * because the first initial guess of an eigenvector of a is composed
     * of random values between [0 and 1).
     * The method is implemented from pseudocode in Golub and van Loan 
     * &quot;Matrix Computations&quot;.
     * NOTE that the number of necessary iterations is dependent upon
     * how close the largest and second largest eigenvalues are and that ratio
     * tends to be near &quot;1&quot; for large matrices and in that case, the power
     * method isn't the right method (consider QR or SVD).
     * @param a a positive definite matrix
     * @param tolerance iterations are stopped when the current multiplication vector
     * difference from previous is smaller than tolerance for each item.
     * @return 
     */
    public static double powerMethod(double[][] a, double tolerance) {
<span class="fc" id="L3109">        double[] x = new double[a.length];</span>
<span class="fc" id="L3110">        return powerMethod(a, tolerance, x);</span>
    }
    
    /**
     * determine the eigenvalue pairs using the power method.  note that
     * array a must be diagonalizable, that is, a positive definite matrix.
     * for best results, perform standard normalization on matrix a first
     * because the first initial guess of an eigenvector of a is composed
     * of random values between [0 and 1).
     * The method follows &quot;Mining of Massive Datasets&quot; by Leskovec, Rajaraman,
     * and Ullman.  http://www.mmds.org/
     * @param a a positive definite matrix
     * @param tolerance iterations are stopped when the current multiplication vector
     * difference from previous is smaller than tolerance for each item.
     * @return an array of a.length eigenvectors
     */
    public static double[] powerMethodEigenPairs(double[][] a, double tolerance) {
        
<span class="fc" id="L3128">        double[] x = new double[a.length];</span>
        double eig;
<span class="fc" id="L3130">        double[] eigs = new double[a.length];</span>
        double[][] x2, a2;
        
<span class="fc bfc" id="L3133" title="All 2 branches covered.">        for (int nr = 0; nr &lt; a.length; ++nr) {</span>
            
<span class="fc" id="L3135">            eigs[nr] = powerMethod(a, tolerance, x);</span>
            
<span class="fc" id="L3137">            x2 = outerProduct(x, x);</span>
<span class="fc" id="L3138">            a2 = copy(a);</span>
<span class="fc bfc" id="L3139" title="All 2 branches covered.">            for (int i = 0; i &lt; a2.length; ++i) {</span>
<span class="fc bfc" id="L3140" title="All 2 branches covered.">                for (int j = 0; j &lt; a2[i].length; ++j) {</span>
<span class="fc" id="L3141">                    a2[i][j] -= (eigs[nr] * x2[i][j]);</span>
                }
            }
<span class="fc" id="L3144">            a = a2;</span>
            
<span class="fc" id="L3146">            System.out.printf(&quot;eig[%d]=%.5f x=%s\n&quot;, nr, eigs[nr], Arrays.toString(x));</span>
<span class="fc" id="L3147">            System.out.println(&quot;  a2=\n&quot;);</span>
<span class="fc bfc" id="L3148" title="All 2 branches covered.">            for (int i = 0; i &lt; a2.length; ++i) {</span>
<span class="fc" id="L3149">                System.out.printf(&quot;  %s\n&quot;, Arrays.toString(a2[i]));</span>
            }
        }
                
<span class="fc" id="L3153">        return eigs;</span>
    }
    
    /**
     * calculate (matrix A)^power using it's eigen decompostion:
     * A^power = S * (Delta^power) * S^-1
     * where S holds eigenvectors in its columns.  Delta is a diagonal matrix
     * holding the eigenvalues.
     * @param a a square matrix
     * @param power
     * @return 
     */
    public double[][] powerOf(double[][] a, int power) throws NotConvergedException {
<span class="nc bnc" id="L3166" title="All 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L3167">            throw new IllegalArgumentException(&quot;matrix a must be square&quot;);</span>
        }
<span class="nc" id="L3169">        double eps = 1E-15;</span>
<span class="nc" id="L3170">        MatrixUtil.SVDProducts svd = MatrixUtil.performSVD(a);</span>
        
<span class="nc" id="L3172">        int rank = 0;</span>
<span class="nc bnc" id="L3173" title="All 2 branches missed.">        for (double sv : svd.s) {</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">            if (sv &gt; eps) {</span>
<span class="nc" id="L3175">                rank++;</span>
            }
        }
        
<span class="nc bnc" id="L3179" title="All 2 branches missed.">        if (rank &lt; svd.u.length) {</span>
            // this case has eigenvalues that are 0.
            //  det(A - lambda*I) = 0, so is not diagonalizable.
<span class="nc" id="L3182">            throw new IllegalStateException(&quot;there are eigenvalues with value 0, so matrix a is not diagonalizable&quot;);</span>
        }
        
<span class="nc" id="L3185">        double[] d = new double[a.length];</span>
<span class="nc bnc" id="L3186" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L3187">            d[i] = Math.pow(svd.s[i], power);</span>
        }
                
<span class="nc" id="L3190">        double[][] s = svd.u;</span>
        
        double[][] sInv;
        // check that the eigenvectors are independent.
        // using left divide notation:
        //  x = A\B solves the system of linear equations A*x = B for x.
        //  X = A\B in MTJ is X = A.solve(B, X), that is, inputs are A and B.
        //  S*S^-1 = I
        //  S.solve(I, sInv) to get sInv using MTJ:
<span class="nc" id="L3199">        DenseMatrix _sInv = new DenseMatrix(s.length, s.length);</span>
<span class="nc" id="L3200">        _sInv = (DenseMatrix) new DenseMatrix(s).solve(</span>
<span class="nc" id="L3201">             new DenseMatrix(MatrixUtil.createIdentityMatrix(s.length)), </span>
             _sInv);
<span class="nc" id="L3203">        sInv = MatrixUtil.convertToRowMajor(_sInv);</span>
 
        /*
            // check this condition... S not invertible so check math in A = S^-1 * Delta * S
            //                         where S^-1 is pseudoinverse
            //sInv = svd(s).V * pseudoinverse(svd(s).s) * svd(s).U^T
            sInv = MatrixUtil.pseudoinverseRankDeficient(s, false);
            double[][] chk = MatrixUtil.multiply(s, sInv);
            System.out.printf(&quot;check S*S^-1 ~ I:\n%s\n&quot;, FormatArray.toString(chk, &quot;%.5e&quot;));
        */
        
        // A = S^-1 * delta^power * S
<span class="nc" id="L3215">        double[][] aP = MatrixUtil.multiply(MatrixUtil.multiplyByDiagonal(s, d), sInv);</span>
        
<span class="nc" id="L3217">        return aP;</span>
    }
    
    /**
     * calculate the square root of symmetric positive definite matrix A using SVD.
     * 
     * &lt;pre&gt;
     *    [U, S, V] = svd(A)
     *    J = V * S^(1/2) * V^T is a symmetric nn matrix, such that square root of A = JJ.
     *    J is non-negative definite.
     * &lt;/pre&gt;
     * from Allan Jepson's lecture on Gilbert Strang's SVD in machine learning
     * http://www.cs.toronto.edu/~jepson/csc420/notes/introSVD.pdf
     * Also see Chap 7.4 of &quot;Introduction to LinearAlgebra&quot; by Strang, the section
     * on Polar Decomposition.
     * @param a a square symmetric positive definite matrix.  If the matrix is not
     *          positive definite matrix, use nearestPositiveSemidefiniteToA() first.
     * @throws no.uib.cipr.matrix.NotConvergedException
     */
    public static double[][] squareRoot(double[][] a) throws NotConvergedException {

<span class="pc bpc" id="L3238" title="1 of 2 branches missed.">        if (!MatrixUtil.isPositiveDefinite(a)) {</span>
<span class="nc" id="L3239">            throw new IllegalArgumentException(&quot;a must be a non-negative definite matrix&quot;);</span>
        }
                
<span class="fc" id="L3242">        int m = a.length;</span>
<span class="fc" id="L3243">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3245" title="1 of 2 branches missed.">        if (m &lt; n) {</span>
<span class="nc" id="L3246">            a = MatrixUtil.transpose(a);</span>
<span class="nc" id="L3247">            m = a.length;</span>
<span class="nc" id="L3248">            n = a[0].length;</span>
        }
        
        // limit for a number to be significant above 0
<span class="fc" id="L3252">        double eps = 1e-16;</span>

<span class="fc" id="L3254">        DenseMatrix aMatrix = new DenseMatrix(a);</span>
<span class="fc" id="L3255">        SVD svd = SVD.factorize(aMatrix); // U is mxn; S=nxn; V=nxn</span>
        
        // s is an array of size min(m,n)  which is nxn here
<span class="fc" id="L3258">        double[] s = svd.getS();</span>
        
<span class="fc" id="L3260">        double[][] sMatrix = new double[n][n];</span>
<span class="fc bfc" id="L3261" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3262">            sMatrix[i] = new double[n];</span>
<span class="fc" id="L3263">            sMatrix[i][i] = Math.sqrt(s[i]);</span>
        }
        
<span class="fc" id="L3266">        int rank = 0;</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">        for (double sv : s) {</span>
<span class="pc bpc" id="L3268" title="1 of 2 branches missed.">            if (sv &gt; eps) {</span>
<span class="fc" id="L3269">                rank++;</span>
            }
        }
        // the number of distinct non-zero eigenvalues is rank.
        // there are 2^(rank) square roots
        
        /*
        S has singular values along the diagonal and those are the square roots 
        of positive eigenvalues of A.  the number of them is == the rank of A.
        NOTE the singular values are the eigenvalues of A*A^T of A^T*A.
        
        S = [ sqrt(_1)     0        ...
            [     0      sqrt(_2)   ...
        
        */
                
        /*
        U is mxm orthonormal columns
        S is mxn with non-negative singular values.  rank is number of non-zero entries
        V is  nxn
        
            [nxn] * [nxn] * [nxn]
        J = V * S^(1/2) * V^T  is [nxn]
        */       
                 
        /*
          a00  a01   s00  0 
          a10  a11     0  s11
          a20  a21
        
        a_r0_c0 * s_r0_c0 + 0(=s_r1_c0)    0(=s_r0_c1) + a_r0_c1 * s_r1_c1
        a_r1_c0 * s_r0_c0 + 0(=s_r1_c0)    0(=s_r0_c1) + a_r1_c1 * s_r1_c1
        a_r2_c0 * s_r0_c0 + 0(=s_r1_c0)    0(=s_r0_c1) + a_r2_c1 * s_r1_c1
        =
        a_r0_c0 * s[0]    a_r0_c1 * s[1]
        a_r1_c0 * s[0]    a_r1_c1 * s[1]
        a_r2_c0 * s[0]    a_r2_c1 * s[1]
        */
<span class="fc" id="L3307">        DenseMatrix vT = (DenseMatrix) svd.getVt();</span>
        //DenseMatrix u = (DenseMatrix) svd.getU();
        
<span class="fc" id="L3310">        double[][] _vT = Matrices.getArray(vT);</span>
      
<span class="fc" id="L3312">        double[][] j = MatrixUtil.multiply(MatrixUtil.transpose(_vT), sMatrix);</span>
<span class="fc" id="L3313">        j = MatrixUtil.multiply(j, _vT);</span>

        // Strang,&quot;Introduction to Linear Algebra&quot;, chap 7, Section Polar Decomposition&quot;
        // A = U *  * V^T
        //   = (U * V^T) * (V *  * V^T)
        //   =  (Q)      *  (H)

<span class="fc" id="L3320">        return j;</span>
    }
    
    public static boolean isSquare(double[][] a) {
<span class="pc bpc" id="L3324" title="1 of 2 branches missed.">        return (a.length == a[0].length);</span>
    }

    /**
     *  checks for a_ij == a_ji.  no normalization for row factors is made.
     *  that is, there may be a factor which makes the matrix symmetric.
     // e.g. [33, 24]
     //      [48, 57] &lt;--- divide by 2 and the matrix is symmetric
     //
     * @param a
     * @return
     */
    public static boolean isSymmetric(double[][] a, double tol) {
<span class="pc bpc" id="L3337" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L3338">            return false;</span>
        }
        // compare aij with aji

<span class="fc" id="L3342">        int n = a.length;</span>
        int i, j;
<span class="fc bfc" id="L3344" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L3345" title="All 2 branches covered.">            for (j = i; j &lt; n; ++j) {</span>
<span class="fc bfc" id="L3346" title="All 2 branches covered.">                if (Math.abs(a[i][j] - a[j][i]) &gt; tol) {</span>
<span class="fc" id="L3347">                    return false;</span>
                }
            }
        }

        // if false, there may be a factor which makes the matrix symmetric.
        // e.g. [33, 24]
        //      [48, 57] &lt;--- divide by 2 and the matrix is symmetric
        //

<span class="fc" id="L3357">        return true;</span>
    }
    
    public static boolean isPositiveSymmetric(double[][] a) {
<span class="nc bnc" id="L3361" title="All 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L3362">            return false;</span>
        }
                        
<span class="nc" id="L3365">        double tol = 1e-3;</span>
<span class="nc" id="L3366">        int n = a.length;</span>
        int i, j;
<span class="nc bnc" id="L3368" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L3369" title="All 2 branches missed.">            for (j = i; j &lt; n; ++j) {</span>
<span class="nc bnc" id="L3370" title="All 4 branches missed.">                if (Math.abs(a[i][j]) &lt; 1e-17 || Math.abs(a[j][i]) &lt; 1e-17) {</span>
<span class="nc" id="L3371">                    return false;</span>
                }
<span class="nc bnc" id="L3373" title="All 2 branches missed.">                if (Math.abs(a[i][j] - a[j][i]) &gt; tol) {</span>
<span class="nc" id="L3374">                    return false;</span>
                }
            }
        }
<span class="nc" id="L3378">        return true;</span>
    }
    
    /**
     * holds data structures for having solved for the vector x which is the
     * closest to a given vector b in the subspace defined by A which is
     * n columns of linearly independent vectors of length m (they are in 
     * real space R^m).
     * x is an approximation so is noted as x^{hat}.
     * the projection p = A*x^{hat}.
     * The matrix projection P = p*b.
     */
    public static class ProjectionResults {
        double[] x;
        double[] p;
        double[][] pMatrix;
    }
    /**
     * solve for the vector x which is the closest to a given vector b in the 
     * subspace defined by A which is n columns of linearly independent vectors 
     * of length m (they are in real space R^m).
     * x is an approximation so is noted as x^{hat}.
     * the projection p = A*x^{hat}.
     * The matrix projection P = p*b.
     * @param a subspace defined by A which is n columns of linearly 
     * independent vectors of length m (they are in real space R^m).
     * @param b 
     * @return 
     */
    public static ProjectionResults projection(double[][] a, double[] b) throws NotConvergedException {
        
        /*
        from Chap 4 of the book &quot;Introduction to Linear Algebra&quot; by W Gilbert Strang,
           x^{hat} = (A^T*A)^-1 * A^T * b
         and p = A * x^{hat}
         and P = p * b
        */
        
<span class="fc" id="L3416">        ProjectionResults pr = new ProjectionResults();</span>
        
        // A_pseudoinverse = inverse(A^T*A) * A^T 
        // [a[0].length][a.length]
<span class="fc" id="L3420">        double[][] aPseudoInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
        
<span class="fc" id="L3422">        pr.x = MatrixUtil.multiplyMatrixByColumnVector(aPseudoInv, b);</span>
        
<span class="fc" id="L3424">        pr.p = MatrixUtil.multiplyMatrixByColumnVector(a, pr.x);</span>
        
<span class="fc" id="L3426">        pr.pMatrix = MatrixUtil.multiply(a, aPseudoInv);</span>
        
<span class="fc" id="L3428">        return pr;</span>
    }
    
    /**
     * A matrix is positive definite if its symmetric and all its eigenvalues are positive,
     * which means its pivots are positive.  a quick test is that x^T * A * x is strictly positive for every non-zero
     * column vector x of n real numbers where A is n x n.
     * Every positive definite matrix can be factored into L*D*L^T with positive pivots.
     * Also note that if a hasnindependent columns (r==n), A^T*A is positive definite.
     * @param a
     * @return 
     */
    public static boolean isPositiveDefinite(double[][] a) {

<span class="fc bfc" id="L3442" title="All 2 branches covered.">        if (!isSymmetric(a, 1E-7)) {</span>
<span class="fc" id="L3443">            System.err.println(&quot;matrix is not symmetric in current form&quot;);</span>
            //return false;
        }
        
        /*
        from Strang &quot;Introduction to Linear Algebra&quot;, chapter 6.5.
        
        matrix A is positive definite for every non-zero vector x if x^T*A*x &gt; 0 
        
        when a symmetric nxn matrix has 1 of these 4, it has all 4:
            1) both eigenvectors are positive
               Note: mathworks recommends a tolerance for error, so all eigenvalues &gt; tolerance above 0.
            2) all upper left determinants (the 1x1 and 2x2 ... ) are positive
            3) the pivots are positive a&gt;0 and a*c-b^2&gt;0
            4) the function x^T * A * x is positive except at x = 0
        */

<span class="fc" id="L3460">        int n = a.length;</span>
        int i;

<span class="fc" id="L3463">        double[] x = new double[n];</span>
<span class="fc bfc" id="L3464" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3465">            x[i] = i + 1;</span>
        }
<span class="fc" id="L3467">        double p = MatrixUtil.innerProduct(MatrixUtil.multiplyRowVectorByMatrix(x, a), x);</span>
        //return p &gt; 0;

        // using rule that left upward rooted determinants &gt; 0
        double[][] sa;
        double det;
<span class="fc bfc" id="L3473" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3474">            sa = MatrixUtil.copySubMatrix(a, 0, i, 0, i);</span>
<span class="fc" id="L3475">            det = MatrixUtil.determinant(sa);</span>
<span class="pc bpc" id="L3476" title="1 of 2 branches missed.">            if (det &lt; 0) {</span>
<span class="nc" id="L3477">                return false;</span>
            }
        }
<span class="fc" id="L3480">        return true;</span>
    }
    
        /*
         * e.g.    | 1  -5  2 |         | 3 4 |         | 7 4 |         | 7 3 |
         *         | 7   3  4 |  =  1 * | 1 5 |  +  5 * | 2 5 |  +  2 * | 2 1 |  = 11 + 135 + 2 =
 148
         *         | 2   1  5 |
         *
         *          3 4     7  4    7  3
         *          1 5     2  5    2  1
         * 
         *         -5 2     1  2    1 -5
         *          1 5     2  5    2  1
         *
         *         -5 2     1  2    1 -5
         *          3 4     7  4    7  3
    */
    public static double[][] createCofactor(double[][] m) {

<span class="fc" id="L3500">        int ncols = m.length;</span>
<span class="fc" id="L3501">        int nrows = m[0].length;</span>

<span class="fc" id="L3503">        double[][] cofactor = new double[ncols][nrows];</span>

<span class="fc bfc" id="L3505" title="All 2 branches covered.">        for (int i = 0; i &lt; ncols; i++) {</span>
            
<span class="fc" id="L3507">            cofactor[i] = new double[nrows];</span>

<span class="fc bfc" id="L3509" title="All 2 branches covered.">            boolean si = ((i &amp; 1) == 1); // sign is -</span>

<span class="fc bfc" id="L3511" title="All 2 branches covered.">            for (int j = 0; j &lt; nrows; j++) {</span>

<span class="fc bfc" id="L3513" title="All 2 branches covered.">                boolean sj = ((j &amp; 1) == 1); // sign is -</span>

<span class="fc" id="L3515">                double[][] n = copyExcept(m, i, j);</span>

<span class="fc" id="L3517">                double cfctr = determinant(n);</span>

<span class="fc bfc" id="L3519" title="All 2 branches covered.">                if (si ^ sj) { // XOR if either is 1 but not both</span>
<span class="fc" id="L3520">                    cfctr = -1*cfctr;</span>
                }

<span class="fc" id="L3523">                cofactor[i][j] = cfctr;</span>
            }
         }
<span class="fc" id="L3526">        return cofactor;</span>
    }
    
    /**
     * find the equation for which A * A^(-1) = the identity matrix using cramer's rule.
     * 
     * note that for a to be invertible, none of its eigenvalues can be 0.
     * also note that if the number of linearly independent vectors os matrix
     * A is equal to the number of columns of A, one can use the spectral
     * decomposition: A^-1 = Q * (delta)^-1 * Q^-1
     * where Q is a matrix whose columns hold eigenvectors and delta is a diagonal
     * matrix holding the eigenvalues.
     *
     *             1
     * A^(-1) =  ------ C^(T)  where C_ij = cofactor of a_ij
     *            det A
     *
     * @param m a square invertible matrix.
     * @return
     */
    public static double[][] inverse(double[][] m) {

        // create cofactor of matrix:
<span class="fc" id="L3549">        double[][] cofactor = createCofactor(m);</span>

<span class="fc" id="L3551">        double[][] cofactorTransposed = transpose(cofactor);</span>

<span class="fc" id="L3553">        double det = determinant(m);</span>

<span class="fc" id="L3555">        multiply(cofactorTransposed, 1./det);</span>

<span class="fc" id="L3557">        return cofactorTransposed;</span>
    }
    
    /**
     * given a as vectors of data of nSamples of nVariables, return the
     * mean of each of the variables. 
     * note that the format must be a[nSamples][nVariables],
     * e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
     * and nVariables = 3;
     * @param a
     * @return mean of each column as an array of size a[0].length
     */
    public static double[] mean(double[][] a) {
<span class="fc" id="L3570">        int nSamples = a.length;</span>
<span class="fc" id="L3571">        int nVariables = a[0].length;</span>
        
        int i, j;
<span class="fc" id="L3574">        double[] mean = new double[nVariables];</span>
        double sum;
<span class="fc bfc" id="L3576" title="All 2 branches covered.">        for (j = 0; j &lt; nVariables; ++j) {</span>
<span class="fc" id="L3577">            sum = 0;</span>
<span class="fc bfc" id="L3578" title="All 2 branches covered.">            for (i = 0; i &lt; nSamples; ++i) {</span>
<span class="fc" id="L3579">                sum += (a[i][j]);</span>
            }
<span class="fc" id="L3581">            mean[j] = sum/(double)nSamples;</span>
        }
<span class="fc" id="L3583">        return mean;</span>
    }
    
    /**
     * given a as vectors of data of nSamples of nVariables, return the
     * mean of each of the variables. 
     * note that the format must be a[nSamples][nVariables],
     * e.g. a[0] = [10, 100, 1000]', a[1] = [9, 101, 999]; for nSamples = 2
     * and nVariables = 3;
     * @param a
     * @return 
     */
    public static double[] standardDeviation(double[][] a) {
<span class="fc" id="L3596">        int nSamples = a.length;</span>
<span class="fc" id="L3597">        int nVars = a[0].length;</span>
        
<span class="fc" id="L3599">        double[] c = mean(a);</span>
        
<span class="fc" id="L3601">        double[] out = new double[nVars];</span>
        int i, d;
        double diff;
<span class="fc bfc" id="L3604" title="All 2 branches covered.">        for (i = 0; i &lt; nSamples; ++i) {</span>
<span class="fc bfc" id="L3605" title="All 2 branches covered.">            for (d = 0; d &lt; nVars; ++d) {</span>
<span class="fc" id="L3606">                diff = a[i][d] - c[d];</span>
<span class="fc" id="L3607">                out[d] += (diff*diff);</span>
            }
        }
<span class="fc bfc" id="L3610" title="All 2 branches covered.">        for (d = 0; d &lt; nVars; ++d) {</span>
<span class="fc" id="L3611">            out[d] = Math.sqrt(out[d]/(nSamples - 1.0)); </span>
        }
        
<span class="fc" id="L3614">        return out;</span>
    }
    
    /**
     * calculate a - v*I where A is square matrix and v is a vector.  I is the identity
     * matrix.
     * @param a a square matrix.
     * @param v a vector of length of a.length.
     * @return the matrix a - v*I.
     */
    public static double[][] aMinusVectorTimesIdentity(double[][] a, double[] v) {
<span class="fc" id="L3625">        int n = a.length;</span>
<span class="pc bpc" id="L3626" title="1 of 2 branches missed.">        if (n != a[0].length) {</span>
<span class="nc" id="L3627">            throw new IllegalArgumentException(&quot;a must be a square matrix&quot;);</span>
        }
<span class="pc bpc" id="L3629" title="1 of 2 branches missed.">        if (n != v.length) {</span>
<span class="nc" id="L3630">            throw new IllegalArgumentException(&quot;v must be same length as a&quot;);</span>
        }
        
<span class="fc" id="L3633">        double[][] out = copy(a);</span>
        
        int i;
<span class="fc bfc" id="L3636" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3637">            out[i][i] -= v[i];</span>
        }
        
<span class="fc" id="L3640">        return out;</span>
    }
    
    /**
     * calculate the sum of the diagonal elements of a.
     * Note that the trace of matrix A equals the sum of its eigenvalues.
     * Note: the trace of A is equal to the sum of its eigenvalues.
     * @param a a square matrix.
     * @return the sum of the diagonal elements of a
     */
    public static double trace(double[][] a) {
<span class="fc" id="L3651">        int n = a.length;</span>
<span class="pc bpc" id="L3652" title="1 of 2 branches missed.">        if (n != a[0].length) {</span>
<span class="nc" id="L3653">            throw new IllegalArgumentException(&quot;a must be a square matrix&quot;);</span>
        }
        
<span class="fc" id="L3656">        double sum = 0;</span>
        
        int i;
<span class="fc bfc" id="L3659" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3660">            sum += a[i][i];</span>
        }
        
<span class="fc" id="L3663">        return sum;</span>
    }
    
    /**
     * calculate the sum of the diagonal elements of v*I (i.e. sum of all elements of v)
     * @param v a vector to be treated as diagonal elements of an identity matrix.
     * @return the sum of the elements of v
     */
    public static double trace(double[] v) {
<span class="fc" id="L3672">        int n = v.length;</span>
        
<span class="fc" id="L3674">        double sum = 0;</span>
        
        int i;
<span class="fc bfc" id="L3677" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3678">            sum += v[i];</span>
        }
        
<span class="fc" id="L3681">        return sum;</span>
    }
    
    /**
     * pointwise multiplication
     * @param a
     * @param b
     * @return 
     */
    public static double[][] pointwiseMultiplication(double[][] a, double[][] b) {
<span class="fc" id="L3691">        int m = a.length;</span>
<span class="fc" id="L3692">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3694" title="2 of 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3695">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
        int j;
<span class="fc" id="L3699">        double[][] out = new double[m][n];</span>
<span class="fc bfc" id="L3700" title="All 2 branches covered.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L3701">            out[i] = new double[n];</span>
<span class="fc bfc" id="L3702" title="All 2 branches covered.">            for (j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L3703">                out[i][j] = a[i][j] * b[i][j];</span>
            }
        }
<span class="fc" id="L3706">        return out;</span>
    }
    
    /**
     * pointwise multiplication
     * @param a
     * @param b
     * @return 
     */
    public static int[][] pointwiseMultiplication(int[][] a, int[][] b) {
<span class="fc" id="L3716">        int m = a.length;</span>
<span class="fc" id="L3717">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3719" title="2 of 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3720">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
        int j;
<span class="fc" id="L3724">        int[][] out = new int[m][n];</span>
<span class="fc bfc" id="L3725" title="All 2 branches covered.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L3726">            out[i] = new int[n];</span>
<span class="fc bfc" id="L3727" title="All 2 branches covered.">            for (j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L3728">                out[i][j] = a[i][j] * b[i][j];</span>
            }
        }
<span class="fc" id="L3731">        return out;</span>
    }
    
    /**
     * pointwise addition
     * @param a
     * @param b
     * @return 
     */
    public static double[][] pointwiseAdd(double[][] a, double[][] b) {
<span class="fc" id="L3741">        double[][] out = MatrixUtil.zeros(a.length, a[0].length);</span>
<span class="fc" id="L3742">        pointwiseAdd(a, b, out);</span>
<span class="fc" id="L3743">        return out;</span>
    }
    
    /**
     * pointwise addition
     * @param a
     * @param b
     * @param out the results of element wise add of a + b. Note that it
     * is safe to provide out as the same object as input argument a or b.
     */
    public static void pointwiseAdd(double[][] a, double[][] b, double[][] out) {
<span class="fc" id="L3754">        int m = a.length;</span>
<span class="fc" id="L3755">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3757" title="2 of 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3758">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L3760" title="2 of 4 branches missed.">        if (out.length != m || out[0].length != n) {</span>
<span class="nc" id="L3761">            throw new IllegalArgumentException(&quot;a and out must have same dimensions&quot;);</span>
        }
        
        int i, j;
<span class="fc bfc" id="L3765" title="All 2 branches covered.">        for (i = 0; i &lt; out.length; ++i) {</span>
<span class="fc bfc" id="L3766" title="All 2 branches covered.">            for (j = 0; j &lt; out[i].length; ++j) {</span>
<span class="fc" id="L3767">                out[i][j] = a[i][j] + b[i][j];</span>
            }
        }
<span class="fc" id="L3770">    }</span>
    
    /** pointwise subtraction
     * @param a
     * @param b
     * @return 
     */
    public static double[][] pointwiseSubtract(double[][] a, double[][] b) {
<span class="fc" id="L3778">        double[][] out = MatrixUtil.zeros(a.length, a[0].length);</span>
<span class="fc" id="L3779">        pointwiseSubtract(a, b, out);</span>
<span class="fc" id="L3780">        return out;</span>
    }
    
    /**
     * pointwise subtraction
     * @param a
     * @param b
     * @param out the results of element wise subtraction, a - b. Note that it
     */
    public static void pointwiseSubtract(double[][] a, double[][] b, double[][] out) {
<span class="fc" id="L3790">        int m = a.length;</span>
<span class="fc" id="L3791">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3793" title="2 of 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3794">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L3796" title="2 of 4 branches missed.">        if (out.length != m || out[0].length != n) {</span>
<span class="nc" id="L3797">            throw new IllegalArgumentException(&quot;a and out must have same dimensions&quot;);</span>
        }
        
        int i, j;
<span class="fc bfc" id="L3801" title="All 2 branches covered.">        for (i = 0; i &lt; out.length; ++i) {</span>
<span class="fc bfc" id="L3802" title="All 2 branches covered.">            for (j = 0; j &lt; out[i].length; ++j) {</span>
<span class="fc" id="L3803">                out[i][j] = a[i][j] - b[i][j];</span>
            }
        }
<span class="fc" id="L3806">    }</span>
    
    /**
     * point-wise subtraction
     * @param a
     * @param b
     * @return the results of point-wise subtraction, a - b.
     */
    public static int[][] pointwiseSubtract(int[][] a, int[][] b) {
<span class="fc" id="L3815">        int m = a.length;</span>
<span class="fc" id="L3816">        int n = a[0].length;</span>
        
<span class="pc bpc" id="L3818" title="2 of 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3819">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
<span class="fc" id="L3822">        int[][] out = new int[m][];</span>
        
        int i, j;
<span class="fc bfc" id="L3825" title="All 2 branches covered.">        for (i = 0; i &lt; out.length; ++i) {</span>
<span class="fc" id="L3826">            out[i] = new int[n];</span>
<span class="fc bfc" id="L3827" title="All 2 branches covered.">            for (j = 0; j &lt; out[i].length; ++j) {</span>
<span class="fc" id="L3828">                out[i][j] = a[i][j] - b[i][j];</span>
            }
        }
<span class="fc" id="L3831">        return out;</span>
    }
    
    /**
     * pointwise subtraction
     * @param a
     * @param b
     * @param out the results of element wise subtraction, a - b. Note that it
     * is safe to provide out as the same object as input argument a or b.
     */
    public static void pointwiseSubtract(double[] a, double[] b, double[] out) {
<span class="fc" id="L3842">        int m = a.length;</span>
        
<span class="pc bpc" id="L3844" title="1 of 2 branches missed.">        if (b.length != m) {</span>
<span class="nc" id="L3845">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L3847" title="1 of 2 branches missed.">        if (out.length != m) {</span>
<span class="nc" id="L3848">            throw new IllegalArgumentException(&quot;a and out must have same dimensions&quot;);</span>
        }
        
        int i;
<span class="fc bfc" id="L3852" title="All 2 branches covered.">        for (i = 0; i &lt; out.length; ++i) {</span>
<span class="fc" id="L3853">            out[i] = a[i] - b[i];</span>
        }
<span class="fc" id="L3855">    }</span>
    
    /**
     * pointwise multiplication
     * @param a
     * @param b
     * @return 
     */
    public static double[] pointwiseMultiplication(double[] a, double[] b) {
<span class="nc" id="L3864">        int m = a.length;</span>
        
<span class="nc bnc" id="L3866" title="All 2 branches missed.">        if (b.length != m) {</span>
<span class="nc" id="L3867">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
        int j;
<span class="nc" id="L3871">        double[] out = new double[m];</span>
<span class="nc bnc" id="L3872" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L3873">            out[i] = a[i] * b[i];</span>
        }
<span class="nc" id="L3875">        return out;</span>
    }
    
    /**
     * dot product, summation_over_i(a[i]*b[i])
     * @param a
     * @param b
     * @return 
     */
    public static double dot(double[] a, double[] b) {
<span class="nc" id="L3885">        int m = a.length;</span>
        
<span class="nc bnc" id="L3887" title="All 2 branches missed.">        if (b.length != m) {</span>
<span class="nc" id="L3888">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
<span class="nc" id="L3891">        double out = 0;</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L3893">            out += a[i] * b[i];</span>
        }
<span class="nc" id="L3895">        return out;</span>
    }
    
    /**
     * create an array of zeros
     * @param nRows
     * @param nCols
     * @return 
     */
    public static double[][] zeros(int nRows, int nCols) {
<span class="fc" id="L3905">        double[][] out = new double[nRows][nCols];</span>
<span class="fc bfc" id="L3906" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L3907">            out[i] = new double[nCols];</span>
            // java, by default, initializes with zeroes
        }
<span class="fc" id="L3910">        return out;</span>
    }
    
    public static double[][] createIdentityMatrix(int nRows) {
<span class="fc" id="L3914">        double[][] out = new double[nRows][nRows];</span>
<span class="fc bfc" id="L3915" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L3916">            out[i] = new double[nRows];</span>
<span class="fc" id="L3917">            out[i][i] = 1;</span>
        }
<span class="fc" id="L3919">        return out;</span>
    }
    
    /**
     * right divide is pointwise division
     * @param a
     * @param b
     * @return 
     */
    public static double[][] pointwiseDivision(double[][] a, double[][] b) {
<span class="nc" id="L3929">        int m = a.length;</span>
<span class="nc" id="L3930">        int n = a[0].length;</span>
        
<span class="nc bnc" id="L3932" title="All 4 branches missed.">        if (b.length != m || b[0].length != n) {</span>
<span class="nc" id="L3933">            throw new IllegalArgumentException(&quot;a and b must have same dimensions&quot;);</span>
        }
        
        int j;
<span class="nc" id="L3937">        double[][] out = new double[m][n];</span>
<span class="nc bnc" id="L3938" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L3939">            out[i] = new double[n];</span>
<span class="nc bnc" id="L3940" title="All 2 branches missed.">            for (j = 0; j &lt; n; ++j) {</span>
<span class="nc" id="L3941">                out[i][j] = a[i][j] / b[i][j];</span>
            }
        }
<span class="nc" id="L3944">        return out;</span>
    }
    
    /**
     * right divide is pointwise division, that is a[i]/b[i] for i = [0, a.length).
     * @param a
     * @param b
     * @return 
     */
    public static double[] pointwiseDivision(double[] a, double[] b) {
<span class="nc" id="L3954">        int m = a.length;</span>
        
<span class="nc bnc" id="L3956" title="All 2 branches missed.">        if (b.length != m) {</span>
<span class="nc" id="L3957">            throw new IllegalArgumentException(&quot;a and b must have same lengths&quot;);</span>
        }
        
        int j;
<span class="nc" id="L3961">        double[] out = Arrays.copyOf(a, m);</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L3963">            out[i] /= b[i];</span>
        }
<span class="nc" id="L3965">        return out;</span>
    }
    
    /**
     * perform a left-right swap of the columns of a, flipping the matrix
     * vertically.  the method mimics matlab's flipur.
     * @param a 
     */
    public static void flipLR(double[][] a) {
<span class="fc" id="L3974">        int idxHi = a[0].length - 1;</span>
<span class="fc" id="L3975">        int idxLo = 0;</span>
<span class="fc" id="L3976">        int n = idxHi - idxLo + 1;</span>
<span class="fc" id="L3977">        int end = idxLo + (n/2);</span>
        
        double swap;
        int col, row, idx2;
<span class="fc" id="L3981">        int count = 0;</span>
<span class="fc bfc" id="L3982" title="All 2 branches covered.">        for (col = idxLo; col &lt; end; col++) {</span>
<span class="fc" id="L3983">            idx2 = idxHi - count;</span>
<span class="fc bfc" id="L3984" title="All 2 branches covered.">            for (row = 0; row &lt; a.length; row++) {</span>
<span class="fc" id="L3985">                swap = a[row][col];</span>
<span class="fc" id="L3986">                a[row][col] = a[row][idx2];</span>
<span class="fc" id="L3987">                a[row][idx2] = swap;</span>
            }
<span class="fc" id="L3989">            count++;</span>
        }
<span class="fc" id="L3991">    }</span>
    
    /**
     * perform an up-down swap of the rows of a, flipping the matrix
     * horizontally.  the method mimics matlab's flipud.
     * @param a 
     */
    public static void flipUD(double[][] a) {
<span class="fc" id="L3999">        int idxHi = a.length - 1;</span>
<span class="fc" id="L4000">        int idxLo = 0;</span>
<span class="fc" id="L4001">        int n = idxHi - idxLo + 1;</span>
        
<span class="fc" id="L4003">        int end = idxLo + (n/2);</span>
        double[] swap;
<span class="fc" id="L4005">        int count = 0;</span>
        int i, idx2;
<span class="fc bfc" id="L4007" title="All 2 branches covered.">        for (i = idxLo; i &lt; end; i++) {</span>
<span class="fc" id="L4008">            idx2 = idxHi - count;</span>
<span class="fc" id="L4009">            swap = a[i];</span>
<span class="fc" id="L4010">            a[i] = a[idx2];</span>
<span class="fc" id="L4011">            a[idx2] = swap;</span>
<span class="fc" id="L4012">            count++;</span>
        }
<span class="fc" id="L4014">    }</span>
    
    /**
     * solves for vector x in the equation L*x=b where L is the lower triangular
     * matrix and b is a vector.
     * runtime complexity is approx (b.length)^2.
     * @param lowerTriangular the lower triangular matrix
     * @param b vector on the righthand side of the equation L*x=b
     * @return x in equation L*x = b
     */
    public static double[] forwardSubstitution(double[][] lowerTriangular, double[] b) {
<span class="fc" id="L4025">        double[] outX = new double[b.length];</span>
<span class="fc" id="L4026">        forwardSubstitution(lowerTriangular, b, outX);</span>
<span class="fc" id="L4027">        return outX;</span>
    }
    
    /**
     * solves for vector x in the equation L*x=b where L is the lower triangular
     * matrix and b is a vector.
     * runtime complexity is approx (b.length)^2.
     * method follows Golub &amp; Van Loan algorithm 4.1-1.
     * @param lowerTriangular the lower triangular matrix
     * @param b vector on the righthand side of the equation L*x=b
     * @param outX output variable x in equation L*x = b.  length is b.length.
     */
    public static void forwardSubstitution(double[][] lowerTriangular, double[] b,
        double[] outX) {
        
<span class="fc" id="L4042">        int m = b.length;</span>
        
<span class="pc bpc" id="L4044" title="1 of 2 branches missed.">        if (lowerTriangular[0].length != m) {</span>
<span class="nc" id="L4045">            throw new IllegalArgumentException(&quot;the number of columns in &quot;</span>
                    + &quot;lowerTriangular must equal the length of b&quot;);
        }
<span class="pc bpc" id="L4048" title="1 of 2 branches missed.">        if (outX.length != m) {</span>
<span class="nc" id="L4049">            throw new IllegalArgumentException(&quot;outX.length must equal the length of b&quot;);</span>
        }
                
        int i, j;
<span class="fc bfc" id="L4053" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L4054">            outX[i] = b[i];</span>
<span class="fc bfc" id="L4055" title="All 2 branches covered.">            for (j = 0; j &lt;= (i-1); ++j) {</span>
<span class="fc" id="L4056">                outX[i] -= (lowerTriangular[i][j] * outX[j]);</span>
            }
<span class="fc" id="L4058">            outX[i] /= lowerTriangular[i][i];</span>
        }
<span class="fc" id="L4060">    }</span>
    
    /**
     * solves for vector x in the equation L*x=b where L is the lower triangular
     * matrix and b is a vector.
     * runtime complexity is approx (b.length)^2.
     * method follows Golub &amp; Van Loan algorithm 4.1-1.
     * @param lowerTriangular the lower triangular matrix
     * @param b vector on the righthand side of the equation L*x=b
     * @return x in equation L*x = b
     */
    public static double[] forwardSubstitution(LowerTriangDenseMatrix lowerTriangular, double[] b) {
        
<span class="fc" id="L4073">        int m = b.length;</span>
        
<span class="pc bpc" id="L4075" title="1 of 2 branches missed.">        if (lowerTriangular.numColumns() != m) {</span>
<span class="nc" id="L4076">            throw new IllegalArgumentException(&quot;the number of columns in &quot;</span>
                    + &quot;lowerTriangular must equal the length of b&quot;);
        }
        
<span class="fc" id="L4080">        double[] x = new double[b.length];</span>
                
        int i, j;
<span class="fc bfc" id="L4083" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L4084">            x[i] = b[i];</span>
<span class="fc bfc" id="L4085" title="All 2 branches covered.">            for (j = 0; j &lt;= (i-1); ++j) {</span>
<span class="fc" id="L4086">                x[i] -= (lowerTriangular.get(i, j) * x[j]);</span>
            }
<span class="fc" id="L4088">            x[i] /= lowerTriangular.get(i, i);</span>
        }
        
<span class="fc" id="L4091">        return x;</span>
    }
    
    /**
     * solves for vector x in the equation U*x = y where 
     * U is an upper triangular matrix and y is a vector.
     * runtime complexity is approx (y.length)^2.
     * method follows Golub &amp; Van Loan algorithm 4.1-2.
     * @param upperTriangular the upper triangular matrix
     * (a_i_j=0 where i&gt;j)
     * &lt;pre&gt;
     *     0  1  2
        2  *  *  *
        1  *  *  
        0  *
           0  1  2
     * &lt;/pre&gt;
     * @param y vector on righthand side of equation
     * @return x in equation U*x = y
     */
    public static double[] backwardSubstitution(double[][] upperTriangular, double[] y) {
        
<span class="fc" id="L4113">        double[] outX = new double[y.length];</span>
        
<span class="fc" id="L4115">        backwardSubstitution(upperTriangular, y, outX);</span>
        
<span class="fc" id="L4117">        return outX;</span>
    }
    
    /**
     * solves for vector x in the equation U*x = y where 
     * U is an upper triangular matrix and y is a vector.
     * runtime complexity is approx (y.length)^2.
     * @param upperTriangular the upper triangular matrix
     * (a_i_j=0 where i&gt;j)
     * &lt;pre&gt;
     *     0  1  2
        2  *  *  *
        1  *  *  
        0  *
           0  1  2
     * &lt;/pre&gt;
     * @param y vector on righthand side of equation
     * @param outX output variable x in equation U*x = y.  must be length y.length.
     */
    public static void backwardSubstitution(double[][] upperTriangular, double[] y,
        double[] outX) {
        
<span class="fc" id="L4139">        int m = y.length;</span>
        
<span class="pc bpc" id="L4141" title="1 of 2 branches missed.">        if (upperTriangular[0].length != m) {</span>
<span class="nc" id="L4142">            throw new IllegalArgumentException(&quot;the number of columns in &quot;</span>
                    + &quot;upperTriangular must equal the length of y&quot;);
        }
<span class="pc bpc" id="L4145" title="1 of 2 branches missed.">        if (outX.length != m) {</span>
<span class="nc" id="L4146">            throw new IllegalArgumentException(&quot;outX.length must equal the length of y&quot;);</span>
        }
                
        int i, j;
<span class="fc bfc" id="L4150" title="All 2 branches covered.">        for (i = m-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L4151">            outX[i] = y[i];</span>
<span class="fc bfc" id="L4152" title="All 2 branches covered.">            for (j = i+1; j &lt; m; ++j) {</span>
<span class="fc" id="L4153">                outX[i] -= (outX[j]*upperTriangular[i][j]);</span>
            }
<span class="fc" id="L4155">            outX[i] /= upperTriangular[i][i];</span>
        }        
<span class="fc" id="L4157">    }</span>
    
    /**
     * solves for vector x in the equation U*x = y where 
     * U is an upper triangular matrix and y is a vector.
     * runtime complexity is approx (y.length)^2.
     * @param upperTriangular the upper triangular matrix
     * @param y vector on righthand side of equation
     * @return x in equation U*x = y
     */
    public static double[] backwardSubstitution(UpperTriangDenseMatrix upperTriangular, 
        double[] y) {
        
<span class="fc" id="L4170">        int m = y.length;</span>
        
<span class="pc bpc" id="L4172" title="1 of 2 branches missed.">        if (upperTriangular.numColumns() != m) {</span>
<span class="nc" id="L4173">            throw new IllegalArgumentException(&quot;the number of columns in &quot;</span>
                    + &quot;upperTriangular must equal the length of y&quot;);
        }
        
<span class="fc" id="L4177">        double[] x = new double[m];</span>
        int i, j;
<span class="fc bfc" id="L4179" title="All 2 branches covered.">        for (i = m-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L4180">            x[i] = y[i];</span>
<span class="fc bfc" id="L4181" title="All 2 branches covered.">            for (j = i+1; j &lt; m; ++j) {</span>
<span class="fc" id="L4182">                x[i] -= (x[j]*upperTriangular.get(i, j));</span>
            }
<span class="fc" id="L4184">            x[i] /= upperTriangular.get(i, i);</span>
        }
<span class="fc" id="L4186">        return x;</span>
    }
            
    public static void fill(double[][] a, double value) {
        int i;
<span class="fc bfc" id="L4191" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L4192">            Arrays.fill(a[i], value);</span>
        }
<span class="fc" id="L4194">    }</span>
    
    public static BlockMatrixIsometric transpose(BlockMatrixIsometric a) {
        
<span class="fc" id="L4198">        double[][] _b = MatrixUtil.zeros(a.getA()[0].length, a.getA().length);</span>
        
<span class="fc" id="L4200">        BlockMatrixIsometric b = new BlockMatrixIsometric(_b, a.getBlockSize1(), a.getBlockSize0());</span>
        
<span class="fc" id="L4202">        transpose(a.getA(), b.getA());</span>
        
        /*
        double[][] block = MatrixUtil.zeros(a.getBlockSize0(), a.getBlockSize1());
        double[][] blockT = MatrixUtil.zeros(a.getBlockSize1(), a.getBlockSize0());
        
        int nb0 = a.getA().length / a.getBlockSize0();
        int nb1 = a.getA()[0].length / a.getBlockSize1();
        
        int i, j;
        
        for (i = 0; i &lt; nb0; ++i) {
            for (j = 0; j &lt; nb1; ++j) {
                a.getBlock(block, i, j);
                transpose(block, blockT);
                b.setBlock(blockT, j, i);
                System.out.printf(&quot;(%d,%d) blockT=\n%s\n&quot;, j, i, FormatArray.toString(blockT, &quot;%.3f&quot;));
                System.out.printf(&quot;b=\n%s\n&quot;, FormatArray.toString(b.getA(), &quot;%.3f&quot;));
            }
        }
        */
        
<span class="fc" id="L4224">        return b;</span>
    }
    
    /**
     * rewrite matrix a into a vector using the order of all rows of column 0,
     * then all rows of column 1, etc.
     * @param a
     * @return 
     */
    public static double[] reshapeToVector(double[][] a) {
<span class="fc" id="L4234">        double[] out = new double[a.length * a[0].length];</span>
<span class="fc" id="L4235">        int c = 0;</span>
        int i, j;
<span class="fc bfc" id="L4237" title="All 2 branches covered.">        for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc bfc" id="L4238" title="All 2 branches covered.">            for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L4239">                out[c] = a[i][j];</span>
<span class="fc" id="L4240">                c++;</span>
            }
        }
<span class="fc" id="L4243">        return out;</span>
    }
     
    /**
     * calculate a pre-conditoner matrix based upon the matrix U in
     * the decompositon P*A = L*U where P is a permutation matrix,
     * L is a lower triangular matrix, U is an upper triangular matrix.
     * 
     * see Bjork 1991 Section 4.3, &quot;Algorithms for linear least squares problems&quot;,
     * especially the end of the section.
     * 
     * from wikipedia:
     * LU factorization with partial pivoting: It turns out that a proper 
     * permutation in rows (or columns) is sufficient for LU factorization. 
     * LU factorization with partial pivoting (LUP) refers often to LU 
     * factorization with row permutations only.
     * 
     * The choice of a good preconditioner may improve the speed of an iterative
     * method.
     * 
     * Note that if matrix a has full rank, the ideal choice of a preconditioner
     * is instead of this method's results, is to use the Cholesky factor of 
     * A^T*A. 
     * Note that another preconditioner uses the columns of a to form a diagonal
     * matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
     *   d_j = (||a_j||_2)^2  where a_j is column j of a.
     * &lt;pre&gt;
     * using a preconditioner involves reforming A*x = b into
     * A * (M^-1) * y = b, solve for y
     * and M * x = y, solve for x.
     * 
     * Or the left precondition:
     *   (M^-1) * (A*x - b) = 0
     * 
     * &lt;/pre&gt;
     * 
     * @param a and m X n matrix
     * @return matrix with dimensions of a^T
     * @throws NotConvergedException 
     */
    public static double[][] calculatePreconditionerFromLUP(double[][] a) throws NotConvergedException {
        
<span class="nc" id="L4285">        LUP lup = LinearEquations.LUPDecomposition(a);</span>
        
<span class="nc" id="L4287">        return lup.u;</span>
    }
    
    /**
     * calculate a pre-conditoner matrix based upon the columns of matrix a to 
     * form a diagonal matrix:   D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
     *   d_j = (||a_j||_2)^2  where a_j is column j of a.
     * 
     * see Bjork 1991 Section 4.3, &quot;Algorithms for linear least squares problems&quot;,
     * especially the end of the section.
     * 
     * from wikipedia:
     * LU factorization with partial pivoting: It turns out that a proper 
     * permutation in rows (or columns) is sufficient for LU factorization. 
     * LU factorization with partial pivoting (LUP) refers often to LU 
     * factorization with row permutations only.
     * 
     * The choice of a good preconditioner may improve the speed of an iterative
     * method.
     * 
     * Note that if matrix a has full rank, the ideal choice of a preconditioner
     * is instead of this method's results, is to use the Cholesky factor of 
     * A^T*A. 
     * 
     * &lt;pre&gt;
     * using a preconditioner involves reforming A*x = b into
     * A * (M^-1) * y = b, solve for y
     * and M * x = y, solve for x.
     * 
     * Or the left precondition:
     *   (M^-1) * (A*x - b) = 0
     * 
     * &lt;/pre&gt;
     * 
     * @param a and m X n matrix
     * @return matrix with dimensions of a^T
     * @throws NotConvergedException 
     */
    public static double[][] calculatePreconditionerFromColumns(double[][] a) throws NotConvergedException {
<span class="nc" id="L4326">        int m = a.length;</span>
<span class="nc" id="L4327">        int n = a[0].length;</span>
        /*
        D^(1/2) = diag( sqrt(d_1), ... sqrt(d_n)) where 
        d_j = (||a_j||_2)^2  where a_j is column j of a.
        */
        int j, i;
<span class="nc" id="L4333">        double[][] diag = MatrixUtil.zeros(n, n);</span>
        
<span class="nc bnc" id="L4335" title="All 2 branches missed.">        for (j = 0; j &lt; n; ++j) {</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">            for (i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L4337">                diag[j][j] += (a[i][j] + a[i][j]);</span>
            }
<span class="nc" id="L4339">            diag[j][j] = Math.sqrt(diag[j][j]);</span>
        }
        
<span class="nc" id="L4342">        return diag;</span>
    }
    
    /**
     * perform a polar decomposition on square matrix a.
     * A = Q*H where Q is orthogonal and H is a symmetric positive semidefinite matrix.  
     If A is invertible, then H is symmetric positive definite.
     The method follows Strang &quot;Introduction to Linear Algebra&quot; Chapter 7 section G.
     * @param a square matrix
     * @return 
     */
    public static QH performPolarDecomposition(double[][] a) throws NotConvergedException {
        
<span class="pc bpc" id="L4355" title="1 of 2 branches missed.">        if (!isSquare(a)) {</span>
<span class="nc" id="L4356">            throw new IllegalArgumentException(&quot;a must be a square matrix&quot;);</span>
        }
        
<span class="fc" id="L4359">        SVDProducts svd = performSVD(a);</span>
        
<span class="fc" id="L4361">        double[][] q = MatrixUtil.multiply(svd.u, svd.vT);</span>
        
<span class="fc" id="L4363">        double[][] v = MatrixUtil.transpose(svd.vT);</span>
        
<span class="fc" id="L4365">        double[][] h = MatrixUtil.multiplyByDiagonal(v, svd.s);</span>
<span class="fc" id="L4366">        h = MatrixUtil.multiply(h, svd.vT);</span>
        
<span class="fc" id="L4368">        QH qh = new QH();</span>
<span class="fc" id="L4369">        qh.q = q;</span>
<span class="fc" id="L4370">        qh.h = h;</span>
        
<span class="fc" id="L4372">        return qh;</span>
    }
    
    /**
     * a class to hold the results of a polar decomposition
     */
    public static class QH {
        
        /**
         * Q is an orthogonal matrix
         */
        public double[][] q;
        
        /**
         * H is a symmetric positive semidefinite matrix.  
         * If the decomposed matrix A is invertible, then H is
         * symmetric positive definite.
         */
        public double[][] h;
    }
    
    /**
     * given 2 non-decreasing ordered sequences of numbers, find their intersection.
     * The method is called multiset because the sequences may contain more than
     * one element having the same value... the method is used for multisets as multi-sequences.
     * The runtime complexity is O(max(a.length, b.length).
     * @param orderedA an increasing sequence of numbers (i.e. ascending sorted). 
     * @param orderedB an increasing sequence of numbers (i.e. sorted by non-decreasing order)
     * @return 
     */
    public static int[] multisetIntersection(int[] orderedA, int[] orderedB) {
        
<span class="fc" id="L4404">        TIntList c = new TIntArrayList();</span>
        
<span class="fc" id="L4406">        int i = 0, j = 0;</span>
<span class="fc bfc" id="L4407" title="All 4 branches covered.">        while (i &lt; orderedA.length &amp;&amp; j &lt; orderedB.length) {</span>
<span class="fc bfc" id="L4408" title="All 2 branches covered.">            if (orderedA[i] == orderedB[j]) {</span>
<span class="fc" id="L4409">                c.add(orderedA[i]);</span>
<span class="fc" id="L4410">                i++; </span>
<span class="fc" id="L4411">                j++;</span>
<span class="fc bfc" id="L4412" title="All 2 branches covered.">            } else if (orderedA[i] &lt; orderedB[j]) {</span>
<span class="fc" id="L4413">                i++;</span>
            } else {
<span class="fc" id="L4415">                j++;</span>
            }
        }
<span class="fc" id="L4418">        return c.toArray();</span>
    }
    
    /**
     * given 2 sequences of numbers, find their intersection.
     * The method is called multiset because the sequences may contain more than
     * one element having the same value... the method is used for multisets as multi-sequences.
     * The runtime complexity is O(N*log_2(N)) where N is max(a.length, b.length).
     * @param a a sequence of numbers 
     * @param b a sequence of numbers
     * @return 
     */
    public static int[] multisetUnorderedIntersection(int[] a, int[] b) {
        
<span class="fc" id="L4432">        a = Arrays.copyOf(a, a.length);</span>
<span class="fc" id="L4433">        b = Arrays.copyOf(b, b.length);</span>
<span class="fc" id="L4434">        Arrays.sort(a);</span>
<span class="fc" id="L4435">        Arrays.sort(b);</span>
        
<span class="fc" id="L4437">        return multisetIntersection(a, b);</span>
    }
    
    public static TIntObjectMap&lt;TIntSet&gt; copy(TIntObjectMap&lt;TIntSet&gt; a) {
<span class="fc" id="L4441">        TIntObjectMap&lt;TIntSet&gt; c = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
<span class="fc" id="L4442">        TIntObjectIterator&lt;TIntSet&gt; iter = a.iterator();</span>
        TIntSet set, cSet;
        TIntIterator iter2;
        int i, key;
<span class="fc bfc" id="L4446" title="All 2 branches covered.">        for (i = 0; i &lt; a.size(); ++i) {</span>
<span class="fc" id="L4447">            iter.advance();</span>
            
<span class="fc" id="L4449">            key = iter.key();</span>
<span class="fc" id="L4450">            set = iter.value();</span>
            
<span class="fc" id="L4452">            cSet = new TIntHashSet();</span>
            
<span class="fc" id="L4454">            iter2 = set.iterator();</span>
            
<span class="fc bfc" id="L4456" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L4457">                cSet.add(iter2.next());</span>
            }
<span class="fc" id="L4459">            c.put(key, cSet);</span>
        }
<span class="fc" id="L4461">        return c;</span>
    }
    
    public static TObjectDoubleMap&lt;PairInt&gt; copy(TObjectDoubleMap&lt;PairInt&gt; a) {
        
<span class="fc" id="L4466">        TObjectDoubleMap&lt;PairInt&gt; out = new TObjectDoubleHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L4468">        TObjectDoubleIterator&lt;PairInt&gt; iter = a.iterator();</span>
        PairInt p;
        int i;
<span class="fc bfc" id="L4471" title="All 2 branches covered.">        for (i = 0; i &lt; a.size(); ++i) {</span>
<span class="fc" id="L4472">            iter.advance();</span>
<span class="fc" id="L4473">            p = iter.key();</span>
<span class="fc" id="L4474">            out.put(p.copy(), iter.value());</span>
        }
        
<span class="fc" id="L4477">        return out;</span>
    }
    
    /**
     * create a symmetric adjacency map from a
     * @param a
     * @return 
     */
    public static TIntObjectMap&lt;TIntSet&gt; copyToSymmetricMap(TIntObjectMap&lt;TIntSet&gt; a) {
<span class="fc" id="L4486">        TIntObjectMap&lt;TIntSet&gt; out = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
<span class="fc" id="L4488">        TIntObjectIterator&lt;TIntSet&gt; iter = a.iterator();</span>
        TIntSet set, uSet, vSet;
        TIntIterator iter2;
        
        int i, u, v;
<span class="fc bfc" id="L4493" title="All 2 branches covered.">        for (i = 0; i &lt; a.size(); ++i) {</span>
<span class="fc" id="L4494">            iter.advance();</span>
            
<span class="fc" id="L4496">            u = iter.key();</span>
<span class="fc" id="L4497">            set = iter.value();</span>
            
<span class="fc" id="L4499">            uSet = out.get(u);</span>
<span class="fc bfc" id="L4500" title="All 2 branches covered.">            if (uSet == null) {</span>
<span class="fc" id="L4501">                uSet = new TIntHashSet();</span>
<span class="fc" id="L4502">                out.put(u, uSet);</span>
            }
            
<span class="fc" id="L4505">            iter2 = set.iterator();</span>
<span class="fc bfc" id="L4506" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L4507">                v = iter2.next();</span>
                
<span class="fc" id="L4509">                uSet.add(v);</span>
                
<span class="fc" id="L4511">                vSet = out.get(v);</span>
<span class="fc bfc" id="L4512" title="All 2 branches covered.">                if (vSet == null) {</span>
<span class="fc" id="L4513">                    vSet = new TIntHashSet();</span>
<span class="fc" id="L4514">                    out.put(v, vSet);</span>
                }
<span class="fc" id="L4516">                vSet.add(u);</span>
            }
        }
        
<span class="fc" id="L4520">        return out;</span>
    }
    
    public static TIntIntMap copy(TIntIntMap a) {
<span class="nc" id="L4524">        TIntIntMap c = new TIntIntHashMap();</span>
<span class="nc" id="L4525">        TIntIntIterator iter = a.iterator();</span>
        int i;
<span class="nc bnc" id="L4527" title="All 2 branches missed.">        for (i = 0; i &lt; a.size(); ++i) {</span>
<span class="nc" id="L4528">            iter.advance();</span>
<span class="nc" id="L4529">            c.put(iter.key(), iter.value());</span>
        }
<span class="nc" id="L4531">        return c;</span>
    }
    
    public static float[][] convertToFloat(double[][] a) {
<span class="fc" id="L4535">        float[][] c = new float[a.length][];</span>
        int i, j;
<span class="fc bfc" id="L4537" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L4538">            c[i] = new float[a[0].length];</span>
<span class="fc bfc" id="L4539" title="All 2 branches covered.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="fc" id="L4540">                c[i][j] = (float) a[i][j];</span>
            }
        }
<span class="fc" id="L4543">        return c;</span>
    }
    public static float[] convertToFloat(double[] a) {
<span class="fc" id="L4546">        float[] c = new float[a.length];</span>
        int i;
<span class="fc bfc" id="L4548" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L4549">            c[i] = (float) a[i];</span>
        }
<span class="fc" id="L4551">        return c;</span>
    }
    public static double[][] convertIntToDouble(int[][] a) {
<span class="nc" id="L4554">        double[][] c = new double[a.length][];</span>
        int i, j;
<span class="nc bnc" id="L4556" title="All 2 branches missed.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L4557">            c[i] = new double[a[0].length];</span>
<span class="nc bnc" id="L4558" title="All 2 branches missed.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="nc" id="L4559">                c[i][j] = a[i][j];</span>
            }
        }
<span class="nc" id="L4562">        return c;</span>
    }
    public static double[][] convertToDouble(float[][] a) {
<span class="nc" id="L4565">        double[][] c = new double[a.length][];</span>
        int i, j;
<span class="nc bnc" id="L4567" title="All 2 branches missed.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L4568">            c[i] = new double[a[0].length];</span>
<span class="nc bnc" id="L4569" title="All 2 branches missed.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="nc" id="L4570">                c[i][j] = a[i][j];</span>
            }
        }
<span class="nc" id="L4573">        return c;</span>
    }

    public static float[][] convertToFloat(int[][] a) {
<span class="nc" id="L4577">        float[][] c = new float[a.length][];</span>
        int i, j;
<span class="nc bnc" id="L4579" title="All 2 branches missed.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L4580">            c[i] = new float[a[0].length];</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">            for (j = 0; j &lt; a[0].length; ++j) {</span>
<span class="nc" id="L4582">                c[i][j] = a[i][j];</span>
            }
        }
<span class="nc" id="L4585">        return c;</span>
    }
    
    /**
     * create a permutation matrix given the vector of permuted element indexes.
     * Usage: pre-multiplying, P*A, results in permuting the rows of A.
     * post-multiplying, A*P, results in permuting the columns of A.
     * @param assignments the permutation vector.
     * @return 
     */
    public static int[][] createPermutationMatrix(int[] assignments) {
<span class="fc" id="L4596">        int n = assignments.length;</span>
<span class="fc" id="L4597">        int[][] p = new int[n][];</span>
        int i;
<span class="fc bfc" id="L4599" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L4600">            p[i] = new int[n];</span>
        }
<span class="fc bfc" id="L4602" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L4603">            p[i][assignments[i]] = 1;</span>
        }
<span class="pc bnc" id="L4605" title="All 2 branches missed.">        assert(MatrixUtil.isAPermutationMatrix(p));</span>
<span class="fc" id="L4606">        return p;</span>
    }

    /**
     * extract each column of a and append it to an output vector.
     * if a is [mxn], the output vector length will be m*n.
     * @param a
     * @return the output vector of stacked columns of a
     */
    public static double[] stack(double[][] a) {
<span class="fc" id="L4616">        int m = a.length;</span>
<span class="fc" id="L4617">        int n = a[0].length;</span>
<span class="fc" id="L4618">        double[] out = new double[m*n];</span>
        int j;
<span class="fc bfc" id="L4620" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L4621" title="All 2 branches covered.">            for (j = 0; j &lt; m; ++j) {</span>
<span class="fc" id="L4622">                out[i*m + j] = a[j][i];</span>
            }
        }

<span class="fc" id="L4626">        return out;</span>
    }

    /**
     * Given two matrices A  R^(mxn) and B  R^(kxl), their Kronecker product,
     * denoted by AB, is a new matrix  R^(mk x nl)
     * @param a
     * @param b
     * @return
     */
    public static double[][] kroneckerProduct(double[][] a, double[][] b) {

<span class="fc" id="L4638">        int m = a.length;</span>
<span class="fc" id="L4639">        int n = a[0].length;</span>
<span class="fc" id="L4640">        int k = b.length;</span>
<span class="fc" id="L4641">        int l = b[0].length;</span>
<span class="fc" id="L4642">        int mk = m * k;</span>
<span class="fc" id="L4643">        int nl = n * l;</span>

<span class="fc" id="L4645">        double[][] kron = MatrixUtil.zeros(mk, nl);</span>
        int i;
        int j;
        int ii;
        double[][] b2;
<span class="fc" id="L4650">        int r = 0;</span>
<span class="fc" id="L4651">        int c = 0;</span>
<span class="fc bfc" id="L4652" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc bfc" id="L4653" title="All 2 branches covered.">            for (j = 0; j &lt; n; ++j) {</span>
                // multiply each a[i][j] by entire matrix b2
<span class="fc" id="L4655">                b2 = MatrixUtil.copy(b);</span>
<span class="fc" id="L4656">                MatrixUtil.multiply(b2, a[i][j]);</span>
                // write the kXl items of b2 into [m*k][n*l] matrix starting at [i*k][j*l]
<span class="fc bfc" id="L4658" title="All 2 branches covered.">                for (ii = 0; ii &lt; k; ++ii) {</span>
<span class="fc" id="L4659">                    System.arraycopy(b2[ii], 0, kron[i*k + ii], j*l, b2[ii].length);</span>
                }

                // e.g. m=1,n=3,  k=3, l=4
                // B: 0,0  0,1  0,2  0,3    0,4 0,5 0,6 0,7  j=0:[0,l*j] j=1:[0,l*j]
                //    1, .. ..
                //    2, .. ..
                // B: 3, ...
            }
        }
<span class="fc" id="L4669">        return kron;</span>
    }

    /**
     * Given two vectors A  R^(m) and B  R^(k), their Kronecker product,
     * denoted by AB, is a new matrix  R^(mk).  It is the outer product of the
     * vectors.
     * @param a
     * @param b
     * @return the outer product
     */
    public static double[][] kroneckerProduct(double[] a, double[] b) {
<span class="nc" id="L4681">        return outerProduct(a, b);</span>
    }

    /**
     * return the nullspace of matrix A using SVD.  This method is more accurate, but slower than
     * using QR decomposition.
     * @param a matrix of dimensions [mXn]
     * @param tol tolerance as the equivalent to 0 which is approximately machine precision.
     * @return nullspace of matrix A, transposed to row vectors for easier use.
     */
    public static double[][] nullSpaceUsingSVD(double[][] a, double tol) throws NotConvergedException {
<span class="nc" id="L4692">        SVDProducts svd = MatrixUtil.performSVD(a);</span>
<span class="nc" id="L4693">        int rank = 0;</span>
        int i;
<span class="nc bnc" id="L4695" title="All 2 branches missed.">        for (i = 0; i &lt; svd.s.length; ++i) {</span>
<span class="nc bnc" id="L4696" title="All 2 branches missed.">            if (svd.s[i] &gt; tol) {</span>
<span class="nc" id="L4697">                rank++;</span>
            }
        }
<span class="nc" id="L4700">        int n = a[0].length;</span>
        // the last n-rank columns of V hold the nullspace
<span class="nc" id="L4702">        double[][] nullspace = new double[n-rank][];</span>
        int c;
<span class="nc bnc" id="L4704" title="All 2 branches missed.">        for (i = rank, c = 0; i &lt; n; ++i, ++c) {</span>
<span class="nc" id="L4705">            nullspace[c] = Arrays.copyOf(svd.vT[i], svd.vT[i].length);</span>
        }
<span class="nc" id="L4707">        return nullspace;</span>
    }

    /**
     * return the nullspace of matrix A using QR decomposition.
     * This method is less accurate, but faster than using SVD decomposition.
     * @param a matrix of dimensions [mXn] where m must be &lt;= n.
     * @param tol tolerance as the equivalent to 0 which is approximately machine precision.
     * @return nullspace of matrix A transposed to row vectors for easier use.
     */
    public static double[][] nullSpaceUsingQR(double[][] a, double tol) throws NotConvergedException {

<span class="nc" id="L4719">        QR qr = QR.factorize(new DenseMatrix(a));</span>
<span class="nc" id="L4720">        UpperTriangDenseMatrix r = qr.getR();</span>
<span class="nc" id="L4721">        DenseMatrix q = qr.getQ();</span>
<span class="nc" id="L4722">        int rank = 0;</span>
        int i;
        // r is square so can use the number of rows
<span class="nc bnc" id="L4725" title="All 2 branches missed.">        for (i = 0; i &lt; r.numRows(); ++i) {</span>
<span class="nc bnc" id="L4726" title="All 2 branches missed.">            if (r.get(i, i) &gt; tol) {</span>
<span class="nc" id="L4727">                rank++;</span>
            }
        }
<span class="nc" id="L4730">        int n = a[0].length;</span>
<span class="nc" id="L4731">        double[][] qT = MatrixUtil.transpose(Matrices.getArray(q));</span>
        // the last n-rank columns of q hold the nullspace
<span class="nc" id="L4733">        double[][] nullspace = new double[n-rank][];</span>
        int c;
<span class="nc bnc" id="L4735" title="All 2 branches missed.">        for (i = rank, c = 0; i &lt; n; ++i, ++c) {</span>
<span class="nc" id="L4736">            nullspace[c] = Arrays.copyOf(qT[i], qT[i].length);</span>
        }
<span class="nc" id="L4738">        return nullspace;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>