<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Misc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.scheduling</a> &gt; <span class="el_source">Misc.java</span></div><h1>Misc.java</h1><pre class="source lang-java linenums">package algorithms.scheduling;

import algorithms.sort.MiscSorter;
import gnu.trove.iterator.TIntDoubleIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntDoubleMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntDoubleHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="fc" id="L23">public class Misc {</span>
        
     /**
     * For a single resource, schedule a set of n tasks where each task is associated with a execution time
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be the amount
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity O(N * log_2(N)).
      * The results are optimal in minimizing the maximum lateness.
     * 
     @param duration duration of task. duration a.k.a. burst time a.k.a. execution time
     @param deadline deadline for task
     @param outputStart output array to hold start times for the resulting scheduled index order 
     @param outputLate output array to hold lateness for the resulting scheduled index order.
     * if is on time, element will be 0.
     @return indexes for scheduling order
     */
    public int[] unweightedIntervalMinimizeLateGreedy(double[] duration, double[] deadline,
        double[] outputStart, double[] outputLate) {
<span class="fc" id="L53">        int n = duration.length;</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (deadline.length != n) {</span>
<span class="nc" id="L55">            throw new IllegalArgumentException(&quot;d.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (outputStart.length != n) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;outputStart.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (outputLate.length != n) {</span>
<span class="nc" id="L61">            throw new IllegalArgumentException(&quot;outputLate.length must equal t.length&quot;);</span>
        }
<span class="fc" id="L63">        duration = Arrays.copyOf(duration, duration.length);</span>
<span class="fc" id="L64">        deadline = Arrays.copyOf(deadline, deadline.length);</span>
<span class="fc" id="L65">        Arrays.fill(outputStart, 0);</span>
<span class="fc" id="L66">        Arrays.fill(outputLate, 0);</span>
        
        //sort tasks by increasing deadline to minimize the lateness
<span class="fc" id="L69">        int[] indexes = MiscSorter.mergeBy1stArgThen2nd(deadline, duration);</span>

<span class="fc" id="L71">        double f_prev = 0; // f is the finish time of previous task</span>
        int i; 
<span class="fc bfc" id="L73" title="All 2 branches covered.">        for (i = 0; i &lt; duration.length; ++i) {</span>
            //assign task i to start at 
<span class="fc" id="L75">            outputStart[i] = f_prev;  // start next task</span>
<span class="fc" id="L76">            f_prev = /*f[i] =*/ outputStart[i] + duration[i];  // its finish time</span>
            //lateness[i] = max(0, f[i] - d[i])     // its lateness
<span class="fc" id="L78">            outputLate[i] = Math.max(0, f_prev - deadline[i]);</span>
        }
<span class="fc" id="L80">        return indexes;</span>
    }
    
    /**
     * schedule a set of n tasks where each task is associated with a execution time 
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be amount 
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * The algorithm is aka Earliest Finish First (EFF) and Earliest Deadline First (EDF)
     *    (1) sort tasks by finish time
     *    (2) iterate over tasks, scheduling each that starts after the previous ended
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity is O(N * log_2(N)).
     * This is a greedy and optimal solution.
     * 
     @param s start times for tasks
     @param f finish times for tasks
     @return indexes for scheduled non-conflicting tasks
     */
    public int[] unweightedIntervalNoConflicts(double[] s, double[] f) {
<span class="fc" id="L111">        int n = s.length;</span>
<span class="fc" id="L112">        s = Arrays.copyOf(s, s.length);</span>
<span class="fc" id="L113">        f = Arrays.copyOf(f, f.length);</span>
        
        //sort tasks by increasing finish times .  O(N * log_2(N))
<span class="fc" id="L116">        int[] indexes = MiscSorter.mergeBy1stArgThen2nd(f, s);</span>
<span class="fc" id="L117">        double f_prev = -1; // f is the finish time of previous task</span>
        int i; 
<span class="fc" id="L119">        int[] scheduled = new int[n];</span>
<span class="fc" id="L120">        int count = 0;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (s[i] &gt; f_prev) {</span>
<span class="fc" id="L123">                scheduled[count++] = indexes[i];</span>
<span class="fc" id="L124">                f_prev = f[i];</span>
            }
        }
<span class="fc" id="L127">        scheduled = Arrays.copyOfRange(scheduled, 0, count);</span>
<span class="fc" id="L128">        return scheduled;</span>
    }
    
    /**
     * The objective is to compute any maximum sized subset of non-overlapping intervals.
     * Weighted Interval Scheduling: 
     * given a set S = {1, . . . , n} of n activity requests, 
     * where each activity is expressed as an interval [s_i, f_i] from a given 
     * start time si to a given finish time f_i
     * and each request is associated with a numeric weight or value v_i.
     * 
     * The objective is to find a set of non-overlapping requests such that sum 
     * of values of the scheduled requests is maximum.
     * 
     * This code uses dynamic programming and has runtime complexity O(n^2).
     * 
     * The code follows the lecture notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf
     
     @param s interval start times
     @param f interval finish times
     @param v interval weights
     @return indexes of scheduled intervals.
     */
    public int[] weightedIntervalBottomUp(double[] s, double[] f, double[] v) {
        //interval [si, fi] of start and finish times
<span class="fc" id="L155">        s = Arrays.copyOf(s, s.length);</span>
<span class="fc" id="L156">        f = Arrays.copyOf(f, f.length);</span>
<span class="fc" id="L157">        v = Arrays.copyOf(v, v.length);</span>
        
<span class="fc" id="L159">        int n = f.length;</span>
        
        // ascending order sort by f
        // runtime complexity is O(log_2(n))
<span class="fc" id="L163">        int[] origIndexes = sort2(f, s, v);</span>
        //System.out.printf(&quot;sorted indexes=%s\n&quot;, Arrays.toString(origIndexes));
        
        // p[i] is the largest index such that f[p(i)] &lt; s[i]
        //     p[i] is &lt; i
        // runtime complexity is less than O(n^2)
<span class="fc" id="L169">        int[] p = calcP(s, f);</span>
        
<span class="fc" id="L171">        int[] pred = new int[n+1];</span>
        
<span class="fc" id="L173">        double[] memo = new double[n+1];</span>
<span class="fc" id="L174">        Arrays.fill(memo, -1);</span>
<span class="fc" id="L175">        memo[0] = 0;</span>
        int j;
        double leaveWeight, takeWeight;
        // runtime complexity is O(n)
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L180">            leaveWeight = memo[j];                // total weight if we leave j</span>
<span class="fc" id="L181">            takeWeight = v[j] + memo[p[j]];         // total weight if we take j</span>
            //System.out.printf(&quot;j=%d lw=M[j]=%.2f tw=v[j]+M[p[j]]=%.2f+%.2f=%.2f (where p[j]=%d) &quot;, 
            //    j, leaveWeight, v[j], memo[p[j]], takeWeight, p[j]);
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (leaveWeight &gt; takeWeight) {</span>
<span class="fc" id="L185">                memo[j + 1] = leaveWeight;              // better to leave j</span>
<span class="fc" id="L186">                pred[j+1] = j;                   // previous is j-1</span>
            } else {
<span class="fc" id="L188">                memo[j + 1] = takeWeight;               // better to take j</span>
<span class="fc" id="L189">                pred[j+1] = p[j];                  // previous is p[j]</span>
            }
           // System.out.printf(&quot;  M[j+1]=%.2f\n&quot;, memo[j+1]);
        }
         
        //System.out.printf(&quot;memo=%s\n&quot;, FormatArray.toString(memo, &quot;%.3f&quot;));
        //System.out.printf(&quot;   p=%s\n&quot;, Arrays.toString(p));
        //System.out.printf(&quot;pred=%s\n&quot;, Arrays.toString(pred));
        
<span class="fc" id="L198">        int[] sched = new int[j];</span>
<span class="fc" id="L199">        int count = 0;</span>
<span class="fc" id="L200">        j = pred.length-1;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        while (j &gt; 0) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (pred[j] == p[j-1]) {</span>
                //System.out.printf(&quot;  sched[%d]=%d\n&quot;, j-1, origIndexes[j-1]);
<span class="fc" id="L204">                sched[count++] = origIndexes[j - 1];</span>
            }
<span class="fc" id="L206">            j = pred[j];</span>
        }
<span class="fc" id="L208">        sched = Arrays.copyOfRange(sched, 0, count);</span>
<span class="fc" id="L209">        return sched;</span>
    }
    
    /**
     * The objective is to compute any maximum sized subset of non-overlapping intervals.
     * Weighted Interval Scheduling: 
     * given a set S = {1, . . . , n} of n activity requests, 
     * where each activity is expressed as an interval [s_i, f_i] from a given 
     * start time si to a given finish time f_i
     * and each request is associated with a numeric weight or value v_i.
     * 
     * The objective is to find a set of non-overlapping requests such that sum 
     * of values of the scheduled requests is maximum.
     * 
     * This code uses dynamic programming and has runtime complexity O(n^2).
     * 
     * The problem is from the lecture notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf
     * 
     * His pseudocode is present in the version of this method called 
     * weightedIntervalBottomUp().
     * 
     * runtime complexity is O(n^2)
     * 
     * The version here is a simpler dynamic programming solution:
     * 
       &lt;pre&gt;
         Roughly:
         
           Through these 2 short examples, one can see that a dynamic solution
           avoiding exponential comparisons of every permutation through re-use
           the answers from sub-problems, should be possible.
           
          First, sort tasks by finish time.

          example:
            0 ---------|
            1    ------------|*
            2             -----|
            3          ------------|
            0+2 is possible. store total weight.
            0+3 is possible and has larger weight than 0+2. store total weight.

          Mount's example:
              0  1  2  3  4  5  6  7  8  9
           0  ---------|
           1     ------------|*
           2           --------|
           3        ---------------|
           4                   ------|*
           5                       -----|
             indexes that can be appended after 0: 2,4,5
             indexes that can be appended after 1: 4,5
             indexes that can be appended after 2: 4,5
             indexes that can be appended after 3: 5
             indexes that can be appended after 4:

             start from i=5.  best combination = [5], weight=w[5]
                        i=4.  best combination = [4], weight=w[4]
                        i=3.  best combination = [3,5], weight=w[3]+memo[5]
                        i=2.  combinations max([2,4], [2,5]) = max(w[2]+memo[4], w[2]+memo[5])
                        i=1.  combinations max([1,4], [1,5]) = max(w[1]+memo[4], w[1]+memo[5])
                        i=0.  combinations max([0,2], [0,4], [0,5]) = max(w[0]+memo[2], w[0]+memo[4], w[0]+memo[5])

             so memo can be a 1-dimensional array
             can also store the indexes in a map with key=integer and value=integer hashset

        sort tasks by finish time.

        for i=[n-1,0]
          max = int.min
          jmax = -1
          for j=[i+1, n) { // memo[j] will already exist and hold best max sum for its part of the schedule to end
            if (s[j] .geq. f[i]) { // task j can be appended after task i
              if (memo[j] .gt. max) {
                jmax = j;
                max = memo[j];
              }
            }
          }
          set = new hashset int();
          map.put(i, set);
          set.add(i);
          if (jmax==-1) {
            memo[i] = w[i];
          } else {
            memo[i] = w[i] + max;
            set.add(jmax);
          }
        }
     * &lt;/pre&gt;
     * 
     @param s interval start times
     @param f interval finish times
     @param v interval weights
     @return indexes of scheduled intervals.
     */
    public int[] weightedIntervalBottomUp2(double[] s, double[] f, double[] v) {
        //interval [si, fi] of start and finish times
<span class="fc" id="L309">        s = Arrays.copyOf(s, s.length);</span>
<span class="fc" id="L310">        f = Arrays.copyOf(f, f.length);</span>
<span class="fc" id="L311">        v = Arrays.copyOf(v, v.length);</span>

<span class="fc" id="L313">        int n = f.length;</span>

        // ascending order sort by f
        // runtime complexity is O(n*log_2(n))
<span class="fc" id="L317">        int[] origIndexes = sort2(f, s, v);</span>
        //System.out.printf(&quot;sorted indexes=%s\n&quot;, Arrays.toString(origIndexes));

        // memo is populated from the bottom up.
        // the index of memo is the same index of sorted arrays.
        // memo[i=n-1] holds best solution schedulable from i to higher indexes,
        // so one can see that memo[i=n-1] must be values[n-1].
        // then we solve for memo[i=n-2] by iterating over j=n-2+1 to j=n-1
        // to find the max memo[j] that is schedulable, and assign memo[i] = that
        // max of value[j] plus values[i].
        // continuing this way, solving sub-problems from bottom-up, reusing already
        // solved memo of higher indexes.
        // then the memo array is scanned for maximum solution.
        // meanwhile, in the memo[i] solutions above, a map was made to keep track of which
        // indexes were added, so that the schedule can be constructed from it afterwards.

        // index is same as sorted f.  value is max sum of schedulable values from memo[i] and higher.
<span class="fc" id="L334">        double[] memo = new double[n];</span>
<span class="fc" id="L335">        TIntObjectMap&lt;TIntSet&gt; map = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

        int i;
        int j;
        double max;
        int jMax;
        TIntSet set;

        // runtime complexity is O(n^2)
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for (i = n - 1; i &gt;= 0; --i) {</span>
<span class="fc" id="L345">            set = new TIntHashSet();</span>
<span class="fc" id="L346">            map.put(i, set);</span>
<span class="fc" id="L347">            set.add(i);</span>
<span class="fc" id="L348">            memo[i] = v[i];</span>

<span class="fc" id="L350">            max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L351">            jMax = -1;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            for (j = i + 1; j &lt; n; ++j) { // memo[j] will already exist and hold best max sum for its part of the schedule to end</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                if (s[j] &gt;= f[i]) { // task j can be appended after task i</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                    if (memo[j] &gt; max) {</span>
<span class="fc" id="L355">                        jMax = j;</span>
<span class="fc" id="L356">                        max = memo[j];</span>
                    }
                }
            }// end loop over j

<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (jMax &gt; -1) {</span>
<span class="fc" id="L362">                memo[i] += memo[jMax];</span>
<span class="fc" id="L363">                set.addAll( map.get(jMax) );</span>
            }
        }//end loop over i

<span class="fc" id="L367">        max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L368">        jMax = -1;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">            if (memo[i] &gt; max) {</span>
<span class="fc" id="L371">                max = memo[i];</span>
<span class="fc" id="L372">                jMax = i;</span>
            }
        }

<span class="fc" id="L376">        int[] sched = map.get(jMax).toArray();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (i = 0; i &lt; sched.length; ++i) {</span>
<span class="fc" id="L378">            sched[i] = origIndexes[sched[i]];</span>
        }

<span class="fc" id="L381">        Arrays.sort(sched);</span>

<span class="fc" id="L383">        return sched;</span>
    }

    /**
     * given one machine and n tasks (where n = duration.length and the task properties
     * are duration, deadline and profit v) find a schedule which maximizes the summed
     * profits v.  A profit v_i is only received for a task finished before its deadline,
     * else there is not a penalty for lateness but no sum is added to the total profit,
     * so all tasks should be scheduled if possible.  The machine can only process one task at a time
     * and without interruption (no preemption).

     The algorithm is optimal.
     This algorithm uses dynamic programming.
     The runtime complexity is (n^2).

     The algorithm arises from question 34-4 of Cormen, Leiserson, Rivest, and Stein,
     &quot;Introduction to Algorithms&quot;, fourth edition

     * @param duration non-negative amount of times to complete each task
     * @param deadline non-negative deadlines for each task
     * @param v non-negative profits for each task completed before its deadline.
     * @param outputSchedule output array of length n to be populated by this algorithm with the order for scheduling tasks.
     * @param outLastOnTimeIdx output array of length 1 holding the index of outputSchedule which
     *                      is the last task in the schedule that completes before its deadline.
     * @return the summed profits for the tasks scheduled which will complete on time.
     */
    public static double weightedDynamicSingleResource(int[] duration, double[] deadline, double[] v, int[] outputSchedule, int[] outLastOnTimeIdx) {
<span class="fc" id="L410">        int n = duration.length;</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (deadline.length != n) {</span>
<span class="nc" id="L412">            throw new IllegalArgumentException(&quot;deadline.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (v.length != n) {</span>
<span class="nc" id="L415">            throw new IllegalArgumentException(&quot;v.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">        if (outputSchedule.length != n) {</span>
<span class="nc" id="L418">            throw new IllegalArgumentException(&quot;outputSchedule.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (outLastOnTimeIdx.length != 1) {</span>
<span class="nc" id="L421">            throw new IllegalArgumentException(&quot;outLastOnTimeIdx.length must equal 1&quot;);</span>
        }

<span class="fc" id="L424">        duration = Arrays.copyOf(duration, n);</span>
<span class="fc" id="L425">        deadline = Arrays.copyOf(deadline, n);</span>
<span class="fc" id="L426">        v = Arrays.copyOf(v, n);</span>

        // ascending order sort by deadline
        // runtime complexity is O(n*log_2(n))

<span class="fc" id="L431">        int[] origIndexes = sort2(deadline, duration, v);</span>
        //System.out.printf(&quot;sorted indexes=%s\n&quot;, Arrays.toString(origIndexes));

        // see notes on this algorithm at bottom of method

        // interval [si, fi] of start and finish times
        // where finish time f is calculated as time + duration of task.

        // memo needs a composite key of index and f
        // memo value is the summed profit
<span class="fc" id="L441">        TIntObjectMap&lt;TIntDoubleMap&gt; memo = new TIntObjectHashMap&lt;TIntDoubleMap&gt;();</span>

        // fMap key is index, and value is set of fi values stored from evaluation at index.  the fi values are used
        // to find summed profits in the memo map.
<span class="fc" id="L445">        TIntObjectMap&lt;TIntSet&gt; fMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

        // populating memo and fMap is at worst 2*(2^n))

        // dynamic programming using maps instead of dense matrix

        int i;
        int f;
        double sumP;
        TIntSet prevFMapSet, fMapSet;
        TIntDoubleMap memoFPMap;

<span class="fc" id="L457">        int count = 0;</span>

        // init:
        // include i=0 task
<span class="fc" id="L461">        i = 0;</span>
<span class="fc" id="L462">        fMapSet = new TIntHashSet();</span>
<span class="fc" id="L463">        memoFPMap = new TIntDoubleHashMap();</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (duration[i] &lt;= deadline[i]) {</span>
<span class="fc" id="L465">            f = duration[i];</span>
<span class="fc" id="L466">            sumP = v[i];</span>
<span class="fc" id="L467">            fMapSet.add(f);</span>
<span class="fc" id="L468">            memoFPMap.put(f, sumP);</span>
        }
        // exclude i=0 task
<span class="fc" id="L471">        f = 0;</span>
<span class="fc" id="L472">        sumP = 0;</span>
<span class="fc" id="L473">        fMapSet.add(f);</span>
<span class="fc" id="L474">        memoFPMap.put(f, sumP);</span>

        // update memo and fMap
<span class="fc" id="L477">        memo.put(i, memoFPMap);</span>
<span class="fc" id="L478">        fMap.put(i, fMapSet);</span>

<span class="fc" id="L480">        count+=2;</span>

        TIntIterator iter;
        int fPrev;
        double pPrev;
<span class="fc bfc" id="L485" title="All 2 branches covered.">        for (i = 1; i &lt; n; ++i) {</span>
            // get f's from prev index
<span class="fc" id="L487">            prevFMapSet = fMapSet;</span>
<span class="fc" id="L488">            fMapSet = new TIntHashSet();</span>
<span class="fc" id="L489">            memoFPMap = new TIntDoubleHashMap();//int f, double v</span>
<span class="fc" id="L490">            memo.put(i, memoFPMap);</span>
<span class="fc" id="L491">            fMap.put(i, fMapSet);</span>

<span class="fc" id="L493">            ++count;</span>

<span class="fc" id="L495">            iter = prevFMapSet.iterator();</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L497">                fPrev = iter.next();</span>
<span class="fc" id="L498">                pPrev = memo.get(i - 1).get(fPrev);</span>
                // tentative f
<span class="fc" id="L500">                f = fPrev + duration[i];</span>

<span class="fc" id="L502">                count++;</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">                if (f &lt;= deadline[i]) {</span>
                    // === include task i ====
<span class="fc" id="L506">                    sumP = pPrev + v[i];</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">                    if (memoFPMap.containsKey(f)) {</span>
                        // if entry already exists, take max of this and that
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                        if (memoFPMap.get(f) &lt; sumP) {</span>
<span class="nc" id="L510">                            memoFPMap.put(f, sumP);</span>
                        }
                    } else {
<span class="fc" id="L513">                        memoFPMap.put(f, sumP);</span>
<span class="fc" id="L514">                        fMapSet.add(f);</span>
                    }
                }

                // === exclude task i ====
                // by storing fPrev and pPrev after a check for existing entry in current memo for i
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                if (memoFPMap.containsKey(fPrev)) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    if (memoFPMap.get(fPrev) &lt; pPrev) {</span>
<span class="nc" id="L522">                        memoFPMap.put(fPrev, pPrev);</span>
                    }
                } else {
<span class="fc" id="L525">                    memoFPMap.put(fPrev, pPrev);</span>
<span class="fc" id="L526">                    fMapSet.add(fPrev);</span>
                }
            } // end loop over f
        } // end loop over i

<span class="fc" id="L531">        System.out.printf(&quot;count=%d\n&quot;, count);</span>

        // get max of memo[n-1]
<span class="fc" id="L534">        memoFPMap = memo.get(n - 1);</span>
<span class="fc" id="L535">        int maxF = -1;</span>
        double p;
<span class="fc" id="L537">        double maxP = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L538">        TIntDoubleIterator iter2 = memoFPMap.iterator();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        while (iter2.hasNext()) {</span>
<span class="fc" id="L540">            iter2.advance();</span>
<span class="fc" id="L541">            f = iter2.key();</span>
<span class="fc" id="L542">            p = iter2.value();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            if (p &gt; maxP) {</span>
<span class="fc" id="L544">                maxP = p;</span>
<span class="fc" id="L545">                maxF = f;</span>
            }
        }

        // recover indexes for schedule with backtracking
<span class="fc" id="L550">        f = maxF;</span>
<span class="fc" id="L551">        p = maxP;</span>
<span class="fc" id="L552">        TIntList sched = new TIntArrayList();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (i = n - 1; i &gt;= 0; --i) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if (p &lt;= 0) {</span>
<span class="nc" id="L555">                break;</span>
            }
<span class="fc bfc" id="L557" title="All 4 branches covered.">            if ((i &gt; 0) &amp;&amp; p == memo.get(i-1).get(f)) {</span>
<span class="fc" id="L558">                continue;</span>
            } else {
<span class="fc" id="L560">                sched.add(i);</span>
<span class="fc" id="L561">                p -= v[i];</span>
<span class="fc" id="L562">                f -= duration[i];</span>
            }
        }
<span class="pc bnc" id="L565" title="All 2 branches missed.">        assert(f == 0);</span>

<span class="fc" id="L567">        sched.reverse();</span>

<span class="fc" id="L569">        outLastOnTimeIdx[0] = sched.size() - 1;</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (sched.size() &lt; n) {</span>
<span class="fc" id="L572">            TIntSet schedSet = new TIntHashSet(sched);</span>
            // add the remaining tasks.  since they are ordered by deadline already,
            // this will minimize the lateness
<span class="fc bfc" id="L575" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                if (!schedSet.contains(i)) {</span>
<span class="fc" id="L577">                    sched.add(i);</span>
                }
            }
        }

        // transform to original indexes
<span class="fc bfc" id="L583" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L584">            outputSchedule[i] = origIndexes[sched.get(i)];</span>
        }

<span class="fc" id="L587">        return maxP;</span>
    }

    // s and f are sorted by ascending order of f before passed to this method
    // runtime complexity is O(n^2)
    private int[] calcP(double[] s, double[] f) {
        // iterating from highest index to lowest,
        // find for each s, highest previous index in which f[i-...] &lt; s_i
        int i, j;
<span class="fc" id="L596">        int[] p = new int[f.length+1];</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (i = s.length - 1; i &gt; -1; i--) {</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            for (j = i - 1; j &gt; -1; j--) {</span>
                //System.out.printf(&quot;calcP: %d,%d) f[%d]=%.2f s[%d]=%.2f\n&quot;, i,j, j, f[j], i, s[i]);
<span class="fc bfc" id="L600" title="All 2 branches covered.">                if (f[j] &lt;= s[i]) {</span>
<span class="fc" id="L601">                    p[i] = j+1;</span>
                    //System.out.printf(&quot;   p[%d]=%d\n&quot;, i, p[i]);
<span class="fc" id="L603">                    break;</span>
                }
            }
        }
<span class="fc" id="L607">        return p;</span>
    }
    
    /**
     * sect 16.5 of Cormen, Leiserson, Rivest, and Stein
     * 
     * there are numTasks number of tasks, each of which takes 1 unit of time
     * and has its own deadline and penalty for missing the deadline.
     * 
     * minimize the total penalty incurred for missed deadlines.
     * 
     * early tasks: finishes before or at deadline.
     * 
     * late tasks: finish after their deadlines.
     * 
     * early-first form:  early tasks precede late tasks.
     * 
     * canonical form: 
     *     early tasks precede late tasks
     *     and early tasks are in monotonically increasing order of deadlines.
     *     (1) put schedule in early first form
     *     (2) swap sequential pairs in the early list when d_{k} .gt. d_{k+1}
     *     (3) list the early tasks
     *     (4) list the late tasks in any order
     * 
     * if no tasks are late, the set is independent.
     * 
     * the early set by themselves is an independent set.
     * 
     * let L = set of all sets on independent tasks.
     * 
     * N_t(A) = number of tasks t=0,1,2...n in set A whose deadline is t or earlier.
     * 
     * if N_t(A) .gt. t then there is no way to schedule all tasks within deadline.
     * 
     * the problem of maximizing the sum of penalties for the early tasks
     *  is the same as minimizing the sum of penalties for the late tasks.
     * 
     * algorithm with r.t. O(N * log_2(N)):
     * 
     * (1) Use the Greedy algorithm to find a maximum weight independent set of
     *     tasks A.
     * (2) create an optimal schedule having the tasks in A as its early tasks.
    
     @param deadlines values must be between 1 and numTasks, inclusive
     @param penalties penalties for missing a deadline
     @return order of scheduled tasks
     */
    public int[] weightedGreedySingleResource(int[] deadlines, int[] penalties) {
        
        //O(N * log_2(N))
        //System.out.println(&quot;starting greedy algorithm to find indep sets&quot;);
<span class="fc" id="L659">        int[] indexes2 = greedy(Arrays.copyOf(deadlines, deadlines.length), </span>
<span class="fc" id="L660">            Arrays.copyOf(penalties, penalties.length));</span>
        //System.out.println(&quot;greedy algorithm resulting indexes=&quot; + Arrays.toString(indexes2));
        
        // rewrite d2 and p2 to be only the greedy results.   indexes2.length is &lt;= deadline.
<span class="fc" id="L664">        int[] d2 = new int[indexes2.length];</span>
<span class="fc" id="L665">        int[] p2 = new int[indexes2.length];</span>
<span class="fc" id="L666">        int[] i2 = new int[indexes2.length];</span>
        int i;
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (i = 0; i &lt; d2.length; ++i) {</span>
<span class="fc" id="L669">            d2[i] = deadlines[indexes2[i]];</span>
<span class="fc" id="L670">            p2[i] = penalties[indexes2[i]];</span>
<span class="fc" id="L671">            i2[i] = indexes2[i]; // storing indexes2</span>
        }
        
        // sort by increasing deadlines. O(N2 * log_2(N2))
        //these indexes are w.r.t. the truncated d2 and p2, that is, i2
<span class="fc" id="L676">        indexes2 = mergesortIncreasingADecreasingB(d2, p2);</span>
        
<span class="fc" id="L678">        int[] scheduled = new int[deadlines.length];</span>
<span class="fc" id="L679">        TIntSet allI = new TIntHashSet();</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        for (i = 0; i &lt; deadlines.length; ++i) {</span>
<span class="fc" id="L681">            allI.add(i);</span>
        }
<span class="fc bfc" id="L683" title="All 2 branches covered.">        for (i = 0; i &lt; indexes2.length; ++i) {</span>
            // transform indexes back to original array indexes
<span class="fc" id="L685">            scheduled[i] = i2[indexes2[i]];</span>
            //System.out.printf(&quot;  a%d (%d, %d)\n&quot;, 
            //    scheduled[i]+1, deadlines[scheduled[i]], penalties[scheduled[i]]);
<span class="fc" id="L688">            allI.remove(scheduled[i]);</span>
        }
        //System.out.println(&quot;appending late tasks in any order:&quot;);
<span class="fc" id="L691">        TIntIterator iter = allI.iterator();</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L693">            scheduled[i] = iter.next();</span>
            //System.out.printf(&quot;  a%d (%d, %d)\n&quot;, 
            //    scheduled[i]+1, deadlines[scheduled[i]], penalties[scheduled[i]]);
<span class="fc" id="L696">            i++;</span>
        }
        
<span class="fc" id="L699">        return scheduled;</span>
    }
  
    /**
     * schedule the largest penalties first if they fit before deadline (duration of
     * each task is a time unit of 1).
     * runtime complexity is O(N * log_2(N))
     @param deadlines deadlines of each task
     @param penalties penalties of each task
     @return task schedule order
     */
    private int[] greedy(int[] deadlines, int[] penalties) {

<span class="fc" id="L712">        deadlines = Arrays.copyOf(deadlines, deadlines.length);</span>
<span class="fc" id="L713">        penalties = Arrays.copyOf(penalties, penalties.length);</span>

        //O(N * log_2(N))
        // sort w, m into monotonically decreasing order by penalties
<span class="fc" id="L717">        int[] origIndexes = sortDecr(penalties, deadlines);</span>
        int i, oIdx;
        
        /*
        System.out.println(&quot;sorted by decr penalty:&quot;);
        for(i = 0; i &lt; penalties.length; ++i) {
            oIdx = origIndexes[i];
            System.out.printf(&quot;a%d deadline=%d penalty=%d\n&quot;, oIdx+1, deadlines[i], penalties[i]);
        }
        */
       
<span class="fc" id="L728">        TIntList a = new TIntArrayList();</span>
<span class="fc" id="L729">        int prevA = -1;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        for(i = 0; i &lt; deadlines.length; ++i) {</span>
            //oIdx = origIndexes[i];
            //System.out.printf(&quot;i=%d, oIdx=%d, a%d f_i=%d, (%d,%d): &quot;, i, oIdx, oIdx+1, (a.size()+1), deadlines[i], penalties[i]);
<span class="fc bfc" id="L733" title="All 2 branches covered.">            if (deadlines[i] &gt;= (a.size()+1)) {</span>
                //done early
<span class="fc" id="L735">                a.add(i);</span>
<span class="fc" id="L736">                prevA = i;</span>
                //System.out.println(&quot;  early accept&quot;);
<span class="pc bpc" id="L738" title="1 of 4 branches missed.">            } else if (!a.isEmpty() </span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">                &amp;&amp; (deadlines[prevA] &gt; deadlines[i]) &amp;&amp; (deadlines[prevA] &gt;= (a.size() + 1))</span>
                ) {
<span class="fc" id="L741">                a.add(i);</span>
<span class="fc" id="L742">                prevA = i;</span>
                //System.out.println(&quot;  accept&quot;);
            } /*else {
                System.out.println(&quot;  reject&quot;);
            }*/
        }
        // rewrite indexes in context of original array indexes:
<span class="fc" id="L749">        int[] ao = new int[a.size()];</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for (i = 0; i &lt; ao.length; ++i) {</span>
<span class="fc" id="L751">            ao[i] = origIndexes[a.get(i)];</span>
        }
<span class="fc" id="L753">        return ao;</span>
    }

    private static int[] sort2(double[] a, double[] b, double[] c) {
<span class="fc" id="L757">        int[] oIdxs = new int[a.length];</span>
        int i;
<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L760">            oIdxs[i] = i;</span>
        }
<span class="fc" id="L762">        mergesort(a, oIdxs, 0, a.length - 1);</span>
<span class="fc" id="L763">        double[] t = new double[b.length];</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L765">            t[i] = b[oIdxs[i]];</span>
        }
<span class="fc" id="L767">        System.arraycopy(t, 0, b, 0, b.length);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L769">            t[i] = c[oIdxs[i]];</span>
        }
<span class="fc" id="L771">        System.arraycopy(t, 0, c, 0, c.length);</span>
<span class="fc" id="L772">        return oIdxs;</span>
    }

    private static int[] sort2(double[] a, int[] b, double[] c) {

<span class="fc" id="L777">        int[] oIdxs = MiscSorter.mergeSortIncreasing(a);</span>
        int i;
<span class="fc" id="L779">        int[] tb = new int[b.length];</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L781">            tb[i] = b[oIdxs[i]];</span>
        }
<span class="fc" id="L783">        System.arraycopy(tb, 0, b, 0, b.length);</span>

<span class="fc" id="L785">        double[] tc = new double[b.length];</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L787">            tc[i] = c[oIdxs[i]];</span>
        }
<span class="fc" id="L789">        System.arraycopy(tc, 0, c, 0, c.length);</span>

<span class="fc" id="L791">        return oIdxs;</span>
    }

    private static void mergesort(double[] a, int[] b, int idxLo, int idxHi) {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L796">            int idxMid = (idxLo + idxHi) &gt;&gt; 1;</span>
<span class="fc" id="L797">            mergesort(a, b, idxLo, idxMid);           </span>
<span class="fc" id="L798">            mergesort(a, b, idxMid + 1, idxHi);       </span>
<span class="fc" id="L799">            merge(a, b, idxLo, idxMid, idxHi);</span>
        }
<span class="fc" id="L801">    }</span>

    private static void merge(double[] a, int[] b, int idxLo, int idxMid, int idxHi) {
<span class="fc" id="L804">        double[] aL = Arrays.copyOfRange(a, idxLo, idxMid + 2);</span>
<span class="fc" id="L805">        double[] aR = Arrays.copyOfRange(a, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L806">        aL[aL.length - 1] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L807">        aR[aR.length - 1] = Double.POSITIVE_INFINITY;</span>

<span class="fc" id="L809">        int[] bL = Arrays.copyOfRange(b, idxLo, idxMid + 2);</span>
<span class="fc" id="L810">        int[] bR = Arrays.copyOfRange(b, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L811">        bL[bL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L812">        bR[bR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L814">        int posL = 0;</span>
<span class="fc" id="L815">        int posR = 0;</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; k++) {</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">            if (aL[posL] &lt;= aR[posR]) {</span>
<span class="fc" id="L818">                a[k] = aL[posL];</span>
<span class="fc" id="L819">                b[k] = bL[posL];</span>
<span class="fc" id="L820">                posL++;</span>
            } else {
<span class="fc" id="L822">                a[k] = aR[posR];</span>
<span class="fc" id="L823">                b[k] = bR[posR];</span>
<span class="fc" id="L824">                posR++;</span>
            }
        }
<span class="fc" id="L827">    }</span>

    private int[] mergesortIncreasingADecreasingB(int[] a, int[] b) {
<span class="fc" id="L830">        int[] indexes = new int[a.length];</span>
        int i;
<span class="fc bfc" id="L832" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L833">            indexes[i] = i;</span>
        }
<span class="fc" id="L835">        mergesortIncreasingADecreasingB(a, b, indexes, 0, a.length-1);</span>
<span class="fc" id="L836">        return indexes;</span>
    }

    private void mergesortIncreasingADecreasingB(int[] a, int[] b, int[] c, int idxLo, int idxHi) {
<span class="fc bfc" id="L840" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L841">            int idxMid = (idxHi + idxLo)/2;</span>
<span class="fc" id="L842">            mergesortIncreasingADecreasingB(a, b, c, 0, idxMid);</span>
<span class="fc" id="L843">            mergesortIncreasingADecreasingB(a, b, c, idxMid + 1, idxHi);</span>
<span class="fc" id="L844">            mergeIncreasingADecreasingB(a, b, c, idxLo, idxMid, idxHi);</span>
        }
<span class="fc" id="L846">    }</span>

    private void mergeIncreasingADecreasingB(int[] a, int[] b, int[] c, 
        int idxLo, int idxMid, int idxHi) {
        
<span class="fc" id="L851">        int[] aL = Arrays.copyOfRange(a, idxLo, idxMid + 2);</span>
<span class="fc" id="L852">        int[] aR = Arrays.copyOfRange(a, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L853">        aL[aL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L854">        aR[aR.length - 1] = Integer.MAX_VALUE;</span>

<span class="fc" id="L856">        int[] bL = Arrays.copyOfRange(b, idxLo, idxMid + 2);</span>
<span class="fc" id="L857">        int[] bR = Arrays.copyOfRange(b, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L858">        bL[bL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L859">        bR[bR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L861">        int[] cL = Arrays.copyOfRange(c, idxLo, idxMid + 2);</span>
<span class="fc" id="L862">        int[] cR = Arrays.copyOfRange(c, idxMid + 1, idxHi + 2); </span>
<span class="fc" id="L863">        cL[cL.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc" id="L864">        cR[cR.length - 1] = Integer.MAX_VALUE;</span>
        
<span class="fc" id="L866">        int posL = 0;</span>
<span class="fc" id="L867">        int posR = 0;</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">        for (int k = idxLo; k &lt;= idxHi; ++k) {</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">            if (aL[posL] &lt; aR[posR]) {</span>
<span class="fc" id="L870">                a[k] = aL[posL];</span>
<span class="fc" id="L871">                b[k] = bL[posL];</span>
<span class="fc" id="L872">                c[k] = cL[posL];</span>
<span class="fc" id="L873">                posL++;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">            } else if (aL[posL] &gt; aR[posR]) {</span>
<span class="fc" id="L875">                a[k] = aR[posR];</span>
<span class="fc" id="L876">                b[k] = bR[posR];</span>
<span class="fc" id="L877">                c[k] = cR[posR];</span>
<span class="fc" id="L878">                posR++;</span>
            } else {
                // they're equal, so break ties by values of b
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">                if (bL[posL] &gt;= bR[posR]) {</span>
<span class="fc" id="L882">                    a[k] = aL[posL];</span>
<span class="fc" id="L883">                    b[k] = bL[posL];</span>
<span class="fc" id="L884">                    c[k] = cL[posL];</span>
<span class="fc" id="L885">                    posL++;</span>
                } else {
<span class="nc" id="L887">                    a[k] = aR[posR];</span>
<span class="nc" id="L888">                    b[k] = bR[posR];</span>
<span class="nc" id="L889">                    c[k] = cR[posR];</span>
<span class="nc" id="L890">                    posR++;</span>
                }
            }
        }
<span class="fc" id="L894">    }</span>
    
    
    private int[] sortDecr(int[] a, int[] b) {
<span class="fc" id="L898">        int[] oIdxs = new int[a.length];</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L900">            oIdxs[i] = i;</span>
        }
<span class="fc" id="L902">        quicksortDecr(a, oIdxs, 0, a.length - 1);</span>
<span class="fc" id="L903">        int[] t = new int[b.length];</span>
        int i;
<span class="fc bfc" id="L905" title="All 2 branches covered.">        for (i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L906">            t[i] = b[oIdxs[i]];</span>
        }
<span class="fc" id="L908">        System.arraycopy(t, 0, b, 0, b.length);</span>
<span class="fc" id="L909">        return oIdxs;</span>
    }
    
    private void quicksortDecr(int[] a, int[] b, int idxLo, int idxHi) {
<span class="fc bfc" id="L913" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L914">            int idxMid = partitionDecr(a, b, idxLo, idxHi);</span>
<span class="fc" id="L915">            quicksortDecr(a, b, idxLo, idxMid-1);</span>
<span class="fc" id="L916">            quicksortDecr(a, b, idxMid+1, idxHi);</span>
        }
<span class="fc" id="L918">    }</span>
    private int partitionDecr(int[] a, int[] b, int idxLo, int idxHi) {
<span class="fc" id="L920">        int xa = a[idxHi];</span>
<span class="fc" id="L921">        int i = idxLo - 1;  </span>
        int swap;
<span class="fc bfc" id="L923" title="All 2 branches covered.">        for (int j = idxLo; j &lt; idxHi ; j++ ) {</span>
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            if (a[j] &gt;= xa) { </span>
<span class="fc" id="L925">                i++;</span>
<span class="fc" id="L926">                swap = a[i];</span>
<span class="fc" id="L927">                a[i] = a[j];</span>
<span class="fc" id="L928">                a[j] = swap;</span>
<span class="fc" id="L929">                swap = b[i];</span>
<span class="fc" id="L930">                b[i] = b[j];</span>
<span class="fc" id="L931">                b[j] = swap;</span>
            }
        }
<span class="fc" id="L934">        swap = a[i + 1];</span>
<span class="fc" id="L935">        a[i + 1] = a[idxHi];</span>
<span class="fc" id="L936">        a[idxHi] = swap;</span>
<span class="fc" id="L937">        swap = b[i + 1];</span>
<span class="fc" id="L938">        b[i + 1] = b[idxHi];</span>
<span class="fc" id="L939">        b[idxHi] = swap;</span>
<span class="fc" id="L940">        return i + 1;</span>
    }

    /**
    Interval Partitioning:
    Given an infinite number of possible exclusive resources to use, 
    schedule all the activities using the smallest number of resources.
    The activity requests each have a start and finish time.
    Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
    such that events of R_j are mutually non-conflicting, for each j: 0  j  (d-1).

    References:
    &lt;pre&gt;
    lecture 7 notes of David Mount for CMSC 451       
    Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
    https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
    &lt;/pre&gt;

     runtime complexity is O(n^2).
     The approach is greedy but produces an optimal solution.

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;
     * 
     @param s start times
     @param f finish times
     @return indexes of resources to schedule the requests on.
     */
    public int[] intervalPartitionGreedy(double[] s, double[] f) {     
        
<span class="fc" id="L975">        double[] s2 = Arrays.copyOf(s, s.length);</span>
        
        /*
        (1) sort the requests by increasing order of start times. 
        (2) assign to each request the smallest color (possibly a new color) 
            such that it conflicts with no other requests of this color class. 
        */
        
        // runtime complexity O(n*log_2(n))
        //sort requests by increasing start times
<span class="fc" id="L985">        int[] indexes = MiscSorter.mergeSortIncreasing(s2);</span>
<span class="fc" id="L986">        double[] f2 = new double[s2.length];</span>
        int i, j;
<span class="fc bfc" id="L988" title="All 2 branches covered.">        for (i = 0; i &lt; f.length; ++i) {</span>
<span class="fc" id="L989">            f2[i] = f[indexes[i]];</span>
        }
        
        //System.out.println(&quot;indexes sorted by start times = &quot; + Arrays.toString(indexes));
        
        // a color for each request
<span class="fc" id="L995">        int[] c = new int[s.length];</span>
        
<span class="fc" id="L997">        TIntSet excl = new TIntHashSet();</span>
        int color;
<span class="fc bfc" id="L999" title="All 2 branches covered.">        for (i = 0; i &lt; f2.length; ++i) {</span>
<span class="fc" id="L1000">            excl.clear();</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">            for (j = 0; j &lt; i; ++j) {</span>
                //j is always smaller than i so s[j] &lt;= s[i].  
                //  then order is (sj,fj)  (si,fi)
                
                //if ([s[j],f[j]] overlaps [s[i],f[i]]) 
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                if (s2[i] &lt; f2[j]) {</span>
<span class="fc" id="L1007">                    excl.add(c[j]);</span>
                    /*System.out.printf(&quot;conflict for i2=%d, j2=%d (s2[%d]&lt;f2[%d])=(%.1f, %.2f)\n&quot;,
                        i, j, i, j, s2[i], f2[i]);
                    System.out.printf(&quot;==&gt; i=%d, j=%d (s2[%d]&lt;f2[%d])=(%.1f, %.2f)\n&quot;,
                        indexes[i], indexes[j], indexes[i], indexes[j], 
                        s[indexes[i]], f[indexes[i]]);
                    */
                }
            }
            //Let c be the smallest color NOT in E
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">            for (color = 0; color &lt; f2.length; ++color) {</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                if (!excl.contains(color)) {</span>
<span class="fc" id="L1019">                    break;</span>
                }
            }
<span class="fc" id="L1022">            c[i] = color;</span>
        }

        //rewrite c in terms of original indexes of method argument's unsorted (s,f)
<span class="fc" id="L1026">        int[] c2 = new int[f2.length];</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        for (i = 0; i &lt; f2.length; ++i) {</span>
<span class="fc" id="L1028">            c2[i] = c[indexes[i]];</span>
        }
<span class="fc" id="L1030">        return c2;</span>
    }

    /**
     Interval Partitioning:
     Given an infinite number of possible exclusive resources to use,
     schedule all the activities using the smallest number of resources.
     The activity requests each have a start and finish time.
     Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
     such that events of R_j are mutually non-conflicting, for each j: 0  j  (d-1).

     runtime complexity is O(n^2).

     The algorithm used is sometimes called &quot;left edge&quot;.

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;
     *
     @param s start times
     @param f finish times
     @return indexes of resources to schedule the requests on.
     */
    public int[] intervalPartitionGreedy2(double[] s, double[] f) {
<span class="fc" id="L1058">        int n = s.length;</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">        if (f.length != n) {</span>
<span class="nc" id="L1060">            throw new IllegalArgumentException(&quot;s and f must be same length&quot;);</span>
        }
<span class="fc" id="L1062">        double[] f2 = Arrays.copyOf(f, f.length);</span>

        // runtime complexity O(n*log(n))
        //sort requests by increasing finish times
<span class="fc" id="L1066">        int[] indexes = MiscSorter.mergeSortIncreasing(f2);</span>
<span class="fc" id="L1067">        double[] s2 = new double[n];</span>
        int i, j;
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1070">            s2[i] = s[indexes[i]];</span>
        }

<span class="fc" id="L1073">        List&lt;List&lt;Integer&gt;&gt; resources = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L1074">        List&lt;Integer&gt; current = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1075">        resources.add(current);</span>
<span class="fc" id="L1076">        double fPrev = -1;</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            if (s2[i] &lt; fPrev) {</span>
<span class="fc" id="L1079">                current = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1080">                resources.add(current);</span>
            }
<span class="fc" id="L1082">            current.add(i);</span>
<span class="fc" id="L1083">            fPrev = f2[i];</span>
        }
        // merge resources, bottom up
        double start, finish;
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (i = resources.size() - 1; i &gt; 0; --i) {</span>
<span class="fc" id="L1088">            current = resources.get(i);</span>
<span class="fc" id="L1089">            start = s2[current.get(0)];</span>
            // search lower indexes for feasible concatenation
<span class="fc bfc" id="L1091" title="All 2 branches covered.">            for (j = i - 1; j &gt;= 0; --j) {</span>
<span class="fc" id="L1092">                List&lt;Integer&gt; lower = resources.get(j);</span>
<span class="fc" id="L1093">                finish = f2[lower.get(lower.size() - 1)];</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">                if (start &gt;= finish) {</span>
                    // append current to lower
<span class="fc" id="L1096">                    lower.addAll(current);</span>
<span class="fc" id="L1097">                    resources.remove(i);</span>
<span class="fc" id="L1098">                    break;</span>
                }
            }
        }

        //rewrite in terms of original indexes of method argument's unsorted (s,f)
<span class="fc" id="L1104">        int[] schedResource = new int[n];</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        for (i = 0; i &lt; resources.size(); ++i) {</span>
<span class="fc" id="L1106">            current = resources.get(i);</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">            for (j = 0; j &lt; current.size(); ++j) {</span>
<span class="fc" id="L1108">                int idx = indexes[current.get(j)];</span>
<span class="fc" id="L1109">                schedResource[idx] = i;</span>
                //System.out.printf(&quot;%d) [%.3f : %.3f]  %d\n&quot;, i, s[idx], f[idx], idx);
            }
        }
<span class="fc" id="L1113">        return schedResource;</span>
    }

    /**
     Given exclusive use of 1 resource, find the maximum size of mutually compatible activities
     S = {a1, a2, ... an} where each activity has a start time si and finish time fi.
     0 &lt;= si &lt; fi &lt; inf.

     References:
     &lt;pre&gt;
     Chap 15 of &quot;Introduction to Algorithms&quot;, fourth edition
     Cormen, Leiserson, Rivest, and Stein,
     &lt;/pre&gt;

     runtime complexity is O(n) if already sorted, else O(n*log_2(n)).

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;
     *
     @param s start times
     @param f finish times
     @param isSortedByF
     @return indexes of resources to schedule the requests on.
     */
    public static int[] intervalPartitionGreedySingleResource(double[] s, double[] f, boolean isSortedByF) {
<span class="fc" id="L1143">        int n = f.length;</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">        if (s.length != n) {</span>
<span class="nc" id="L1145">            throw new IllegalArgumentException(&quot;s.length must equal f.length&quot;);</span>
        }

        double[] s2;
        double[] f2;
<span class="fc" id="L1150">        int[] indexes = null;</span>
        int i;
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">        if (!isSortedByF) {</span>
            //sort by f ascending
<span class="fc" id="L1154">            f2 = Arrays.copyOf(f, n);</span>
<span class="fc" id="L1155">            indexes = MiscSorter.mergeSortIncreasing(f2);</span>

<span class="fc" id="L1157">            s2 = new double[n];</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">            for (i = 0; i &lt; f.length; ++i) {</span>
<span class="fc" id="L1159">                s2[i] = s[indexes[i]];</span>
            }
        } else {
<span class="nc" id="L1162">            f2 = Arrays.copyOf(f, n);</span>
<span class="nc" id="L1163">            s2 = Arrays.copyOf(s, n);</span>
        }

<span class="fc" id="L1166">        TIntList a = new TIntArrayList();</span>
<span class="fc" id="L1167">        a.add(0);</span>
<span class="fc" id="L1168">        int j = 0;</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        for (i = 1; i &lt; n ; ++i) {</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">            if (s[i] &gt;= f[j]) {</span>
<span class="fc" id="L1171">                a.add(i);</span>
<span class="fc" id="L1172">                j = i;</span>
            }
        }

<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        if (isSortedByF) {</span>
<span class="nc" id="L1177">            return a.toArray();</span>
        }

        //rewrite schedule in terms of original indexes of method argument's unsorted (s,f)
<span class="fc" id="L1181">        int[] c2 = new int[a.size()];</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        for (i = 0; i &lt; a.size(); ++i) {</span>
<span class="fc" id="L1183">            c2[i] = indexes[a.get(i)];</span>
        }
<span class="fc" id="L1185">        return c2;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>