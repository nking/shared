<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Misc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.scheduling</a> &gt; <span class="el_source">Misc.java</span></div><h1>Misc.java</h1><pre class="source lang-java linenums">package algorithms.scheduling;

import algorithms.sort.MiscSorter;
import gnu.trove.iterator.TIntDoubleIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntDoubleMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntDoubleHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;

import java.util.*;
import java.util.stream.IntStream;

/**
 *
 * @author nichole
 */
<span class="fc" id="L22">public class Misc {</span>
        
     /**
     * For a single resource, schedule a set of n tasks where each task is associated with a execution time
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be the amount
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity O(N * log_2(N)).
      * The results are optimal in minimizing the maximum lateness.
     * 
     @param duration duration of task. duration a.k.a. burst time a.k.a. execution time
     @param deadline deadline for task
     @param outputStart output array to hold start times for the resulting scheduled index order 
     @param outputLate output array to hold lateness for the resulting scheduled index order.
     * if is on time, element will be 0.
     @return indexes for scheduling order
     */
    public int[] unweightedIntervalMinimizeLateGreedy(double[] duration, double[] deadline,
        double[] outputStart, double[] outputLate) {
<span class="fc" id="L52">        int n = duration.length;</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (deadline.length != n) {</span>
<span class="nc" id="L54">            throw new IllegalArgumentException(&quot;d.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (outputStart.length != n) {</span>
<span class="nc" id="L57">            throw new IllegalArgumentException(&quot;outputStart.length must equal t.length&quot;);</span>
        }
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        if (outputLate.length != n) {</span>
<span class="nc" id="L60">            throw new IllegalArgumentException(&quot;outputLate.length must equal t.length&quot;);</span>
        }
        //duration = Arrays.copyOf(duration, duration.length);
        //deadline = Arrays.copyOf(deadline, deadline.length);
<span class="fc" id="L64">        Arrays.fill(outputStart, 0);</span>
<span class="fc" id="L65">        Arrays.fill(outputLate, 0);</span>
        
        //sort tasks by increasing deadline to minimize the lateness
<span class="fc" id="L68">        int[] sortedIndexes = IntStream.range(0, deadline.length).boxed()</span>
<span class="fc" id="L69">                .sorted((i, j) -&gt; {</span>
<span class="fc" id="L70">                    int c = Double.compare(deadline[i], deadline[j]);</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                    if (c != 0) return c;</span>
<span class="nc" id="L72">                    return Double.compare(duration[i], duration[j]);</span>
                })
<span class="fc" id="L74">                .mapToInt(ele -&gt; ele)</span>
<span class="fc" id="L75">                .toArray();</span>

<span class="fc" id="L77">        double f_prev = 0; // f is the finish time of previous task</span>
        int i; 
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (int ii = 0; ii &lt; duration.length; ++ii) {</span>
            //assign task i to start at
<span class="fc" id="L81">            i = sortedIndexes[ii];</span>
<span class="fc" id="L82">            outputStart[i] = f_prev;  // start next task</span>
<span class="fc" id="L83">            f_prev = /*f[i] =*/ outputStart[i] + duration[i];  // its finish time</span>
            //lateness[i] = max(0, f[i] - d[i])     // its lateness
<span class="fc" id="L85">            outputLate[i] = Math.max(0, f_prev - deadline[i]);</span>
        }
<span class="fc" id="L87">        return sortedIndexes;</span>
    }
    
    /**
     * schedule a set of n tasks where each task is associated with a execution time 
     * t_i and a deadline d_i. 
     * The objective is to schedule the tasks, no two overlapping in time, 
     * such that they are all completed before their deadline. 
     * If this is not possible, define the lateness of the ith task to be amount 
     * by which its finish time exceeds its deadline. 
     * The objective is to minimize the maximum lateness over all the tasks.
     * 
     * The algorithm is aka Earliest Finish First (EFF) and Earliest Deadline First (EDF)
     *    (1) sort tasks by finish time
     *    (2) iterate over tasks, scheduling each that starts after the previous ended
     * 
     * References:
     * &lt;pre&gt;
     * lecture 7 notes of David Mount for CMSC 451 
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
     * &lt;/pre&gt;
     * 
     * runtime complexity is O(N * log_2(N)).
     * This is a greedy and optimal solution.
     * 
     @param s start times for tasks
     @param f finish times for tasks
     @return indexes for scheduled non-conflicting tasks
     */
    public int[] unweightedIntervalNoConflicts(double[] s, double[] f) {
<span class="fc" id="L118">        int n = s.length;</span>
        
        //sort tasks by increasing finish times .  O(N * log_2(N))
<span class="fc" id="L121">        int[] sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L122">                .sorted((i, j) -&gt; {</span>
<span class="fc" id="L123">                    int c = Double.compare(f[i], f[j]);</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                    if (c != 0) return c;</span>
<span class="nc" id="L125">                    return Double.compare(s[i], s[j]);</span>
                })
<span class="fc" id="L127">                .mapToInt(ele -&gt; ele)</span>
<span class="fc" id="L128">                .toArray();</span>

<span class="fc" id="L130">        double f_prev = -1; // f is the finish time of previous task</span>
        int i; 
<span class="fc" id="L132">        int[] scheduled = new int[n];</span>
<span class="fc" id="L133">        int count = 0;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (s[i] &gt; f_prev) {</span>
<span class="fc" id="L136">                scheduled[count++] = sortedIndexes[i];</span>
<span class="fc" id="L137">                f_prev = f[i];</span>
            }
        }
<span class="fc" id="L140">        scheduled = Arrays.copyOfRange(scheduled, 0, count);</span>
<span class="fc" id="L141">        return scheduled;</span>
    }

    /**
     * The objective is to compute any maximum sized subset of non-overlapping intervals that produce the highest
     * sum of values (profits).

     &lt;pre&gt;
     The algorithm uses dynamic programming and has runtime complexity between O(n*log(n)) and O(n^2).
     &lt;/pre&gt;
     * The problem is adapted from the lecture notes of David Mount for CMSC 451
     * Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
     * https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf
     *
     * The algorithm solution here is a simpler dynamic program.
     * 
       &lt;pre&gt;
         Roughly:
         
           Through these 2 short examples, one can see that a dynamic solution
           avoiding exponential comparisons of every permutation through re-use
           the answers from sub-problems, should be possible.
           
          First, sort tasks by finish time.

          example:
            0 ---------|
            1    ------------|*
            2             -----|
            3          ------------|
            0+2 is possible. store total weight.
            0+3 is possible and has larger weight than 0+2. store total weight.

          Mount's example:
              0  1  2  3  4  5  6  7  8  9
           0  ---------|
           1     ------------|*
           2           --------|
           3        ---------------|
           4                   ------|*
           5                       -----|
             indexes that can be appended after 0: 2,4,5
             indexes that can be appended after 1: 4,5
             indexes that can be appended after 2: 4,5
             indexes that can be appended after 3: 5
             indexes that can be appended after 4:

             start from i=5.  best combination = [5], weight=w[5]
                        i=4.  best combination = [4], weight=w[4]
                        i=3.  best combination = [3,5], weight=w[3]+memo[5]
                        i=2.  combinations max([2,4], [2,5]) = max(w[2]+memo[4], w[2]+memo[5])
                        i=1.  combinations max([1,4], [1,5]) = max(w[1]+memo[4], w[1]+memo[5])
                        i=0.  combinations max([0,2], [0,4], [0,5]) = max(w[0]+memo[2], w[0]+memo[4], w[0]+memo[5])

           Then use dynamic programming with tabulation to store the best schedule starting at n-1
              as scheduline including that task and its profits.
           Then proceed to n-2 and find the max profit schedule already calcuated for higher indexes that can
              fit after this task's finish time.
           repeating until reach first task.

           Then the highest profit schedule in tabulation is kept.
     * &lt;/pre&gt;
     * 
     @param s interval start times
     @param f interval finish times
     @param v interval weights
     @return indexes of scheduled intervals.
     */
    public int[] weightedIntervalBottomUp(double[] s, double[] f, double[] v) {
        //interval [si, fi] of start and finish times

<span class="fc" id="L212">        int n = f.length;</span>

        // ascending order sort by f
        // runtime complexity is O(n*log_2(n))
<span class="fc" id="L216">        int[] sortedIdxs = IntStream.range(0,n).boxed()</span>
<span class="fc" id="L217">                .sorted((i, j)-&gt; Double.compare(f[i], f[j]))</span>
<span class="fc" id="L218">                .mapToInt(ele -&gt; ele)</span>
<span class="fc" id="L219">                .toArray();</span>

        //System.out.printf(&quot;sorted indexes=%s\n&quot;, Arrays.toString(sortedIdxs));

        // use dynamic programming with tabulation
<span class="fc" id="L224">        double[] tabProfits = new double[n];</span>
<span class="fc" id="L225">        Map&lt;Integer, Set&lt;Integer&gt;&gt; tabIndices = new HashMap&lt;&gt;();</span>

        int i;
        int j;
        double max;
        int jjMax;

        // r.t.c is &lt; O(n^2) now, but also &gt; O(n(log(n))
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (int ii = n - 1; ii &gt;= 0; --ii) {</span>
<span class="fc" id="L234">            i = sortedIdxs[ii];</span>
<span class="fc" id="L235">            tabIndices.putIfAbsent(ii, new HashSet&lt;&gt;());</span>
<span class="fc" id="L236">            tabIndices.get(ii).add(i);</span>
<span class="fc" id="L237">            tabProfits[ii] = v[i];</span>

<span class="fc" id="L239">            max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L240">            jjMax = -1;</span>
            //improved by finding the first jj that satifies the conditional clause by using bisecting search here.
            // [ii] &gt; [jj]
            // bisecting floor search
<span class="fc" id="L244">            boolean found = false;</span>
<span class="fc" id="L245">            int lo = ii + 1;</span>
<span class="fc" id="L246">            int hi = n - 1;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            while (lo &lt; hi) {</span>
<span class="fc" id="L248">                int midJJ = lo + (hi - lo)/2;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (f[i] == s[sortedIdxs[midJJ]]) {</span>
<span class="fc" id="L250">                    found = true;</span>
<span class="fc" id="L251">                    hi = midJJ - 1;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                } else if (f[i] &lt; s[sortedIdxs[midJJ]]) {</span>
<span class="fc" id="L253">                    lo = midJJ + 1;</span>
                } else {
<span class="fc" id="L255">                    hi = midJJ - 1;</span>
                }
<span class="fc" id="L257">            }</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            int jj0 = found ? lo : Math.min(lo, hi);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            for (int jj = jj0; jj &lt; n; ++jj) { // tabProfits[jj] will already exist and hold best max sum for its part of the schedule to end</span>
<span class="fc" id="L260">                j = sortedIdxs[jj];</span>
<span class="fc bfc" id="L261" title="All 4 branches covered.">                if (i != j &amp;&amp; s[j] &gt;= f[i]) { // task j can be appended after task i</span>
                    //System.out.printf(&quot;ii=%d, jj=%d\n&quot;, ii, jj);
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    if (tabProfits[jj] &gt; max) {</span>
<span class="fc" id="L264">                        jjMax = jj;</span>
<span class="fc" id="L265">                        max = tabProfits[jj];</span>
                    }
                }
            }// end loop over jj

<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (jjMax &gt; -1) {</span>
<span class="fc" id="L271">                tabProfits[ii] += tabProfits[jjMax];</span>
<span class="fc" id="L272">                tabIndices.get(ii).addAll( tabIndices.get(jjMax) );</span>
            }
        }//end loop over i

        // choose sched w/ max profit:
<span class="fc" id="L277">        max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L278">        jjMax = -1;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            if (tabProfits[i] &gt; max) {</span>
<span class="fc" id="L281">                max = tabProfits[i];</span>
<span class="fc" id="L282">                jjMax = i;</span>
            }
        }

<span class="fc" id="L286">        int[] sched = new int[tabIndices.get(jjMax).size()];</span>
<span class="fc" id="L287">        i = 0;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (int idx : tabIndices.get(jjMax)) {</span>
<span class="fc" id="L289">            sched[i++] = idx;</span>
<span class="fc" id="L290">        }</span>

<span class="fc" id="L292">        Arrays.sort(sched);</span>

<span class="fc" id="L294">        return sched;</span>
    }

    /**
     * given one machine and n tasks (where n = duration.length and the task properties
     * are duration, deadline and profit v) find a schedule which maximizes the summed
     * profits v.  A profit v_i is only received for a task finished before its deadline,
     * else there is not a penalty for lateness but no sum is added to the total profit,
     * so all tasks should be scheduled if possible.  The machine can only process one task at a time
     * and without interruption (no preemption).

     The algorithm is optimal.
     This algorithm uses dynamic programming.
     The runtime complexity is (n^2).

     The algorithm arises from question 34-4 of Cormen, Leiserson, Rivest, and Stein,
     &quot;Introduction to Algorithms&quot;, fourth edition

     * @param duration non-negative amount of times to complete each task
     * @param deadline non-negative deadlines for each task
     * @param v non-negative profits for each task completed before its deadline.
     * @param outputSchedule output array of length n to be populated by this algorithm with the order for scheduling tasks.
     * @param outLastOnTimeIdx output array of length 1 holding the index of outputSchedule which
     *                      is the last task in the schedule that completes before its deadline.
     * @return the summed profits for the tasks scheduled which will complete on time.
     */
    public static double weightedDynamicSingleResource(int[] duration, double[] deadline, double[] v, int[] outputSchedule, int[] outLastOnTimeIdx) {
<span class="fc" id="L321">        int n = duration.length;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (deadline.length != n) {</span>
<span class="nc" id="L323">            throw new IllegalArgumentException(&quot;deadline.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (v.length != n) {</span>
<span class="nc" id="L326">            throw new IllegalArgumentException(&quot;v.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (outputSchedule.length != n) {</span>
<span class="nc" id="L329">            throw new IllegalArgumentException(&quot;outputSchedule.length must equal duration.length&quot;);</span>
        }
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (outLastOnTimeIdx.length != 1) {</span>
<span class="nc" id="L332">            throw new IllegalArgumentException(&quot;outLastOnTimeIdx.length must equal 1&quot;);</span>
        }

        // ascending order sort by deadline
        // runtime complexity is O(n*log_2(n))
<span class="fc" id="L337">        int[] sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L338">                .sorted((i, j) -&gt; Double.compare(deadline[i], deadline[j]))</span>
<span class="fc" id="L339">                .mapToInt(ele -&gt; ele).toArray();</span>

        // see notes on this algorithm at bottom of method

        // interval [si, fi] of start and finish times
        // where finish time f is calculated as time + duration of task.

        // tabProfits key = tab index, value = map w/ key=f, value=summed profits (==summed v).
        //     f is a summed property too.
<span class="fc" id="L348">        TIntObjectMap&lt;TIntDoubleMap&gt; tabProfits = new TIntObjectHashMap&lt;TIntDoubleMap&gt;();</span>

        // tabProfitsF key = tab index, value = set of fs added to this schedule. the f values are used
        // to find summed profits in the tabProfits map.
<span class="fc" id="L352">        TIntObjectMap&lt;TIntSet&gt; tabProfitsF = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

        // populating tabProfits and tabProfitsF is at worst 2*(2^n))

        // dynamic programming using maps instead of dense matrix

        int f;
        double sumP;

<span class="fc" id="L361">        int count = 0;</span>

        TIntIterator iter;
        int fPrev;
        double pPrev;
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int ii = 0; ii &lt; n; ++ii) {</span>
<span class="fc" id="L367">            final int i = sortedIndexes[ii];</span>

            // update tabProfits and tabProfitsF
<span class="fc" id="L370">            tabProfits.put(ii, new TIntDoubleHashMap()); // map has key=f, value=v</span>
<span class="fc" id="L371">            tabProfitsF.put(ii, new TIntHashSet());</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (ii == 0) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                if (duration[i] &lt;= deadline[i]) {</span>
                    // include if possible
<span class="fc" id="L376">                    f = duration[i];</span>
<span class="fc" id="L377">                    sumP = v[i];</span>
<span class="fc" id="L378">                    tabProfitsF.get(ii).add(f);</span>
<span class="fc" id="L379">                    tabProfits.get(ii).put(f, sumP);</span>
                }
                // exclude
<span class="fc" id="L382">                f = 0;</span>
<span class="fc" id="L383">                sumP = 0;</span>
<span class="fc" id="L384">                tabProfitsF.get(ii).add(f);</span>
<span class="fc" id="L385">                tabProfits.get(ii).put(f, sumP);</span>

<span class="fc" id="L387">                count += 2;</span>
<span class="fc" id="L388">                continue;</span>
            }

<span class="fc" id="L391">            ++count;</span>

<span class="fc" id="L393">            iter = tabProfitsF.get(ii-1).iterator();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L395">                fPrev = iter.next();</span>
<span class="fc" id="L396">                pPrev = tabProfits.get(ii - 1).get(fPrev);</span>
                // tentative f
<span class="fc" id="L398">                f = fPrev + duration[i];</span>

<span class="fc" id="L400">                count++;</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">                if (f &lt;= deadline[i]) {</span>
                    // === include task i ====
<span class="fc" id="L404">                    sumP = pPrev + v[i];</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                    if (tabProfits.get(ii).containsKey(f)) {</span>
                        // if entry already exists, take max of this and that
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">                        if (tabProfits.get(ii).get(f) &lt; sumP) {</span>
<span class="nc" id="L408">                            tabProfits.get(ii).put(f, sumP);</span>
                        }
                    } else {
<span class="fc" id="L411">                        tabProfits.get(ii).put(f, sumP);</span>
<span class="fc" id="L412">                        tabProfitsF.get(ii).add(f);</span>
                    }
                }

                // === exclude task i by bringing in previous values and not adding this i to it ====
                // by storing fPrev and pPrev after a check for existing entry in current tabProfits for i
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">                if (tabProfits.get(ii).containsKey(fPrev)) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                    if (tabProfits.get(ii).get(fPrev) &lt; pPrev) {</span>
<span class="nc" id="L420">                        tabProfits.get(ii).put(fPrev, pPrev);</span>
                    }
                } else {
<span class="fc" id="L423">                    tabProfits.get(ii).put(fPrev, pPrev);</span>
<span class="fc" id="L424">                    tabProfitsF.get(ii).add(fPrev);</span>
                }
            } // end loop over f
        } // end loop over i

<span class="fc" id="L429">        System.out.printf(&quot;count=%d\n&quot;, count);</span>

        // get max of tabProfits[n-1]
<span class="fc" id="L432">        int maxF = -1;</span>
        double p;
<span class="fc" id="L434">        double maxP = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L435">        TIntDoubleIterator iter2 = tabProfits.get(n - 1).iterator();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        while (iter2.hasNext()) {</span>
<span class="fc" id="L437">            iter2.advance();</span>
<span class="fc" id="L438">            f = iter2.key();</span>
<span class="fc" id="L439">            p = iter2.value();</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (p &gt; maxP) {</span>
<span class="fc" id="L441">                maxP = p;</span>
<span class="fc" id="L442">                maxF = f;</span>
            }
        }

        // recover indexes for schedule with backtracking
<span class="fc" id="L447">        f = maxF;</span>
<span class="fc" id="L448">        p = maxP;</span>
<span class="fc" id="L449">        TIntList sched = new TIntArrayList();</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        for (int ii = n - 1; ii &gt;= 0; --ii) {</span>
<span class="fc" id="L451">            int i = sortedIndexes[ii];</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (p &lt;= 0) {</span>
<span class="nc" id="L453">                break;</span>
            }
<span class="fc bfc" id="L455" title="All 4 branches covered.">            if ((ii-1 &gt;= 0) &amp;&amp; p == tabProfits.get(ii-1).get(f)) {</span>
<span class="fc" id="L456">                continue;</span>
            } else {
<span class="fc" id="L458">                sched.add(i);</span>
<span class="fc" id="L459">                p -= v[i];</span>
<span class="fc" id="L460">                f -= duration[i];</span>
            }
        }
<span class="pc bnc" id="L463" title="All 2 branches missed.">        assert(f == 0);</span>

<span class="fc" id="L465">        sched.reverse();</span>

<span class="fc" id="L467">        outLastOnTimeIdx[0] = sched.size() - 1;</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (sched.size() &lt; n) {</span>
<span class="fc" id="L470">            TIntSet schedSet = new TIntHashSet(sched);</span>
            // add the remaining tasks.  since they are ordered by deadline already,
            // this will minimize the lateness
<span class="fc bfc" id="L473" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                if (!schedSet.contains(i)) {</span>
<span class="fc" id="L475">                    sched.add(i);</span>
                }
            }
        }

<span class="fc bfc" id="L480" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L481">            outputSchedule[i] = sched.get(i);</span>
        }

<span class="fc" id="L484">        return maxP;</span>
    }

    // s and f are sorted by ascending order of f before passed to this method
    // runtime complexity is O(n^2)
    private int[] calcP(double[] s, double[] f, int[] sortedIndexes) {
        // iterating from highest index to lowest,
        // find for each s, highest previous index in which f[i-...] &lt; s_i
        int i, j;
<span class="nc" id="L493">        int[] p = new int[f.length+1];</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for (int ii = s.length - 1; ii &gt; -1; ii--) {</span>
<span class="nc" id="L495">            i = sortedIndexes[ii];</span>
            //could imporve with a bisecting search here to constrain the range of jj
<span class="nc bnc" id="L497" title="All 2 branches missed.">            for (int jj = ii - 1; jj &gt; -1; jj--) {</span>
<span class="nc" id="L498">                j = sortedIndexes[jj];</span>
                //System.out.printf(&quot;calcP: %d,%d) f[%d]=%.2f s[%d]=%.2f\n&quot;, i,j, j, f[j], i, s[i]);
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (f[j] &lt;= s[i]) {</span>
<span class="nc" id="L501">                    p[i] = j+1;</span>
                    //System.out.printf(&quot;   p[%d]=%d\n&quot;, i, p[i]);
<span class="nc" id="L503">                    break;</span>
                }
            }
        }
<span class="nc" id="L507">        return p;</span>
    }
    
    /**
     * sect 16.5 of Cormen, Leiserson, Rivest, and Stein
     * 
     * there are numTasks number of tasks, each of which takes 1 unit of time
     * and has its own deadline and penalty for missing the deadline.
     * 
     * minimize the total penalty incurred for missed deadlines.
     * 
     * early tasks: finishes before or at deadline.
     * 
     * late tasks: finish after their deadlines.
     * 
     * early-first form:  early tasks precede late tasks.
     * 
     * canonical form: 
     *     early tasks precede late tasks
     *     and early tasks are in monotonically increasing order of deadlines.
     *     (1) put schedule in early first form
     *     (2) swap sequential pairs in the early list when d_{k} .gt. d_{k+1}
     *     (3) list the early tasks
     *     (4) list the late tasks in any order
     * 
     * if no tasks are late, the set is independent.
     * 
     * the early set by themselves is an independent set.
     * 
     * let L = set of all sets on independent tasks.
     * 
     * N_t(A) = number of tasks t=0,1,2...n in set A whose deadline is t or earlier.
     * 
     * if N_t(A) .gt. t then there is no way to schedule all tasks within deadline.
     * 
     * the problem of maximizing the sum of penalties for the early tasks
     *  is the same as minimizing the sum of penalties for the late tasks.
     * 
     * algorithm with r.t. O(N * log_2(N)):
     * 
     * (1) Use the Greedy algorithm to find a maximum weight independent set of
     *     tasks A.
     * (2) create an optimal schedule having the tasks in A as its early tasks.
    
     @param deadlines values must be between 1 and numTasks, inclusive
     @param penalties penalties for missing a deadline
     @return order of scheduled tasks
     */
    public int[] weightedGreedySingleResource(int[] deadlines, int[] penalties) {
        
        //O(N * log_2(N))
        // schedule the largest penalties first if they fit before deadline (duration of each task is a time unit of 1).
        // the result is a list that may be &lt; n in length
<span class="fc" id="L560">        int[] indexes2 = greedy(deadlines, penalties);</span>

        //System.out.println(&quot;greedy algorithm resulting indexes=&quot; + Arrays.toString(indexes2));

        //O(N * log_2(N))
        // sort by ascending deadlines, break ties by descending penalities
<span class="fc" id="L566">        int[] sortedIndexes2 = IntStream.range(0, indexes2.length).boxed()</span>
<span class="fc" id="L567">                .sorted((ii, jj) -&gt; {</span>
<span class="fc" id="L568">                    int c = Double.compare(deadlines[indexes2[ii]], deadlines[indexes2[jj]]);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                    if (c != 0) return c;</span>
<span class="fc" id="L570">                    return Double.compare(penalties[indexes2[jj]],  penalties[indexes2[ii]]);</span>
                })
<span class="fc" id="L572">                .mapToInt(ele -&gt; ele).toArray();</span>

<span class="fc" id="L574">        int[] scheduled2 = new int[deadlines.length];</span>

<span class="fc" id="L576">        TIntSet allI2 = new TIntHashSet();</span>
        int i;
<span class="fc bfc" id="L578" title="All 2 branches covered.">        for (i = 0; i &lt; deadlines.length; ++i) {</span>
<span class="fc" id="L579">            allI2.add(i);</span>
        }

<span class="fc bfc" id="L582" title="All 2 branches covered.">        for (i = 0; i &lt; sortedIndexes2.length; ++i) {</span>
            // transform indexes back to original array indexes
<span class="fc" id="L584">            scheduled2[i] = sortedIndexes2[i];</span>
<span class="fc" id="L585">            allI2.remove(scheduled2[i]);</span>
        }
        //System.out.println(&quot;appending late tasks in any order:&quot;);
<span class="fc" id="L588">        TIntIterator iter = allI2.iterator();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L590">            scheduled2[i] = iter.next();</span>
<span class="fc" id="L591">            i++;</span>
        }

<span class="fc" id="L594">        return scheduled2;</span>
    }
  
    /**
     * schedule the largest penalties first if they fit before deadline (duration of
     * each task is a time unit of 1).
     * runtime complexity is O(N * log_2(N))
     @param deadlines deadlines of each task
     @param penalties penalties of each task
     @return task schedule order
     */
    private int[] greedy(int[] deadlines, int[] penalties) {

<span class="fc" id="L607">        int n = deadlines.length;</span>

        //O(N * log_2(N))
        // sort w, m into monotonically decreasing order by penalties
<span class="fc" id="L611">        int[] sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L612">                .sorted((i, j) -&gt; {return penalties[j] - penalties[i];})</span>
<span class="fc" id="L613">                .mapToInt(ele -&gt; ele)</span>
<span class="fc" id="L614">                .toArray();</span>

        /*
        System.out.println(&quot;sorted by decr penalty:&quot;);
        for(i = 0; i &lt; penalties.length; ++i) {
            oIdx = origIndexes[i];
            System.out.printf(&quot;a%d deadline=%d penalty=%d\n&quot;, oIdx+1, deadlines[i], penalties[i]);
        }
        */

        //TODO: consider overloading method for durations.  then need an array b to complement a, holding integrated
        // durations.
       
<span class="fc" id="L627">        TIntList a = new TIntArrayList();</span>
<span class="fc" id="L628">        int prevA = -1;</span>
        int i;
<span class="fc bfc" id="L630" title="All 2 branches covered.">        for (int ii = 0; ii &lt; n; ++ii) {</span>
<span class="fc" id="L631">            i = sortedIndexes[ii];</span>
            //System.out.printf(&quot;i=%d, oIdx=%d, a%d f_i=%d, (%d,%d): &quot;, i, oIdx, oIdx+1, (a.size()+1), deadlines[i], penalties[i]);
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (deadlines[i] &gt;= (a.size()+1)) {</span>
                //done early
<span class="fc" id="L635">                a.add(i);</span>
<span class="fc" id="L636">                prevA = i;</span>
                //System.out.println(&quot;  early accept&quot;);
<span class="pc bpc" id="L638" title="1 of 4 branches missed.">            } else if (!a.isEmpty() </span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                &amp;&amp; (deadlines[prevA] &gt; deadlines[i]) &amp;&amp; (deadlines[prevA] &gt;= (a.size() + 1))</span>
                ) {
<span class="fc" id="L641">                a.add(i);</span>
<span class="fc" id="L642">                prevA = i;</span>
                //System.out.println(&quot;  accept&quot;);
            } /*else {
                System.out.println(&quot;  reject&quot;);
            }*/
        }
<span class="fc" id="L648">        int[] ao = new int[a.size()];</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">        for (i = 0; i &lt; ao.length; ++i) {</span>
<span class="fc" id="L650">            ao[i] = a.get(i);</span>
        }
<span class="fc" id="L652">        return ao;</span>
    }

    /**
    Interval Partitioning:
    Given an infinite number of possible exclusive resources to use, 
    schedule all the activities using the smallest number of resources.
    The activity requests each have a start and finish time.
    Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
    such that events of R_j are mutually non-conflicting, for each j: 0 ≤ j ≤ (d-1).

    References:
    &lt;pre&gt;
    lecture 7 notes of David Mount for CMSC 451       
    Design and Analysis of Computer Algorithms (with some corrections for pseudocode indexes).
    https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect07-greedy-sched.pdf
    &lt;/pre&gt;

     runtime complexity is O(n^2).
     The approach is greedy but produces an optimal solution.

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;

     @param s start times
     @param f finish times
     @return indexes of resources to schedule the requests on.
     */
    public int[] intervalPartitionGreedy2(double[] s, double[] f) {

        /*
        (1) sort the requests by increasing order of start times. 
        (2) assign to each request the smallest color (possibly a new color) 
            such that it conflicts with no other requests of this color class. 
        */

<span class="fc" id="L693">        int n = s.length;</span>
        
        // runtime complexity O(n*log_2(n))
        //sort requests by increasing start times
<span class="fc" id="L697">        int[] sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L698">                .sorted((i, j) -&gt; Double.compare(s[i], s[j]))</span>
<span class="fc" id="L699">                .mapToInt(ele -&gt; ele).toArray();</span>

        // a color for each request
<span class="fc" id="L702">        int[] c = new int[s.length];</span>
        
<span class="fc" id="L704">        TIntSet excl = new TIntHashSet();</span>
        int color;
        int i, j;
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (int ii = 0; ii &lt; n; ++ii) {</span>
<span class="fc" id="L708">            excl.clear();</span>
<span class="fc" id="L709">            i = sortedIndexes[ii];</span>
            //TODO: can further constrain the range of jj with a bisecting search
<span class="fc bfc" id="L711" title="All 2 branches covered.">            for (int jj = 0; jj &lt; ii; ++jj) {</span>
                //j is always smaller than i so s[j] &lt;= s[i].
                //  then order is (sj,fj)  (si,fi)
<span class="fc" id="L714">                j = sortedIndexes[jj];</span>
                //if ([s[j],f[j]] overlaps [s[i],f[i]]) 
<span class="fc bfc" id="L716" title="All 2 branches covered.">                if (s[i] &lt; f[j]) {</span>
<span class="fc" id="L717">                    excl.add(c[j]);</span>
                }
            }
            //Let c be the smallest color NOT in E
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">            for (color = 0; color &lt; n; ++color) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">                if (!excl.contains(color)) {</span>
<span class="fc" id="L723">                    break;</span>
                }
            }
<span class="fc" id="L726">            c[i] = color;</span>
        }

<span class="fc" id="L729">        return c;</span>
    }

    /**
     Interval Partitioning:
     Given an infinite number of possible exclusive resources to use,
     schedule all the activities using the smallest number of resources.
     The activity requests each have a start and finish time.
     Let the resources be a collection R, partitioned into d disjoint subsets R_0,...R_{d-1}
     such that events of R_j are mutually non-conflicting, for each j: 0 ≤ j ≤ (d-1).

     runtime complexity is O(n*log_2(n)).

     The algorithm used is sometimes called EFF (early finish first) for unlimited resources.

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;
     *
     @param s start times
     @param f finish times
     @return indexes of resources to schedule the requests on.
     */
    public int[] intervalPartitionGreedy(double[] s, double[] f) {
<span class="fc" id="L757">        int n = s.length;</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (f.length != n) {</span>
<span class="nc" id="L759">            throw new IllegalArgumentException(&quot;s and f must be same length&quot;);</span>
        }

        // runtime complexity O(n*log(n))
        //sort requests by increasing finish times
<span class="fc" id="L764">        int[] sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L765">                .sorted((i, j) -&gt; Double.compare(f[i], f[j]))</span>
<span class="fc" id="L766">                .mapToInt(ele -&gt; ele).toArray();</span>

<span class="fc" id="L768">        List&lt;List&lt;Integer&gt;&gt; resources = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L769">        List&lt;Integer&gt; current = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L770">        resources.add(current);</span>
<span class="fc" id="L771">        double fPrev = -1;</span>
        int i;
        //O(n)
<span class="fc bfc" id="L774" title="All 2 branches covered.">        for (int ii = 0; ii &lt; n; ++ii) {</span>
<span class="fc" id="L775">            i = sortedIndexes[ii];</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (s[i] &lt; fPrev) {</span>
<span class="fc" id="L777">                current = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L778">                resources.add(current);</span>
            }
<span class="fc" id="L780">            current.add(i);</span>
<span class="fc" id="L781">            fPrev = f[i];</span>
        }
        //O(n)
        // merge resources, bottom up
        double start, finish;
        int jj, j;
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (int ii = resources.size() - 1; ii &gt; 0; --ii) {</span>
<span class="fc" id="L788">            current = resources.get(ii);</span>
<span class="fc" id="L789">            start = s[current.get(0)];</span>
            // search lower indexes for feasible concatenation
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (jj = ii - 1; jj &gt;= 0; --jj) {</span>
<span class="fc" id="L792">                List&lt;Integer&gt; lower = resources.get(jj);</span>
<span class="fc" id="L793">                finish = f[lower.get(lower.size() - 1)];</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">                if (start &gt;= finish) {</span>
                    // append current to lower
<span class="fc" id="L796">                    lower.addAll(current);</span>
<span class="fc" id="L797">                    resources.remove(ii);</span>
<span class="fc" id="L798">                    break;</span>
                }
            }
        }

        //O(n)
        //for each index, write the scheduled resource number
<span class="fc" id="L805">        int[] schedResource = new int[n];</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        for (i = 0; i &lt; resources.size(); ++i) {</span>
<span class="fc" id="L807">            current = resources.get(i);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">            for (j = 0; j &lt; current.size(); ++j) {</span>
<span class="fc" id="L809">                schedResource[current.get(j)] = i;</span>
            }
        }
<span class="fc" id="L812">        return schedResource;</span>
    }

    /**
     Given exclusive use of 1 resource, find the maximum size of mutually compatible activities
     S = {a1, a2, ... an} where each activity has a start time si and finish time fi.
     0 &lt;= si &lt; fi &lt; inf.

     References:
     &lt;pre&gt;
     Chap 15 of &quot;Introduction to Algorithms&quot;, fourth edition
     Cormen, Leiserson, Rivest, and Stein,
     &lt;/pre&gt;

     runtime complexity is O(n) if already sorted, else O(n*log_2(n)).

     &lt;pre&gt;
     https://en.wikipedia.org/wiki/Interval_scheduling
     Interval scheduling is a class of problems in computer science, particularly in the area of
     algorithm design. The problems consider a set of tasks. Each task is represented by an
     interval describing the time in which it needs to be processed by some machine
     (or, equivalently, scheduled on some resource).
     &lt;/pre&gt;
     *
     @param s start times
     @param f finish times
     @param isSortedByF
     @return indexes of resources to schedule the requests on.
     */
    public static int[] intervalPartitionGreedySingleResource(double[] s, double[] f, boolean isSortedByF) {
<span class="fc" id="L842">        int n = f.length;</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">        if (s.length != n) {</span>
<span class="nc" id="L844">            throw new IllegalArgumentException(&quot;s.length must equal f.length&quot;);</span>
        }

<span class="fc" id="L847">        int[] sortedIndexes = null;</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">        if (isSortedByF) {</span>
<span class="nc" id="L849">            sortedIndexes = new int[n];</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L851">                sortedIndexes[i] = i;</span>
            }
        } else {
<span class="fc" id="L854">            sortedIndexes = IntStream.range(0, n).boxed()</span>
<span class="fc" id="L855">                    .sorted((i, j) -&gt; Double.compare(f[i], f[j]))</span>
<span class="fc" id="L856">                    .mapToInt(ele -&gt; ele)</span>
<span class="fc" id="L857">                    .toArray();</span>
        }

<span class="fc" id="L860">        TIntList a = new TIntArrayList();</span>
<span class="fc" id="L861">        a.add(sortedIndexes[0]);</span>
<span class="fc" id="L862">        int i, j = sortedIndexes[0];</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">        for (int ii = 1; ii &lt; n ; ++ii) {</span>
<span class="fc" id="L864">            i = sortedIndexes[ii];</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (s[i] &gt;= f[j]) {</span>
<span class="fc" id="L866">                a.add(i);</span>
<span class="fc" id="L867">                j = i;</span>
            }
        }

<span class="fc" id="L871">        return a.toArray();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>