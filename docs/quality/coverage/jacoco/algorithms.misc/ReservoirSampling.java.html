<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReservoirSampling.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.misc</a> &gt; <span class="el_source">ReservoirSampling.java</span></div><h1>ReservoirSampling.java</h1><pre class="source lang-java linenums">package algorithms.misc;

import java.util.Random;

<span class="nc" id="L5">public class ReservoirSampling {</span>

    /**
     * create a random sample of length k from array a.
     *
     * the method internally uses Fisher-Yates shuffle (n-k) times
     * after filling the output array with the first k items.
     *
     * r.t.c. is O(n) where n = a.length
     *
     * @param a
     * @param k
     * @return
     */
    public static int[] sample(int[] a, int k) {
<span class="nc bnc" id="L20" title="All 2 branches missed.">        if (k &gt; a.length) {</span>
<span class="nc" id="L21">            throw new IllegalStateException(&quot;a.length must be &gt; k&quot;);</span>
        }
<span class="nc" id="L23">        int[] out = new int[k];</span>
<span class="nc" id="L24">        Random rand = new Random();</span>
<span class="nc" id="L25">        System.arraycopy(a, 0, out, 0, k);</span>

        int t;
        //for (int i = k; i &lt; a.length-1; ++i) {
<span class="nc bnc" id="L29" title="All 2 branches missed.">        for (int i = a.length-1; i &gt;= k; --i) {</span>
<span class="nc" id="L30">            t = rand.nextInt(i + 1);</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">            if (t &lt; k) {</span>
<span class="nc" id="L32">                out[t] = a[i];</span>
            }
        }
<span class="nc" id="L35">        return out;</span>
    }

    /**
     * create a random sample of length k from array a.
     &lt;pre&gt;
     reference:
     &quot;Reservoir-Sampling Algorithms of Time Complexity O(n(l + 10g(/V /n)))&quot;
     KIM-HUNG LI
     1994 ACM 0098-3500/94/1200-0481 $03.50
     https://en.wikipedia.org/wiki/Reservoir_sampling

     algorithm L of
     https://dl.acm.org/doi/10.1145/198429.198435

     &lt;/pre&gt;
     *
     * r.t.c. is O(k * 1 + log(n/k)) where n = a.length.
     *
     * @param a data stream to sample
     * @param k length of output sample
     * @return
     */
    public static int[] sampleOptimally(int[] a, int k) {
<span class="nc" id="L59">        int n = a.length;</span>

<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (k &gt; n) {</span>
<span class="nc" id="L62">            throw new IllegalStateException(&quot;a.length must be &gt; k&quot;);</span>
        }
<span class="nc" id="L64">        int[] out = new int[k];</span>
<span class="nc" id="L65">        Random rand = new Random();</span>
<span class="nc" id="L66">        System.arraycopy(a, 0, out, 0, k);</span>

        // uses geometric distibution inverse function to generate a random number.
        //W is the simulation of the largest value in a sample of size k from the U(O, b)
        // distribution (where b=1 here) and it
        // can be generated by b*random( )^(1/k)
        // which is programmed as b *exp(log(random( ))/k).
<span class="nc" id="L73">        double w = Math.exp(Math.log(rand.nextDouble())/k);</span>
<span class="nc" id="L74">        int i = k;</span>
        int j;
<span class="nc bnc" id="L76" title="All 2 branches missed.">        while (i &lt;= n) {</span>
<span class="nc" id="L77">            j = (int) Math.floor(Math.log(rand.nextDouble()) / Math.log(1. - w));</span>
<span class="nc" id="L78">            i += j + 1;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (i &lt;= n) {</span>
                //* replace a random item of the reservoir with item i
<span class="nc" id="L81">                j = rand.nextInt(k);</span>
<span class="nc" id="L82">                out[j] = a[i];</span>
<span class="nc" id="L83">                w = w * Math.exp(Math.log(rand.nextDouble())/k);</span>
            }
        }
<span class="nc" id="L86">        return out;</span>
    }

    /**
     * create a random sample of length k from array a.
     &lt;pre&gt;
     reference:
     &quot;Reservoir-Sampling Algorithms of Time Complexity O(n(l + 10g(/V /n)))&quot;
     KIM-HUNG LI
     1994 ACM 0098-3500/94/1200-0481 $03.50
     https://en.wikipedia.org/wiki/Reservoir_sampling

     algorithm L of
     https://dl.acm.org/doi/10.1145/198429.198435

     &lt;/pre&gt;
     *
     * r.t.c. is O(k * 1 + log(n/k)) where n = a.length.
     *
     * @param a data stream to sample
     * @param k length of output sample
     * @return
     */
    public static double[] sampleOptimally(double[] a, int k) {
<span class="fc" id="L110">        int n = a.length;</span>

<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (k &gt; n) {</span>
<span class="nc" id="L113">            throw new IllegalStateException(&quot;a.length must be &gt; k&quot;);</span>
        }
<span class="fc" id="L115">        double[] out = new double[k];</span>
<span class="fc" id="L116">        Random rand = new Random();</span>
<span class="fc" id="L117">        System.arraycopy(a, 0, out, 0, k);</span>

        // uses geometric distibution inverse function to generate a random number.
        //W is the simulation of the largest value in a sample of size k from the U(O, b)
        // distribution (where b=1 here) and it
        // can be generated by b*random( )^(1/k)
        // which is programmed as b *exp(log(random( ))/k).
<span class="fc" id="L124">        double w = Math.exp(Math.log(rand.nextDouble())/k);</span>
<span class="fc" id="L125">        int i = k;</span>
        int j;
<span class="fc bfc" id="L127" title="All 2 branches covered.">        while (i &lt;= n) {</span>
<span class="fc" id="L128">            j = (int) Math.floor(Math.log(rand.nextDouble()) / Math.log(1. - w));</span>
<span class="fc" id="L129">            i += j + 1;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (i &lt;= n) {</span>
                //* replace a random item of the reservoir with item i
<span class="fc" id="L132">                j = rand.nextInt(k);</span>
<span class="fc" id="L133">                out[j] = a[i];</span>
<span class="fc" id="L134">                w = w * Math.exp(Math.log(rand.nextDouble())/k);</span>
            }
        }
<span class="fc" id="L137">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>