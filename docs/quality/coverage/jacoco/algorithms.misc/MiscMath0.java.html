<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscMath0.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.misc</a> &gt; <span class="el_source">MiscMath0.java</span></div><h1>MiscMath0.java</h1><pre class="source lang-java linenums">package algorithms.misc;

import algorithms.SubsetChooser;
import algorithms.matrix.MatrixUtil;
import algorithms.sort.CountingSort;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;

import java.util.*;

import gnu.trove.set.TIntSet;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TFloatArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;

import algorithms.sort.MiscSorter;

import java.math.RoundingMode;

/**
    miscellaneous math methods. some could probably be improved.

    first implemented in projects
     https://github.com/nking/two-point-correlation
     w/ Copyright (c) 2013-2015 Nichole King
     http://nking.github.io/two-point-correlation/
     using The MIT License (MIT)
     and
     https://github.com/nking/curvature-scale-space-corners-and-transformations
     w/ Copyright (c) 2014 Climb With Your Feet
     and using The MIT License (MIT)

   then moved to this shared library project which has the same copyright
   and license.

 * @author nichole
 */
<span class="fc" id="L44">public class MiscMath0 {</span>

    /**
     *
     @param a
     @return
     */
    public static float[] calculateOuterRoundedMinAndMax(float[] a) {

        // find the powers of 10 for the data min and max
<span class="fc" id="L54">        float xmin = Float.MAX_VALUE;</span>
<span class="fc" id="L55">        float xmax = Float.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">            if (a[i] &gt; xmax) {</span>
<span class="fc" id="L58">                xmax = a[i];</span>
            }
<span class="fc bfc" id="L60" title="All 2 branches covered.">            if (a[i] &lt; xmin) {</span>
<span class="fc" id="L61">                xmin = a[i];</span>
            }
        }

<span class="fc" id="L65">        xmax = MiscMath0.roundUpByLargestPower(xmax);</span>

<span class="fc" id="L67">        xmin = MiscMath0.roundDownByLargestPower(xmin);</span>

        // xmax &gt; 1 and xmin is between 0 and 1, round xmin down
<span class="pc bpc" id="L70" title="1 of 6 branches missed.">        if ((xmax &gt; 1) &amp;&amp; (xmin &gt; 0) &amp;&amp; (xmin &lt; 1.0)) {</span>
<span class="nc" id="L71">            xmin = 0;</span>
        }

<span class="fc" id="L74">        return new float[]{xmin, xmax};</span>
    }

    /**
     Round number up to the next digit in the largest power.

        MiscMath0.roundUpByLargestPower(31.1f) == 40.0f;

        MiscMath0.roundUpByLargestPower(0.11f) == 1.0f;

        MiscMath0.roundUpByLargestPower(-0.011f) == -0.02f;

        MiscMath0.roundUpByLargestPower(310.1f) == 400.0f;

        MiscMath0.roundUpByLargestPower(-3.1) == -4.0f;

        MiscMath0.roundUpByLargestPower(3.1) == 4.0f;

    @param f
    @return
    */
    public static float roundUpByLargestPower(float f) {

<span class="fc" id="L97">        int pow = findPowerOf10(f);</span>

<span class="fc" id="L99">        double pow10 = Math.pow(10, pow);</span>

<span class="fc" id="L101">        int d = (int)(f/pow10);</span>
        int m;
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (f == pow10) {</span>
<span class="fc" id="L104">            m = d;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        } else if (f &gt; 0) {</span>
            // residual ?
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (f &gt; (d*pow10)) {</span>
<span class="fc" id="L108">                m = d + 1;</span>
            } else {
<span class="fc" id="L110">                m = d;</span>
            }
        } else {
            // decimals
<span class="fc" id="L114">            m = d - 1;</span>
        }

<span class="fc" id="L117">        float r = (float) (m * pow10);</span>

<span class="fc" id="L119">        return r;</span>
    }

    /**
     * Round number down to in the largest power.
     * For example,
     *     roundDownByLargestPower(3.1) returns 3.0
     *     roundDownByLargestPower(-3.1) returns -4.0
     *     roundDownByLargestPower(31.1) returns 30.0
     *
     @param f
     @return
     */
    public static float roundDownByLargestPower(float f) {

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (f == 0) {</span>
<span class="fc" id="L135">            return 0;</span>
        }

<span class="fc" id="L138">        int pow = findPowerOf10(f);</span>
<span class="fc" id="L139">        double pow10 = Math.pow(10, pow);</span>

        double r;
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (f &gt; 0) {</span>
<span class="fc" id="L143">            double m = f % pow10;</span>
<span class="fc" id="L144">            r = f - m;</span>
<span class="fc" id="L145">        } else {</span>
<span class="fc" id="L146">            int m = (int)(f/pow10);</span>
<span class="fc" id="L147">            r = pow10 * (m - 1);</span>
        }

<span class="fc" id="L150">        return (float)r;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static int findPowerOf10(float a) {

<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (a == 0) {</span>
<span class="fc" id="L161">            return 0;</span>
        }
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (a &lt; 0.f) {</span>
<span class="fc" id="L164">            a *= -1.0f;</span>
        }
<span class="fc" id="L166">        double b = Math.log10(a);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (b &gt; 0) {</span>
<span class="fc" id="L168">            return (int)b;</span>
        } else {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (b &gt;= 1) {</span>
<span class="nc" id="L171">                return (int)Math.round(b);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            } else if (b &gt; -1) {</span>
                // fractions between -1 and +1
<span class="fc" id="L174">                 return findPowerOf10_2(a);</span>
            } else {
<span class="fc" id="L176">                return (int)Math.round(b);</span>
            }
        }
    }

    /**
     *
     @param a
     @return
     */
    public static int findPowerOf10_2(float a) {

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (a == 0) {</span>
<span class="nc" id="L189">            return 0;</span>
        }

<span class="fc" id="L192">        int power = 0;</span>

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (a &lt;= 1.0f) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            while (a &lt; 1.0) {</span>
<span class="fc" id="L196">                a *=  10.0;</span>
<span class="fc" id="L197">                power--;</span>
            }
        } else {
            // precision errors in multiplication here are trouble for non base2 numbers such as powers of 10
<span class="nc bnc" id="L201" title="All 2 branches missed.">            while (a &gt;= 1.0) {</span>
<span class="nc" id="L202">                a /= 10.0;</span>
<span class="nc" id="L203">                power++;</span>
            }
<span class="nc" id="L205">            power--;</span>
        }

<span class="fc" id="L208">        return power;</span>
    }

    /**
     * find max but ignore values such as FLOAT.MAX_VALUE, infinity, and NAN
     @param a
     @return
     */
    public static int findYMaxIndex(float[] a) {
<span class="pc bpc" id="L217" title="2 of 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L218">            return -1;</span>
        }
<span class="fc" id="L220">        float max = Float.NEGATIVE_INFINITY;</span>
<span class="fc" id="L221">        int index = 0;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="pc bpc" id="L223" title="3 of 8 branches missed.">            if ((a[i] &gt; max) &amp;&amp; !Float.isInfinite(a[i]) &amp;&amp; !Float.isNaN(a[i]) </span>
                &amp;&amp; (a[i] &lt; Float.MAX_VALUE)) {
<span class="fc" id="L225">                max = a[i];</span>
<span class="fc" id="L226">                index = i;</span>
            }
        }
<span class="fc" id="L229">        return index;</span>
    }
    
    /**
     * find max but ignore values such as infinity, and NAN
     @param a
     @return
     */
    public static int findYMaxIndex(double[] a) {
<span class="pc bpc" id="L238" title="2 of 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L239">            return -1;</span>
        }
<span class="fc" id="L241">        double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L242">        int index = 0;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="pc bpc" id="L244" title="2 of 6 branches missed.">            if ((a[i] &gt; max) &amp;&amp; !Double.isInfinite(a[i]) &amp;&amp; !Double.isNaN(a[i]) </span>
                ) {
<span class="fc" id="L246">                max = a[i];</span>
<span class="fc" id="L247">                index = i;</span>
            }
        }
<span class="fc" id="L250">        return index;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static int findYMaxIndex(int[] a) {
<span class="pc bpc" id="L259" title="2 of 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L260">            return -1;</span>
        }
<span class="fc" id="L262">        int max = Integer.MIN_VALUE;</span>
<span class="fc" id="L263">        int index = 0;</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (a[i] &gt; max) {</span>
<span class="fc" id="L266">                max = a[i];</span>
<span class="fc" id="L267">                index = i;</span>
            }
        }
<span class="fc" id="L270">        return index;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static int findYMaxIndex(TIntList a) {
<span class="pc bpc" id="L279" title="2 of 4 branches missed.">        if (a == null || a.size() == 0) {</span>
<span class="nc" id="L280">            return -1;</span>
        }
<span class="fc" id="L282">        int max = Integer.MIN_VALUE;</span>
<span class="fc" id="L283">        int index = 0;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        for (int i = 0; i &lt; a.size(); i++) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            if (a.get(i) &gt; max) {</span>
<span class="fc" id="L286">                max = a.get(i);</span>
<span class="fc" id="L287">                index = i;</span>
            }
        }
<span class="fc" id="L290">        return index;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static int findYMaxIndex(long[] a) {
    
<span class="nc bnc" id="L300" title="All 4 branches missed.">        if (a == null || a.length == 0) {</span>
<span class="nc" id="L301">            return -1;</span>
        }
<span class="nc" id="L303">        long max = Long.MIN_VALUE;</span>
<span class="nc" id="L304">        int index = 0;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (a[i] &gt; max) {</span>
<span class="nc" id="L307">                max = a[i];</span>
<span class="nc" id="L308">                index = i;</span>
            }
        }
<span class="nc" id="L311">        return index;</span>
    }
 
    /**
     *
     @param a
     @return
     */
    public static float findMin(float[] a) {
<span class="fc" id="L320">        float min = Float.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="pc bpc" id="L322" title="2 of 6 branches missed.">            if ((a[i] &lt; min) &amp;&amp; !Float.isInfinite(a[i]) &amp;&amp; !Float.isNaN(a[i])) {</span>
<span class="fc" id="L323">                min = a[i];</span>
            }
        }
<span class="fc" id="L326">        return min;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static double findMin(double[] a) {
<span class="fc" id="L335">        double min = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="pc bpc" id="L337" title="2 of 6 branches missed.">            if ((a[i] &lt; min) &amp;&amp; !Double.isInfinite(a[i]) &amp;&amp; !Double.isNaN(a[i])) {</span>
<span class="fc" id="L338">                min = a[i];</span>
            }
        }
<span class="fc" id="L341">        return min;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static int findMin(int[] a) {
<span class="fc" id="L350">        int min = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (a[i] &lt; min) {</span>
<span class="fc" id="L353">                min = a[i];</span>
            }
        }
<span class="fc" id="L356">        return min;</span>
    }

    /**
     * find max 
     @param a
     @return
     */
    public static int findMax(int[] a) {
<span class="fc" id="L365">        int max = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (a[i] &gt; max) {</span>
<span class="fc" id="L368">                max = a[i];</span>
            }
        }
<span class="fc" id="L371">        return max;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static int findMax(int[][] a) {
<span class="fc" id="L380">        int max = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                if (a[i][j] &gt; max) {</span>
<span class="fc" id="L384">                    max = a[i][j];</span>
                }
            }
        }
<span class="fc" id="L388">        return max;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static int findMin(int[][] a) {
<span class="fc" id="L397">        int min = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (a[i][j] &lt; min) {</span>
<span class="fc" id="L401">                    min = a[i][j];</span>
                }
            }
        }
<span class="fc" id="L405">        return min;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static float findMax(float[][] a) {
<span class="fc" id="L414">        float max = Float.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if (a[i][j] &gt; max) {</span>
<span class="fc" id="L418">                    max = a[i][j];</span>
                }
            }
        }
<span class="fc" id="L422">        return max;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static float findMin(float[][] a) {
<span class="fc" id="L431">        float min = Float.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                if (a[i][j] &lt; min) {</span>
<span class="fc" id="L435">                    min = a[i][j];</span>
                }
            }
        }
<span class="fc" id="L439">        return min;</span>
    }

    /**
     * find max 
     @param a
     @return
     */
    public static float findMax(float[] a) {
<span class="fc" id="L448">        float max = Float.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (a[i] &gt; max) {</span>
<span class="fc" id="L451">                max = a[i];</span>
            }
        }
<span class="fc" id="L454">        return max;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static double findMax(double[] a) {
<span class="fc" id="L463">        double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">            if (a[i] &gt; max) {</span>
<span class="fc" id="L466">                max = a[i];</span>
            }
        }
<span class="fc" id="L469">        return max;</span>
    }
    
    /**
     *
     @param img
     @return
     */
    public static double findMin(double[][] img) {
        
<span class="nc" id="L479">        double min = Double.POSITIVE_INFINITY;</span>
        
<span class="nc bnc" id="L481" title="All 2 branches missed.">        for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (int j = 0; j &lt; img[i].length; ++j) {</span>
<span class="nc" id="L483">                double v = img[i][j];</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (v &lt; min) {</span>
<span class="nc" id="L485">                    min = v;</span>
                }
            }
        }
        
<span class="nc" id="L490">        return min;</span>
    }
    
    /**
     *
     @param img
     @return
     */
    public static double findMax(double[][] img) {
        
<span class="nc" id="L500">        double max = Double.NEGATIVE_INFINITY;</span>
        
<span class="nc bnc" id="L502" title="All 2 branches missed.">        for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            for (int j = 0; j &lt; img[i].length; ++j) {</span>
<span class="nc" id="L504">                double v = img[i][j];</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (v &gt; max) {</span>
<span class="nc" id="L506">                    max = v;</span>
                }
            }
        }
        
<span class="nc" id="L511">        return max;</span>
    }

    /**
     * for the given histogram, returns the indexes of the primary peak and
     * any peaks which are larger than frac*maxPeak above their neighboring
     * values.
     @param h
     @param frac the fraction of the y value of the maximum peak that is used
     * as a critical limit that any other peaks must have in excess of their
     * neighboring points.  For example, 0.1.
     @return 
     */
    public static List&lt;Integer&gt; findStrongPeakIndexes(HistogramHolder h, float frac) {
        
<span class="fc" id="L526">        float[] x = h.getXHist();</span>
<span class="fc" id="L527">        int[] y = h.getYHist();</span>
        
<span class="pc bpc" id="L529" title="4 of 8 branches missed.">        if (x == null || y == null || x.length == 0 || y.length == 0) {</span>
<span class="nc" id="L530">            return null;</span>
        }
        
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L534">            List&lt;Integer&gt; minMaxIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (y[0] &gt; 0) {</span>
<span class="nc" id="L536">                minMaxIndexes.add(Integer.valueOf(0));</span>
            }
<span class="nc" id="L538">            return minMaxIndexes;</span>
        }
        
<span class="fc" id="L541">        int yPeakIdx = MiscMath0.findYMaxIndex(y);</span>
        
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (yPeakIdx == -1) {</span>
<span class="nc" id="L544">            return null;</span>
        }
        
<span class="fc" id="L547">        int yMaxPeak = y[yPeakIdx];</span>
        
        /*
        storing the minima and maxima in the same array list.
        the minima have -1*index within k
        and the maxima keep their positive values of the index within k.
        */
<span class="fc" id="L554">        List&lt;Integer&gt; minMaxIndexes = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc" id="L556">        float lastY = y[0];</span>
<span class="fc" id="L557">        boolean incr = true;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int ii = 1; ii &lt; y.length; ii++) {</span>
<span class="fc bfc" id="L559" title="All 4 branches covered.">            if ((y[ii] &lt; lastY) &amp;&amp; incr) {</span>
<span class="fc" id="L560">                minMaxIndexes.add(Integer.valueOf(ii - 1));</span>
<span class="fc" id="L561">                incr = false;</span>
<span class="fc bfc" id="L562" title="All 4 branches covered.">            } else if ((y[ii] &gt; lastY) &amp;&amp; !incr) {</span>
<span class="fc" id="L563">                minMaxIndexes.add(Integer.valueOf(-1*(ii - 1)));</span>
<span class="fc" id="L564">                incr = true;</span>
            }
<span class="fc" id="L566">            lastY = y[ii];</span>
        }
        
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        if (incr) {</span>
            // add the last point
<span class="nc" id="L571">             minMaxIndexes.add(Integer.valueOf(y.length - 1));</span>
        }
        
        // for the histograms of euclidean point combination differences,
        // this should usually be singly peaked
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (minMaxIndexes.size() == 1) {</span>
<span class="fc" id="L577">            return minMaxIndexes;</span>
        }
        
<span class="fc" id="L580">        float limit = frac * yMaxPeak;</span>
        
        // find peaks where y[ii] is &gt; limit above adjacent local minima
        
<span class="fc" id="L584">        List&lt;Integer&gt; peaks = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">        for (int ii = 0; ii &lt; minMaxIndexes.size(); ii++) {</span>

<span class="fc" id="L588">            int idx = minMaxIndexes.get(ii).intValue();</span>

<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (idx &gt; -1) {</span>
                // this is a maxima
                
<span class="fc" id="L593">                boolean found = false;</span>
                
                // compare to preceding minimum
<span class="pc bfc" id="L596" title="All 2 branches covered.">                for (int iii = (ii - 1); iii &gt; -1; iii--) {</span>
<span class="fc" id="L597">                    int idx2 = minMaxIndexes.get(iii).intValue();</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="fc" id="L599">                        float compare = y[-1*idx2];</span>
<span class="fc" id="L600">                        float diff = y[idx] - compare;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                        if (diff &gt;= limit) {</span>
<span class="fc" id="L602">                            peaks.add(Integer.valueOf(idx));</span>
<span class="fc" id="L603">                            found = true;</span>
                        }
                        break;
                    }
                }
<span class="fc bfc" id="L608" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L609">                    continue;</span>
                }

                //compare to proceeding minimum
<span class="pc bfc" id="L613" title="All 2 branches covered.">                for (int iii = (ii + 1); iii &lt; minMaxIndexes.size(); iii++) {</span>
<span class="fc" id="L614">                    int idx2 = minMaxIndexes.get(iii).intValue();</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="fc" id="L616">                        float compare = y[-1*idx2];</span>
<span class="fc" id="L617">                        float diff = y[idx] - compare;</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                        if (diff &gt;= limit) {</span>
<span class="fc" id="L619">                            peaks.add(Integer.valueOf(idx));</span>
                        }
                        break;
                    }
                }
            }
        }
       
<span class="fc" id="L627">        return peaks;</span>
    }

    /**
     *
     @param hist
     @param fracMax
     @return
     */
    public static List&lt;Integer&gt; findStrongPeakIndexesDescSort(
        HistogramHolder hist, float fracMax) {

<span class="fc" id="L639">        List&lt;Integer&gt; indexes = findStrongPeakIndexes(hist, fracMax);</span>
        
<span class="pc bpc" id="L641" title="1 of 4 branches missed.">        if (indexes == null || indexes.size() &lt; 2) {</span>
<span class="fc" id="L642">            return indexes;</span>
        }
        
<span class="fc" id="L645">        int[] idxs = new int[indexes.size()];</span>
<span class="fc" id="L646">        int[] c = new int[idxs.length];</span>
        
<span class="fc" id="L648">        int maxC = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">        for (int i = 0; i &lt; indexes.size(); ++i) {</span>
<span class="fc" id="L650">            idxs[i] = indexes.get(i).intValue();</span>
<span class="fc" id="L651">            c[i] = hist.getYHist()[idxs[i]];</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (c[i] &gt; maxC) {</span>
<span class="fc" id="L653">                maxC = c[i];</span>
            }
        }
        
<span class="fc" id="L657">        CountingSort.sortByDecr(c, idxs);</span>
        
<span class="fc" id="L659">        indexes.clear();</span>
        
<span class="fc bfc" id="L661" title="All 2 branches covered.">        for (int i = 0; i &lt; idxs.length; ++i) {</span>
<span class="fc" id="L662">            indexes.add(Integer.valueOf(idxs[i]));</span>
        }
        
<span class="fc" id="L665">        return indexes;</span>
    }

    /**
     * given an array of points, return the average and standard deviation from
     * the average
     @param x
     @return 
     */
    public static double[] getAvgAndStDev(int[] x) {
        
<span class="fc" id="L676">        return getAvgAndStDev(x, x.length);</span>
    }

    /**
     * given an array of points, return the average and standard deviation from
     * the average
     @param x
     @param length
     @return 
     */
    public static double[] getAvgAndStDev(int[] x, int length) {
        
<span class="fc" id="L688">        long sumX = 0;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L690">            sumX += x[i];</span>
        }
        
<span class="fc" id="L693">        double avgX = (double)sumX/(double)length;</span>
        
<span class="fc" id="L695">        sumX = 0;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L697">            double diffX = x[i] - avgX;</span>
<span class="fc" id="L698">            sumX += (diffX * diffX);</span>
        }
<span class="fc" id="L700">        double stdDevX = Math.sqrt(sumX/(length - 1.0f));</span>
        
<span class="fc" id="L702">        return new double[]{avgX, stdDevX};</span>
    }
    
    /**
     * given an array of points, return the average and standard deviation from
     * the average
     @param x
     @param length
     @return 
     */
    public static double[] getAvgAndStDev(long[] x, int length) {
        
<span class="fc" id="L714">        long sumX = 0;</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L716">            sumX += x[i];</span>
        }
        
<span class="fc" id="L719">        double avgX = (double)sumX/(double)length;</span>
        
        double diffX;
<span class="fc" id="L722">        sumX = 0;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L724">            diffX = x[i] - avgX;</span>
<span class="fc" id="L725">            sumX += (diffX * diffX);</span>
        }
<span class="fc" id="L727">        double stdDevX = Math.sqrt(sumX/(length - 1.0f));</span>
        
<span class="fc" id="L729">        return new double[]{avgX, stdDevX};</span>
    }
    
    /**
     * calculate the quartiles Q1, Q2, and Q3 of x as
     * &lt;pre&gt;
     * x = ascending sort(x)
     * n = x.length;
     * Q1 = median of x[0] through x[n/2] which is x[n/4];
     * Q2 = median of x = x[n/2];
     * Q3 = median of x[n/2] through x[n-1] = x[(int)0.75*n];
     * &lt;/pre&gt;
     * The IQR is Q3 - Q1;
     @param x
     @return an array holding Q1, Q2, Q3, min and max
     */
    public static double[] calculateQuartiles(double[] x) {
        
<span class="fc" id="L747">        x = Arrays.copyOf(x, x.length);</span>
<span class="fc" id="L748">        Arrays.sort(x);</span>
        
<span class="fc" id="L750">        int n = x.length;</span>
        
<span class="fc" id="L752">        double[] q = new double[]{</span>
            x[n/4], x[n/2], x[(int)(0.75*n)], x[0], x[n-1]
        };
        
<span class="fc" id="L756">        return q;</span>
    }
    
    /**
    uses Tukey fences to find inlier indexes in x with factor k=1.5
    &lt;pre&gt;
    calculated as
       q = calculateQuartiles(x);
       iqr = q[2]-q[0];
       inliers are in the range [q[0] - k*iqr, q[2] + k*iqr], inclusive.
    &lt;/pre&gt;
     @param x
     @return 
    */
    public static int[] findInliersUsingTukeyFences(double[] x) {
<span class="nc" id="L771">        return findInliersUsingTukeyFences(x, 1.5);</span>
    }
    
    /**
    uses Tukey fences to find inlier indexes in x with factor k=3
    &lt;pre&gt;
    calculated as
       q = calculateQuartiles(x);
       iqr = q[2]-q[0];
       inliers are in the range [q[0] - k*iqr, q[2] + k*iqr], inclusive.
    &lt;/pre&gt;
     @param x
     @return 
    */
    public static int[] findFarInliersUsingTukeyFences(double[] x) {
<span class="nc" id="L786">        return findInliersUsingTukeyFences(x, 3);</span>
    }
    
    /**
    uses Tukey fences to find inlier indexes in x.
    &lt;pre&gt;
    calculated as
       q = calculateQuartiles(x);
       iqr = q[2]-q[0];
       inliers are in the range [q[0] - k*iqr, q[2] + k*iqr], inclusive.
    &lt;/pre&gt;
     @param x
     @param k
     @return 
    */
    public static int[] findInliersUsingTukeyFences(double[] x, double k) {
        // from https://en.m.wikipedia.org/wiki/Outlier
<span class="fc" id="L803">        double[] q = calculateQuartiles(x);</span>
<span class="fc" id="L804">        int n = x.length;</span>
<span class="fc" id="L805">        int[] inlierIndexes = new int[n];</span>
        int i;
<span class="fc" id="L807">        int count = 0;</span>
<span class="fc" id="L808">        double iqr = q[2] - q[0];</span>
<span class="fc" id="L809">        double r0 = q[0] - k*iqr;</span>
<span class="fc" id="L810">        double r1 = q[2] + k*iqr;</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L812" title="All 4 branches covered.">            if (x[i] &gt;= r0 &amp;&amp; x[i] &lt;= r1) {</span>
<span class="fc" id="L813">                inlierIndexes[count] = i;</span>
<span class="fc" id="L814">                count++;</span>
            }
        }
<span class="fc" id="L817">        return Arrays.copyOf(inlierIndexes, count);</span>
    }
    
    /**
     * calculate the median of absolute deviation (MAD) as
     * &lt;pre&gt;
     *  absDev_i = abs(x_i - median(x))
        mad = median( absDev)
     * &lt;/pre&gt;
     * and returns [median of absolute deviation, median, min, max].
     * To use the MAD as one uses standard deviation in determining outliers,
     * use stDev = k*MAD where k is a constant scale factor.  
     * For gaussian k~1.4826.  Outliers are outside the range [median - 3*MAD, median + 3*MAD].
     @param x
     @return an array holding the median of absolute deviation of x, 
     * the median, the min, and the max.
     */
    public static double[] calculateMedianOfAbsoluteDeviation(double[] x) {
        
<span class="fc" id="L836">        x = Arrays.copyOf(x, x.length);</span>
<span class="fc" id="L837">        Arrays.sort(x);</span>
        
<span class="fc" id="L839">        int n = x.length;</span>
        
<span class="fc" id="L841">        double median = x[n/2];</span>
        
<span class="fc" id="L843">        double[] d = new double[n];</span>
        
        int i;
<span class="fc bfc" id="L846" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L847">            d[i] = Math.abs(x[i] - median);</span>
        }
        
<span class="fc" id="L850">        Arrays.sort(d);</span>
        
<span class="fc" id="L852">        return new double[]{d[n/2], median, x[0], x[n-1]};</span>
    }
    
    /**
     * calculate the median and the interquartile range
     @param x
     @return 
     */
    public static double[] calcMedianAndIQR(double[] x) {
<span class="fc" id="L861">        x = Arrays.copyOf(x, x.length);</span>
<span class="fc" id="L862">        MiscSorter.mergeSortIncreasing(x);</span>
<span class="fc" id="L863">        double[] r = new double[2];</span>
<span class="fc" id="L864">        int n = x.length;</span>
<span class="fc" id="L865">        r[0] = x[n/2];</span>
<span class="fc" id="L866">        r[1] = (x[3*n/4] - x[n/2]);</span>
<span class="fc" id="L867">        return r;</span>
    }

    /**
     * calculate the mean of x and the sum of the squared differences
     * (SSD) between x and the mean.
     * The SSD can be used to calculate the biased or unbiased
     * variance, standard deviation, and standard error.
     &lt;pre&gt;
     mean = (1/n)*sum_{i=0 to n-1}(x_i) where n = x.length

     SSD = sum_{i=0 to n-1}((x_i - mean)^2)

     sample standard deviation:
         n-1 degrees of freedom within a sample of size n for having
         to estimate the mean from data,
         is a.k.a. unbiased standard deviation.
         note that standard deviation is not appropriate for all
         distributions, e.g. categorical.
     = sqrt( SSD / (n-1) )

     population standard deviation:
         true population mean is known, so n degrees of freedom
         within a sample of size n
     = sqrt( SSD/ n) biased, population mean is known

     standard error (SE):
         the standard deviation of the mean itself, across more
         than one sample.
         used in confidence intervals and hypothesis testing.
         e.g. 95% - confidence interval = mean += 1.96 * SE for
         gaussian normal distribution
         assumptions of same sample size and drawn from same population.
     = sample standard deviation / sqrt(n)
     = sqrt( SSD / (n*(n-1)) )

     &lt;/pre&gt;
     * @param x
     * @return array of length 2 holding the mean of x and the ssum of
     * the square differences of x from the mean.
     */
    public static double[] calcMeanAndSSD(double[] x) {

<span class="fc" id="L910">        double[] out = new double[]{calcMean(x), 0.};</span>

<span class="fc" id="L912">        double s = 0;</span>
        double d;
<span class="fc bfc" id="L914" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L915">            d = (out[0] - x[i]);</span>
<span class="fc" id="L916">            s += (d * d);</span>
        }
<span class="fc" id="L918">        out[1] = s;</span>
<span class="fc" id="L919">        return out;</span>
    }

    /**
     * calculate the mean of x and the sum of the squared differences
     * (SSD) between x and the mean.
     * The SSD can be used to calculate the biased or unbiased
     * variance, standard deviation, and standard error.
     &lt;pre&gt;
     mean = (1/n)*sum_{i=0 to n-1}(x_i) where n = x.length

     SSD = sum_{i=0 to n-1}((x_i - mean)^2)

     sample standard deviation:
         n-1 degrees of freedom within a sample of size n for having
         to estimate the mean from data,
         is a.k.a. unbiased standard deviation.
         note that standard deviation is not appropriate for all
         distributions, e.g. categorical.
     = sqrt( SSD / (n-1) )

     population standard deviation:
         true population mean is known, so n degrees of freedom
         within a sample of size n
     = sqrt( SSD/ n) biased, population mean is known

     standard error (SE):
         the standard deviation of the mean itself, across more
         than one sample.
         used in confidence intervals and hypothesis testing.
         e.g. 95% - confidence interval = mean += 1.96 * SE for
         gaussian normal distribution
         assumptions of same sample size and drawn from same population.
     = sample standard deviation / sqrt(n)
     = sqrt( SSD / (n*(n-1)) )

     &lt;/pre&gt;
     * @param x
     * @return array of length 2 holding the mean of x and the ssum of
     * the square differences of x from the mean.
     */
    public static double[] calcMeanAndSSD(int[] x) {
<span class="fc" id="L961">        return calcMeanAndSSD(convertIntToDouble(x));</span>
    }

    /**
     * calculate the arithmetic mean of x
     &lt;pre&gt;
     arithetic mean: (1/n)*sum(x_i) for i = 0 to n-1 where n = x.length
     &lt;/pre&gt;
     * @param x array of values
     * @return arithmetic mean of x
     */
    public static double calcMean(double[] x) {
<span class="fc" id="L973">        double s = 0;</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L975">            s += x[i];</span>
        }
<span class="fc" id="L977">        return s/x.length;</span>
    }

    /**
     * calculate the geometric mean of array x.
     &lt;pre&gt;
     geometric mean: (product(x_i))^(1/n) for i=0 to n-1 where n=x.length.
     &lt;/pre&gt;
     Note that to handle potentially very small and very large numbers, the logarithm is used
     followed by exponential of the result. (logarithm transforms the product into sum, making it
     the arithmetic mean).
     * @param x array of values.  note that a 0 in x results in a geometric mean of 0
     * @return geometric mean of x
     */
    public static double calcGeometricMean(double[] x) {
<span class="fc" id="L992">        int n = x.length;</span>
        // to avoid problems with very large and very small numbers, take logarithm,
        // which then turns product into sum
<span class="fc" id="L995">        double mean = calcMean(log(x));</span>
<span class="fc" id="L996">        return Math.exp(mean);</span>
    }

    /**
     * calculate the harmonic mean of array x.
     &lt;pre&gt;
     harmonic mean: n/(sum(1/a_i)) for i=0 to n-1 where n = x.length
     &lt;/pre&gt;
     * @param x array of values.  note that any 0 in x will throw a divide by zero runtime error.
     * @return harmonic mean
     */
    public static double calcHarmonicMean(double[] x) {
<span class="fc" id="L1008">        int n = x.length;</span>
        // n/(sum(1/a_i)) = 1/arithmetic sum of the reciprocals of each x_i
<span class="fc" id="L1010">        double[] recip = new double[x.length];</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L1012">            recip[i] = 1./x[i];</span>
        }
<span class="fc" id="L1014">        return 1./calcMean(recip);</span>
    }

    /**
     * returns the logarithm of each value in x
     * @param x array of values
     * @return logarithm of each value in x
     */
    public static double[] log(double[] x) {
<span class="fc" id="L1023">        double[] out = new double[x.length];</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L1025">            out[i] = Math.log(x[i]);</span>
        }
<span class="fc" id="L1027">        return out;</span>
    }
    
    /**
     * given an array of points, return the average and standard deviation from
     * the average
     @param x
     @return 
     */
    public static double[] getAvgAndStDev(double[] x) {
        
<span class="fc" id="L1038">        double sumX = 0;</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L1040">            sumX += x[i];</span>
        }
        
<span class="fc" id="L1043">        double avgX = (double)sumX/(double)x.length;</span>
        
<span class="fc" id="L1045">        sumX = 0;</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L1047">            double diffX = x[i] - avgX;</span>
<span class="fc" id="L1048">            sumX += (diffX * diffX);</span>
        }
<span class="fc" id="L1050">        double stdDevX = Math.sqrt(sumX/(x.length - 1.0));</span>
        
<span class="fc" id="L1052">        return new double[]{avgX, stdDevX};</span>
    }    

    /**
     *
     @return
     */
    public static PairIntArray get20NeighborOffsets() {
        
<span class="fc" id="L1061">        PairIntArray r2Offsets = new PairIntArray();</span>
        
<span class="fc" id="L1063">                              r2Offsets.add(-1, 2); r2Offsets.add(0, 2); r2Offsets.add(1, 2);</span>
<span class="fc" id="L1064">        r2Offsets.add(-2, 1); r2Offsets.add(-1, 1); r2Offsets.add(0, 1); r2Offsets.add(1, 1); r2Offsets.add(2, 1);</span>
<span class="fc" id="L1065">        r2Offsets.add(-2, 0); r2Offsets.add(-1, 0);                       r2Offsets.add(1, 0); r2Offsets.add(2, 0);</span>
<span class="fc" id="L1066">        r2Offsets.add(-2, -1); r2Offsets.add(-1, -1); r2Offsets.add(0, -1); r2Offsets.add(1, -1); r2Offsets.add(2, -1);</span>
<span class="fc" id="L1067">                              r2Offsets.add(-1, -2); r2Offsets.add(0, -2); r2Offsets.add(1, -2);</span>
        
<span class="fc" id="L1069">        return r2Offsets;</span>
    }

     /**
     *
     @param a
     @return
     */
    public static int[] findMinMaxValues(int[][] a) {
        
<span class="nc" id="L1079">        int min = Integer.MAX_VALUE;</span>
<span class="nc" id="L1080">        int max = Integer.MIN_VALUE;</span>
        
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            for (int j = 0; j &lt; a[i].length; ++j) {</span>
<span class="nc" id="L1084">                int v = a[i][j];</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                if (v &lt; min) {</span>
<span class="nc" id="L1086">                    min = v;</span>
                }
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                if (v &gt; max) {</span>
<span class="nc" id="L1089">                    max = v;</span>
                }
            }
        }
        
<span class="nc" id="L1094">        return new int[]{min, max};</span>
    }

    /**
     * find the minima and maxima of x and y and return them as
     * int[]{xMin, xMax, yMin, yMax}
     @param points
     @return minMaxXY int[]{xMin, xMax, yMin, yMax}
     */
    public static int[] findMinMaxXY(Collection&lt;PairInt&gt; points) {
        
<span class="fc" id="L1105">        int xMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L1106">        int xMax = Integer.MIN_VALUE;</span>
<span class="fc" id="L1107">        int yMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L1108">        int yMax = Integer.MIN_VALUE;</span>
        
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L1111">            int x = p.getX();</span>
<span class="fc" id="L1112">            int y = p.getY();</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            if (x &lt; xMin) {</span>
<span class="fc" id="L1114">                xMin = x;</span>
            }
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            if (y &lt; yMin) {</span>
<span class="fc" id="L1117">                yMin = y;</span>
            }
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            if (x &gt; xMax) {</span>
<span class="fc" id="L1120">                xMax = x;</span>
            }
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            if (y &gt; yMax) {</span>
<span class="fc" id="L1123">                yMax = y;</span>
            }
<span class="fc" id="L1125">        }</span>
<span class="fc" id="L1126">        return new int[]{xMin, xMax, yMin, yMax};</span>
    }
    
    /**
     * find the minima and maxima of x and y and return them as
     * int[]{xMin, xMax, yMin, yMax}
     @param pixelIdxs
     @param imgWidth
     @return minMaxXY int[]{xMin, xMax, yMin, yMax}
     */
    public static int[] findMinMaxXY(TIntSet pixelIdxs, int imgWidth) {
        
<span class="fc" id="L1138">        int xMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L1139">        int xMax = Integer.MIN_VALUE;</span>
<span class="fc" id="L1140">        int yMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L1141">        int yMax = Integer.MIN_VALUE;</span>
        
<span class="fc" id="L1143">        TIntIterator iter = pixelIdxs.iterator();</span>
        
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
            
<span class="fc" id="L1147">            int pixIdx = iter.next();</span>
<span class="fc" id="L1148">            int y = pixIdx/imgWidth;</span>
<span class="fc" id="L1149">            int x = pixIdx - (y * imgWidth);</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">            if (x &lt; xMin) {</span>
<span class="fc" id="L1151">                xMin = x;</span>
            }
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            if (y &lt; yMin) {</span>
<span class="fc" id="L1154">                yMin = y;</span>
            }
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (x &gt; xMax) {</span>
<span class="fc" id="L1157">                xMax = x;</span>
            }
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            if (y &gt; yMax) {</span>
<span class="fc" id="L1160">                yMax = y;</span>
            }
<span class="fc" id="L1162">        }</span>
<span class="fc" id="L1163">        return new int[]{xMin, xMax, yMin, yMax};</span>
    }

    /**
     * find the minima and maxima of x and y and return them as
     * int[]{xMin, xMax, yMin, yMax}
     @param points
     @return minMaxXY int[]{xMin, xMax, yMin, yMax}
     */
    public static int[] findMinMaxXY(PairIntArray points) {
        
<span class="nc" id="L1174">        int xMin = Integer.MAX_VALUE;</span>
<span class="nc" id="L1175">        int xMax = Integer.MIN_VALUE;</span>
<span class="nc" id="L1176">        int yMin = Integer.MAX_VALUE;</span>
<span class="nc" id="L1177">        int yMax = Integer.MIN_VALUE;</span>
        
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        for (int i = 0; i &lt; points.getN(); ++i) {</span>
<span class="nc" id="L1180">            int x = points.getX(i);</span>
<span class="nc" id="L1181">            int y = points.getY(i);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (x &lt; xMin) {</span>
<span class="nc" id="L1183">                xMin = x;</span>
            }
<span class="nc bnc" id="L1185" title="All 2 branches missed.">            if (y &lt; yMin) {</span>
<span class="nc" id="L1186">                yMin = y;</span>
            }
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (x &gt; xMax) {</span>
<span class="nc" id="L1189">                xMax = x;</span>
            }
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            if (y &gt; yMax) {</span>
<span class="nc" id="L1192">                yMax = y;</span>
            }
        }
<span class="nc" id="L1195">        return new int[]{xMin, xMax, yMin, yMax};</span>
    }
    
    /**
     * test for whether n is a power of 2.
     @param n a non-negative number.
     @return true if is a power of , else false.
     */
    public static boolean isAPowerOf2(int n) {
        // bitmask test e.g. 128 &amp; 0x7f = 0
<span class="pc bpc" id="L1205" title="1 of 4 branches missed.">        return ((n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0));</span>
    }
    
    /**
     * convert integer a to the given base. 
     * java.lang.Integer already has radix toString operations,
     * so this is just here for convenience.
     @param a
     @param base
     @return 
     */
    public static String convertToBase(int a, int base) {
<span class="nc" id="L1217">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        while (a &gt; 0) {</span>
<span class="nc" id="L1219">            sb.append(Integer.toString(a % base));</span>
<span class="nc" id="L1220">            a /= base;</span>
        }
<span class="nc" id="L1222">        sb.reverse();</span>
<span class="nc" id="L1223">        return sb.toString();</span>
    }
    
    /**
     * get fractional part of a.  
     * e.g. for a = 385.55, fractional part = 0.55.
     * for a = -385.55, fractional part = -0.55.
     @param a 
     @return 
     */
    public static double getFractionalPart(double a) {
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (a &lt; 0) {</span>
<span class="nc" id="L1235">            return -1*(-a % 1);</span>
        }
<span class="nc" id="L1237">        return a % 1;</span>
    }
    
    /**
     * determine the number of bits, that is, the msb position + 1.
     * Note that a value of 0 returns a bit length of 1.
     @param v
     @return 
     */
    public static int numberOfBits(int v) {
<span class="pc bpc" id="L1247" title="2 of 4 branches missed.">        if (v == Integer.MAX_VALUE || v == Integer.MIN_VALUE) return 31;</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (v &lt; 0) {</span>
<span class="fc" id="L1249">            v *= -1;</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">        } else if (v == 0) {</span>
<span class="fc" id="L1251">            return 1;</span>
        }
<span class="fc" id="L1253">        return 32 - Integer.numberOfLeadingZeros(v);</span>
    }
    
    /**
     * determine the number of bits, that is the msb position + 1.
     * Note that a value of 0 returns a bit length of 1.
     @param v
     @return 
     */
    public static int numberOfBits(long v) {
<span class="pc bpc" id="L1263" title="2 of 4 branches missed.">        if (v == Long.MAX_VALUE || v == Long.MIN_VALUE) return 63;</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">        if (v &lt; 0) {</span>
<span class="fc" id="L1265">            v *= -1;</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">        } else if (v == 0) {</span>
<span class="fc" id="L1267">            return 1;</span>
        }
<span class="fc" id="L1269">        return 64 -  Long.numberOfLeadingZeros(v);</span>
    }

    public static int MSBWithoutBuiltIn(long v) {
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">        if (v == 0) return 0;</span>
<span class="fc bfc" id="L1274" title="All 4 branches covered.">        if (v == Long.MAX_VALUE || v == Long.MIN_VALUE) return 63;</span>
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        if (v &lt; 0) {</span>
<span class="fc" id="L1276">            v *= -1;</span>
        }
        // bisecting left search to find power of 2
<span class="fc" id="L1279">        int lo = 0, hi = 63;</span>
        int mid;
<span class="fc bfc" id="L1281" title="All 2 branches covered.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L1282">            mid = lo + (hi - lo)/2;</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">            if ((1L&lt;&lt;mid) &lt; v) {</span>
<span class="fc" id="L1284">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L1286">                hi = mid - 1;</span>
            }
        }
<span class="fc" id="L1289">        return Math.max(lo, hi) - 1;</span>
    }
    public static int LSB(long v) {
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">        if (v == 0) return 0;</span>
<span class="fc" id="L1293">        return Long.numberOfTrailingZeros(v);</span>
    }
    public static int LSBWithoutBuiltIn1(long v) {
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">        if (v == 0) return 0;</span>
<span class="fc" id="L1297">        int power = (int)(v &amp; -v);</span>
<span class="fc" id="L1298">        return (int)(Math.log(power)/Math.log(2));</span>
    }
    public static int LSBWithoutBuilt1n2(long v) {
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">        if (v == 0) return 0;</span>
<span class="fc" id="L1302">        int power = (int)(v &amp; -v);</span>
        // bisecting search to find power of 2
<span class="fc" id="L1304">        int lo = 0, hi = 63;</span>
        int mid;
        long t;
        // power=16 0b10000
        // 0 63, mid=31, p&gt;&gt;31 = 0,
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">        while (power &gt; 0) {</span>
<span class="fc" id="L1310">            mid = lo + (hi - lo)/2;</span>
<span class="fc" id="L1311">            t = power &gt;&gt; mid;</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">            if (t == 1L) {</span>
<span class="fc" id="L1313">                return mid;</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">            } else if (t &gt; 0) {</span>
<span class="fc" id="L1315">                lo = mid + 1;</span>
            } else {
<span class="fc" id="L1317">                hi = mid - 1;</span>
            }
        }
<span class="nc" id="L1320">        throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
    }

    /**
     * determine the number of set bits.  this method uses the
     * hamming weight which uses binary magic numbers.
     &lt;pre&gt;
     reference:
     https://en.wikipedia.org/wiki/Hamming_weight
     method popcount64c
     &lt;/pre&gt;
     @param x the bitstring with the set bits to count
     @return the number of bits set in x
     */
    public static int numberOfSetBits(long x) {
        //put count of each 2 bits into those 2 bits, where the mask is 62 bits of repeated '10's
<span class="fc" id="L1336">        x -= (x &gt;&gt; 1) &amp; 0x5555555555555555L;</span>
        //put count of each 4 bits into those 4 bits
<span class="fc" id="L1338">        x = (x &amp; 0x3333333333333333L) + ((x &gt;&gt; 2) &amp; 0x3333333333333333L);</span>
        //put count of each 8 bits into those 8 bits
<span class="fc" id="L1340">        x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f0f0f0f0fL;</span>
        //returns left 8 bits of x + (x&lt;&lt;8) + (x&lt;&lt;16) + (x&lt;&lt;24) + ...
<span class="fc" id="L1342">        x = ((x * 0x0101010101010101L) &gt;&gt; 56);</span>
<span class="fc" id="L1343">        return (int) (x &amp; 0x7f);</span>
    }
    
    /**
     * 
     @param v
     @param nBits
     @return 
     */
    public static int bitReverse(int v, int nBits) {

<span class="fc" id="L1354">        int r = v;</span>
                
<span class="fc" id="L1356">        int rev = 0;</span>
<span class="fc bfc" id="L1357" title="All 2 branches covered.">        for (int i = 0; i &lt; nBits; i++) {</span>
<span class="fc" id="L1358">            rev = (rev &lt;&lt; 1) | (r &amp; 1);</span>
<span class="fc" id="L1359">            r &gt;&gt;= 1;</span>
        }
        
<span class="fc" id="L1362">        return rev;</span>
        
    }
    
       /**
     * method from scipy's numpy package to return numbers spaced evenly 
     * on a log scale.
     &lt;pre&gt;
     numpy is licensed under BSD 3-clause &quot;New&quot; or &quot;Revised&quot; License
      
     https://github.com/numpy/numpy/blob/master/LICENSE.txt
     &lt;/pre&gt;
    
    @param start is the starting value of the sequence.
    @param stop float is the final value of the sequence, 
       unless `endpoint` is False.  
       In that case, ``num + 1`` values are spaced over the
        interval in log-space, of which all but the last 
        (a sequence of length ``num``) are returned.
    @param num : Number of samples to generate.  Default is 50.
    @param endpoint : If true, `stop` is the last sample. 
        Otherwise, it is not included.
        Default is True.
     @return 
    */
    public static TDoubleArrayList logspace(float start, float stop, int num,
        boolean endpoint) {
                
<span class="nc" id="L1390">        TFloatArrayList y = linspace(start, stop, num, endpoint);</span>

<span class="nc" id="L1392">        TDoubleArrayList logY = new TDoubleArrayList(y.size());</span>

<span class="nc bnc" id="L1394" title="All 2 branches missed.">        for (int i = 0; i &lt; y.size(); ++i) {</span>
<span class="nc" id="L1395">            float v = y.get(i);</span>
<span class="nc" id="L1396">            double l = Math.pow(10, v);</span>
<span class="nc" id="L1397">            logY.add(l);</span>
        }
        
<span class="nc" id="L1400">        return logY;</span>
    }
    
    /**
     * adapted method from scipy's numpy package to return evenly spaced numbers 
     * over a specified interval
     &lt;pre&gt;
     numpy is licensed under BSD 3-clause &quot;New&quot; or &quot;Revised&quot; License
      
     https://github.com/numpy/numpy/blob/master/LICENSE.txt
     &lt;/pre&gt;
    
    @param start is the starting value of the sequence.
    @param stop float is the final value of the sequence, 
       unless `endpoint` is False.  
       In that case, ``num + 1`` values are spaced over the
        interval in log-space, of which all but the last 
        (a sequence of length ``num``) are returned.
    @param num : Number of samples to generate.  Default is 50.
    @param endpoint : If true, `stop` is the last sample. 
        Otherwise, it is not included.
        Default is True.
     @return 
    */
    public static TFloatArrayList linspace(
        float start, float stop, int num,
        boolean endpoint) {
        
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        if (num &lt; 0) {</span>
<span class="nc" id="L1429">            throw new IllegalArgumentException(&quot;num must be .gte. 0&quot;);</span>
        }
        
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        int n2 = endpoint ? (num - 1) : num;</span>
        
<span class="nc" id="L1434">        float dt = (stop - start)/n2;</span>
        
<span class="nc" id="L1436">        TFloatArrayList y = new TFloatArrayList(num);</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">        for (int i = 0; i &lt;= num; ++i) {</span>
<span class="nc" id="L1438">            float v = start + (dt * i);</span>
<span class="nc" id="L1439">            y.add(v);</span>
        }
        
<span class="nc" id="L1442">        return y;</span>
    }
    
    /**
     * calculates the mean of the data per dimension and returns it as a point 
     * in all dimensions.
     @param data nDimensional data points in format [ point_0 in all dimensions,
     *   point_1 in all dimensions, ... point_{n-1} in all dimensions[
     @param nDimensions the number of dimensions of a point
     @return an array holding the mean per dimension, e.g. point_0_0,
     * point_0_1, point_0_2...point_0_{nDimensions-1}]
     */
    public static double[] mean(double[] data, int nDimensions) {
        
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">        if ((data.length % nDimensions) != 0) {</span>
<span class="nc" id="L1457">            throw new IllegalArgumentException(&quot;data.length must be a multiple of nDimensions&quot;);</span>
        }
<span class="fc" id="L1459">        int nData = data.length/nDimensions;</span>
        
<span class="fc" id="L1461">        double[] c = new double[nDimensions];</span>
        int i, j, d;
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        for (i = 0; i &lt; nData; ++i) {</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">            for (d = 0; d &lt; nDimensions; ++d) {</span>
<span class="fc" id="L1465">                j = i * nDimensions + d;</span>
<span class="fc" id="L1466">                c[d] += data[j];</span>
            }
        }
<span class="fc bfc" id="L1469" title="All 2 branches covered.">        for (d = 0; d &lt; nDimensions; ++d) {</span>
<span class="fc" id="L1470">            c[d] /= (double) nData;</span>
        }
<span class="fc" id="L1472">        return c;</span>
    }
    /**
     * calculates the mean of the data
     @param data data points
     @return the sample mean
     */
    public static double mean(double[] data) {

<span class="fc" id="L1481">        int n = data.length;</span>
        int i;
<span class="fc" id="L1483">        double sum = 0;</span>
<span class="fc bfc" id="L1484" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1485">            sum += data[i];</span>
        }
<span class="fc" id="L1487">        sum /= (double)n;</span>
<span class="fc" id="L1488">        return sum;</span>
    }

    /**
     * calculates the mean per dimension and standard deviation per dimension
     * of the data and returns them in a double array of size [2][nDimensions] 
     @param data nDimensional data points in format [ point_0 in all dimensions,
     *   point_1 in all dimensions, ... point_{n-1} in all dimensions[
     @param nDimensions the number of dimensions of a point
     @return the standard deviation of the data in each dimension.  return format
     * is a double array of size [2][nDimensions] 
     */
    public static double[][] standardDeviation(double[] data, int nDimensions) {
        
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">        if ((data.length % nDimensions) != 0) {</span>
<span class="nc" id="L1503">            throw new IllegalArgumentException(&quot;data.length must be a multiple of nDimensions&quot;);</span>
        }
<span class="fc" id="L1505">        int nData = data.length/nDimensions;</span>
        
<span class="fc" id="L1507">        double[] c = mean(data, nDimensions);</span>
<span class="fc" id="L1508">        double[][] out = new double[2][];</span>
<span class="fc" id="L1509">        out[0] = c;</span>
<span class="fc" id="L1510">        out[1] = new double[nDimensions];</span>
        
        int i, j, d;
        double diff;
<span class="fc bfc" id="L1514" title="All 2 branches covered.">        for (i = 0; i &lt; nData; ++i) {</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">            for (d = 0; d &lt; nDimensions; ++d) {</span>
<span class="fc" id="L1516">                j = i * nDimensions + d;</span>
<span class="fc" id="L1517">                diff = data[j] - out[0][d];</span>
<span class="fc" id="L1518">                out[1][d] += (diff*diff);</span>
            }
        }
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        for (d = 0; d &lt; nDimensions; ++d) {</span>
<span class="fc" id="L1522">            out[1][d] = Math.sqrt(out[1][d]/(nData - 1.0f)); </span>
        }
        
<span class="fc" id="L1525">        return out;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static double[] cumulativeSum(double[] a) {
        
<span class="fc" id="L1535">        double[] s = Arrays.copyOf(a, a.length);</span>
        
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        for (int i = 1; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1538">            s[i] += s[i - 1];</span>
        }
        
<span class="fc" id="L1541">        return s;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static int[] cumulativeSum(int[] a) {
        
<span class="fc" id="L1551">        int[] s = Arrays.copyOf(a, a.length);</span>
        
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        for (int i = 1; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1554">            s[i] += s[i - 1];</span>
        }
        
<span class="fc" id="L1557">        return s;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static double[][] cumulativeSumMatlabPort(double[][] a) {
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (a.length &gt; 1) {</span>
<span class="nc" id="L1567">            return cumulativeSumAlongColumns(a);</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">        } else if (a[0].length &gt; 1) {</span>
<span class="nc" id="L1569">            return cumulativeSumAlongRows(a);</span>
        }
<span class="nc" id="L1571">        throw new IllegalArgumentException(&quot;a must have at least one dimension of size &gt; 1&quot;);</span>
    }
    
    /**
     * calculate cumulative sums along columns.
     &lt;pre&gt;
     e.g. a = | 1  2  3 |
              | 4  5  6 |
              | 7  8  9 |
     cumulative sum along columns =
              | 1   2   3  |
              | 5   7   9  |
              | 12  15  18 |
     &lt;/pre&gt;
     @param a matrix
     @return matrix holding cumulative sums along columns of a
     */
    public static double[][] cumulativeSumAlongColumns(double[][] a) {
        
<span class="fc" id="L1590">        double[][] s = MatrixUtil.copy(a);</span>
        
<span class="fc bfc" id="L1592" title="All 2 branches covered.">        for (int row = 1; row &lt; a.length; ++row) {</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">            for (int col = 0; col &lt; a[0].length; ++col) {</span>
<span class="fc" id="L1594">               s[row][col] += s[row - 1][col];</span>
            }
        }
        
<span class="fc" id="L1598">        return s;</span>
    }
    
    /**
     *
     @param a
     @return
     */
    public static double[][] cumulativeSumAlongRows(double[][] a) {
        
<span class="nc" id="L1608">        double[][] s = new double[a.length][a[0].length];</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L1610">            s[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
        
<span class="nc bnc" id="L1613" title="All 2 branches missed.">        for (int row = 0; row &lt; a.length; ++row) {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            for (int col = 1; col &lt; a[0].length; ++col) {</span>
<span class="nc" id="L1615">               s[row][col] += s[row][col - 1];</span>
            }
        }
        
<span class="nc" id="L1619">        return s;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static TIntIntMap makeFrequencyMap(int[] a) {
<span class="fc" id="L1628">        TIntIntMap f = new TIntIntHashMap();</span>
        int c;
<span class="fc bfc" id="L1630" title="All 2 branches covered.">        for (int key : a) {</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">            if (f.containsKey(key)) {</span>
<span class="fc" id="L1632">                c = f.get(key) + 1;</span>
            } else {
<span class="fc" id="L1634">                c = 1;</span>
            }
<span class="fc" id="L1636">            f.put(key, c);</span>
        }
<span class="fc" id="L1638">        return f;</span>
    }

    /**
     * calc binomial coefficient C(n, k), a.k.a. &quot;n choose k&quot; = (n!/(k!*(n-k)!)
     * runtime complexity is O(n*k).
     * Use computeNDivKTimesNMinusK(n,k) instead because its runtime complexity is O(k).
     * This is here as a dynamic programming exercise.
     * @param n
     * @param k
     * @return
     */
    private static long calcBinomialCoeff(final int n, final int k) {
<span class="nc bnc" id="L1651" title="All 2 branches missed.">        if (k &lt;= 0) {</span>
<span class="nc" id="L1652">            throw new IllegalArgumentException(&quot;k must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (n&lt;k) {</span>
<span class="nc" id="L1655">            throw new IllegalArgumentException(&quot;n must be &gt;= k&quot;);</span>
        }
<span class="nc" id="L1657">        long[] prev = new long[k + 1];</span>
<span class="nc" id="L1658">        long[] curr = new long[k + 1];</span>
        int j;
<span class="nc bnc" id="L1660" title="All 2 branches missed.">        for (int i = 0; i &lt;= n; ++i) {</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">            for (j = 0; j &lt;= Math.min(i, k); ++j) {</span>
                // base cases:
<span class="nc bnc" id="L1663" title="All 4 branches missed.">                if (j == 0 || j == i) curr[j] = 1;</span>
                    // add prev k entry
<span class="nc" id="L1665">                else curr[j] = prev[j - 1] + prev[j];</span>
            }
<span class="nc" id="L1667">            prev = Arrays.copyOf(curr, curr.length);</span>
        }
<span class="nc" id="L1669">        return curr[k];</span>
    }
    
     /**
     * compute n!/k!(n-k)!.
     * if the result is larger than Long.MAX_VALUE the method throws an ArithmeticException.
      *
      * runtime complexity is O(k)
     *
     * (Aho and Ullman &quot;Foundations of Computer Science&quot;)
     @param n
     @param k
     @return
     * @throws ArithmeticException thrown when result is out of range of type long
     */
    public static long computeNDivKTimesNMinusK(int n, int k) {
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">        if (k &lt;= 0) {</span>
<span class="nc" id="L1686">            throw new IllegalArgumentException(&quot;k must be &gt;= 0&quot;);</span>
        }
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        if (n&lt;k) {</span>
<span class="nc" id="L1689">            throw new IllegalArgumentException(&quot;n must be &gt;= k&quot;);</span>
        }

<span class="fc bfc" id="L1692" title="All 2 branches covered.">        if (n == k) {</span>
<span class="fc" id="L1693">            return 1;</span>
        }

        int i;
<span class="fc" id="L1697">        double result = 1;</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">        for (i = n; i &gt; (n-k); i--) {</span>
<span class="fc" id="L1699">            result = result*i;</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">            if (result &lt; 0) throw new ArithmeticException(&quot;the result will not fit in a long.  Use computeNDivKTimesNMinusKBigInteger instead.&quot;);</span>
<span class="fc" id="L1701">            result /= (i - n + k);</span>
        }

<span class="fc" id="L1704">        return Math.round(result);</span>
    }
    
     /**
     * compute n!/(n-k)!... needed for large numbers
     *
     @param n
     @param k
     @return
     */
    public static long computeNDivNMinusK(int n, int k) {

<span class="fc bfc" id="L1716" title="All 2 branches covered.">        if (n == k) {</span>
<span class="fc" id="L1717">            return 1;</span>
        }

<span class="fc" id="L1720">        long result = 1;</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">        for (int i = n; i &gt; (n-k); i--) {</span>
<span class="fc" id="L1722">            result *= i;</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">            if (result &lt; 0) throw new ArithmeticException(&quot;the result will not fit in a long&quot;);</span>
        }
<span class="fc" id="L1725">        return result;</span>
    }
    
    /**
     * compute n!/k!(n-k)!.
     * runtime complexity is O(k).
     @param n
     @param k
     @return 
     * @throws ArithmeticException thrown when result is out of range of type long
     */
    public static BigInteger computeNDivKTimesNMinusKBigInteger(int n, int k) {
        
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">        if (n == k) {</span>
<span class="nc" id="L1739">            return BigInteger.ONE;</span>
        }
        
<span class="fc" id="L1742">        MathContext ctx = MathContext.DECIMAL128;//MathContext.UNLIMITED;</span>
        
        /*
        following Aho &amp; Ullman &quot;Foundations of Computer Science&quot;.
        
        runtime O(k)
        */
        
<span class="fc" id="L1750">        BigDecimal result = BigDecimal.ONE;</span>
        int i;
        BigDecimal m;
        
<span class="fc bfc" id="L1754" title="All 2 branches covered.">        for (i = n; i &gt; (n - k); i--) {</span>
<span class="fc" id="L1755">            m = new BigDecimal(Integer.toString(i), ctx);</span>
<span class="fc" id="L1756">            result = result.multiply(m, ctx);</span>
<span class="fc" id="L1757">            m = new BigDecimal(Integer.toString(i - n + k), ctx);</span>
<span class="fc" id="L1758">            result = result.divide(m, ctx);</span>
        }
<span class="fc" id="L1760">        result = result.setScale(0, RoundingMode.HALF_UP);</span>
<span class="fc" id="L1761">        return result.toBigInteger();</span>
    }
    
    /**
     * compute n!
     *
     @param n
     @return
     */
    public static long factorial(int n) {

<span class="fc bfc" id="L1772" title="All 2 branches covered.">        if (n &lt; 3) {</span>
<span class="fc" id="L1773">            return n;</span>
        }
        
<span class="pc bpc" id="L1776" title="1 of 2 branches missed.">        if (n &gt; 20) {</span>
<span class="nc" id="L1777">            throw new IllegalArgumentException(&quot;use factorialBigInteger instead&quot;);</span>
        }

<span class="fc" id="L1780">        long result = 1;</span>
<span class="fc bfc" id="L1781" title="All 2 branches covered.">        for (int i = 2; i &lt;= n; i++) {</span>
<span class="fc" id="L1782">            result *= i;</span>
        }
<span class="fc" id="L1784">        return result;</span>
    }
    
    /**
     * compute n!
     *
     @param n
     @return
     */
    public static BigInteger factorialBigInteger(int n) {

<span class="fc" id="L1795">        BigInteger result = BigInteger.ONE;</span>

<span class="fc bfc" id="L1797" title="All 2 branches covered.">        for (int i = 2; i &lt;= n; i++) {</span>
            
<span class="fc" id="L1799">            byte[] bytes = MiscMath0.writeToBigEndianBytes(i);</span>
            
<span class="fc" id="L1801">            BigInteger v = new BigInteger(bytes);</span>
            
<span class="fc" id="L1803">            result = result.multiply(v);</span>
        }
        
<span class="fc" id="L1806">        return result;</span>
    }
    
    /**
     * write value to a byte array in big endian, that is LSB in highest order bit
     * (MSB is in lowest memory address).
     * these are signed values stored as twos complement and can be input
     * to BigInteger's constructor.
     @param value
     @return 
     */
    public static byte[] writeToBigEndianBytes(long value) {
    
<span class="fc" id="L1819">        long nBits = numberOfBits(value);</span>
        
<span class="fc" id="L1821">        int nBytes = (int) Math.ceil((float)nBits/(float)4);</span>
        
        //System.out.println(&quot;nBits=&quot; + nBits + &quot; value=&quot; + value + &quot; nBytes=&quot; + nBytes);
        
<span class="fc" id="L1825">        byte[] bytes = new byte[nBytes];</span>

<span class="fc bfc" id="L1827" title="All 2 branches covered.">        for (int i = 0; i &lt; nBytes; i++) {</span>
<span class="fc" id="L1828">            long shift = i * 8;</span>
<span class="fc" id="L1829">            long a = (value &gt;&gt; shift);</span>
<span class="fc" id="L1830">            byte b = (byte)a;</span>
<span class="fc" id="L1831">            bytes[nBytes - i - 1] = b;</span>
        }

<span class="fc" id="L1834">        return bytes;</span>
    }

    /**
     *
     @param d
     @return
     */
    public static double[] getMinMax(double[] d) {
<span class="fc" id="L1843">        double min = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1844">        double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L1845" title="All 2 branches covered.">        for (double a : d) {</span>
<span class="fc bfc" id="L1846" title="All 2 branches covered.">            if (a &lt; min) {</span>
<span class="fc" id="L1847">                min = a;</span>
            }
<span class="fc bfc" id="L1849" title="All 2 branches covered.">            if (a &gt; max) {</span>
<span class="fc" id="L1850">                max = a;</span>
            }
        }
<span class="fc" id="L1853">        return new double[]{min, max};</span>
    }
    
    /**
     *
     @param d
     @return
     */
    public static float[] getMinMax(float[] d) {
<span class="fc" id="L1862">        float min = Float.POSITIVE_INFINITY;</span>
<span class="fc" id="L1863">        float max = Float.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">        for (float a : d) {</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">            if (a &lt; min) {</span>
<span class="fc" id="L1866">                min = a;</span>
            }
<span class="fc bfc" id="L1868" title="All 2 branches covered.">            if (a &gt; max) {</span>
<span class="fc" id="L1869">                max = a;</span>
            }
        }
<span class="fc" id="L1872">        return new float[]{min, max};</span>
    }

    /**
     * third standardized moment of skewness as sample skewness:
     * &lt;pre&gt;
     *  https://en.m.wikipedia.org/wiki/Skewness
     *     g1 = kappa_3/((kappa_2)^(3/2))
     *        = (1/n) * summation from i=1 to n ( (x_i - mean)^3)
     *           / ([ (1/n) * summation from i=1 to n ( (x_i - mean)^2) ]^(3/2) )
     *
     *           where kappa_2 is the 2nd cumulant = variance.
     *          kappa_3 = central moment which is skewness
     * &lt;/pre&gt;
     @param data
     @return
     */
    public static double calcSampleSkewness(double[] data) {
<span class="nc" id="L1890">        double mean = MiscMath0.mean(data);</span>
<span class="nc" id="L1891">        int n = data.length;</span>
<span class="nc" id="L1892">        double sum2 = 0;</span>
<span class="nc" id="L1893">        double sum3 = 0;</span>
        int i;
        double diff;
        double d2;
<span class="nc bnc" id="L1897" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1898">            diff = data[i] - mean;</span>
<span class="nc" id="L1899">            d2 = diff * diff;</span>
<span class="nc" id="L1900">            sum2 += d2;</span>
<span class="nc" id="L1901">            sum3 += (diff * d2);</span>
        }
<span class="nc" id="L1903">        sum3 /= (double)n;</span>
<span class="nc" id="L1904">        sum2 /= (double)n;</span>
<span class="nc" id="L1905">        sum2 = Math.pow(sum2, 1.5);</span>

<span class="nc" id="L1907">        return sum3/sum2;</span>
    }

    /**
     *
     @param x
     @return
     */
    public static Number findMin(Number[] x) {
<span class="pc bpc" id="L1916" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L1917">            return null;</span>
        }
<span class="fc" id="L1919">        double min = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1920">        Number m = null;</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">            if (x[i].doubleValue() &lt; min) {</span>
<span class="fc" id="L1923">                min = x[i].doubleValue();</span>
<span class="fc" id="L1924">                m = x[i];</span>
            }
        }
<span class="fc" id="L1927">        return m;</span>
    }

    /**
     *
     @param x
     @return
     */
    public static Number findMax(Number[] x) {
<span class="pc bpc" id="L1936" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L1937">            return null;</span>
        }
<span class="fc" id="L1939">        double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L1940">        Number m = null;</span>
<span class="fc bfc" id="L1941" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc bfc" id="L1942" title="All 2 branches covered.">            if (x[i].doubleValue() &gt; max) {</span>
<span class="fc" id="L1943">                max = x[i].doubleValue();</span>
<span class="fc" id="L1944">                m = x[i];</span>
            }
        }
<span class="fc" id="L1947">        return m;</span>
    }

    /**
     *
     @param v
     @return
     */
    public int sign(int v) {
<span class="nc" id="L1956">        return v &gt;&gt;&gt; 31;</span>
    }
    
<span class="fc" id="L1959">    static int[] MultiplyDeBruijnBitPosition = new int[]{</span>
        0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
        8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31
    };
    /**
     * determine the number of bits without branching and using only an int
     @param v
     @return 
     */
    public static int numberOfBitsWOB(int v) {
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">        if (v == 0) {</span>
<span class="nc" id="L1970">            return 1;</span>
        }
        //from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog
        // then edited for negative numbers and signed int
<span class="fc" id="L1974">        int sign = v &gt;&gt;&gt; 31;</span>
        // + sign=0 --&gt;  0
        // - sign=1 --&gt; -1
<span class="fc" id="L1977">        v = v + sign * (-2) * v;</span>
<span class="fc" id="L1978">        v |= v &gt;&gt; 1;</span>
<span class="fc" id="L1979">        v |= v &gt;&gt; 2;</span>
<span class="fc" id="L1980">        v |= v &gt;&gt; 4;</span>
<span class="fc" id="L1981">        v |= v &gt;&gt; 8;</span>
<span class="fc" id="L1982">        v |= v &gt;&gt; 16;</span>
<span class="fc" id="L1983">        int idx = (v * 0x07C4ACDD) &gt;&gt; 27;</span>
<span class="fc" id="L1984">        sign = idx &gt;&gt;&gt; 31;</span>
        //System.out.println(&quot;    v=&quot; + v + &quot; sign=&quot; + sign);
<span class="fc" id="L1986">        idx += sign*32;</span>
<span class="fc" id="L1987">        int r = MultiplyDeBruijnBitPosition[idx];</span>
<span class="fc" id="L1988">        return r + 1;</span>
    }
   
    /**
     * http://en.wikipedia.org/wiki/Mersenne_prime
     @param powerOf2
     @return 
     */
    public static long getMarsennePrime(int powerOf2) {
<span class="nc" id="L1997">        return (1L &lt;&lt; powerOf2) - 1;</span>
    }
    
    /**
     *
     @param z
     @return
     */
    public static double acosh(double z) {
        //https://mathworld.wolfram.com/InverseHyperbolicCosine.html
<span class="nc" id="L2007">        return Math.log(z + Math.sqrt(z + 1) * Math.sqrt(z - 1));</span>
    }

    /**
     *
     @param x
     @param y
     @return
     */
    public static double areaOfTriangle(double[] x, double[] y) {
<span class="nc bnc" id="L2017" title="All 4 branches missed.">        if (x.length != 3 || y.length != 3) {</span>
<span class="nc" id="L2018">            throw new IllegalArgumentException(&quot;x and y must be lengths 3&quot;);</span>
        }
        // choose the first x,y pair to be the origin (0, 0)
<span class="nc" id="L2021">        double oX = -x[0];</span>
<span class="nc" id="L2022">        double oY = -y[0];</span>

        // translate all points by adding xO and oY, then the area is
<span class="nc" id="L2025">        double x1 = x[1] + oX;</span>
<span class="nc" id="L2026">        double x2 = x[2] + oX;</span>
<span class="nc" id="L2027">        double y1 = y[1] + oY;</span>
<span class="nc" id="L2028">        double y2 = y[2] + oY;</span>
        // 0.5 * det|x y| = 0.5 * (x1*y2 - x2*y1)
<span class="nc" id="L2030">        return 0.5 * ((x1 * y2) - (y1 * x2));</span>
    }
    
    /**
     *
     @param z
     @return
     */
    public static double asinh(double z) {
        //https://mathworld.wolfram.com/InverseHyperbolicSine.html
<span class="nc" id="L2040">        return Math.log(z + Math.sqrt(z*z + 1));</span>
    }
    
    /**
     *
     @param a
     */
    public static void reverse(int[] a) {
        
<span class="fc" id="L2049">        int n = a.length;</span>
        
<span class="pc bpc" id="L2051" title="1 of 2 branches missed.">        if (n &lt; 2) {</span>
<span class="nc" id="L2052">            return;</span>
        }
                
<span class="fc" id="L2055">        int end = n &gt;&gt; 1;</span>
        int swap, i2;
        // 0 1 2 3 4
<span class="fc bfc" id="L2058" title="All 2 branches covered.">        for (int i = 0; i &lt; end; i++) {</span>
<span class="fc" id="L2059">            i2 = n - i - 1;</span>
<span class="fc" id="L2060">            swap = a[i];</span>
<span class="fc" id="L2061">            a[i] = a[i2];</span>
<span class="fc" id="L2062">            a[i2] = swap;</span>
        }
<span class="fc" id="L2064">    }</span>

    /**
     * return the Euler-Mascheroni constant.
     * It is the first derivative of the gamma function w.r.t. n at n=1.
     * &lt;pre&gt;
     *     Chap 19 of &quot;Statistical Distributions&quot; by Evans et al.
     * &lt;/pre&gt;
     @return
     */
    public static double eulerMascheroniConstant() {
<span class="fc" id="L2075">        return 0.5772156649;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static float[] convertDoubleToFloat(double[] a) {
<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2085">            return null;</span>
        }
<span class="fc" id="L2087">        float[] b = new float[a.length];</span>
<span class="fc bfc" id="L2088" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2089">            b[i] = (float)a[i];</span>
        }
<span class="fc" id="L2091">        return b;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static double[] convertFloatToDouble(float[] a) {
<span class="pc bpc" id="L2100" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2101">            return null;</span>
        }
<span class="fc" id="L2103">        double[] b = new double[a.length];</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2105">            b[i] = a[i];</span>
        }
<span class="fc" id="L2107">        return b;</span>
    }

    /**
     *
     @param a
     @return
     */
    public static double[] convertIntToDouble(int[] a) {
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2117">            return null;</span>
        }
<span class="fc" id="L2119">        double[] b = new double[a.length];</span>
<span class="fc bfc" id="L2120" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L2121">            b[i] = a[i];</span>
        }
<span class="fc" id="L2123">        return b;</span>
    }

    /**
     * determine whether any 3 points in X are colinear.
     * note that the method has not been edited for large number of points
     * in X yet.
     @param X data points in format [2 X nPoints] or [3 X nPoints]
     *          where row 0 are the 'x dimension' points,
     *          and row 1 are the 'y dimension' points.
     *          if row 2 is present, it is ignored as it is expected
     *          to be the z-axis of homogenous points (= value 1) and
     *          hence is not used.
     @param tol
     @return
     */
    public static boolean areColinear(double[][] X, double tol) {
<span class="pc bpc" id="L2140" title="3 of 4 branches missed.">        if (X.length != 3 &amp;&amp; X.length != 2) {</span>
<span class="nc" id="L2141">            throw new IllegalArgumentException(&quot;X.length must be 2 or 3&quot;);</span>
        }
<span class="fc" id="L2143">        int ns = X[0].length;</span>
<span class="fc" id="L2144">        int k = 3;</span>
<span class="fc" id="L2145">        int[] selectedIndexes = new int[k];</span>
<span class="fc" id="L2146">        long nComb = MiscMath0.computeNDivKTimesNMinusK(ns, k);</span>
<span class="fc" id="L2147">        SubsetChooser chooser = new SubsetChooser(ns, k);</span>
<span class="fc" id="L2148">        int c = 0;</span>
<span class="fc bfc" id="L2149" title="All 2 branches covered.">        while (chooser.getNextSubset(selectedIndexes) != -1) {</span>
<span class="fc" id="L2150">            double x1 = X[0][selectedIndexes[0]];</span>
<span class="fc" id="L2151">            double y1 = X[1][selectedIndexes[0]];</span>
<span class="fc" id="L2152">            double x2 = X[0][selectedIndexes[1]];</span>
<span class="fc" id="L2153">            double y2 = X[1][selectedIndexes[1]];</span>
<span class="fc" id="L2154">            double x3 = X[0][selectedIndexes[2]];</span>
<span class="fc" id="L2155">            double y3 = X[1][selectedIndexes[2]];</span>
<span class="fc bfc" id="L2156" title="All 2 branches covered.">            if (areColinear(x1, y1, x2, y2, x3, y3, tol)) {</span>
<span class="fc" id="L2157">                return true;</span>
            }
<span class="fc" id="L2159">            c++;</span>
<span class="fc" id="L2160">        }</span>
<span class="fc" id="L2161">        return false;</span>
    }

    /**
     * given 3 pairs of points, determine whether they are colinear.
     @param tol
     @param x1
     @param y1
     @param x2
     @param y2
     @param x3
     @param y3
     @return
     */
    public static boolean areColinear(double x1, double y1, double x2, double y2,
                                      double x3, double y3, double tol) {
        // designating (x1,y1) the origin, so subtracting it from the other points
        // then calculate direction using the cross product.
<span class="fc" id="L2179">        x2 -= x1;</span>
<span class="fc" id="L2180">        x3 -= x1;</span>
<span class="fc" id="L2181">        y2 -= y1;</span>
<span class="fc" id="L2182">        y3 -= y1;</span>
<span class="fc" id="L2183">        double direction = (x2*y3) - (y2*x3);</span>
        // p1 . [p2 × p3] if = 0, they are coplanar

<span class="fc bfc" id="L2186" title="All 2 branches covered.">        return Math.abs(direction) &lt; tol;</span>
    }

    public static double[] uniformRandomDouble(int n) {
<span class="fc" id="L2190">        long seed = System.nanoTime();</span>
<span class="fc" id="L2191">        Random rand = new Random(seed);</span>
<span class="fc" id="L2192">        return uniformRandomDouble(n, rand);</span>
    }
    public static double[] uniformRandomDouble(int n, Random rand) {
<span class="fc" id="L2195">        double[] out = new double[n];</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L2197">            out[i] = rand.nextDouble();</span>
        }
<span class="fc" id="L2199">        return out;</span>
    }

    public static boolean equalsWithinTolerance(double[] a1, double[] a2, double tol) {
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L2204">            return false;</span>
        }
<span class="fc bfc" id="L2206" title="All 2 branches covered.">        for (int i = 0; i &lt; a1.length; ++i) {</span>
<span class="fc bfc" id="L2207" title="All 2 branches covered.">            if (Math.abs(a1[i] - a2[i]) &gt; tol) return false;</span>
        }
<span class="fc" id="L2209">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>