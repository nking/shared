<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BruteForce.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.correlation</a> &gt; <span class="el_source">BruteForce.java</span></div><h1>BruteForce.java</h1><pre class="source lang-java linenums">package algorithms.correlation;

import algorithms.matrix.MatrixUtil;
import java.util.Arrays;

/**
 * implemented from 
        
 * useful for Mahalanobis distance among many things.
 * 
 * @author nichole
 */
<span class="nc" id="L13">public class BruteForce {</span>
    
    /**
     * calculate the correlation matrix for a using a brute force method
     * @param a an mxn matrix of data with the dimensions being columns
     * and the datum number being rows.
     * runtime complexity is O(m^2 * n + n^2)
     * &lt;pre&gt;
     * e.g.  a[0] = new double[]{10, 100, 1000}
     *       a[1] = new double[]{ 9, 110, 900}
     * &lt;/pre&gt;
     * @return the correlation matrix as a double array of size [a[0].length][a[0].length]
     */
    public static double[][] correlation(double[][] a) {
        
<span class="fc" id="L28">        double eps= 1.e-15;</span>
        
        // cor_i_j = cov_i_j / (sqrt(var_i)*sqrt(var_j))

        //The runtime complexity is O(m^2 * n) where m = a.length and n = a[0].length.
        // cov size is [n X n].
<span class="fc" id="L34">        double[][] cov = covariance(a);</span>
        
<span class="fc" id="L36">        double[][] cor = new double[cov.length][cov[0].length];</span>
        int i, j;
<span class="fc bfc" id="L38" title="All 2 branches covered.">        for (i = 0; i &lt; cov.length; ++i) {</span>
<span class="fc" id="L39">            cor[i] = new double[cov[i].length];</span>
        }
        double si, sj;
        // runtime complexity is ~2*(n+1)*(n) ~ n^2
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (i = 0; i &lt; cov.length; ++i) {</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">            si = (cov[i][i] &gt; eps) ? Math.sqrt(cov[i][i]) : 0;</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">            for (j = i; j &lt; cov[i].length; ++j) {</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">                sj = (cov[j][j] &gt; eps) ? Math.sqrt(cov[j][j]) : 0;</span>
<span class="pc bpc" id="L47" title="2 of 4 branches missed.">                if (si &gt; eps &amp;&amp; sj &gt; eps) {</span>
<span class="fc" id="L48">                    cor[i][j] = cov[i][j]/(si*sj);</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">                    if (i != j) {</span>
<span class="fc" id="L50">                        cor[j][i] = cor[i][j];</span>
                    }
                }
            }
        }
        
<span class="fc" id="L56">        return cor;</span>
    }
    
    /**
     * calculate the covariance matrix for a using a brute force method.
     * The covariance matrix is also known as auto-covariance matrix, 
     * dispersion matrix, variance matrix, and the variance–covariance matrix.
     * The runtime complexity is O(m^2 * n) where m = a.length and n = a[0].length.
     * @param a an mxn matrix of data with the dimensions being columns
     * and the datum number being rows.
     * &lt;pre&gt;
     * e.g.  a[0] = new double[]{10, 100, 1000}
     *       a[1] = new double[]{ 9, 110, 900}
     * &lt;/pre&gt;
     *          Note, aside from unit tests, a quick comparison with python numpy cov function produces same result.
     *
     * @return the covariance matrix as a double array of size [a[0].length][a[0].length]
     */
    public static double[][] covariance(double[][] a) {
        
<span class="fc" id="L76">        int nRows = a.length;</span>
<span class="fc" id="L77">        int nCols = a[0].length;</span>
        
        int i, j;
        
        // mean of each column:
<span class="fc" id="L82">        double[] mean = MatrixUtil.mean(a);</span>
        // r.t. nRows * nCols
<span class="fc" id="L84">        double[][] diffs = new double[nRows][];</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        for (i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L86">            diffs[i] = new double[nCols];</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            for (j = 0; j &lt; nCols; ++j) {</span>
<span class="fc" id="L88">                diffs[i][j] = (a[i][j] - mean[j]);</span>
            }
        }
        
        /*System.out.printf(&quot;bf stand. means=%s\n&quot;, Arrays.toString(mean));
        
        System.out.flush();
        System.out.printf(&quot;bf stand. diffs=\n&quot;);
        for ( i = 0; i &lt; diffs.length; ++i) {
            for ( j = 0; j &lt; diffs[i].length; ++j) {
                System.out.printf(&quot;%11.3e  &quot;, diffs[i][j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
        System.out.flush();
        */
        
<span class="fc" id="L105">        double[][] cov = new double[nCols][];</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (i = 0; i &lt; nCols; ++i) {</span>
<span class="fc" id="L107">            cov[i] = new double[nCols];</span>
        }

        // r.t. nRows^2 * nCols
        double sum;
        int ii;
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (j = i; j &lt; nCols; ++j) {</span>
<span class="fc" id="L115">                sum = 0;</span>
                // multiply diffs[*][i] by diffs[*][j]
<span class="fc bfc" id="L117" title="All 2 branches covered.">                for (ii = 0; ii &lt; nRows; ++ii) {</span>
<span class="fc" id="L118">                    sum += (diffs[ii][i] * diffs[ii][j]);</span>
                }
<span class="fc" id="L120">                sum /= ((double)(nRows-1.));</span>
<span class="fc" id="L121">                cov[i][j] = sum;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">                if (i != j) {</span>
<span class="fc" id="L123">                    cov[j][i] = sum;</span>
                }
            }
        }
        
        /*System.out.printf(&quot;bf stand. cov=\n&quot;);
        for ( i = 0; i &lt; cov.length; ++i) {
            for ( j = 0; j &lt; cov[i].length; ++j) {
                System.out.printf(&quot;%11.3e  &quot;, cov[i][j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
        System.out.flush();*/
        
<span class="fc" id="L137">        return cov;</span>
    }
    
    /**
     * calculate the covariance matrix for a using simplest brute force method
     * Cov_a = (1/n) a * a^T for a being standardized to subtract the mean of
     * each type from the measurement of same type.
     * The covariance matrix is also known as auto-covariance matrix, 
     * dispersion matrix, variance matrix, and the variance–covariance matrix.
     * @param a an mxn matrix of data with the dimensions being rows
     * and the datum number being columns.  NOTE that a must be &quot;zero mean&quot; centered.
     * &lt;pre&gt;
     * e.g.  a[0] = new double[]{10,  9}
     *       a[1] = new double[]{99,  100}
     *       a[2] = new double[]{1000, 900}
     * &lt;/pre&gt;
     * @return the covariance matrix as a double array of size [a[0].length][a[0].length]
     */
    public static double[][] covariance2(double[][] a) {
        
<span class="fc" id="L157">        double[][] cov = MatrixUtil.createATransposedTimesA(a);</span>

        int i, j;
<span class="fc" id="L160">        int n = a[0].length;</span>
<span class="fc" id="L161">        double invN2 = 1./((double)n - 1.);</span>
<span class="fc" id="L162">        invN2 *= invN2;</span>
<span class="fc" id="L163">        MatrixUtil.multiply(cov, invN2);</span>

        /*
        System.out.printf(&quot;bf cov=\n&quot;);
        for ( i = 0; i &lt; cov.length; ++i) {
            for ( j = 0; j &lt; cov[i].length; ++j) {
                System.out.printf(&quot;%11.3e  &quot;, cov[i][j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
        System.out.flush();
        */

<span class="fc" id="L176">        return cov;</span>
    }
   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>