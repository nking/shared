package algorithms.misc;

import java.util.Random;

public class ReservoirSampling {

    /**
     * create a random sample of length k from array a.
     *
     * the method internally uses Fisher-Yates shuffle (n-k) times
     * after filling the output array with the first k items.
     *
     * r.t.c. is O(n) where n = a.length
     *
     * @param a
     * @param k
     * @return
     */
    public static int[] sample(int[] a, int k) {
        if (k > a.length) {
            throw new IllegalStateException("a.length must be > k");
        }
        int[] out = new int[k];
        Random rand = new Random();
        System.arraycopy(a, 0, out, 0, k);

        int t;
        //for (int i = k; i < a.length-1; ++i) {
        for (int i = a.length-1; i >= k; --i) {
            t = rand.nextInt(i + 1);
            if (t < k) {
                out[t] = a[i];
            }
        }
        return out;
    }

    /**
     * create a random sample of length k from array a.
     <pre>
     reference:
     "Reservoir-Sampling Algorithms of Time Complexity O(n(l + 10g(/V /n)))"
     KIM-HUNG LI
     1994 ACM 0098-3500/94/1200-0481 $03.50
     https://en.wikipedia.org/wiki/Reservoir_sampling

     algorithm L of
     https://dl.acm.org/doi/10.1145/198429.198435

     </pre>
     *
     * r.t.c. is O(k * 1 + log(n/k)) where n = a.length.
     *
     * @param a data stream to sample
     * @param k length of output sample
     * @return
     */
    public static int[] sampleOptimally(int[] a, int k) {
        int n = a.length;

        if (k > n) {
            throw new IllegalStateException("a.length must be > k");
        }
        int[] out = new int[k];
        Random rand = new Random();
        System.arraycopy(a, 0, out, 0, k);

        // uses geometric distibution inverse function to generate a random number.
        //W is the simulation of the largest value in a sample of size k from the U(O, b)
        // distribution (where b=1 here) and it
        // can be generated by b*random( )^(1/k)1,
        // which is programmed as b *exp(log(random( ))/n).
        double w = Math.exp(Math.log(rand.nextDouble())/k);
        int i = k;
        int j;
        while (i <= n) {
            j = (int) Math.floor(Math.log(rand.nextDouble()) / Math.log(1. - w));
            i += j + 1;
            if (i <= n) {
                //* replace a random item of the reservoir with item i
                j = rand.nextInt(k);
                out[j] = a[i];
                w = w * Math.exp(Math.log(rand.nextDouble())/k);
            }
        }
        return out;
    }

    /**
     * create a random sample of length k from array a.
     <pre>
     reference:
     "Reservoir-Sampling Algorithms of Time Complexity O(n(l + 10g(/V /n)))"
     KIM-HUNG LI
     1994 ACM 0098-3500/94/1200-0481 $03.50
     https://en.wikipedia.org/wiki/Reservoir_sampling

     algorithm L of
     https://dl.acm.org/doi/10.1145/198429.198435

     </pre>
     *
     * r.t.c. is O(k * 1 + log(n/k)) where n = a.length.
     *
     * @param a data stream to sample
     * @param k length of output sample
     * @return
     */
    public static double[] sampleOptimally(double[] a, int k) {
        int n = a.length;

        if (k > n) {
            throw new IllegalStateException("a.length must be > k");
        }
        double[] out = new double[k];
        Random rand = new Random();
        System.arraycopy(a, 0, out, 0, k);

        // uses geometric distibution inverse function to generate a random number.
        //W is the simulation of the largest value in a sample of size k from the U(O, b)
        // distribution (where b=1 here) and it
        // can be generated by b*random( )^(1/k)1,
        // which is programmed as b *exp(log(random( ))/n).
        double w = Math.exp(Math.log(rand.nextDouble())/k);
        int i = k;
        int j;
        while (i <= n) {
            j = (int) Math.floor(Math.log(rand.nextDouble()) / Math.log(1. - w));
            i += j + 1;
            if (i <= n) {
                //* replace a random item of the reservoir with item i
                j = rand.nextInt(k);
                out[j] = a[i];
                w = w * Math.exp(Math.log(rand.nextDouble())/k);
            }
        }
        return out;
    }
}
